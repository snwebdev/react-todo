/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	__webpack_require__(4);
	module.exports = __webpack_require__(6);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(2)(__webpack_require__(3))

/***/ },
/* 2 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function(src) {
		if (typeof execScript === "function")
			execScript(src);
		else
			eval.call(null, src);
	}

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = "\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*! jQuery v2.2.4 | (c) jQuery Foundation | jquery.org/license */\n!function (a, b) {\n  \"object\" == (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) && \"object\" == _typeof(module.exports) ? module.exports = a.document ? b(a, !0) : function (a) {\n    if (!a.document) throw new Error(\"jQuery requires a window with a document\");return b(a);\n  } : b(a);\n}(\"undefined\" != typeof window ? window : undefined, function (a, b) {\n  var c = [],\n      d = a.document,\n      e = c.slice,\n      f = c.concat,\n      g = c.push,\n      h = c.indexOf,\n      i = {},\n      j = i.toString,\n      k = i.hasOwnProperty,\n      l = {},\n      m = \"2.2.4\",\n      n = function n(a, b) {\n    return new n.fn.init(a, b);\n  },\n      o = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n      p = /^-ms-/,\n      q = /-([\\da-z])/gi,\n      r = function r(a, b) {\n    return b.toUpperCase();\n  };n.fn = n.prototype = { jquery: m, constructor: n, selector: \"\", length: 0, toArray: function toArray() {\n      return e.call(this);\n    }, get: function get(a) {\n      return null != a ? 0 > a ? this[a + this.length] : this[a] : e.call(this);\n    }, pushStack: function pushStack(a) {\n      var b = n.merge(this.constructor(), a);return b.prevObject = this, b.context = this.context, b;\n    }, each: function each(a) {\n      return n.each(this, a);\n    }, map: function map(a) {\n      return this.pushStack(n.map(this, function (b, c) {\n        return a.call(b, c, b);\n      }));\n    }, slice: function slice() {\n      return this.pushStack(e.apply(this, arguments));\n    }, first: function first() {\n      return this.eq(0);\n    }, last: function last() {\n      return this.eq(-1);\n    }, eq: function eq(a) {\n      var b = this.length,\n          c = +a + (0 > a ? b : 0);return this.pushStack(c >= 0 && b > c ? [this[c]] : []);\n    }, end: function end() {\n      return this.prevObject || this.constructor();\n    }, push: g, sort: c.sort, splice: c.splice }, n.extend = n.fn.extend = function () {\n    var a,\n        b,\n        c,\n        d,\n        e,\n        f,\n        g = arguments[0] || {},\n        h = 1,\n        i = arguments.length,\n        j = !1;for (\"boolean\" == typeof g && (j = g, g = arguments[h] || {}, h++), \"object\" == (typeof g === \"undefined\" ? \"undefined\" : _typeof(g)) || n.isFunction(g) || (g = {}), h === i && (g = this, h--); i > h; h++) {\n      if (null != (a = arguments[h])) for (b in a) {\n        c = g[b], d = a[b], g !== d && (j && d && (n.isPlainObject(d) || (e = n.isArray(d))) ? (e ? (e = !1, f = c && n.isArray(c) ? c : []) : f = c && n.isPlainObject(c) ? c : {}, g[b] = n.extend(j, f, d)) : void 0 !== d && (g[b] = d));\n      }\n    }return g;\n  }, n.extend({ expando: \"jQuery\" + (m + Math.random()).replace(/\\D/g, \"\"), isReady: !0, error: function error(a) {\n      throw new Error(a);\n    }, noop: function noop() {}, isFunction: function isFunction(a) {\n      return \"function\" === n.type(a);\n    }, isArray: Array.isArray, isWindow: function isWindow(a) {\n      return null != a && a === a.window;\n    }, isNumeric: function isNumeric(a) {\n      var b = a && a.toString();return !n.isArray(a) && b - parseFloat(b) + 1 >= 0;\n    }, isPlainObject: function isPlainObject(a) {\n      var b;if (\"object\" !== n.type(a) || a.nodeType || n.isWindow(a)) return !1;if (a.constructor && !k.call(a, \"constructor\") && !k.call(a.constructor.prototype || {}, \"isPrototypeOf\")) return !1;for (b in a) {}return void 0 === b || k.call(a, b);\n    }, isEmptyObject: function isEmptyObject(a) {\n      var b;for (b in a) {\n        return !1;\n      }return !0;\n    }, type: function type(a) {\n      return null == a ? a + \"\" : \"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) || \"function\" == typeof a ? i[j.call(a)] || \"object\" : typeof a === \"undefined\" ? \"undefined\" : _typeof(a);\n    }, globalEval: function globalEval(a) {\n      var b,\n          c = eval;a = n.trim(a), a && (1 === a.indexOf(\"use strict\") ? (b = d.createElement(\"script\"), b.text = a, d.head.appendChild(b).parentNode.removeChild(b)) : c(a));\n    }, camelCase: function camelCase(a) {\n      return a.replace(p, \"ms-\").replace(q, r);\n    }, nodeName: function nodeName(a, b) {\n      return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase();\n    }, each: function each(a, b) {\n      var c,\n          d = 0;if (s(a)) {\n        for (c = a.length; c > d; d++) {\n          if (b.call(a[d], d, a[d]) === !1) break;\n        }\n      } else for (d in a) {\n        if (b.call(a[d], d, a[d]) === !1) break;\n      }return a;\n    }, trim: function trim(a) {\n      return null == a ? \"\" : (a + \"\").replace(o, \"\");\n    }, makeArray: function makeArray(a, b) {\n      var c = b || [];return null != a && (s(Object(a)) ? n.merge(c, \"string\" == typeof a ? [a] : a) : g.call(c, a)), c;\n    }, inArray: function inArray(a, b, c) {\n      return null == b ? -1 : h.call(b, a, c);\n    }, merge: function merge(a, b) {\n      for (var c = +b.length, d = 0, e = a.length; c > d; d++) {\n        a[e++] = b[d];\n      }return a.length = e, a;\n    }, grep: function grep(a, b, c) {\n      for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++) {\n        d = !b(a[f], f), d !== h && e.push(a[f]);\n      }return e;\n    }, map: function map(a, b, c) {\n      var d,\n          e,\n          g = 0,\n          h = [];if (s(a)) for (d = a.length; d > g; g++) {\n        e = b(a[g], g, c), null != e && h.push(e);\n      } else for (g in a) {\n        e = b(a[g], g, c), null != e && h.push(e);\n      }return f.apply([], h);\n    }, guid: 1, proxy: function proxy(a, b) {\n      var c, d, f;return \"string\" == typeof b && (c = a[b], b = a, a = c), n.isFunction(a) ? (d = e.call(arguments, 2), f = function f() {\n        return a.apply(b || this, d.concat(e.call(arguments)));\n      }, f.guid = a.guid = a.guid || n.guid++, f) : void 0;\n    }, now: Date.now, support: l }), \"function\" == typeof Symbol && (n.fn[Symbol.iterator] = c[Symbol.iterator]), n.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"), function (a, b) {\n    i[\"[object \" + b + \"]\"] = b.toLowerCase();\n  });function s(a) {\n    var b = !!a && \"length\" in a && a.length,\n        c = n.type(a);return \"function\" === c || n.isWindow(a) ? !1 : \"array\" === c || 0 === b || \"number\" == typeof b && b > 0 && b - 1 in a;\n  }var t = function (a) {\n    var b,\n        c,\n        d,\n        e,\n        f,\n        g,\n        h,\n        i,\n        j,\n        k,\n        l,\n        m,\n        n,\n        o,\n        p,\n        q,\n        r,\n        s,\n        t,\n        u = \"sizzle\" + 1 * new Date(),\n        v = a.document,\n        w = 0,\n        x = 0,\n        y = ga(),\n        z = ga(),\n        A = ga(),\n        B = function B(a, b) {\n      return a === b && (l = !0), 0;\n    },\n        C = 1 << 31,\n        D = {}.hasOwnProperty,\n        E = [],\n        F = E.pop,\n        G = E.push,\n        H = E.push,\n        I = E.slice,\n        J = function J(a, b) {\n      for (var c = 0, d = a.length; d > c; c++) {\n        if (a[c] === b) return c;\n      }return -1;\n    },\n        K = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n        L = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n        M = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n        N = \"\\\\[\" + L + \"*(\" + M + \")(?:\" + L + \"*([*^$|!~]?=)\" + L + \"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + M + \"))|)\" + L + \"*\\\\]\",\n        O = \":(\" + M + \")(?:\\\\((('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + N + \")*)|.*)\\\\)|)\",\n        P = new RegExp(L + \"+\", \"g\"),\n        Q = new RegExp(\"^\" + L + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + L + \"+$\", \"g\"),\n        R = new RegExp(\"^\" + L + \"*,\" + L + \"*\"),\n        S = new RegExp(\"^\" + L + \"*([>+~]|\" + L + \")\" + L + \"*\"),\n        T = new RegExp(\"=\" + L + \"*([^\\\\]'\\\"]*?)\" + L + \"*\\\\]\", \"g\"),\n        U = new RegExp(O),\n        V = new RegExp(\"^\" + M + \"$\"),\n        W = { ID: new RegExp(\"^#(\" + M + \")\"), CLASS: new RegExp(\"^\\\\.(\" + M + \")\"), TAG: new RegExp(\"^(\" + M + \"|[*])\"), ATTR: new RegExp(\"^\" + N), PSEUDO: new RegExp(\"^\" + O), CHILD: new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + L + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + L + \"*(?:([+-]|)\" + L + \"*(\\\\d+)|))\" + L + \"*\\\\)|)\", \"i\"), bool: new RegExp(\"^(?:\" + K + \")$\", \"i\"), needsContext: new RegExp(\"^\" + L + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + L + \"*((?:-\\\\d)?\\\\d*)\" + L + \"*\\\\)|)(?=[^-]|$)\", \"i\") },\n        X = /^(?:input|select|textarea|button)$/i,\n        Y = /^h\\d$/i,\n        Z = /^[^{]+\\{\\s*\\[native \\w/,\n        $ = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n        _ = /[+~]/,\n        aa = /'|\\\\/g,\n        ba = new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + L + \"?|(\" + L + \")|.)\", \"ig\"),\n        ca = function ca(a, b, c) {\n      var d = \"0x\" + b - 65536;return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320);\n    },\n        da = function da() {\n      m();\n    };try {\n      H.apply(E = I.call(v.childNodes), v.childNodes), E[v.childNodes.length].nodeType;\n    } catch (ea) {\n      H = { apply: E.length ? function (a, b) {\n          G.apply(a, I.call(b));\n        } : function (a, b) {\n          var c = a.length,\n              d = 0;while (a[c++] = b[d++]) {}a.length = c - 1;\n        } };\n    }function fa(a, b, d, e) {\n      var f,\n          h,\n          j,\n          k,\n          l,\n          o,\n          r,\n          s,\n          w = b && b.ownerDocument,\n          x = b ? b.nodeType : 9;if (d = d || [], \"string\" != typeof a || !a || 1 !== x && 9 !== x && 11 !== x) return d;if (!e && ((b ? b.ownerDocument || b : v) !== n && m(b), b = b || n, p)) {\n        if (11 !== x && (o = $.exec(a))) if (f = o[1]) {\n          if (9 === x) {\n            if (!(j = b.getElementById(f))) return d;if (j.id === f) return d.push(j), d;\n          } else if (w && (j = w.getElementById(f)) && t(b, j) && j.id === f) return d.push(j), d;\n        } else {\n          if (o[2]) return H.apply(d, b.getElementsByTagName(a)), d;if ((f = o[3]) && c.getElementsByClassName && b.getElementsByClassName) return H.apply(d, b.getElementsByClassName(f)), d;\n        }if (c.qsa && !A[a + \" \"] && (!q || !q.test(a))) {\n          if (1 !== x) w = b, s = a;else if (\"object\" !== b.nodeName.toLowerCase()) {\n            (k = b.getAttribute(\"id\")) ? k = k.replace(aa, \"\\\\$&\") : b.setAttribute(\"id\", k = u), r = g(a), h = r.length, l = V.test(k) ? \"#\" + k : \"[id='\" + k + \"']\";while (h--) {\n              r[h] = l + \" \" + qa(r[h]);\n            }s = r.join(\",\"), w = _.test(a) && oa(b.parentNode) || b;\n          }if (s) try {\n            return H.apply(d, w.querySelectorAll(s)), d;\n          } catch (y) {} finally {\n            k === u && b.removeAttribute(\"id\");\n          }\n        }\n      }return i(a.replace(Q, \"$1\"), b, d, e);\n    }function ga() {\n      var a = [];function b(c, e) {\n        return a.push(c + \" \") > d.cacheLength && delete b[a.shift()], b[c + \" \"] = e;\n      }return b;\n    }function ha(a) {\n      return a[u] = !0, a;\n    }function ia(a) {\n      var b = n.createElement(\"div\");try {\n        return !!a(b);\n      } catch (c) {\n        return !1;\n      } finally {\n        b.parentNode && b.parentNode.removeChild(b), b = null;\n      }\n    }function ja(a, b) {\n      var c = a.split(\"|\"),\n          e = c.length;while (e--) {\n        d.attrHandle[c[e]] = b;\n      }\n    }function ka(a, b) {\n      var c = b && a,\n          d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || C) - (~a.sourceIndex || C);if (d) return d;if (c) while (c = c.nextSibling) {\n        if (c === b) return -1;\n      }return a ? 1 : -1;\n    }function la(a) {\n      return function (b) {\n        var c = b.nodeName.toLowerCase();return \"input\" === c && b.type === a;\n      };\n    }function ma(a) {\n      return function (b) {\n        var c = b.nodeName.toLowerCase();return (\"input\" === c || \"button\" === c) && b.type === a;\n      };\n    }function na(a) {\n      return ha(function (b) {\n        return b = +b, ha(function (c, d) {\n          var e,\n              f = a([], c.length, b),\n              g = f.length;while (g--) {\n            c[e = f[g]] && (c[e] = !(d[e] = c[e]));\n          }\n        });\n      });\n    }function oa(a) {\n      return a && \"undefined\" != typeof a.getElementsByTagName && a;\n    }c = fa.support = {}, f = fa.isXML = function (a) {\n      var b = a && (a.ownerDocument || a).documentElement;return b ? \"HTML\" !== b.nodeName : !1;\n    }, m = fa.setDocument = function (a) {\n      var b,\n          e,\n          g = a ? a.ownerDocument || a : v;return g !== n && 9 === g.nodeType && g.documentElement ? (n = g, o = n.documentElement, p = !f(n), (e = n.defaultView) && e.top !== e && (e.addEventListener ? e.addEventListener(\"unload\", da, !1) : e.attachEvent && e.attachEvent(\"onunload\", da)), c.attributes = ia(function (a) {\n        return a.className = \"i\", !a.getAttribute(\"className\");\n      }), c.getElementsByTagName = ia(function (a) {\n        return a.appendChild(n.createComment(\"\")), !a.getElementsByTagName(\"*\").length;\n      }), c.getElementsByClassName = Z.test(n.getElementsByClassName), c.getById = ia(function (a) {\n        return o.appendChild(a).id = u, !n.getElementsByName || !n.getElementsByName(u).length;\n      }), c.getById ? (d.find.ID = function (a, b) {\n        if (\"undefined\" != typeof b.getElementById && p) {\n          var c = b.getElementById(a);return c ? [c] : [];\n        }\n      }, d.filter.ID = function (a) {\n        var b = a.replace(ba, ca);return function (a) {\n          return a.getAttribute(\"id\") === b;\n        };\n      }) : (delete d.find.ID, d.filter.ID = function (a) {\n        var b = a.replace(ba, ca);return function (a) {\n          var c = \"undefined\" != typeof a.getAttributeNode && a.getAttributeNode(\"id\");return c && c.value === b;\n        };\n      }), d.find.TAG = c.getElementsByTagName ? function (a, b) {\n        return \"undefined\" != typeof b.getElementsByTagName ? b.getElementsByTagName(a) : c.qsa ? b.querySelectorAll(a) : void 0;\n      } : function (a, b) {\n        var c,\n            d = [],\n            e = 0,\n            f = b.getElementsByTagName(a);if (\"*\" === a) {\n          while (c = f[e++]) {\n            1 === c.nodeType && d.push(c);\n          }return d;\n        }return f;\n      }, d.find.CLASS = c.getElementsByClassName && function (a, b) {\n        return \"undefined\" != typeof b.getElementsByClassName && p ? b.getElementsByClassName(a) : void 0;\n      }, r = [], q = [], (c.qsa = Z.test(n.querySelectorAll)) && (ia(function (a) {\n        o.appendChild(a).innerHTML = \"<a id='\" + u + \"'></a><select id='\" + u + \"-\\r\\\\' msallowcapture=''><option selected=''></option></select>\", a.querySelectorAll(\"[msallowcapture^='']\").length && q.push(\"[*^$]=\" + L + \"*(?:''|\\\"\\\")\"), a.querySelectorAll(\"[selected]\").length || q.push(\"\\\\[\" + L + \"*(?:value|\" + K + \")\"), a.querySelectorAll(\"[id~=\" + u + \"-]\").length || q.push(\"~=\"), a.querySelectorAll(\":checked\").length || q.push(\":checked\"), a.querySelectorAll(\"a#\" + u + \"+*\").length || q.push(\".#.+[+~]\");\n      }), ia(function (a) {\n        var b = n.createElement(\"input\");b.setAttribute(\"type\", \"hidden\"), a.appendChild(b).setAttribute(\"name\", \"D\"), a.querySelectorAll(\"[name=d]\").length && q.push(\"name\" + L + \"*[*^$|!~]?=\"), a.querySelectorAll(\":enabled\").length || q.push(\":enabled\", \":disabled\"), a.querySelectorAll(\"*,:x\"), q.push(\",.*:\");\n      })), (c.matchesSelector = Z.test(s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ia(function (a) {\n        c.disconnectedMatch = s.call(a, \"div\"), s.call(a, \"[s!='']:x\"), r.push(\"!=\", O);\n      }), q = q.length && new RegExp(q.join(\"|\")), r = r.length && new RegExp(r.join(\"|\")), b = Z.test(o.compareDocumentPosition), t = b || Z.test(o.contains) ? function (a, b) {\n        var c = 9 === a.nodeType ? a.documentElement : a,\n            d = b && b.parentNode;return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)));\n      } : function (a, b) {\n        if (b) while (b = b.parentNode) {\n          if (b === a) return !0;\n        }return !1;\n      }, B = b ? function (a, b) {\n        if (a === b) return l = !0, 0;var d = !a.compareDocumentPosition - !b.compareDocumentPosition;return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === n || a.ownerDocument === v && t(v, a) ? -1 : b === n || b.ownerDocument === v && t(v, b) ? 1 : k ? J(k, a) - J(k, b) : 0 : 4 & d ? -1 : 1);\n      } : function (a, b) {\n        if (a === b) return l = !0, 0;var c,\n            d = 0,\n            e = a.parentNode,\n            f = b.parentNode,\n            g = [a],\n            h = [b];if (!e || !f) return a === n ? -1 : b === n ? 1 : e ? -1 : f ? 1 : k ? J(k, a) - J(k, b) : 0;if (e === f) return ka(a, b);c = a;while (c = c.parentNode) {\n          g.unshift(c);\n        }c = b;while (c = c.parentNode) {\n          h.unshift(c);\n        }while (g[d] === h[d]) {\n          d++;\n        }return d ? ka(g[d], h[d]) : g[d] === v ? -1 : h[d] === v ? 1 : 0;\n      }, n) : n;\n    }, fa.matches = function (a, b) {\n      return fa(a, null, null, b);\n    }, fa.matchesSelector = function (a, b) {\n      if ((a.ownerDocument || a) !== n && m(a), b = b.replace(T, \"='$1']\"), c.matchesSelector && p && !A[b + \" \"] && (!r || !r.test(b)) && (!q || !q.test(b))) try {\n        var d = s.call(a, b);if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d;\n      } catch (e) {}return fa(b, n, null, [a]).length > 0;\n    }, fa.contains = function (a, b) {\n      return (a.ownerDocument || a) !== n && m(a), t(a, b);\n    }, fa.attr = function (a, b) {\n      (a.ownerDocument || a) !== n && m(a);var e = d.attrHandle[b.toLowerCase()],\n          f = e && D.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0;return void 0 !== f ? f : c.attributes || !p ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null;\n    }, fa.error = function (a) {\n      throw new Error(\"Syntax error, unrecognized expression: \" + a);\n    }, fa.uniqueSort = function (a) {\n      var b,\n          d = [],\n          e = 0,\n          f = 0;if (l = !c.detectDuplicates, k = !c.sortStable && a.slice(0), a.sort(B), l) {\n        while (b = a[f++]) {\n          b === a[f] && (e = d.push(f));\n        }while (e--) {\n          a.splice(d[e], 1);\n        }\n      }return k = null, a;\n    }, e = fa.getText = function (a) {\n      var b,\n          c = \"\",\n          d = 0,\n          f = a.nodeType;if (f) {\n        if (1 === f || 9 === f || 11 === f) {\n          if (\"string\" == typeof a.textContent) return a.textContent;for (a = a.firstChild; a; a = a.nextSibling) {\n            c += e(a);\n          }\n        } else if (3 === f || 4 === f) return a.nodeValue;\n      } else while (b = a[d++]) {\n        c += e(b);\n      }return c;\n    }, d = fa.selectors = { cacheLength: 50, createPseudo: ha, match: W, attrHandle: {}, find: {}, relative: { \">\": { dir: \"parentNode\", first: !0 }, \" \": { dir: \"parentNode\" }, \"+\": { dir: \"previousSibling\", first: !0 }, \"~\": { dir: \"previousSibling\" } }, preFilter: { ATTR: function ATTR(a) {\n          return a[1] = a[1].replace(ba, ca), a[3] = (a[3] || a[4] || a[5] || \"\").replace(ba, ca), \"~=\" === a[2] && (a[3] = \" \" + a[3] + \" \"), a.slice(0, 4);\n        }, CHILD: function CHILD(a) {\n          return a[1] = a[1].toLowerCase(), \"nth\" === a[1].slice(0, 3) ? (a[3] || fa.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * (\"even\" === a[3] || \"odd\" === a[3])), a[5] = +(a[7] + a[8] || \"odd\" === a[3])) : a[3] && fa.error(a[0]), a;\n        }, PSEUDO: function PSEUDO(a) {\n          var b,\n              c = !a[6] && a[2];return W.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || \"\" : c && U.test(c) && (b = g(c, !0)) && (b = c.indexOf(\")\", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3));\n        } }, filter: { TAG: function TAG(a) {\n          var b = a.replace(ba, ca).toLowerCase();return \"*\" === a ? function () {\n            return !0;\n          } : function (a) {\n            return a.nodeName && a.nodeName.toLowerCase() === b;\n          };\n        }, CLASS: function CLASS(a) {\n          var b = y[a + \" \"];return b || (b = new RegExp(\"(^|\" + L + \")\" + a + \"(\" + L + \"|$)\")) && y(a, function (a) {\n            return b.test(\"string\" == typeof a.className && a.className || \"undefined\" != typeof a.getAttribute && a.getAttribute(\"class\") || \"\");\n          });\n        }, ATTR: function ATTR(a, b, c) {\n          return function (d) {\n            var e = fa.attr(d, a);return null == e ? \"!=\" === b : b ? (e += \"\", \"=\" === b ? e === c : \"!=\" === b ? e !== c : \"^=\" === b ? c && 0 === e.indexOf(c) : \"*=\" === b ? c && e.indexOf(c) > -1 : \"$=\" === b ? c && e.slice(-c.length) === c : \"~=\" === b ? (\" \" + e.replace(P, \" \") + \" \").indexOf(c) > -1 : \"|=\" === b ? e === c || e.slice(0, c.length + 1) === c + \"-\" : !1) : !0;\n          };\n        }, CHILD: function CHILD(a, b, c, d, e) {\n          var f = \"nth\" !== a.slice(0, 3),\n              g = \"last\" !== a.slice(-4),\n              h = \"of-type\" === b;return 1 === d && 0 === e ? function (a) {\n            return !!a.parentNode;\n          } : function (b, c, i) {\n            var j,\n                k,\n                l,\n                m,\n                n,\n                o,\n                p = f !== g ? \"nextSibling\" : \"previousSibling\",\n                q = b.parentNode,\n                r = h && b.nodeName.toLowerCase(),\n                s = !i && !h,\n                t = !1;if (q) {\n              if (f) {\n                while (p) {\n                  m = b;while (m = m[p]) {\n                    if (h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) return !1;\n                  }o = p = \"only\" === a && !o && \"nextSibling\";\n                }return !0;\n              }if (o = [g ? q.firstChild : q.lastChild], g && s) {\n                m = q, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n && j[2], m = n && q.childNodes[n];while (m = ++n && m && m[p] || (t = n = 0) || o.pop()) {\n                  if (1 === m.nodeType && ++t && m === b) {\n                    k[a] = [w, n, t];break;\n                  }\n                }\n              } else if (s && (m = b, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n), t === !1) while (m = ++n && m && m[p] || (t = n = 0) || o.pop()) {\n                if ((h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) && ++t && (s && (l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), k[a] = [w, t]), m === b)) break;\n              }return t -= e, t === d || t % d === 0 && t / d >= 0;\n            }\n          };\n        }, PSEUDO: function PSEUDO(a, b) {\n          var c,\n              e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || fa.error(\"unsupported pseudo: \" + a);return e[u] ? e(b) : e.length > 1 ? (c = [a, a, \"\", b], d.setFilters.hasOwnProperty(a.toLowerCase()) ? ha(function (a, c) {\n            var d,\n                f = e(a, b),\n                g = f.length;while (g--) {\n              d = J(a, f[g]), a[d] = !(c[d] = f[g]);\n            }\n          }) : function (a) {\n            return e(a, 0, c);\n          }) : e;\n        } }, pseudos: { not: ha(function (a) {\n          var b = [],\n              c = [],\n              d = h(a.replace(Q, \"$1\"));return d[u] ? ha(function (a, b, c, e) {\n            var f,\n                g = d(a, null, e, []),\n                h = a.length;while (h--) {\n              (f = g[h]) && (a[h] = !(b[h] = f));\n            }\n          }) : function (a, e, f) {\n            return b[0] = a, d(b, null, f, c), b[0] = null, !c.pop();\n          };\n        }), has: ha(function (a) {\n          return function (b) {\n            return fa(a, b).length > 0;\n          };\n        }), contains: ha(function (a) {\n          return a = a.replace(ba, ca), function (b) {\n            return (b.textContent || b.innerText || e(b)).indexOf(a) > -1;\n          };\n        }), lang: ha(function (a) {\n          return V.test(a || \"\") || fa.error(\"unsupported lang: \" + a), a = a.replace(ba, ca).toLowerCase(), function (b) {\n            var c;do {\n              if (c = p ? b.lang : b.getAttribute(\"xml:lang\") || b.getAttribute(\"lang\")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + \"-\");\n            } while ((b = b.parentNode) && 1 === b.nodeType);return !1;\n          };\n        }), target: function target(b) {\n          var c = a.location && a.location.hash;return c && c.slice(1) === b.id;\n        }, root: function root(a) {\n          return a === o;\n        }, focus: function focus(a) {\n          return a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !!(a.type || a.href || ~a.tabIndex);\n        }, enabled: function enabled(a) {\n          return a.disabled === !1;\n        }, disabled: function disabled(a) {\n          return a.disabled === !0;\n        }, checked: function checked(a) {\n          var b = a.nodeName.toLowerCase();return \"input\" === b && !!a.checked || \"option\" === b && !!a.selected;\n        }, selected: function selected(a) {\n          return a.parentNode && a.parentNode.selectedIndex, a.selected === !0;\n        }, empty: function empty(a) {\n          for (a = a.firstChild; a; a = a.nextSibling) {\n            if (a.nodeType < 6) return !1;\n          }return !0;\n        }, parent: function parent(a) {\n          return !d.pseudos.empty(a);\n        }, header: function header(a) {\n          return Y.test(a.nodeName);\n        }, input: function input(a) {\n          return X.test(a.nodeName);\n        }, button: function button(a) {\n          var b = a.nodeName.toLowerCase();return \"input\" === b && \"button\" === a.type || \"button\" === b;\n        }, text: function text(a) {\n          var b;return \"input\" === a.nodeName.toLowerCase() && \"text\" === a.type && (null == (b = a.getAttribute(\"type\")) || \"text\" === b.toLowerCase());\n        }, first: na(function () {\n          return [0];\n        }), last: na(function (a, b) {\n          return [b - 1];\n        }), eq: na(function (a, b, c) {\n          return [0 > c ? c + b : c];\n        }), even: na(function (a, b) {\n          for (var c = 0; b > c; c += 2) {\n            a.push(c);\n          }return a;\n        }), odd: na(function (a, b) {\n          for (var c = 1; b > c; c += 2) {\n            a.push(c);\n          }return a;\n        }), lt: na(function (a, b, c) {\n          for (var d = 0 > c ? c + b : c; --d >= 0;) {\n            a.push(d);\n          }return a;\n        }), gt: na(function (a, b, c) {\n          for (var d = 0 > c ? c + b : c; ++d < b;) {\n            a.push(d);\n          }return a;\n        }) } }, d.pseudos.nth = d.pseudos.eq;for (b in { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) {\n      d.pseudos[b] = la(b);\n    }for (b in { submit: !0, reset: !0 }) {\n      d.pseudos[b] = ma(b);\n    }function pa() {}pa.prototype = d.filters = d.pseudos, d.setFilters = new pa(), g = fa.tokenize = function (a, b) {\n      var c,\n          e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k = z[a + \" \"];if (k) return b ? 0 : k.slice(0);h = a, i = [], j = d.preFilter;while (h) {\n        c && !(e = R.exec(h)) || (e && (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = S.exec(h)) && (c = e.shift(), f.push({ value: c, type: e[0].replace(Q, \" \") }), h = h.slice(c.length));for (g in d.filter) {\n          !(e = W[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), f.push({ value: c, type: g, matches: e }), h = h.slice(c.length));\n        }if (!c) break;\n      }return b ? h.length : h ? fa.error(a) : z(a, i).slice(0);\n    };function qa(a) {\n      for (var b = 0, c = a.length, d = \"\"; c > b; b++) {\n        d += a[b].value;\n      }return d;\n    }function ra(a, b, c) {\n      var d = b.dir,\n          e = c && \"parentNode\" === d,\n          f = x++;return b.first ? function (b, c, f) {\n        while (b = b[d]) {\n          if (1 === b.nodeType || e) return a(b, c, f);\n        }\n      } : function (b, c, g) {\n        var h,\n            i,\n            j,\n            k = [w, f];if (g) {\n          while (b = b[d]) {\n            if ((1 === b.nodeType || e) && a(b, c, g)) return !0;\n          }\n        } else while (b = b[d]) {\n          if (1 === b.nodeType || e) {\n            if (j = b[u] || (b[u] = {}), i = j[b.uniqueID] || (j[b.uniqueID] = {}), (h = i[d]) && h[0] === w && h[1] === f) return k[2] = h[2];if (i[d] = k, k[2] = a(b, c, g)) return !0;\n          }\n        }\n      };\n    }function sa(a) {\n      return a.length > 1 ? function (b, c, d) {\n        var e = a.length;while (e--) {\n          if (!a[e](b, c, d)) return !1;\n        }return !0;\n      } : a[0];\n    }function ta(a, b, c) {\n      for (var d = 0, e = b.length; e > d; d++) {\n        fa(a, b[d], c);\n      }return c;\n    }function ua(a, b, c, d, e) {\n      for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++) {\n        (f = a[h]) && (c && !c(f, d, e) || (g.push(f), j && b.push(h)));\n      }return g;\n    }function va(a, b, c, d, e, f) {\n      return d && !d[u] && (d = va(d)), e && !e[u] && (e = va(e, f)), ha(function (f, g, h, i) {\n        var j,\n            k,\n            l,\n            m = [],\n            n = [],\n            o = g.length,\n            p = f || ta(b || \"*\", h.nodeType ? [h] : h, []),\n            q = !a || !f && b ? p : ua(p, m, a, h, i),\n            r = c ? e || (f ? a : o || d) ? [] : g : q;if (c && c(q, r, h, i), d) {\n          j = ua(r, n), d(j, [], h, i), k = j.length;while (k--) {\n            (l = j[k]) && (r[n[k]] = !(q[n[k]] = l));\n          }\n        }if (f) {\n          if (e || a) {\n            if (e) {\n              j = [], k = r.length;while (k--) {\n                (l = r[k]) && j.push(q[k] = l);\n              }e(null, r = [], j, i);\n            }k = r.length;while (k--) {\n              (l = r[k]) && (j = e ? J(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l));\n            }\n          }\n        } else r = ua(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : H.apply(g, r);\n      });\n    }function wa(a) {\n      for (var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[\" \"], i = g ? 1 : 0, k = ra(function (a) {\n        return a === b;\n      }, h, !0), l = ra(function (a) {\n        return J(b, a) > -1;\n      }, h, !0), m = [function (a, c, d) {\n        var e = !g && (d || c !== j) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d));return b = null, e;\n      }]; f > i; i++) {\n        if (c = d.relative[a[i].type]) m = [ra(sa(m), c)];else {\n          if (c = d.filter[a[i].type].apply(null, a[i].matches), c[u]) {\n            for (e = ++i; f > e; e++) {\n              if (d.relative[a[e].type]) break;\n            }return va(i > 1 && sa(m), i > 1 && qa(a.slice(0, i - 1).concat({ value: \" \" === a[i - 2].type ? \"*\" : \"\" })).replace(Q, \"$1\"), c, e > i && wa(a.slice(i, e)), f > e && wa(a = a.slice(e)), f > e && qa(a));\n          }m.push(c);\n        }\n      }return sa(m);\n    }function xa(a, b) {\n      var c = b.length > 0,\n          e = a.length > 0,\n          f = function f(_f, g, h, i, k) {\n        var l,\n            o,\n            q,\n            r = 0,\n            s = \"0\",\n            t = _f && [],\n            u = [],\n            v = j,\n            x = _f || e && d.find.TAG(\"*\", k),\n            y = w += null == v ? 1 : Math.random() || .1,\n            z = x.length;for (k && (j = g === n || g || k); s !== z && null != (l = x[s]); s++) {\n          if (e && l) {\n            o = 0, g || l.ownerDocument === n || (m(l), h = !p);while (q = a[o++]) {\n              if (q(l, g || n, h)) {\n                i.push(l);break;\n              }\n            }k && (w = y);\n          }c && ((l = !q && l) && r--, _f && t.push(l));\n        }if (r += s, c && s !== r) {\n          o = 0;while (q = b[o++]) {\n            q(t, u, g, h);\n          }if (_f) {\n            if (r > 0) while (s--) {\n              t[s] || u[s] || (u[s] = F.call(i));\n            }u = ua(u);\n          }H.apply(i, u), k && !_f && u.length > 0 && r + b.length > 1 && fa.uniqueSort(i);\n        }return k && (w = y, j = v), t;\n      };return c ? ha(f) : f;\n    }return h = fa.compile = function (a, b) {\n      var c,\n          d = [],\n          e = [],\n          f = A[a + \" \"];if (!f) {\n        b || (b = g(a)), c = b.length;while (c--) {\n          f = wa(b[c]), f[u] ? d.push(f) : e.push(f);\n        }f = A(a, xa(e, d)), f.selector = a;\n      }return f;\n    }, i = fa.select = function (a, b, e, f) {\n      var i,\n          j,\n          k,\n          l,\n          m,\n          n = \"function\" == typeof a && a,\n          o = !f && g(a = n.selector || a);if (e = e || [], 1 === o.length) {\n        if (j = o[0] = o[0].slice(0), j.length > 2 && \"ID\" === (k = j[0]).type && c.getById && 9 === b.nodeType && p && d.relative[j[1].type]) {\n          if (b = (d.find.ID(k.matches[0].replace(ba, ca), b) || [])[0], !b) return e;n && (b = b.parentNode), a = a.slice(j.shift().value.length);\n        }i = W.needsContext.test(a) ? 0 : j.length;while (i--) {\n          if (k = j[i], d.relative[l = k.type]) break;if ((m = d.find[l]) && (f = m(k.matches[0].replace(ba, ca), _.test(j[0].type) && oa(b.parentNode) || b))) {\n            if (j.splice(i, 1), a = f.length && qa(j), !a) return H.apply(e, f), e;break;\n          }\n        }\n      }return (n || h(a, o))(f, b, !p, e, !b || _.test(a) && oa(b.parentNode) || b), e;\n    }, c.sortStable = u.split(\"\").sort(B).join(\"\") === u, c.detectDuplicates = !!l, m(), c.sortDetached = ia(function (a) {\n      return 1 & a.compareDocumentPosition(n.createElement(\"div\"));\n    }), ia(function (a) {\n      return a.innerHTML = \"<a href='#'></a>\", \"#\" === a.firstChild.getAttribute(\"href\");\n    }) || ja(\"type|href|height|width\", function (a, b, c) {\n      return c ? void 0 : a.getAttribute(b, \"type\" === b.toLowerCase() ? 1 : 2);\n    }), c.attributes && ia(function (a) {\n      return a.innerHTML = \"<input/>\", a.firstChild.setAttribute(\"value\", \"\"), \"\" === a.firstChild.getAttribute(\"value\");\n    }) || ja(\"value\", function (a, b, c) {\n      return c || \"input\" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue;\n    }), ia(function (a) {\n      return null == a.getAttribute(\"disabled\");\n    }) || ja(K, function (a, b, c) {\n      var d;return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null;\n    }), fa;\n  }(a);n.find = t, n.expr = t.selectors, n.expr[\":\"] = n.expr.pseudos, n.uniqueSort = n.unique = t.uniqueSort, n.text = t.getText, n.isXMLDoc = t.isXML, n.contains = t.contains;var u = function u(a, b, c) {\n    var d = [],\n        e = void 0 !== c;while ((a = a[b]) && 9 !== a.nodeType) {\n      if (1 === a.nodeType) {\n        if (e && n(a).is(c)) break;d.push(a);\n      }\n    }return d;\n  },\n      v = function v(a, b) {\n    for (var c = []; a; a = a.nextSibling) {\n      1 === a.nodeType && a !== b && c.push(a);\n    }return c;\n  },\n      w = n.expr.match.needsContext,\n      x = /^<([\\w-]+)\\s*\\/?>(?:<\\/\\1>|)$/,\n      y = /^.[^:#\\[\\.,]*$/;function z(a, b, c) {\n    if (n.isFunction(b)) return n.grep(a, function (a, d) {\n      return !!b.call(a, d, a) !== c;\n    });if (b.nodeType) return n.grep(a, function (a) {\n      return a === b !== c;\n    });if (\"string\" == typeof b) {\n      if (y.test(b)) return n.filter(b, a, c);b = n.filter(b, a);\n    }return n.grep(a, function (a) {\n      return h.call(b, a) > -1 !== c;\n    });\n  }n.filter = function (a, b, c) {\n    var d = b[0];return c && (a = \":not(\" + a + \")\"), 1 === b.length && 1 === d.nodeType ? n.find.matchesSelector(d, a) ? [d] : [] : n.find.matches(a, n.grep(b, function (a) {\n      return 1 === a.nodeType;\n    }));\n  }, n.fn.extend({ find: function find(a) {\n      var b,\n          c = this.length,\n          d = [],\n          e = this;if (\"string\" != typeof a) return this.pushStack(n(a).filter(function () {\n        for (b = 0; c > b; b++) {\n          if (n.contains(e[b], this)) return !0;\n        }\n      }));for (b = 0; c > b; b++) {\n        n.find(a, e[b], d);\n      }return d = this.pushStack(c > 1 ? n.unique(d) : d), d.selector = this.selector ? this.selector + \" \" + a : a, d;\n    }, filter: function filter(a) {\n      return this.pushStack(z(this, a || [], !1));\n    }, not: function not(a) {\n      return this.pushStack(z(this, a || [], !0));\n    }, is: function is(a) {\n      return !!z(this, \"string\" == typeof a && w.test(a) ? n(a) : a || [], !1).length;\n    } });var A,\n      B = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n      C = n.fn.init = function (a, b, c) {\n    var e, f;if (!a) return this;if (c = c || A, \"string\" == typeof a) {\n      if (e = \"<\" === a[0] && \">\" === a[a.length - 1] && a.length >= 3 ? [null, a, null] : B.exec(a), !e || !e[1] && b) return !b || b.jquery ? (b || c).find(a) : this.constructor(b).find(a);if (e[1]) {\n        if (b = b instanceof n ? b[0] : b, n.merge(this, n.parseHTML(e[1], b && b.nodeType ? b.ownerDocument || b : d, !0)), x.test(e[1]) && n.isPlainObject(b)) for (e in b) {\n          n.isFunction(this[e]) ? this[e](b[e]) : this.attr(e, b[e]);\n        }return this;\n      }return f = d.getElementById(e[2]), f && f.parentNode && (this.length = 1, this[0] = f), this.context = d, this.selector = a, this;\n    }return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : n.isFunction(a) ? void 0 !== c.ready ? c.ready(a) : a(n) : (void 0 !== a.selector && (this.selector = a.selector, this.context = a.context), n.makeArray(a, this));\n  };C.prototype = n.fn, A = n(d);var D = /^(?:parents|prev(?:Until|All))/,\n      E = { children: !0, contents: !0, next: !0, prev: !0 };n.fn.extend({ has: function has(a) {\n      var b = n(a, this),\n          c = b.length;return this.filter(function () {\n        for (var a = 0; c > a; a++) {\n          if (n.contains(this, b[a])) return !0;\n        }\n      });\n    }, closest: function closest(a, b) {\n      for (var c, d = 0, e = this.length, f = [], g = w.test(a) || \"string\" != typeof a ? n(a, b || this.context) : 0; e > d; d++) {\n        for (c = this[d]; c && c !== b; c = c.parentNode) {\n          if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && n.find.matchesSelector(c, a))) {\n            f.push(c);break;\n          }\n        }\n      }return this.pushStack(f.length > 1 ? n.uniqueSort(f) : f);\n    }, index: function index(a) {\n      return a ? \"string\" == typeof a ? h.call(n(a), this[0]) : h.call(this, a.jquery ? a[0] : a) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\n    }, add: function add(a, b) {\n      return this.pushStack(n.uniqueSort(n.merge(this.get(), n(a, b))));\n    }, addBack: function addBack(a) {\n      return this.add(null == a ? this.prevObject : this.prevObject.filter(a));\n    } });function F(a, b) {\n    while ((a = a[b]) && 1 !== a.nodeType) {}return a;\n  }n.each({ parent: function parent(a) {\n      var b = a.parentNode;return b && 11 !== b.nodeType ? b : null;\n    }, parents: function parents(a) {\n      return u(a, \"parentNode\");\n    }, parentsUntil: function parentsUntil(a, b, c) {\n      return u(a, \"parentNode\", c);\n    }, next: function next(a) {\n      return F(a, \"nextSibling\");\n    }, prev: function prev(a) {\n      return F(a, \"previousSibling\");\n    }, nextAll: function nextAll(a) {\n      return u(a, \"nextSibling\");\n    }, prevAll: function prevAll(a) {\n      return u(a, \"previousSibling\");\n    }, nextUntil: function nextUntil(a, b, c) {\n      return u(a, \"nextSibling\", c);\n    }, prevUntil: function prevUntil(a, b, c) {\n      return u(a, \"previousSibling\", c);\n    }, siblings: function siblings(a) {\n      return v((a.parentNode || {}).firstChild, a);\n    }, children: function children(a) {\n      return v(a.firstChild);\n    }, contents: function contents(a) {\n      return a.contentDocument || n.merge([], a.childNodes);\n    } }, function (a, b) {\n    n.fn[a] = function (c, d) {\n      var e = n.map(this, b, c);return \"Until\" !== a.slice(-5) && (d = c), d && \"string\" == typeof d && (e = n.filter(d, e)), this.length > 1 && (E[a] || n.uniqueSort(e), D.test(a) && e.reverse()), this.pushStack(e);\n    };\n  });var G = /\\S+/g;function H(a) {\n    var b = {};return n.each(a.match(G) || [], function (a, c) {\n      b[c] = !0;\n    }), b;\n  }n.Callbacks = function (a) {\n    a = \"string\" == typeof a ? H(a) : n.extend({}, a);var b,\n        c,\n        d,\n        e,\n        f = [],\n        g = [],\n        h = -1,\n        i = function i() {\n      for (e = a.once, d = b = !0; g.length; h = -1) {\n        c = g.shift();while (++h < f.length) {\n          f[h].apply(c[0], c[1]) === !1 && a.stopOnFalse && (h = f.length, c = !1);\n        }\n      }a.memory || (c = !1), b = !1, e && (f = c ? [] : \"\");\n    },\n        j = { add: function add() {\n        return f && (c && !b && (h = f.length - 1, g.push(c)), function d(b) {\n          n.each(b, function (b, c) {\n            n.isFunction(c) ? a.unique && j.has(c) || f.push(c) : c && c.length && \"string\" !== n.type(c) && d(c);\n          });\n        }(arguments), c && !b && i()), this;\n      }, remove: function remove() {\n        return n.each(arguments, function (a, b) {\n          var c;while ((c = n.inArray(b, f, c)) > -1) {\n            f.splice(c, 1), h >= c && h--;\n          }\n        }), this;\n      }, has: function has(a) {\n        return a ? n.inArray(a, f) > -1 : f.length > 0;\n      }, empty: function empty() {\n        return f && (f = []), this;\n      }, disable: function disable() {\n        return e = g = [], f = c = \"\", this;\n      }, disabled: function disabled() {\n        return !f;\n      }, lock: function lock() {\n        return e = g = [], c || (f = c = \"\"), this;\n      }, locked: function locked() {\n        return !!e;\n      }, fireWith: function fireWith(a, c) {\n        return e || (c = c || [], c = [a, c.slice ? c.slice() : c], g.push(c), b || i()), this;\n      }, fire: function fire() {\n        return j.fireWith(this, arguments), this;\n      }, fired: function fired() {\n        return !!d;\n      } };return j;\n  }, n.extend({ Deferred: function Deferred(a) {\n      var b = [[\"resolve\", \"done\", n.Callbacks(\"once memory\"), \"resolved\"], [\"reject\", \"fail\", n.Callbacks(\"once memory\"), \"rejected\"], [\"notify\", \"progress\", n.Callbacks(\"memory\")]],\n          c = \"pending\",\n          d = { state: function state() {\n          return c;\n        }, always: function always() {\n          return e.done(arguments).fail(arguments), this;\n        }, then: function then() {\n          var a = arguments;return n.Deferred(function (c) {\n            n.each(b, function (b, f) {\n              var g = n.isFunction(a[b]) && a[b];e[f[1]](function () {\n                var a = g && g.apply(this, arguments);a && n.isFunction(a.promise) ? a.promise().progress(c.notify).done(c.resolve).fail(c.reject) : c[f[0] + \"With\"](this === d ? c.promise() : this, g ? [a] : arguments);\n              });\n            }), a = null;\n          }).promise();\n        }, promise: function promise(a) {\n          return null != a ? n.extend(a, d) : d;\n        } },\n          e = {};return d.pipe = d.then, n.each(b, function (a, f) {\n        var g = f[2],\n            h = f[3];d[f[1]] = g.add, h && g.add(function () {\n          c = h;\n        }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function () {\n          return e[f[0] + \"With\"](this === e ? d : this, arguments), this;\n        }, e[f[0] + \"With\"] = g.fireWith;\n      }), d.promise(e), a && a.call(e, e), e;\n    }, when: function when(a) {\n      var b = 0,\n          c = e.call(arguments),\n          d = c.length,\n          f = 1 !== d || a && n.isFunction(a.promise) ? d : 0,\n          g = 1 === f ? a : n.Deferred(),\n          h = function h(a, b, c) {\n        return function (d) {\n          b[a] = this, c[a] = arguments.length > 1 ? e.call(arguments) : d, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c);\n        };\n      },\n          i,\n          j,\n          k;if (d > 1) for (i = new Array(d), j = new Array(d), k = new Array(d); d > b; b++) {\n        c[b] && n.isFunction(c[b].promise) ? c[b].promise().progress(h(b, j, i)).done(h(b, k, c)).fail(g.reject) : --f;\n      }return f || g.resolveWith(k, c), g.promise();\n    } });var I;n.fn.ready = function (a) {\n    return n.ready.promise().done(a), this;\n  }, n.extend({ isReady: !1, readyWait: 1, holdReady: function holdReady(a) {\n      a ? n.readyWait++ : n.ready(!0);\n    }, ready: function ready(a) {\n      (a === !0 ? --n.readyWait : n.isReady) || (n.isReady = !0, a !== !0 && --n.readyWait > 0 || (I.resolveWith(d, [n]), n.fn.triggerHandler && (n(d).triggerHandler(\"ready\"), n(d).off(\"ready\"))));\n    } });function J() {\n    d.removeEventListener(\"DOMContentLoaded\", J), a.removeEventListener(\"load\", J), n.ready();\n  }n.ready.promise = function (b) {\n    return I || (I = n.Deferred(), \"complete\" === d.readyState || \"loading\" !== d.readyState && !d.documentElement.doScroll ? a.setTimeout(n.ready) : (d.addEventListener(\"DOMContentLoaded\", J), a.addEventListener(\"load\", J))), I.promise(b);\n  }, n.ready.promise();var K = function K(a, b, c, d, e, f, g) {\n    var h = 0,\n        i = a.length,\n        j = null == c;if (\"object\" === n.type(c)) {\n      e = !0;for (h in c) {\n        K(a, b, h, c[h], !0, f, g);\n      }\n    } else if (void 0 !== d && (e = !0, n.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function b(a, _b, c) {\n      return j.call(n(a), c);\n    })), b)) for (; i > h; h++) {\n      b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));\n    }return e ? a : j ? b.call(a) : i ? b(a[0], c) : f;\n  },\n      L = function L(a) {\n    return 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType;\n  };function M() {\n    this.expando = n.expando + M.uid++;\n  }M.uid = 1, M.prototype = { register: function register(a, b) {\n      var c = b || {};return a.nodeType ? a[this.expando] = c : Object.defineProperty(a, this.expando, { value: c, writable: !0, configurable: !0 }), a[this.expando];\n    }, cache: function cache(a) {\n      if (!L(a)) return {};var b = a[this.expando];return b || (b = {}, L(a) && (a.nodeType ? a[this.expando] = b : Object.defineProperty(a, this.expando, { value: b, configurable: !0 }))), b;\n    }, set: function set(a, b, c) {\n      var d,\n          e = this.cache(a);if (\"string\" == typeof b) e[b] = c;else for (d in b) {\n        e[d] = b[d];\n      }return e;\n    }, get: function get(a, b) {\n      return void 0 === b ? this.cache(a) : a[this.expando] && a[this.expando][b];\n    }, access: function access(a, b, c) {\n      var d;return void 0 === b || b && \"string\" == typeof b && void 0 === c ? (d = this.get(a, b), void 0 !== d ? d : this.get(a, n.camelCase(b))) : (this.set(a, b, c), void 0 !== c ? c : b);\n    }, remove: function remove(a, b) {\n      var c,\n          d,\n          e,\n          f = a[this.expando];if (void 0 !== f) {\n        if (void 0 === b) this.register(a);else {\n          n.isArray(b) ? d = b.concat(b.map(n.camelCase)) : (e = n.camelCase(b), b in f ? d = [b, e] : (d = e, d = d in f ? [d] : d.match(G) || [])), c = d.length;while (c--) {\n            delete f[d[c]];\n          }\n        }(void 0 === b || n.isEmptyObject(f)) && (a.nodeType ? a[this.expando] = void 0 : delete a[this.expando]);\n      }\n    }, hasData: function hasData(a) {\n      var b = a[this.expando];return void 0 !== b && !n.isEmptyObject(b);\n    } };var N = new M(),\n      O = new M(),\n      P = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n      Q = /[A-Z]/g;function R(a, b, c) {\n    var d;if (void 0 === c && 1 === a.nodeType) if (d = \"data-\" + b.replace(Q, \"-$&\").toLowerCase(), c = a.getAttribute(d), \"string\" == typeof c) {\n      try {\n        c = \"true\" === c ? !0 : \"false\" === c ? !1 : \"null\" === c ? null : +c + \"\" === c ? +c : P.test(c) ? n.parseJSON(c) : c;\n      } catch (e) {}O.set(a, b, c);\n    } else c = void 0;return c;\n  }n.extend({ hasData: function hasData(a) {\n      return O.hasData(a) || N.hasData(a);\n    }, data: function data(a, b, c) {\n      return O.access(a, b, c);\n    }, removeData: function removeData(a, b) {\n      O.remove(a, b);\n    }, _data: function _data(a, b, c) {\n      return N.access(a, b, c);\n    }, _removeData: function _removeData(a, b) {\n      N.remove(a, b);\n    } }), n.fn.extend({ data: function data(a, b) {\n      var c,\n          d,\n          e,\n          f = this[0],\n          g = f && f.attributes;if (void 0 === a) {\n        if (this.length && (e = O.get(f), 1 === f.nodeType && !N.get(f, \"hasDataAttrs\"))) {\n          c = g.length;while (c--) {\n            g[c] && (d = g[c].name, 0 === d.indexOf(\"data-\") && (d = n.camelCase(d.slice(5)), R(f, d, e[d])));\n          }N.set(f, \"hasDataAttrs\", !0);\n        }return e;\n      }return \"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) ? this.each(function () {\n        O.set(this, a);\n      }) : K(this, function (b) {\n        var c, d;if (f && void 0 === b) {\n          if (c = O.get(f, a) || O.get(f, a.replace(Q, \"-$&\").toLowerCase()), void 0 !== c) return c;if (d = n.camelCase(a), c = O.get(f, d), void 0 !== c) return c;if (c = R(f, d, void 0), void 0 !== c) return c;\n        } else d = n.camelCase(a), this.each(function () {\n          var c = O.get(this, d);O.set(this, d, b), a.indexOf(\"-\") > -1 && void 0 !== c && O.set(this, a, b);\n        });\n      }, null, b, arguments.length > 1, null, !0);\n    }, removeData: function removeData(a) {\n      return this.each(function () {\n        O.remove(this, a);\n      });\n    } }), n.extend({ queue: function queue(a, b, c) {\n      var d;return a ? (b = (b || \"fx\") + \"queue\", d = N.get(a, b), c && (!d || n.isArray(c) ? d = N.access(a, b, n.makeArray(c)) : d.push(c)), d || []) : void 0;\n    }, dequeue: function dequeue(a, b) {\n      b = b || \"fx\";var c = n.queue(a, b),\n          d = c.length,\n          e = c.shift(),\n          f = n._queueHooks(a, b),\n          g = function g() {\n        n.dequeue(a, b);\n      };\"inprogress\" === e && (e = c.shift(), d--), e && (\"fx\" === b && c.unshift(\"inprogress\"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire();\n    }, _queueHooks: function _queueHooks(a, b) {\n      var c = b + \"queueHooks\";return N.get(a, c) || N.access(a, c, { empty: n.Callbacks(\"once memory\").add(function () {\n          N.remove(a, [b + \"queue\", c]);\n        }) });\n    } }), n.fn.extend({ queue: function queue(a, b) {\n      var c = 2;return \"string\" != typeof a && (b = a, a = \"fx\", c--), arguments.length < c ? n.queue(this[0], a) : void 0 === b ? this : this.each(function () {\n        var c = n.queue(this, a, b);n._queueHooks(this, a), \"fx\" === a && \"inprogress\" !== c[0] && n.dequeue(this, a);\n      });\n    }, dequeue: function dequeue(a) {\n      return this.each(function () {\n        n.dequeue(this, a);\n      });\n    }, clearQueue: function clearQueue(a) {\n      return this.queue(a || \"fx\", []);\n    }, promise: function promise(a, b) {\n      var c,\n          d = 1,\n          e = n.Deferred(),\n          f = this,\n          g = this.length,\n          h = function h() {\n        --d || e.resolveWith(f, [f]);\n      };\"string\" != typeof a && (b = a, a = void 0), a = a || \"fx\";while (g--) {\n        c = N.get(f[g], a + \"queueHooks\"), c && c.empty && (d++, c.empty.add(h));\n      }return h(), e.promise(b);\n    } });var S = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,\n      T = new RegExp(\"^(?:([+-])=|)(\" + S + \")([a-z%]*)$\", \"i\"),\n      U = [\"Top\", \"Right\", \"Bottom\", \"Left\"],\n      V = function V(a, b) {\n    return a = b || a, \"none\" === n.css(a, \"display\") || !n.contains(a.ownerDocument, a);\n  };function W(a, b, c, d) {\n    var e,\n        f = 1,\n        g = 20,\n        h = d ? function () {\n      return d.cur();\n    } : function () {\n      return n.css(a, b, \"\");\n    },\n        i = h(),\n        j = c && c[3] || (n.cssNumber[b] ? \"\" : \"px\"),\n        k = (n.cssNumber[b] || \"px\" !== j && +i) && T.exec(n.css(a, b));if (k && k[3] !== j) {\n      j = j || k[3], c = c || [], k = +i || 1;do {\n        f = f || \".5\", k /= f, n.style(a, b, k + j);\n      } while (f !== (f = h() / i) && 1 !== f && --g);\n    }return c && (k = +k || +i || 0, e = c[1] ? k + (c[1] + 1) * c[2] : +c[2], d && (d.unit = j, d.start = k, d.end = e)), e;\n  }var X = /^(?:checkbox|radio)$/i,\n      Y = /<([\\w:-]+)/,\n      Z = /^$|\\/(?:java|ecma)script/i,\n      $ = { option: [1, \"<select multiple='multiple'>\", \"</select>\"], thead: [1, \"<table>\", \"</table>\"], col: [2, \"<table><colgroup>\", \"</colgroup></table>\"], tr: [2, \"<table><tbody>\", \"</tbody></table>\"], td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"], _default: [0, \"\", \"\"] };$.optgroup = $.option, $.tbody = $.tfoot = $.colgroup = $.caption = $.thead, $.th = $.td;function _(a, b) {\n    var c = \"undefined\" != typeof a.getElementsByTagName ? a.getElementsByTagName(b || \"*\") : \"undefined\" != typeof a.querySelectorAll ? a.querySelectorAll(b || \"*\") : [];return void 0 === b || b && n.nodeName(a, b) ? n.merge([a], c) : c;\n  }function aa(a, b) {\n    for (var c = 0, d = a.length; d > c; c++) {\n      N.set(a[c], \"globalEval\", !b || N.get(b[c], \"globalEval\"));\n    }\n  }var ba = /<|&#?\\w+;/;function ca(a, b, c, d, e) {\n    for (var f, g, h, i, j, k, l = b.createDocumentFragment(), m = [], o = 0, p = a.length; p > o; o++) {\n      if (f = a[o], f || 0 === f) if (\"object\" === n.type(f)) n.merge(m, f.nodeType ? [f] : f);else if (ba.test(f)) {\n        g = g || l.appendChild(b.createElement(\"div\")), h = (Y.exec(f) || [\"\", \"\"])[1].toLowerCase(), i = $[h] || $._default, g.innerHTML = i[1] + n.htmlPrefilter(f) + i[2], k = i[0];while (k--) {\n          g = g.lastChild;\n        }n.merge(m, g.childNodes), g = l.firstChild, g.textContent = \"\";\n      } else m.push(b.createTextNode(f));\n    }l.textContent = \"\", o = 0;while (f = m[o++]) {\n      if (d && n.inArray(f, d) > -1) e && e.push(f);else if (j = n.contains(f.ownerDocument, f), g = _(l.appendChild(f), \"script\"), j && aa(g), c) {\n        k = 0;while (f = g[k++]) {\n          Z.test(f.type || \"\") && c.push(f);\n        }\n      }\n    }return l;\n  }!function () {\n    var a = d.createDocumentFragment(),\n        b = a.appendChild(d.createElement(\"div\")),\n        c = d.createElement(\"input\");c.setAttribute(\"type\", \"radio\"), c.setAttribute(\"checked\", \"checked\"), c.setAttribute(\"name\", \"t\"), b.appendChild(c), l.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, b.innerHTML = \"<textarea>x</textarea>\", l.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue;\n  }();var da = /^key/,\n      ea = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n      fa = /^([^.]*)(?:\\.(.+)|)/;function ga() {\n    return !0;\n  }function ha() {\n    return !1;\n  }function ia() {\n    try {\n      return d.activeElement;\n    } catch (a) {}\n  }function ja(a, b, c, d, e, f) {\n    var g, h;if (\"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b))) {\n      \"string\" != typeof c && (d = d || c, c = void 0);for (h in b) {\n        ja(a, h, c, d, b[h], f);\n      }return a;\n    }if (null == d && null == e ? (e = c, d = c = void 0) : null == e && (\"string\" == typeof c ? (e = d, d = void 0) : (e = d, d = c, c = void 0)), e === !1) e = ha;else if (!e) return a;return 1 === f && (g = e, e = function e(a) {\n      return n().off(a), g.apply(this, arguments);\n    }, e.guid = g.guid || (g.guid = n.guid++)), a.each(function () {\n      n.event.add(this, b, e, d, c);\n    });\n  }n.event = { global: {}, add: function add(a, b, c, d, e) {\n      var f,\n          g,\n          h,\n          i,\n          j,\n          k,\n          l,\n          m,\n          o,\n          p,\n          q,\n          r = N.get(a);if (r) {\n        c.handler && (f = c, c = f.handler, e = f.selector), c.guid || (c.guid = n.guid++), (i = r.events) || (i = r.events = {}), (g = r.handle) || (g = r.handle = function (b) {\n          return \"undefined\" != typeof n && n.event.triggered !== b.type ? n.event.dispatch.apply(a, arguments) : void 0;\n        }), b = (b || \"\").match(G) || [\"\"], j = b.length;while (j--) {\n          h = fa.exec(b[j]) || [], o = q = h[1], p = (h[2] || \"\").split(\".\").sort(), o && (l = n.event.special[o] || {}, o = (e ? l.delegateType : l.bindType) || o, l = n.event.special[o] || {}, k = n.extend({ type: o, origType: q, data: d, handler: c, guid: c.guid, selector: e, needsContext: e && n.expr.match.needsContext.test(e), namespace: p.join(\".\") }, f), (m = i[o]) || (m = i[o] = [], m.delegateCount = 0, l.setup && l.setup.call(a, d, p, g) !== !1 || a.addEventListener && a.addEventListener(o, g)), l.add && (l.add.call(a, k), k.handler.guid || (k.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, k) : m.push(k), n.event.global[o] = !0);\n        }\n      }\n    }, remove: function remove(a, b, c, d, e) {\n      var f,\n          g,\n          h,\n          i,\n          j,\n          k,\n          l,\n          m,\n          o,\n          p,\n          q,\n          r = N.hasData(a) && N.get(a);if (r && (i = r.events)) {\n        b = (b || \"\").match(G) || [\"\"], j = b.length;while (j--) {\n          if (h = fa.exec(b[j]) || [], o = q = h[1], p = (h[2] || \"\").split(\".\").sort(), o) {\n            l = n.event.special[o] || {}, o = (d ? l.delegateType : l.bindType) || o, m = i[o] || [], h = h[2] && new RegExp(\"(^|\\\\.)\" + p.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\"), g = f = m.length;while (f--) {\n              k = m[f], !e && q !== k.origType || c && c.guid !== k.guid || h && !h.test(k.namespace) || d && d !== k.selector && (\"**\" !== d || !k.selector) || (m.splice(f, 1), k.selector && m.delegateCount--, l.remove && l.remove.call(a, k));\n            }g && !m.length && (l.teardown && l.teardown.call(a, p, r.handle) !== !1 || n.removeEvent(a, o, r.handle), delete i[o]);\n          } else for (o in i) {\n            n.event.remove(a, o + b[j], c, d, !0);\n          }\n        }n.isEmptyObject(i) && N.remove(a, \"handle events\");\n      }\n    }, dispatch: function dispatch(a) {\n      a = n.event.fix(a);var b,\n          c,\n          d,\n          f,\n          g,\n          h = [],\n          i = e.call(arguments),\n          j = (N.get(this, \"events\") || {})[a.type] || [],\n          k = n.event.special[a.type] || {};if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) {\n        h = n.event.handlers.call(this, a, j), b = 0;while ((f = h[b++]) && !a.isPropagationStopped()) {\n          a.currentTarget = f.elem, c = 0;while ((g = f.handlers[c++]) && !a.isImmediatePropagationStopped()) {\n            a.rnamespace && !a.rnamespace.test(g.namespace) || (a.handleObj = g, a.data = g.data, d = ((n.event.special[g.origType] || {}).handle || g.handler).apply(f.elem, i), void 0 !== d && (a.result = d) === !1 && (a.preventDefault(), a.stopPropagation()));\n          }\n        }return k.postDispatch && k.postDispatch.call(this, a), a.result;\n      }\n    }, handlers: function handlers(a, b) {\n      var c,\n          d,\n          e,\n          f,\n          g = [],\n          h = b.delegateCount,\n          i = a.target;if (h && i.nodeType && (\"click\" !== a.type || isNaN(a.button) || a.button < 1)) for (; i !== this; i = i.parentNode || this) {\n        if (1 === i.nodeType && (i.disabled !== !0 || \"click\" !== a.type)) {\n          for (d = [], c = 0; h > c; c++) {\n            f = b[c], e = f.selector + \" \", void 0 === d[e] && (d[e] = f.needsContext ? n(e, this).index(i) > -1 : n.find(e, this, null, [i]).length), d[e] && d.push(f);\n          }d.length && g.push({ elem: i, handlers: d });\n        }\n      }return h < b.length && g.push({ elem: this, handlers: b.slice(h) }), g;\n    }, props: \"altKey bubbles cancelable ctrlKey currentTarget detail eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"), fixHooks: {}, keyHooks: { props: \"char charCode key keyCode\".split(\" \"), filter: function filter(a, b) {\n        return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), a;\n      } }, mouseHooks: { props: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"), filter: function filter(a, b) {\n        var c,\n            e,\n            f,\n            g = b.button;return null == a.pageX && null != b.clientX && (c = a.target.ownerDocument || d, e = c.documentElement, f = c.body, a.pageX = b.clientX + (e && e.scrollLeft || f && f.scrollLeft || 0) - (e && e.clientLeft || f && f.clientLeft || 0), a.pageY = b.clientY + (e && e.scrollTop || f && f.scrollTop || 0) - (e && e.clientTop || f && f.clientTop || 0)), a.which || void 0 === g || (a.which = 1 & g ? 1 : 2 & g ? 3 : 4 & g ? 2 : 0), a;\n      } }, fix: function fix(a) {\n      if (a[n.expando]) return a;var b,\n          c,\n          e,\n          f = a.type,\n          g = a,\n          h = this.fixHooks[f];h || (this.fixHooks[f] = h = ea.test(f) ? this.mouseHooks : da.test(f) ? this.keyHooks : {}), e = h.props ? this.props.concat(h.props) : this.props, a = new n.Event(g), b = e.length;while (b--) {\n        c = e[b], a[c] = g[c];\n      }return a.target || (a.target = d), 3 === a.target.nodeType && (a.target = a.target.parentNode), h.filter ? h.filter(a, g) : a;\n    }, special: { load: { noBubble: !0 }, focus: { trigger: function trigger() {\n          return this !== ia() && this.focus ? (this.focus(), !1) : void 0;\n        }, delegateType: \"focusin\" }, blur: { trigger: function trigger() {\n          return this === ia() && this.blur ? (this.blur(), !1) : void 0;\n        }, delegateType: \"focusout\" }, click: { trigger: function trigger() {\n          return \"checkbox\" === this.type && this.click && n.nodeName(this, \"input\") ? (this.click(), !1) : void 0;\n        }, _default: function _default(a) {\n          return n.nodeName(a.target, \"a\");\n        } }, beforeunload: { postDispatch: function postDispatch(a) {\n          void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result);\n        } } } }, n.removeEvent = function (a, b, c) {\n    a.removeEventListener && a.removeEventListener(b, c);\n  }, n.Event = function (a, b) {\n    return this instanceof n.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? ga : ha) : this.type = a, b && n.extend(this, b), this.timeStamp = a && a.timeStamp || n.now(), void (this[n.expando] = !0)) : new n.Event(a, b);\n  }, n.Event.prototype = { constructor: n.Event, isDefaultPrevented: ha, isPropagationStopped: ha, isImmediatePropagationStopped: ha, isSimulated: !1, preventDefault: function preventDefault() {\n      var a = this.originalEvent;this.isDefaultPrevented = ga, a && !this.isSimulated && a.preventDefault();\n    }, stopPropagation: function stopPropagation() {\n      var a = this.originalEvent;this.isPropagationStopped = ga, a && !this.isSimulated && a.stopPropagation();\n    }, stopImmediatePropagation: function stopImmediatePropagation() {\n      var a = this.originalEvent;this.isImmediatePropagationStopped = ga, a && !this.isSimulated && a.stopImmediatePropagation(), this.stopPropagation();\n    } }, n.each({ mouseenter: \"mouseover\", mouseleave: \"mouseout\", pointerenter: \"pointerover\", pointerleave: \"pointerout\" }, function (a, b) {\n    n.event.special[a] = { delegateType: b, bindType: b, handle: function handle(a) {\n        var c,\n            d = this,\n            e = a.relatedTarget,\n            f = a.handleObj;return e && (e === d || n.contains(d, e)) || (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c;\n      } };\n  }), n.fn.extend({ on: function on(a, b, c, d) {\n      return ja(this, a, b, c, d);\n    }, one: function one(a, b, c, d) {\n      return ja(this, a, b, c, d, 1);\n    }, off: function off(a, b, c) {\n      var d, e;if (a && a.preventDefault && a.handleObj) return d = a.handleObj, n(a.delegateTarget).off(d.namespace ? d.origType + \".\" + d.namespace : d.origType, d.selector, d.handler), this;if (\"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a))) {\n        for (e in a) {\n          this.off(e, b, a[e]);\n        }return this;\n      }return b !== !1 && \"function\" != typeof b || (c = b, b = void 0), c === !1 && (c = ha), this.each(function () {\n        n.event.remove(this, a, c, b);\n      });\n    } });var ka = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:-]+)[^>]*)\\/>/gi,\n      la = /<script|<style|<link/i,\n      ma = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n      na = /^true\\/(.*)/,\n      oa = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;function pa(a, b) {\n    return n.nodeName(a, \"table\") && n.nodeName(11 !== b.nodeType ? b : b.firstChild, \"tr\") ? a.getElementsByTagName(\"tbody\")[0] || a.appendChild(a.ownerDocument.createElement(\"tbody\")) : a;\n  }function qa(a) {\n    return a.type = (null !== a.getAttribute(\"type\")) + \"/\" + a.type, a;\n  }function ra(a) {\n    var b = na.exec(a.type);return b ? a.type = b[1] : a.removeAttribute(\"type\"), a;\n  }function sa(a, b) {\n    var c, d, e, f, g, h, i, j;if (1 === b.nodeType) {\n      if (N.hasData(a) && (f = N.access(a), g = N.set(b, f), j = f.events)) {\n        delete g.handle, g.events = {};for (e in j) {\n          for (c = 0, d = j[e].length; d > c; c++) {\n            n.event.add(b, e, j[e][c]);\n          }\n        }\n      }O.hasData(a) && (h = O.access(a), i = n.extend({}, h), O.set(b, i));\n    }\n  }function ta(a, b) {\n    var c = b.nodeName.toLowerCase();\"input\" === c && X.test(a.type) ? b.checked = a.checked : \"input\" !== c && \"textarea\" !== c || (b.defaultValue = a.defaultValue);\n  }function ua(a, b, c, d) {\n    b = f.apply([], b);var e,\n        g,\n        h,\n        i,\n        j,\n        k,\n        m = 0,\n        o = a.length,\n        p = o - 1,\n        q = b[0],\n        r = n.isFunction(q);if (r || o > 1 && \"string\" == typeof q && !l.checkClone && ma.test(q)) return a.each(function (e) {\n      var f = a.eq(e);r && (b[0] = q.call(this, e, f.html())), ua(f, b, c, d);\n    });if (o && (e = ca(b, a[0].ownerDocument, !1, a, d), g = e.firstChild, 1 === e.childNodes.length && (e = g), g || d)) {\n      for (h = n.map(_(e, \"script\"), qa), i = h.length; o > m; m++) {\n        j = e, m !== p && (j = n.clone(j, !0, !0), i && n.merge(h, _(j, \"script\"))), c.call(a[m], j, m);\n      }if (i) for (k = h[h.length - 1].ownerDocument, n.map(h, ra), m = 0; i > m; m++) {\n        j = h[m], Z.test(j.type || \"\") && !N.access(j, \"globalEval\") && n.contains(k, j) && (j.src ? n._evalUrl && n._evalUrl(j.src) : n.globalEval(j.textContent.replace(oa, \"\")));\n      }\n    }return a;\n  }function va(a, b, c) {\n    for (var d, e = b ? n.filter(b, a) : a, f = 0; null != (d = e[f]); f++) {\n      c || 1 !== d.nodeType || n.cleanData(_(d)), d.parentNode && (c && n.contains(d.ownerDocument, d) && aa(_(d, \"script\")), d.parentNode.removeChild(d));\n    }return a;\n  }n.extend({ htmlPrefilter: function htmlPrefilter(a) {\n      return a.replace(ka, \"<$1></$2>\");\n    }, clone: function clone(a, b, c) {\n      var d,\n          e,\n          f,\n          g,\n          h = a.cloneNode(!0),\n          i = n.contains(a.ownerDocument, a);if (!(l.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || n.isXMLDoc(a))) for (g = _(h), f = _(a), d = 0, e = f.length; e > d; d++) {\n        ta(f[d], g[d]);\n      }if (b) if (c) for (f = f || _(a), g = g || _(h), d = 0, e = f.length; e > d; d++) {\n        sa(f[d], g[d]);\n      } else sa(a, h);return g = _(h, \"script\"), g.length > 0 && aa(g, !i && _(a, \"script\")), h;\n    }, cleanData: function cleanData(a) {\n      for (var b, c, d, e = n.event.special, f = 0; void 0 !== (c = a[f]); f++) {\n        if (L(c)) {\n          if (b = c[N.expando]) {\n            if (b.events) for (d in b.events) {\n              e[d] ? n.event.remove(c, d) : n.removeEvent(c, d, b.handle);\n            }c[N.expando] = void 0;\n          }c[O.expando] && (c[O.expando] = void 0);\n        }\n      }\n    } }), n.fn.extend({ domManip: ua, detach: function detach(a) {\n      return va(this, a, !0);\n    }, remove: function remove(a) {\n      return va(this, a);\n    }, text: function text(a) {\n      return K(this, function (a) {\n        return void 0 === a ? n.text(this) : this.empty().each(function () {\n          1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = a);\n        });\n      }, null, a, arguments.length);\n    }, append: function append() {\n      return ua(this, arguments, function (a) {\n        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n          var b = pa(this, a);b.appendChild(a);\n        }\n      });\n    }, prepend: function prepend() {\n      return ua(this, arguments, function (a) {\n        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n          var b = pa(this, a);b.insertBefore(a, b.firstChild);\n        }\n      });\n    }, before: function before() {\n      return ua(this, arguments, function (a) {\n        this.parentNode && this.parentNode.insertBefore(a, this);\n      });\n    }, after: function after() {\n      return ua(this, arguments, function (a) {\n        this.parentNode && this.parentNode.insertBefore(a, this.nextSibling);\n      });\n    }, empty: function empty() {\n      for (var a, b = 0; null != (a = this[b]); b++) {\n        1 === a.nodeType && (n.cleanData(_(a, !1)), a.textContent = \"\");\n      }return this;\n    }, clone: function clone(a, b) {\n      return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function () {\n        return n.clone(this, a, b);\n      });\n    }, html: function html(a) {\n      return K(this, function (a) {\n        var b = this[0] || {},\n            c = 0,\n            d = this.length;if (void 0 === a && 1 === b.nodeType) return b.innerHTML;if (\"string\" == typeof a && !la.test(a) && !$[(Y.exec(a) || [\"\", \"\"])[1].toLowerCase()]) {\n          a = n.htmlPrefilter(a);try {\n            for (; d > c; c++) {\n              b = this[c] || {}, 1 === b.nodeType && (n.cleanData(_(b, !1)), b.innerHTML = a);\n            }b = 0;\n          } catch (e) {}\n        }b && this.empty().append(a);\n      }, null, a, arguments.length);\n    }, replaceWith: function replaceWith() {\n      var a = [];return ua(this, arguments, function (b) {\n        var c = this.parentNode;n.inArray(this, a) < 0 && (n.cleanData(_(this)), c && c.replaceChild(b, this));\n      }, a);\n    } }), n.each({ appendTo: \"append\", prependTo: \"prepend\", insertBefore: \"before\", insertAfter: \"after\", replaceAll: \"replaceWith\" }, function (a, b) {\n    n.fn[a] = function (a) {\n      for (var c, d = [], e = n(a), f = e.length - 1, h = 0; f >= h; h++) {\n        c = h === f ? this : this.clone(!0), n(e[h])[b](c), g.apply(d, c.get());\n      }return this.pushStack(d);\n    };\n  });var wa,\n      xa = { HTML: \"block\", BODY: \"block\" };function ya(a, b) {\n    var c = n(b.createElement(a)).appendTo(b.body),\n        d = n.css(c[0], \"display\");return c.detach(), d;\n  }function za(a) {\n    var b = d,\n        c = xa[a];return c || (c = ya(a, b), \"none\" !== c && c || (wa = (wa || n(\"<iframe frameborder='0' width='0' height='0'/>\")).appendTo(b.documentElement), b = wa[0].contentDocument, b.write(), b.close(), c = ya(a, b), wa.detach()), xa[a] = c), c;\n  }var Aa = /^margin/,\n      Ba = new RegExp(\"^(\" + S + \")(?!px)[a-z%]+$\", \"i\"),\n      Ca = function Ca(b) {\n    var c = b.ownerDocument.defaultView;return c && c.opener || (c = a), c.getComputedStyle(b);\n  },\n      Da = function Da(a, b, c, d) {\n    var e,\n        f,\n        g = {};for (f in b) {\n      g[f] = a.style[f], a.style[f] = b[f];\n    }e = c.apply(a, d || []);for (f in b) {\n      a.style[f] = g[f];\n    }return e;\n  },\n      Ea = d.documentElement;!function () {\n    var b,\n        c,\n        e,\n        f,\n        g = d.createElement(\"div\"),\n        h = d.createElement(\"div\");if (h.style) {\n      (function () {\n        var i = function i() {\n          h.style.cssText = \"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%\", h.innerHTML = \"\", Ea.appendChild(g);var d = a.getComputedStyle(h);b = \"1%\" !== d.top, f = \"2px\" === d.marginLeft, c = \"4px\" === d.width, h.style.marginRight = \"50%\", e = \"4px\" === d.marginRight, Ea.removeChild(g);\n        };\n\n        h.style.backgroundClip = \"content-box\", h.cloneNode(!0).style.backgroundClip = \"\", l.clearCloneStyle = \"content-box\" === h.style.backgroundClip, g.style.cssText = \"border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute\", g.appendChild(h);n.extend(l, { pixelPosition: function pixelPosition() {\n            return i(), b;\n          }, boxSizingReliable: function boxSizingReliable() {\n            return null == c && i(), c;\n          }, pixelMarginRight: function pixelMarginRight() {\n            return null == c && i(), e;\n          }, reliableMarginLeft: function reliableMarginLeft() {\n            return null == c && i(), f;\n          }, reliableMarginRight: function reliableMarginRight() {\n            var b,\n                c = h.appendChild(d.createElement(\"div\"));return c.style.cssText = h.style.cssText = \"-webkit-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0\", c.style.marginRight = c.style.width = \"0\", h.style.width = \"1px\", Ea.appendChild(g), b = !parseFloat(a.getComputedStyle(c).marginRight), Ea.removeChild(g), h.removeChild(c), b;\n          } });\n      })();\n    }\n  }();function Fa(a, b, c) {\n    var d,\n        e,\n        f,\n        g,\n        h = a.style;return c = c || Ca(a), g = c ? c.getPropertyValue(b) || c[b] : void 0, \"\" !== g && void 0 !== g || n.contains(a.ownerDocument, a) || (g = n.style(a, b)), c && !l.pixelMarginRight() && Ba.test(g) && Aa.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f), void 0 !== g ? g + \"\" : g;\n  }function Ga(a, b) {\n    return { get: function get() {\n        return a() ? void delete this.get : (this.get = b).apply(this, arguments);\n      } };\n  }var Ha = /^(none|table(?!-c[ea]).+)/,\n      Ia = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n      Ja = { letterSpacing: \"0\", fontWeight: \"400\" },\n      Ka = [\"Webkit\", \"O\", \"Moz\", \"ms\"],\n      La = d.createElement(\"div\").style;function Ma(a) {\n    if (a in La) return a;var b = a[0].toUpperCase() + a.slice(1),\n        c = Ka.length;while (c--) {\n      if (a = Ka[c] + b, a in La) return a;\n    }\n  }function Na(a, b, c) {\n    var d = T.exec(b);return d ? Math.max(0, d[2] - (c || 0)) + (d[3] || \"px\") : b;\n  }function Oa(a, b, c, d, e) {\n    for (var f = c === (d ? \"border\" : \"content\") ? 4 : \"width\" === b ? 1 : 0, g = 0; 4 > f; f += 2) {\n      \"margin\" === c && (g += n.css(a, c + U[f], !0, e)), d ? (\"content\" === c && (g -= n.css(a, \"padding\" + U[f], !0, e)), \"margin\" !== c && (g -= n.css(a, \"border\" + U[f] + \"Width\", !0, e))) : (g += n.css(a, \"padding\" + U[f], !0, e), \"padding\" !== c && (g += n.css(a, \"border\" + U[f] + \"Width\", !0, e)));\n    }return g;\n  }function Pa(a, b, c) {\n    var d = !0,\n        e = \"width\" === b ? a.offsetWidth : a.offsetHeight,\n        f = Ca(a),\n        g = \"border-box\" === n.css(a, \"boxSizing\", !1, f);if (0 >= e || null == e) {\n      if (e = Fa(a, b, f), (0 > e || null == e) && (e = a.style[b]), Ba.test(e)) return e;d = g && (l.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0;\n    }return e + Oa(a, b, c || (g ? \"border\" : \"content\"), d, f) + \"px\";\n  }function Qa(a, b) {\n    for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++) {\n      d = a[g], d.style && (f[g] = N.get(d, \"olddisplay\"), c = d.style.display, b ? (f[g] || \"none\" !== c || (d.style.display = \"\"), \"\" === d.style.display && V(d) && (f[g] = N.access(d, \"olddisplay\", za(d.nodeName)))) : (e = V(d), \"none\" === c && e || N.set(d, \"olddisplay\", e ? c : n.css(d, \"display\"))));\n    }for (g = 0; h > g; g++) {\n      d = a[g], d.style && (b && \"none\" !== d.style.display && \"\" !== d.style.display || (d.style.display = b ? f[g] || \"\" : \"none\"));\n    }return a;\n  }n.extend({ cssHooks: { opacity: { get: function get(a, b) {\n          if (b) {\n            var c = Fa(a, \"opacity\");return \"\" === c ? \"1\" : c;\n          }\n        } } }, cssNumber: { animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: { \"float\": \"cssFloat\" }, style: function style(a, b, c, d) {\n      if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {\n        var e,\n            f,\n            g,\n            h = n.camelCase(b),\n            i = a.style;return b = n.cssProps[h] || (n.cssProps[h] = Ma(h) || h), g = n.cssHooks[b] || n.cssHooks[h], void 0 === c ? g && \"get\" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b] : (f = typeof c === \"undefined\" ? \"undefined\" : _typeof(c), \"string\" === f && (e = T.exec(c)) && e[1] && (c = W(a, b, e), f = \"number\"), null != c && c === c && (\"number\" === f && (c += e && e[3] || (n.cssNumber[h] ? \"\" : \"px\")), l.clearCloneStyle || \"\" !== c || 0 !== b.indexOf(\"background\") || (i[b] = \"inherit\"), g && \"set\" in g && void 0 === (c = g.set(a, c, d)) || (i[b] = c)), void 0);\n      }\n    }, css: function css(a, b, c, d) {\n      var e,\n          f,\n          g,\n          h = n.camelCase(b);return b = n.cssProps[h] || (n.cssProps[h] = Ma(h) || h), g = n.cssHooks[b] || n.cssHooks[h], g && \"get\" in g && (e = g.get(a, !0, c)), void 0 === e && (e = Fa(a, b, d)), \"normal\" === e && b in Ja && (e = Ja[b]), \"\" === c || c ? (f = parseFloat(e), c === !0 || isFinite(f) ? f || 0 : e) : e;\n    } }), n.each([\"height\", \"width\"], function (a, b) {\n    n.cssHooks[b] = { get: function get(a, c, d) {\n        return c ? Ha.test(n.css(a, \"display\")) && 0 === a.offsetWidth ? Da(a, Ia, function () {\n          return Pa(a, b, d);\n        }) : Pa(a, b, d) : void 0;\n      }, set: function set(a, c, d) {\n        var e,\n            f = d && Ca(a),\n            g = d && Oa(a, b, d, \"border-box\" === n.css(a, \"boxSizing\", !1, f), f);return g && (e = T.exec(c)) && \"px\" !== (e[3] || \"px\") && (a.style[b] = c, c = n.css(a, b)), Na(a, c, g);\n      } };\n  }), n.cssHooks.marginLeft = Ga(l.reliableMarginLeft, function (a, b) {\n    return b ? (parseFloat(Fa(a, \"marginLeft\")) || a.getBoundingClientRect().left - Da(a, { marginLeft: 0 }, function () {\n      return a.getBoundingClientRect().left;\n    })) + \"px\" : void 0;\n  }), n.cssHooks.marginRight = Ga(l.reliableMarginRight, function (a, b) {\n    return b ? Da(a, { display: \"inline-block\" }, Fa, [a, \"marginRight\"]) : void 0;\n  }), n.each({ margin: \"\", padding: \"\", border: \"Width\" }, function (a, b) {\n    n.cssHooks[a + b] = { expand: function expand(c) {\n        for (var d = 0, e = {}, f = \"string\" == typeof c ? c.split(\" \") : [c]; 4 > d; d++) {\n          e[a + U[d] + b] = f[d] || f[d - 2] || f[0];\n        }return e;\n      } }, Aa.test(a) || (n.cssHooks[a + b].set = Na);\n  }), n.fn.extend({ css: function css(a, b) {\n      return K(this, function (a, b, c) {\n        var d,\n            e,\n            f = {},\n            g = 0;if (n.isArray(b)) {\n          for (d = Ca(a), e = b.length; e > g; g++) {\n            f[b[g]] = n.css(a, b[g], !1, d);\n          }return f;\n        }return void 0 !== c ? n.style(a, b, c) : n.css(a, b);\n      }, a, b, arguments.length > 1);\n    }, show: function show() {\n      return Qa(this, !0);\n    }, hide: function hide() {\n      return Qa(this);\n    }, toggle: function toggle(a) {\n      return \"boolean\" == typeof a ? a ? this.show() : this.hide() : this.each(function () {\n        V(this) ? n(this).show() : n(this).hide();\n      });\n    } });function Ra(a, b, c, d, e) {\n    return new Ra.prototype.init(a, b, c, d, e);\n  }n.Tween = Ra, Ra.prototype = { constructor: Ra, init: function init(a, b, c, d, e, f) {\n      this.elem = a, this.prop = c, this.easing = e || n.easing._default, this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (n.cssNumber[c] ? \"\" : \"px\");\n    }, cur: function cur() {\n      var a = Ra.propHooks[this.prop];return a && a.get ? a.get(this) : Ra.propHooks._default.get(this);\n    }, run: function run(a) {\n      var b,\n          c = Ra.propHooks[this.prop];return this.options.duration ? this.pos = b = n.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : this.pos = b = a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : Ra.propHooks._default.set(this), this;\n    } }, Ra.prototype.init.prototype = Ra.prototype, Ra.propHooks = { _default: { get: function get(a) {\n        var b;return 1 !== a.elem.nodeType || null != a.elem[a.prop] && null == a.elem.style[a.prop] ? a.elem[a.prop] : (b = n.css(a.elem, a.prop, \"\"), b && \"auto\" !== b ? b : 0);\n      }, set: function set(a) {\n        n.fx.step[a.prop] ? n.fx.step[a.prop](a) : 1 !== a.elem.nodeType || null == a.elem.style[n.cssProps[a.prop]] && !n.cssHooks[a.prop] ? a.elem[a.prop] = a.now : n.style(a.elem, a.prop, a.now + a.unit);\n      } } }, Ra.propHooks.scrollTop = Ra.propHooks.scrollLeft = { set: function set(a) {\n      a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now);\n    } }, n.easing = { linear: function linear(a) {\n      return a;\n    }, swing: function swing(a) {\n      return .5 - Math.cos(a * Math.PI) / 2;\n    }, _default: \"swing\" }, n.fx = Ra.prototype.init, n.fx.step = {};var Sa,\n      Ta,\n      Ua = /^(?:toggle|show|hide)$/,\n      Va = /queueHooks$/;function Wa() {\n    return a.setTimeout(function () {\n      Sa = void 0;\n    }), Sa = n.now();\n  }function Xa(a, b) {\n    var c,\n        d = 0,\n        e = { height: a };for (b = b ? 1 : 0; 4 > d; d += 2 - b) {\n      c = U[d], e[\"margin\" + c] = e[\"padding\" + c] = a;\n    }return b && (e.opacity = e.width = a), e;\n  }function Ya(a, b, c) {\n    for (var d, e = (_a.tweeners[b] || []).concat(_a.tweeners[\"*\"]), f = 0, g = e.length; g > f; f++) {\n      if (d = e[f].call(c, b, a)) return d;\n    }\n  }function Za(a, b, c) {\n    var d,\n        e,\n        f,\n        g,\n        h,\n        i,\n        j,\n        k,\n        l = this,\n        m = {},\n        o = a.style,\n        p = a.nodeType && V(a),\n        q = N.get(a, \"fxshow\");c.queue || (h = n._queueHooks(a, \"fx\"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function () {\n      h.unqueued || i();\n    }), h.unqueued++, l.always(function () {\n      l.always(function () {\n        h.unqueued--, n.queue(a, \"fx\").length || h.empty.fire();\n      });\n    })), 1 === a.nodeType && (\"height\" in b || \"width\" in b) && (c.overflow = [o.overflow, o.overflowX, o.overflowY], j = n.css(a, \"display\"), k = \"none\" === j ? N.get(a, \"olddisplay\") || za(a.nodeName) : j, \"inline\" === k && \"none\" === n.css(a, \"float\") && (o.display = \"inline-block\")), c.overflow && (o.overflow = \"hidden\", l.always(function () {\n      o.overflow = c.overflow[0], o.overflowX = c.overflow[1], o.overflowY = c.overflow[2];\n    }));for (d in b) {\n      if (e = b[d], Ua.exec(e)) {\n        if (delete b[d], f = f || \"toggle\" === e, e === (p ? \"hide\" : \"show\")) {\n          if (\"show\" !== e || !q || void 0 === q[d]) continue;p = !0;\n        }m[d] = q && q[d] || n.style(a, d);\n      } else j = void 0;\n    }if (n.isEmptyObject(m)) \"inline\" === (\"none\" === j ? za(a.nodeName) : j) && (o.display = j);else {\n      q ? \"hidden\" in q && (p = q.hidden) : q = N.access(a, \"fxshow\", {}), f && (q.hidden = !p), p ? n(a).show() : l.done(function () {\n        n(a).hide();\n      }), l.done(function () {\n        var b;N.remove(a, \"fxshow\");for (b in m) {\n          n.style(a, b, m[b]);\n        }\n      });for (d in m) {\n        g = Ya(p ? q[d] : 0, d, l), d in q || (q[d] = g.start, p && (g.end = g.start, g.start = \"width\" === d || \"height\" === d ? 1 : 0));\n      }\n    }\n  }function $a(a, b) {\n    var c, d, e, f, g;for (c in a) {\n      if (d = n.camelCase(c), e = b[d], f = a[c], n.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = n.cssHooks[d], g && \"expand\" in g) {\n        f = g.expand(f), delete a[d];for (c in f) {\n          c in a || (a[c] = f[c], b[c] = e);\n        }\n      } else b[d] = e;\n    }\n  }function _a(a, b, c) {\n    var d,\n        e,\n        f = 0,\n        g = _a.prefilters.length,\n        h = n.Deferred().always(function () {\n      delete i.elem;\n    }),\n        i = function i() {\n      if (e) return !1;for (var b = Sa || Wa(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++) {\n        j.tweens[g].run(f);\n      }return h.notifyWith(a, [j, f, c]), 1 > f && i ? c : (h.resolveWith(a, [j]), !1);\n    },\n        j = h.promise({ elem: a, props: n.extend({}, b), opts: n.extend(!0, { specialEasing: {}, easing: n.easing._default }, c), originalProperties: b, originalOptions: c, startTime: Sa || Wa(), duration: c.duration, tweens: [], createTween: function createTween(b, c) {\n        var d = n.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);return j.tweens.push(d), d;\n      }, stop: function stop(b) {\n        var c = 0,\n            d = b ? j.tweens.length : 0;if (e) return this;for (e = !0; d > c; c++) {\n          j.tweens[c].run(1);\n        }return b ? (h.notifyWith(a, [j, 1, 0]), h.resolveWith(a, [j, b])) : h.rejectWith(a, [j, b]), this;\n      } }),\n        k = j.props;for ($a(k, j.opts.specialEasing); g > f; f++) {\n      if (d = _a.prefilters[f].call(j, a, k, j.opts)) return n.isFunction(d.stop) && (n._queueHooks(j.elem, j.opts.queue).stop = n.proxy(d.stop, d)), d;\n    }return n.map(k, Ya, j), n.isFunction(j.opts.start) && j.opts.start.call(a, j), n.fx.timer(n.extend(i, { elem: a, anim: j, queue: j.opts.queue })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always);\n  }n.Animation = n.extend(_a, { tweeners: { \"*\": [function (a, b) {\n        var c = this.createTween(a, b);return W(c.elem, a, T.exec(b), c), c;\n      }] }, tweener: function tweener(a, b) {\n      n.isFunction(a) ? (b = a, a = [\"*\"]) : a = a.match(G);for (var c, d = 0, e = a.length; e > d; d++) {\n        c = a[d], _a.tweeners[c] = _a.tweeners[c] || [], _a.tweeners[c].unshift(b);\n      }\n    }, prefilters: [Za], prefilter: function prefilter(a, b) {\n      b ? _a.prefilters.unshift(a) : _a.prefilters.push(a);\n    } }), n.speed = function (a, b, c) {\n    var d = a && \"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) ? n.extend({}, a) : { complete: c || !c && b || n.isFunction(a) && a, duration: a, easing: c && b || b && !n.isFunction(b) && b };return d.duration = n.fx.off ? 0 : \"number\" == typeof d.duration ? d.duration : d.duration in n.fx.speeds ? n.fx.speeds[d.duration] : n.fx.speeds._default, null != d.queue && d.queue !== !0 || (d.queue = \"fx\"), d.old = d.complete, d.complete = function () {\n      n.isFunction(d.old) && d.old.call(this), d.queue && n.dequeue(this, d.queue);\n    }, d;\n  }, n.fn.extend({ fadeTo: function fadeTo(a, b, c, d) {\n      return this.filter(V).css(\"opacity\", 0).show().end().animate({ opacity: b }, a, c, d);\n    }, animate: function animate(a, b, c, d) {\n      var e = n.isEmptyObject(a),\n          f = n.speed(b, c, d),\n          g = function g() {\n        var b = _a(this, n.extend({}, a), f);(e || N.get(this, \"finish\")) && b.stop(!0);\n      };return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g);\n    }, stop: function stop(a, b, c) {\n      var d = function d(a) {\n        var b = a.stop;delete a.stop, b(c);\n      };return \"string\" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || \"fx\", []), this.each(function () {\n        var b = !0,\n            e = null != a && a + \"queueHooks\",\n            f = n.timers,\n            g = N.get(this);if (e) g[e] && g[e].stop && d(g[e]);else for (e in g) {\n          g[e] && g[e].stop && Va.test(e) && d(g[e]);\n        }for (e = f.length; e--;) {\n          f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1));\n        }!b && c || n.dequeue(this, a);\n      });\n    }, finish: function finish(a) {\n      return a !== !1 && (a = a || \"fx\"), this.each(function () {\n        var b,\n            c = N.get(this),\n            d = c[a + \"queue\"],\n            e = c[a + \"queueHooks\"],\n            f = n.timers,\n            g = d ? d.length : 0;for (c.finish = !0, n.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--;) {\n          f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1));\n        }for (b = 0; g > b; b++) {\n          d[b] && d[b].finish && d[b].finish.call(this);\n        }delete c.finish;\n      });\n    } }), n.each([\"toggle\", \"show\", \"hide\"], function (a, b) {\n    var c = n.fn[b];n.fn[b] = function (a, d, e) {\n      return null == a || \"boolean\" == typeof a ? c.apply(this, arguments) : this.animate(Xa(b, !0), a, d, e);\n    };\n  }), n.each({ slideDown: Xa(\"show\"), slideUp: Xa(\"hide\"), slideToggle: Xa(\"toggle\"), fadeIn: { opacity: \"show\" }, fadeOut: { opacity: \"hide\" }, fadeToggle: { opacity: \"toggle\" } }, function (a, b) {\n    n.fn[a] = function (a, c, d) {\n      return this.animate(b, a, c, d);\n    };\n  }), n.timers = [], n.fx.tick = function () {\n    var a,\n        b = 0,\n        c = n.timers;for (Sa = n.now(); b < c.length; b++) {\n      a = c[b], a() || c[b] !== a || c.splice(b--, 1);\n    }c.length || n.fx.stop(), Sa = void 0;\n  }, n.fx.timer = function (a) {\n    n.timers.push(a), a() ? n.fx.start() : n.timers.pop();\n  }, n.fx.interval = 13, n.fx.start = function () {\n    Ta || (Ta = a.setInterval(n.fx.tick, n.fx.interval));\n  }, n.fx.stop = function () {\n    a.clearInterval(Ta), Ta = null;\n  }, n.fx.speeds = { slow: 600, fast: 200, _default: 400 }, n.fn.delay = function (b, c) {\n    return b = n.fx ? n.fx.speeds[b] || b : b, c = c || \"fx\", this.queue(c, function (c, d) {\n      var e = a.setTimeout(c, b);d.stop = function () {\n        a.clearTimeout(e);\n      };\n    });\n  }, function () {\n    var a = d.createElement(\"input\"),\n        b = d.createElement(\"select\"),\n        c = b.appendChild(d.createElement(\"option\"));a.type = \"checkbox\", l.checkOn = \"\" !== a.value, l.optSelected = c.selected, b.disabled = !0, l.optDisabled = !c.disabled, a = d.createElement(\"input\"), a.value = \"t\", a.type = \"radio\", l.radioValue = \"t\" === a.value;\n  }();var ab,\n      bb = n.expr.attrHandle;n.fn.extend({ attr: function attr(a, b) {\n      return K(this, n.attr, a, b, arguments.length > 1);\n    }, removeAttr: function removeAttr(a) {\n      return this.each(function () {\n        n.removeAttr(this, a);\n      });\n    } }), n.extend({ attr: function attr(a, b, c) {\n      var d,\n          e,\n          f = a.nodeType;if (3 !== f && 8 !== f && 2 !== f) return \"undefined\" == typeof a.getAttribute ? n.prop(a, b, c) : (1 === f && n.isXMLDoc(a) || (b = b.toLowerCase(), e = n.attrHooks[b] || (n.expr.match.bool.test(b) ? ab : void 0)), void 0 !== c ? null === c ? void n.removeAttr(a, b) : e && \"set\" in e && void 0 !== (d = e.set(a, c, b)) ? d : (a.setAttribute(b, c + \"\"), c) : e && \"get\" in e && null !== (d = e.get(a, b)) ? d : (d = n.find.attr(a, b), null == d ? void 0 : d));\n    }, attrHooks: { type: { set: function set(a, b) {\n          if (!l.radioValue && \"radio\" === b && n.nodeName(a, \"input\")) {\n            var c = a.value;return a.setAttribute(\"type\", b), c && (a.value = c), b;\n          }\n        } } }, removeAttr: function removeAttr(a, b) {\n      var c,\n          d,\n          e = 0,\n          f = b && b.match(G);if (f && 1 === a.nodeType) while (c = f[e++]) {\n        d = n.propFix[c] || c, n.expr.match.bool.test(c) && (a[d] = !1), a.removeAttribute(c);\n      }\n    } }), ab = { set: function set(a, b, c) {\n      return b === !1 ? n.removeAttr(a, c) : a.setAttribute(c, c), c;\n    } }, n.each(n.expr.match.bool.source.match(/\\w+/g), function (a, b) {\n    var c = bb[b] || n.find.attr;bb[b] = function (a, b, d) {\n      var e, f;return d || (f = bb[b], bb[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, bb[b] = f), e;\n    };\n  });var cb = /^(?:input|select|textarea|button)$/i,\n      db = /^(?:a|area)$/i;n.fn.extend({ prop: function prop(a, b) {\n      return K(this, n.prop, a, b, arguments.length > 1);\n    }, removeProp: function removeProp(a) {\n      return this.each(function () {\n        delete this[n.propFix[a] || a];\n      });\n    } }), n.extend({ prop: function prop(a, b, c) {\n      var d,\n          e,\n          f = a.nodeType;if (3 !== f && 8 !== f && 2 !== f) return 1 === f && n.isXMLDoc(a) || (b = n.propFix[b] || b, e = n.propHooks[b]), void 0 !== c ? e && \"set\" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && \"get\" in e && null !== (d = e.get(a, b)) ? d : a[b];\n    }, propHooks: { tabIndex: { get: function get(a) {\n          var b = n.find.attr(a, \"tabindex\");return b ? parseInt(b, 10) : cb.test(a.nodeName) || db.test(a.nodeName) && a.href ? 0 : -1;\n        } } }, propFix: { \"for\": \"htmlFor\", \"class\": \"className\" } }), l.optSelected || (n.propHooks.selected = { get: function get(a) {\n      var b = a.parentNode;return b && b.parentNode && b.parentNode.selectedIndex, null;\n    }, set: function set(a) {\n      var b = a.parentNode;b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex);\n    } }), n.each([\"tabIndex\", \"readOnly\", \"maxLength\", \"cellSpacing\", \"cellPadding\", \"rowSpan\", \"colSpan\", \"useMap\", \"frameBorder\", \"contentEditable\"], function () {\n    n.propFix[this.toLowerCase()] = this;\n  });var eb = /[\\t\\r\\n\\f]/g;function fb(a) {\n    return a.getAttribute && a.getAttribute(\"class\") || \"\";\n  }n.fn.extend({ addClass: function addClass(a) {\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          i = 0;if (n.isFunction(a)) return this.each(function (b) {\n        n(this).addClass(a.call(this, b, fb(this)));\n      });if (\"string\" == typeof a && a) {\n        b = a.match(G) || [];while (c = this[i++]) {\n          if (e = fb(c), d = 1 === c.nodeType && (\" \" + e + \" \").replace(eb, \" \")) {\n            g = 0;while (f = b[g++]) {\n              d.indexOf(\" \" + f + \" \") < 0 && (d += f + \" \");\n            }h = n.trim(d), e !== h && c.setAttribute(\"class\", h);\n          }\n        }\n      }return this;\n    }, removeClass: function removeClass(a) {\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          i = 0;if (n.isFunction(a)) return this.each(function (b) {\n        n(this).removeClass(a.call(this, b, fb(this)));\n      });if (!arguments.length) return this.attr(\"class\", \"\");if (\"string\" == typeof a && a) {\n        b = a.match(G) || [];while (c = this[i++]) {\n          if (e = fb(c), d = 1 === c.nodeType && (\" \" + e + \" \").replace(eb, \" \")) {\n            g = 0;while (f = b[g++]) {\n              while (d.indexOf(\" \" + f + \" \") > -1) {\n                d = d.replace(\" \" + f + \" \", \" \");\n              }\n            }h = n.trim(d), e !== h && c.setAttribute(\"class\", h);\n          }\n        }\n      }return this;\n    }, toggleClass: function toggleClass(a, b) {\n      var c = typeof a === \"undefined\" ? \"undefined\" : _typeof(a);return \"boolean\" == typeof b && \"string\" === c ? b ? this.addClass(a) : this.removeClass(a) : n.isFunction(a) ? this.each(function (c) {\n        n(this).toggleClass(a.call(this, c, fb(this), b), b);\n      }) : this.each(function () {\n        var b, d, e, f;if (\"string\" === c) {\n          d = 0, e = n(this), f = a.match(G) || [];while (b = f[d++]) {\n            e.hasClass(b) ? e.removeClass(b) : e.addClass(b);\n          }\n        } else void 0 !== a && \"boolean\" !== c || (b = fb(this), b && N.set(this, \"__className__\", b), this.setAttribute && this.setAttribute(\"class\", b || a === !1 ? \"\" : N.get(this, \"__className__\") || \"\"));\n      });\n    }, hasClass: function hasClass(a) {\n      var b,\n          c,\n          d = 0;b = \" \" + a + \" \";while (c = this[d++]) {\n        if (1 === c.nodeType && (\" \" + fb(c) + \" \").replace(eb, \" \").indexOf(b) > -1) return !0;\n      }return !1;\n    } });var gb = /\\r/g,\n      hb = /[\\x20\\t\\r\\n\\f]+/g;n.fn.extend({ val: function val(a) {\n      var b,\n          c,\n          d,\n          e = this[0];{\n        if (arguments.length) return d = n.isFunction(a), this.each(function (c) {\n          var e;1 === this.nodeType && (e = d ? a.call(this, c, n(this).val()) : a, null == e ? e = \"\" : \"number\" == typeof e ? e += \"\" : n.isArray(e) && (e = n.map(e, function (a) {\n            return null == a ? \"\" : a + \"\";\n          })), b = n.valHooks[this.type] || n.valHooks[this.nodeName.toLowerCase()], b && \"set\" in b && void 0 !== b.set(this, e, \"value\") || (this.value = e));\n        });if (e) return b = n.valHooks[e.type] || n.valHooks[e.nodeName.toLowerCase()], b && \"get\" in b && void 0 !== (c = b.get(e, \"value\")) ? c : (c = e.value, \"string\" == typeof c ? c.replace(gb, \"\") : null == c ? \"\" : c);\n      }\n    } }), n.extend({ valHooks: { option: { get: function get(a) {\n          var b = n.find.attr(a, \"value\");return null != b ? b : n.trim(n.text(a)).replace(hb, \" \");\n        } }, select: { get: function get(a) {\n          for (var b, c, d = a.options, e = a.selectedIndex, f = \"select-one\" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++) {\n            if (c = d[i], (c.selected || i === e) && (l.optDisabled ? !c.disabled : null === c.getAttribute(\"disabled\")) && (!c.parentNode.disabled || !n.nodeName(c.parentNode, \"optgroup\"))) {\n              if (b = n(c).val(), f) return b;g.push(b);\n            }\n          }return g;\n        }, set: function set(a, b) {\n          var c,\n              d,\n              e = a.options,\n              f = n.makeArray(b),\n              g = e.length;while (g--) {\n            d = e[g], (d.selected = n.inArray(n.valHooks.option.get(d), f) > -1) && (c = !0);\n          }return c || (a.selectedIndex = -1), f;\n        } } } }), n.each([\"radio\", \"checkbox\"], function () {\n    n.valHooks[this] = { set: function set(a, b) {\n        return n.isArray(b) ? a.checked = n.inArray(n(a).val(), b) > -1 : void 0;\n      } }, l.checkOn || (n.valHooks[this].get = function (a) {\n      return null === a.getAttribute(\"value\") ? \"on\" : a.value;\n    });\n  });var ib = /^(?:focusinfocus|focusoutblur)$/;n.extend(n.event, { trigger: function trigger(b, c, e, f) {\n      var g,\n          h,\n          i,\n          j,\n          l,\n          m,\n          o,\n          p = [e || d],\n          q = k.call(b, \"type\") ? b.type : b,\n          r = k.call(b, \"namespace\") ? b.namespace.split(\".\") : [];if (h = i = e = e || d, 3 !== e.nodeType && 8 !== e.nodeType && !ib.test(q + n.event.triggered) && (q.indexOf(\".\") > -1 && (r = q.split(\".\"), q = r.shift(), r.sort()), l = q.indexOf(\":\") < 0 && \"on\" + q, b = b[n.expando] ? b : new n.Event(q, \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && b), b.isTrigger = f ? 2 : 3, b.namespace = r.join(\".\"), b.rnamespace = b.namespace ? new RegExp(\"(^|\\\\.)\" + r.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null, b.result = void 0, b.target || (b.target = e), c = null == c ? [b] : n.makeArray(c, [b]), o = n.event.special[q] || {}, f || !o.trigger || o.trigger.apply(e, c) !== !1)) {\n        if (!f && !o.noBubble && !n.isWindow(e)) {\n          for (j = o.delegateType || q, ib.test(j + q) || (h = h.parentNode); h; h = h.parentNode) {\n            p.push(h), i = h;\n          }i === (e.ownerDocument || d) && p.push(i.defaultView || i.parentWindow || a);\n        }g = 0;while ((h = p[g++]) && !b.isPropagationStopped()) {\n          b.type = g > 1 ? j : o.bindType || q, m = (N.get(h, \"events\") || {})[b.type] && N.get(h, \"handle\"), m && m.apply(h, c), m = l && h[l], m && m.apply && L(h) && (b.result = m.apply(h, c), b.result === !1 && b.preventDefault());\n        }return b.type = q, f || b.isDefaultPrevented() || o._default && o._default.apply(p.pop(), c) !== !1 || !L(e) || l && n.isFunction(e[q]) && !n.isWindow(e) && (i = e[l], i && (e[l] = null), n.event.triggered = q, e[q](), n.event.triggered = void 0, i && (e[l] = i)), b.result;\n      }\n    }, simulate: function simulate(a, b, c) {\n      var d = n.extend(new n.Event(), c, { type: a, isSimulated: !0 });n.event.trigger(d, null, b);\n    } }), n.fn.extend({ trigger: function trigger(a, b) {\n      return this.each(function () {\n        n.event.trigger(a, b, this);\n      });\n    }, triggerHandler: function triggerHandler(a, b) {\n      var c = this[0];return c ? n.event.trigger(a, b, c, !0) : void 0;\n    } }), n.each(\"blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu\".split(\" \"), function (a, b) {\n    n.fn[b] = function (a, c) {\n      return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b);\n    };\n  }), n.fn.extend({ hover: function hover(a, b) {\n      return this.mouseenter(a).mouseleave(b || a);\n    } }), l.focusin = \"onfocusin\" in a, l.focusin || n.each({ focus: \"focusin\", blur: \"focusout\" }, function (a, b) {\n    var c = function c(a) {\n      n.event.simulate(b, a.target, n.event.fix(a));\n    };n.event.special[b] = { setup: function setup() {\n        var d = this.ownerDocument || this,\n            e = N.access(d, b);e || d.addEventListener(a, c, !0), N.access(d, b, (e || 0) + 1);\n      }, teardown: function teardown() {\n        var d = this.ownerDocument || this,\n            e = N.access(d, b) - 1;e ? N.access(d, b, e) : (d.removeEventListener(a, c, !0), N.remove(d, b));\n      } };\n  });var jb = a.location,\n      kb = n.now(),\n      lb = /\\?/;n.parseJSON = function (a) {\n    return JSON.parse(a + \"\");\n  }, n.parseXML = function (b) {\n    var c;if (!b || \"string\" != typeof b) return null;try {\n      c = new a.DOMParser().parseFromString(b, \"text/xml\");\n    } catch (d) {\n      c = void 0;\n    }return c && !c.getElementsByTagName(\"parsererror\").length || n.error(\"Invalid XML: \" + b), c;\n  };var mb = /#.*$/,\n      nb = /([?&])_=[^&]*/,\n      ob = /^(.*?):[ \\t]*([^\\r\\n]*)$/gm,\n      pb = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n      qb = /^(?:GET|HEAD)$/,\n      rb = /^\\/\\//,\n      sb = {},\n      tb = {},\n      ub = \"*/\".concat(\"*\"),\n      vb = d.createElement(\"a\");vb.href = jb.href;function wb(a) {\n    return function (b, c) {\n      \"string\" != typeof b && (c = b, b = \"*\");var d,\n          e = 0,\n          f = b.toLowerCase().match(G) || [];if (n.isFunction(c)) while (d = f[e++]) {\n        \"+\" === d[0] ? (d = d.slice(1) || \"*\", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c);\n      }\n    };\n  }function xb(a, b, c, d) {\n    var e = {},\n        f = a === tb;function g(h) {\n      var i;return e[h] = !0, n.each(a[h] || [], function (a, h) {\n        var j = h(b, c, d);return \"string\" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1);\n      }), i;\n    }return g(b.dataTypes[0]) || !e[\"*\"] && g(\"*\");\n  }function yb(a, b) {\n    var c,\n        d,\n        e = n.ajaxSettings.flatOptions || {};for (c in b) {\n      void 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]);\n    }return d && n.extend(!0, a, d), a;\n  }function zb(a, b, c) {\n    var d,\n        e,\n        f,\n        g,\n        h = a.contents,\n        i = a.dataTypes;while (\"*\" === i[0]) {\n      i.shift(), void 0 === d && (d = a.mimeType || b.getResponseHeader(\"Content-Type\"));\n    }if (d) for (e in h) {\n      if (h[e] && h[e].test(d)) {\n        i.unshift(e);break;\n      }\n    }if (i[0] in c) f = i[0];else {\n      for (e in c) {\n        if (!i[0] || a.converters[e + \" \" + i[0]]) {\n          f = e;break;\n        }g || (g = e);\n      }f = f || g;\n    }return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0;\n  }function Ab(a, b, c, d) {\n    var e,\n        f,\n        g,\n        h,\n        i,\n        j = {},\n        k = a.dataTypes.slice();if (k[1]) for (g in a.converters) {\n      j[g.toLowerCase()] = a.converters[g];\n    }f = k.shift();while (f) {\n      if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift()) if (\"*\" === f) f = i;else if (\"*\" !== i && i !== f) {\n        if (g = j[i + \" \" + f] || j[\"* \" + f], !g) for (e in j) {\n          if (h = e.split(\" \"), h[1] === f && (g = j[i + \" \" + h[0]] || j[\"* \" + h[0]])) {\n            g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));break;\n          }\n        }if (g !== !0) if (g && a[\"throws\"]) b = g(b);else try {\n          b = g(b);\n        } catch (l) {\n          return { state: \"parsererror\", error: g ? l : \"No conversion from \" + i + \" to \" + f };\n        }\n      }\n    }return { state: \"success\", data: b };\n  }n.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: jb.href, type: \"GET\", isLocal: pb.test(jb.protocol), global: !0, processData: !0, async: !0, contentType: \"application/x-www-form-urlencoded; charset=UTF-8\", accepts: { \"*\": ub, text: \"text/plain\", html: \"text/html\", xml: \"application/xml, text/xml\", json: \"application/json, text/javascript\" }, contents: { xml: /\\bxml\\b/, html: /\\bhtml/, json: /\\bjson\\b/ }, responseFields: { xml: \"responseXML\", text: \"responseText\", json: \"responseJSON\" }, converters: { \"* text\": String, \"text html\": !0, \"text json\": n.parseJSON, \"text xml\": n.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function ajaxSetup(a, b) {\n      return b ? yb(yb(a, n.ajaxSettings), b) : yb(n.ajaxSettings, a);\n    }, ajaxPrefilter: wb(sb), ajaxTransport: wb(tb), ajax: function ajax(b, c) {\n      \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && (c = b, b = void 0), c = c || {};var e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k,\n          l,\n          m = n.ajaxSetup({}, c),\n          o = m.context || m,\n          p = m.context && (o.nodeType || o.jquery) ? n(o) : n.event,\n          q = n.Deferred(),\n          r = n.Callbacks(\"once memory\"),\n          s = m.statusCode || {},\n          t = {},\n          u = {},\n          v = 0,\n          w = \"canceled\",\n          x = { readyState: 0, getResponseHeader: function getResponseHeader(a) {\n          var b;if (2 === v) {\n            if (!h) {\n              h = {};while (b = ob.exec(g)) {\n                h[b[1].toLowerCase()] = b[2];\n              }\n            }b = h[a.toLowerCase()];\n          }return null == b ? null : b;\n        }, getAllResponseHeaders: function getAllResponseHeaders() {\n          return 2 === v ? g : null;\n        }, setRequestHeader: function setRequestHeader(a, b) {\n          var c = a.toLowerCase();return v || (a = u[c] = u[c] || a, t[a] = b), this;\n        }, overrideMimeType: function overrideMimeType(a) {\n          return v || (m.mimeType = a), this;\n        }, statusCode: function statusCode(a) {\n          var b;if (a) if (2 > v) for (b in a) {\n            s[b] = [s[b], a[b]];\n          } else x.always(a[x.status]);return this;\n        }, abort: function abort(a) {\n          var b = a || w;return e && e.abort(b), z(0, b), this;\n        } };if (q.promise(x).complete = r.add, x.success = x.done, x.error = x.fail, m.url = ((b || m.url || jb.href) + \"\").replace(mb, \"\").replace(rb, jb.protocol + \"//\"), m.type = c.method || c.type || m.method || m.type, m.dataTypes = n.trim(m.dataType || \"*\").toLowerCase().match(G) || [\"\"], null == m.crossDomain) {\n        j = d.createElement(\"a\");try {\n          j.href = m.url, j.href = j.href, m.crossDomain = vb.protocol + \"//\" + vb.host != j.protocol + \"//\" + j.host;\n        } catch (y) {\n          m.crossDomain = !0;\n        }\n      }if (m.data && m.processData && \"string\" != typeof m.data && (m.data = n.param(m.data, m.traditional)), xb(sb, m, c, x), 2 === v) return x;k = n.event && m.global, k && 0 === n.active++ && n.event.trigger(\"ajaxStart\"), m.type = m.type.toUpperCase(), m.hasContent = !qb.test(m.type), f = m.url, m.hasContent || (m.data && (f = m.url += (lb.test(f) ? \"&\" : \"?\") + m.data, delete m.data), m.cache === !1 && (m.url = nb.test(f) ? f.replace(nb, \"$1_=\" + kb++) : f + (lb.test(f) ? \"&\" : \"?\") + \"_=\" + kb++)), m.ifModified && (n.lastModified[f] && x.setRequestHeader(\"If-Modified-Since\", n.lastModified[f]), n.etag[f] && x.setRequestHeader(\"If-None-Match\", n.etag[f])), (m.data && m.hasContent && m.contentType !== !1 || c.contentType) && x.setRequestHeader(\"Content-Type\", m.contentType), x.setRequestHeader(\"Accept\", m.dataTypes[0] && m.accepts[m.dataTypes[0]] ? m.accepts[m.dataTypes[0]] + (\"*\" !== m.dataTypes[0] ? \", \" + ub + \"; q=0.01\" : \"\") : m.accepts[\"*\"]);for (l in m.headers) {\n        x.setRequestHeader(l, m.headers[l]);\n      }if (m.beforeSend && (m.beforeSend.call(o, x, m) === !1 || 2 === v)) return x.abort();w = \"abort\";for (l in { success: 1, error: 1, complete: 1 }) {\n        x[l](m[l]);\n      }if (e = xb(tb, m, c, x)) {\n        if (x.readyState = 1, k && p.trigger(\"ajaxSend\", [x, m]), 2 === v) return x;m.async && m.timeout > 0 && (i = a.setTimeout(function () {\n          x.abort(\"timeout\");\n        }, m.timeout));try {\n          v = 1, e.send(t, z);\n        } catch (y) {\n          if (!(2 > v)) throw y;z(-1, y);\n        }\n      } else z(-1, \"No Transport\");function z(b, c, d, h) {\n        var j,\n            l,\n            t,\n            u,\n            w,\n            y = c;2 !== v && (v = 2, i && a.clearTimeout(i), e = void 0, g = h || \"\", x.readyState = b > 0 ? 4 : 0, j = b >= 200 && 300 > b || 304 === b, d && (u = zb(m, x, d)), u = Ab(m, u, x, j), j ? (m.ifModified && (w = x.getResponseHeader(\"Last-Modified\"), w && (n.lastModified[f] = w), w = x.getResponseHeader(\"etag\"), w && (n.etag[f] = w)), 204 === b || \"HEAD\" === m.type ? y = \"nocontent\" : 304 === b ? y = \"notmodified\" : (y = u.state, l = u.data, t = u.error, j = !t)) : (t = y, !b && y || (y = \"error\", 0 > b && (b = 0))), x.status = b, x.statusText = (c || y) + \"\", j ? q.resolveWith(o, [l, y, x]) : q.rejectWith(o, [x, y, t]), x.statusCode(s), s = void 0, k && p.trigger(j ? \"ajaxSuccess\" : \"ajaxError\", [x, m, j ? l : t]), r.fireWith(o, [x, y]), k && (p.trigger(\"ajaxComplete\", [x, m]), --n.active || n.event.trigger(\"ajaxStop\")));\n      }return x;\n    }, getJSON: function getJSON(a, b, c) {\n      return n.get(a, b, c, \"json\");\n    }, getScript: function getScript(a, b) {\n      return n.get(a, void 0, b, \"script\");\n    } }), n.each([\"get\", \"post\"], function (a, b) {\n    n[b] = function (a, c, d, e) {\n      return n.isFunction(c) && (e = e || d, d = c, c = void 0), n.ajax(n.extend({ url: a, type: b, dataType: e, data: c, success: d }, n.isPlainObject(a) && a));\n    };\n  }), n._evalUrl = function (a) {\n    return n.ajax({ url: a, type: \"GET\", dataType: \"script\", async: !1, global: !1, \"throws\": !0 });\n  }, n.fn.extend({ wrapAll: function wrapAll(a) {\n      var b;return n.isFunction(a) ? this.each(function (b) {\n        n(this).wrapAll(a.call(this, b));\n      }) : (this[0] && (b = n(a, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && b.insertBefore(this[0]), b.map(function () {\n        var a = this;while (a.firstElementChild) {\n          a = a.firstElementChild;\n        }return a;\n      }).append(this)), this);\n    }, wrapInner: function wrapInner(a) {\n      return n.isFunction(a) ? this.each(function (b) {\n        n(this).wrapInner(a.call(this, b));\n      }) : this.each(function () {\n        var b = n(this),\n            c = b.contents();c.length ? c.wrapAll(a) : b.append(a);\n      });\n    }, wrap: function wrap(a) {\n      var b = n.isFunction(a);return this.each(function (c) {\n        n(this).wrapAll(b ? a.call(this, c) : a);\n      });\n    }, unwrap: function unwrap() {\n      return this.parent().each(function () {\n        n.nodeName(this, \"body\") || n(this).replaceWith(this.childNodes);\n      }).end();\n    } }), n.expr.filters.hidden = function (a) {\n    return !n.expr.filters.visible(a);\n  }, n.expr.filters.visible = function (a) {\n    return a.offsetWidth > 0 || a.offsetHeight > 0 || a.getClientRects().length > 0;\n  };var Bb = /%20/g,\n      Cb = /\\[\\]$/,\n      Db = /\\r?\\n/g,\n      Eb = /^(?:submit|button|image|reset|file)$/i,\n      Fb = /^(?:input|select|textarea|keygen)/i;function Gb(a, b, c, d) {\n    var e;if (n.isArray(b)) n.each(b, function (b, e) {\n      c || Cb.test(a) ? d(a, e) : Gb(a + \"[\" + (\"object\" == (typeof e === \"undefined\" ? \"undefined\" : _typeof(e)) && null != e ? b : \"\") + \"]\", e, c, d);\n    });else if (c || \"object\" !== n.type(b)) d(a, b);else for (e in b) {\n      Gb(a + \"[\" + e + \"]\", b[e], c, d);\n    }\n  }n.param = function (a, b) {\n    var c,\n        d = [],\n        e = function e(a, b) {\n      b = n.isFunction(b) ? b() : null == b ? \"\" : b, d[d.length] = encodeURIComponent(a) + \"=\" + encodeURIComponent(b);\n    };if (void 0 === b && (b = n.ajaxSettings && n.ajaxSettings.traditional), n.isArray(a) || a.jquery && !n.isPlainObject(a)) n.each(a, function () {\n      e(this.name, this.value);\n    });else for (c in a) {\n      Gb(c, a[c], b, e);\n    }return d.join(\"&\").replace(Bb, \"+\");\n  }, n.fn.extend({ serialize: function serialize() {\n      return n.param(this.serializeArray());\n    }, serializeArray: function serializeArray() {\n      return this.map(function () {\n        var a = n.prop(this, \"elements\");return a ? n.makeArray(a) : this;\n      }).filter(function () {\n        var a = this.type;return this.name && !n(this).is(\":disabled\") && Fb.test(this.nodeName) && !Eb.test(a) && (this.checked || !X.test(a));\n      }).map(function (a, b) {\n        var c = n(this).val();return null == c ? null : n.isArray(c) ? n.map(c, function (a) {\n          return { name: b.name, value: a.replace(Db, \"\\r\\n\") };\n        }) : { name: b.name, value: c.replace(Db, \"\\r\\n\") };\n      }).get();\n    } }), n.ajaxSettings.xhr = function () {\n    try {\n      return new a.XMLHttpRequest();\n    } catch (b) {}\n  };var Hb = { 0: 200, 1223: 204 },\n      Ib = n.ajaxSettings.xhr();l.cors = !!Ib && \"withCredentials\" in Ib, l.ajax = Ib = !!Ib, n.ajaxTransport(function (b) {\n    var _c, d;return l.cors || Ib && !b.crossDomain ? { send: function send(e, f) {\n        var g,\n            h = b.xhr();if (h.open(b.type, b.url, b.async, b.username, b.password), b.xhrFields) for (g in b.xhrFields) {\n          h[g] = b.xhrFields[g];\n        }b.mimeType && h.overrideMimeType && h.overrideMimeType(b.mimeType), b.crossDomain || e[\"X-Requested-With\"] || (e[\"X-Requested-With\"] = \"XMLHttpRequest\");for (g in e) {\n          h.setRequestHeader(g, e[g]);\n        }_c = function c(a) {\n          return function () {\n            _c && (_c = d = h.onload = h.onerror = h.onabort = h.onreadystatechange = null, \"abort\" === a ? h.abort() : \"error\" === a ? \"number\" != typeof h.status ? f(0, \"error\") : f(h.status, h.statusText) : f(Hb[h.status] || h.status, h.statusText, \"text\" !== (h.responseType || \"text\") || \"string\" != typeof h.responseText ? { binary: h.response } : { text: h.responseText }, h.getAllResponseHeaders()));\n          };\n        }, h.onload = _c(), d = h.onerror = _c(\"error\"), void 0 !== h.onabort ? h.onabort = d : h.onreadystatechange = function () {\n          4 === h.readyState && a.setTimeout(function () {\n            _c && d();\n          });\n        }, _c = _c(\"abort\");try {\n          h.send(b.hasContent && b.data || null);\n        } catch (i) {\n          if (_c) throw i;\n        }\n      }, abort: function abort() {\n        _c && _c();\n      } } : void 0;\n  }), n.ajaxSetup({ accepts: { script: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\" }, contents: { script: /\\b(?:java|ecma)script\\b/ }, converters: { \"text script\": function textScript(a) {\n        return n.globalEval(a), a;\n      } } }), n.ajaxPrefilter(\"script\", function (a) {\n    void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = \"GET\");\n  }), n.ajaxTransport(\"script\", function (a) {\n    if (a.crossDomain) {\n      var b, _c2;return { send: function send(e, f) {\n          b = n(\"<script>\").prop({ charset: a.scriptCharset, src: a.url }).on(\"load error\", _c2 = function c(a) {\n            b.remove(), _c2 = null, a && f(\"error\" === a.type ? 404 : 200, a.type);\n          }), d.head.appendChild(b[0]);\n        }, abort: function abort() {\n          _c2 && _c2();\n        } };\n    }\n  });var Jb = [],\n      Kb = /(=)\\?(?=&|$)|\\?\\?/;n.ajaxSetup({ jsonp: \"callback\", jsonpCallback: function jsonpCallback() {\n      var a = Jb.pop() || n.expando + \"_\" + kb++;return this[a] = !0, a;\n    } }), n.ajaxPrefilter(\"json jsonp\", function (b, c, d) {\n    var e,\n        f,\n        g,\n        h = b.jsonp !== !1 && (Kb.test(b.url) ? \"url\" : \"string\" == typeof b.data && 0 === (b.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") && Kb.test(b.data) && \"data\");return h || \"jsonp\" === b.dataTypes[0] ? (e = b.jsonpCallback = n.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(Kb, \"$1\" + e) : b.jsonp !== !1 && (b.url += (lb.test(b.url) ? \"&\" : \"?\") + b.jsonp + \"=\" + e), b.converters[\"script json\"] = function () {\n      return g || n.error(e + \" was not called\"), g[0];\n    }, b.dataTypes[0] = \"json\", f = a[e], a[e] = function () {\n      g = arguments;\n    }, d.always(function () {\n      void 0 === f ? n(a).removeProp(e) : a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, Jb.push(e)), g && n.isFunction(f) && f(g[0]), g = f = void 0;\n    }), \"script\") : void 0;\n  }), n.parseHTML = function (a, b, c) {\n    if (!a || \"string\" != typeof a) return null;\"boolean\" == typeof b && (c = b, b = !1), b = b || d;var e = x.exec(a),\n        f = !c && [];return e ? [b.createElement(e[1])] : (e = ca([a], b, f), f && f.length && n(f).remove(), n.merge([], e.childNodes));\n  };var Lb = n.fn.load;n.fn.load = function (a, b, c) {\n    if (\"string\" != typeof a && Lb) return Lb.apply(this, arguments);var d,\n        e,\n        f,\n        g = this,\n        h = a.indexOf(\" \");return h > -1 && (d = n.trim(a.slice(h)), a = a.slice(0, h)), n.isFunction(b) ? (c = b, b = void 0) : b && \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && (e = \"POST\"), g.length > 0 && n.ajax({ url: a, type: e || \"GET\", dataType: \"html\", data: b }).done(function (a) {\n      f = arguments, g.html(d ? n(\"<div>\").append(n.parseHTML(a)).find(d) : a);\n    }).always(c && function (a, b) {\n      g.each(function () {\n        c.apply(this, f || [a.responseText, b, a]);\n      });\n    }), this;\n  }, n.each([\"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\"], function (a, b) {\n    n.fn[b] = function (a) {\n      return this.on(b, a);\n    };\n  }), n.expr.filters.animated = function (a) {\n    return n.grep(n.timers, function (b) {\n      return a === b.elem;\n    }).length;\n  };function Mb(a) {\n    return n.isWindow(a) ? a : 9 === a.nodeType && a.defaultView;\n  }n.offset = { setOffset: function setOffset(a, b, c) {\n      var d,\n          e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k = n.css(a, \"position\"),\n          l = n(a),\n          m = {};\"static\" === k && (a.style.position = \"relative\"), h = l.offset(), f = n.css(a, \"top\"), i = n.css(a, \"left\"), j = (\"absolute\" === k || \"fixed\" === k) && (f + i).indexOf(\"auto\") > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), n.isFunction(b) && (b = b.call(a, c, n.extend({}, h))), null != b.top && (m.top = b.top - h.top + g), null != b.left && (m.left = b.left - h.left + e), \"using\" in b ? b.using.call(a, m) : l.css(m);\n    } }, n.fn.extend({ offset: function offset(a) {\n      if (arguments.length) return void 0 === a ? this : this.each(function (b) {\n        n.offset.setOffset(this, a, b);\n      });var b,\n          c,\n          d = this[0],\n          e = { top: 0, left: 0 },\n          f = d && d.ownerDocument;if (f) return b = f.documentElement, n.contains(b, d) ? (e = d.getBoundingClientRect(), c = Mb(f), { top: e.top + c.pageYOffset - b.clientTop, left: e.left + c.pageXOffset - b.clientLeft }) : e;\n    }, position: function position() {\n      if (this[0]) {\n        var a,\n            b,\n            c = this[0],\n            d = { top: 0, left: 0 };return \"fixed\" === n.css(c, \"position\") ? b = c.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), n.nodeName(a[0], \"html\") || (d = a.offset()), d.top += n.css(a[0], \"borderTopWidth\", !0), d.left += n.css(a[0], \"borderLeftWidth\", !0)), { top: b.top - d.top - n.css(c, \"marginTop\", !0), left: b.left - d.left - n.css(c, \"marginLeft\", !0) };\n      }\n    }, offsetParent: function offsetParent() {\n      return this.map(function () {\n        var a = this.offsetParent;while (a && \"static\" === n.css(a, \"position\")) {\n          a = a.offsetParent;\n        }return a || Ea;\n      });\n    } }), n.each({ scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function (a, b) {\n    var c = \"pageYOffset\" === b;n.fn[a] = function (d) {\n      return K(this, function (a, d, e) {\n        var f = Mb(a);return void 0 === e ? f ? f[b] : a[d] : void (f ? f.scrollTo(c ? f.pageXOffset : e, c ? e : f.pageYOffset) : a[d] = e);\n      }, a, d, arguments.length);\n    };\n  }), n.each([\"top\", \"left\"], function (a, b) {\n    n.cssHooks[b] = Ga(l.pixelPosition, function (a, c) {\n      return c ? (c = Fa(a, b), Ba.test(c) ? n(a).position()[b] + \"px\" : c) : void 0;\n    });\n  }), n.each({ Height: \"height\", Width: \"width\" }, function (a, b) {\n    n.each({ padding: \"inner\" + a, content: b, \"\": \"outer\" + a }, function (c, d) {\n      n.fn[d] = function (d, e) {\n        var f = arguments.length && (c || \"boolean\" != typeof d),\n            g = c || (d === !0 || e === !0 ? \"margin\" : \"border\");return K(this, function (b, c, d) {\n          var e;return n.isWindow(b) ? b.document.documentElement[\"client\" + a] : 9 === b.nodeType ? (e = b.documentElement, Math.max(b.body[\"scroll\" + a], e[\"scroll\" + a], b.body[\"offset\" + a], e[\"offset\" + a], e[\"client\" + a])) : void 0 === d ? n.css(b, c, g) : n.style(b, c, d, g);\n        }, b, f ? d : void 0, f, null);\n      };\n    });\n  }), n.fn.extend({ bind: function bind(a, b, c) {\n      return this.on(a, null, b, c);\n    }, unbind: function unbind(a, b) {\n      return this.off(a, null, b);\n    }, delegate: function delegate(a, b, c, d) {\n      return this.on(b, a, c, d);\n    }, undelegate: function undelegate(a, b, c) {\n      return 1 === arguments.length ? this.off(a, \"**\") : this.off(b, a || \"**\", c);\n    }, size: function size() {\n      return this.length;\n    } }), n.fn.andSelf = n.fn.addBack, \"function\" == typeof define && define.amd && define(\"jquery\", [], function () {\n    return n;\n  });var Nb = a.jQuery,\n      Ob = a.$;return n.noConflict = function (b) {\n    return a.$ === n && (a.$ = Ob), b && a.jQuery === n && (a.jQuery = Nb), n;\n  }, b || (a.jQuery = a.$ = n), n;\n});"

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(2)(__webpack_require__(5))

/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = "\"use strict\";var _typeof=typeof Symbol===\"function\"&&typeof Symbol.iterator===\"symbol\"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol===\"function\"&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj;};function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\");}!function(t){\"use strict\";function e(t){if(void 0===Function.prototype.name){var e=/function\\s([^(]{1,})\\(/,i=e.exec(t.toString());return i&&i.length>1?i[1].trim():\"\";}return void 0===t.prototype?t.constructor.name:t.prototype.constructor.name;}function i(t){return /true/.test(t)?!0:/false/.test(t)?!1:isNaN(1*t)?t:parseFloat(t);}function n(t){return t.replace(/([a-z])([A-Z])/g,\"$1-$2\").toLowerCase();}var s=\"6.2.3\",o={version:s,_plugins:{},_uuids:[],rtl:function rtl(){return\"rtl\"===t(\"html\").attr(\"dir\");},plugin:function plugin(t,i){var s=i||e(t),o=n(s);this._plugins[o]=this[s]=t;},registerPlugin:function registerPlugin(t,i){var s=i?n(i):e(t.constructor).toLowerCase();t.uuid=this.GetYoDigits(6,s),t.$element.attr(\"data-\"+s)||t.$element.attr(\"data-\"+s,t.uuid),t.$element.data(\"zfPlugin\")||t.$element.data(\"zfPlugin\",t),t.$element.trigger(\"init.zf.\"+s),this._uuids.push(t.uuid);},unregisterPlugin:function unregisterPlugin(t){var i=n(e(t.$element.data(\"zfPlugin\").constructor));this._uuids.splice(this._uuids.indexOf(t.uuid),1),t.$element.removeAttr(\"data-\"+i).removeData(\"zfPlugin\").trigger(\"destroyed.zf.\"+i);for(var s in t){t[s]=null;}},reInit:function reInit(e){var i=e instanceof t;try{if(i)e.each(function(){t(this).data(\"zfPlugin\")._init();});else{var s=typeof e===\"undefined\"?\"undefined\":_typeof(e),o=this,a={object:function object(e){e.forEach(function(e){e=n(e),t(\"[data-\"+e+\"]\").foundation(\"_init\");});},string:function string(){e=n(e),t(\"[data-\"+e+\"]\").foundation(\"_init\");},undefined:function undefined(){this.object(Object.keys(o._plugins));}};a[s](e);}}catch(r){console.error(r);}finally{return e;}},GetYoDigits:function GetYoDigits(t,e){return t=t||6,Math.round(Math.pow(36,t+1)-Math.random()*Math.pow(36,t)).toString(36).slice(1)+(e?\"-\"+e:\"\");},reflow:function reflow(e,n){\"undefined\"==typeof n?n=Object.keys(this._plugins):\"string\"==typeof n&&(n=[n]);var s=this;t.each(n,function(n,o){var a=s._plugins[o],r=t(e).find(\"[data-\"+o+\"]\").addBack(\"[data-\"+o+\"]\");r.each(function(){var e=t(this),n={};if(e.data(\"zfPlugin\"))return void console.warn(\"Tried to initialize \"+o+\" on an element that already has a Foundation plugin.\");if(e.attr(\"data-options\")){e.attr(\"data-options\").split(\";\").forEach(function(t,e){var s=t.split(\":\").map(function(t){return t.trim();});s[0]&&(n[s[0]]=i(s[1]));});}try{e.data(\"zfPlugin\",new a(t(this),n));}catch(s){console.error(s);}finally{return;}});});},getFnName:e,transitionend:function transitionend(t){var e,i={transition:\"transitionend\",WebkitTransition:\"webkitTransitionEnd\",MozTransition:\"transitionend\",OTransition:\"otransitionend\"},n=document.createElement(\"div\");for(var s in i){\"undefined\"!=typeof n.style[s]&&(e=i[s]);}return e?e:(e=setTimeout(function(){t.triggerHandler(\"transitionend\",[t]);},1),\"transitionend\");}};o.util={throttle:function throttle(t,e){var i=null;return function(){var n=this,s=arguments;null===i&&(i=setTimeout(function(){t.apply(n,s),i=null;},e));};}};var a=function a(i){var n=typeof i===\"undefined\"?\"undefined\":_typeof(i),s=t(\"meta.foundation-mq\"),a=t(\".no-js\");if(s.length||t('<meta class=\"foundation-mq\">').appendTo(document.head),a.length&&a.removeClass(\"no-js\"),\"undefined\"===n)o.MediaQuery._init(),o.reflow(this);else{if(\"string\"!==n)throw new TypeError(\"We're sorry, \"+n+\" is not a valid parameter. You must use a string representing the method you wish to invoke.\");var r=Array.prototype.slice.call(arguments,1),l=this.data(\"zfPlugin\");if(void 0===l||void 0===l[i])throw new ReferenceError(\"We're sorry, '\"+i+\"' is not an available method for \"+(l?e(l):\"this element\")+\".\");1===this.length?l[i].apply(l,r):this.each(function(e,n){l[i].apply(t(n).data(\"zfPlugin\"),r);});}return this;};window.Foundation=o,t.fn.foundation=a,function(){Date.now&&window.Date.now||(window.Date.now=Date.now=function(){return new Date().getTime();});for(var t=[\"webkit\",\"moz\"],e=0;e<t.length&&!window.requestAnimationFrame;++e){var i=t[e];window.requestAnimationFrame=window[i+\"RequestAnimationFrame\"],window.cancelAnimationFrame=window[i+\"CancelAnimationFrame\"]||window[i+\"CancelRequestAnimationFrame\"];}if(/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent)||!window.requestAnimationFrame||!window.cancelAnimationFrame){var n=0;window.requestAnimationFrame=function(t){var e=Date.now(),i=Math.max(n+16,e);return setTimeout(function(){t(n=i);},i-e);},window.cancelAnimationFrame=clearTimeout;}window.performance&&window.performance.now||(window.performance={start:Date.now(),now:function now(){return Date.now()-this.start;}});}(),Function.prototype.bind||(Function.prototype.bind=function(t){if(\"function\"!=typeof this)throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");var e=Array.prototype.slice.call(arguments,1),i=this,n=function n(){},s=function s(){return i.apply(this instanceof n?this:t,e.concat(Array.prototype.slice.call(arguments)));};return this.prototype&&(n.prototype=this.prototype),s.prototype=new n(),s;});}(jQuery),!function(t){function e(t,e,n,s){var o,a,r,l,u=i(t);if(e){var d=i(e);a=u.offset.top+u.height<=d.height+d.offset.top,o=u.offset.top>=d.offset.top,r=u.offset.left>=d.offset.left,l=u.offset.left+u.width<=d.width+d.offset.left;}else a=u.offset.top+u.height<=u.windowDims.height+u.windowDims.offset.top,o=u.offset.top>=u.windowDims.offset.top,r=u.offset.left>=u.windowDims.offset.left,l=u.offset.left+u.width<=u.windowDims.width;var h=[a,o,r,l];return n?r===l==!0:s?o===a==!0:-1===h.indexOf(!1);}function i(t,e){if(t=t.length?t[0]:t,t===window||t===document)throw new Error(\"I'm sorry, Dave. I'm afraid I can't do that.\");var i=t.getBoundingClientRect(),n=t.parentNode.getBoundingClientRect(),s=document.body.getBoundingClientRect(),o=window.pageYOffset,a=window.pageXOffset;return{width:i.width,height:i.height,offset:{top:i.top+o,left:i.left+a},parentDims:{width:n.width,height:n.height,offset:{top:n.top+o,left:n.left+a}},windowDims:{width:s.width,height:s.height,offset:{top:o,left:a}}};}function n(t,e,n,s,o,a){var r=i(t),l=e?i(e):null;switch(n){case\"top\":return{left:Foundation.rtl()?l.offset.left-r.width+l.width:l.offset.left,top:l.offset.top-(r.height+s)};case\"left\":return{left:l.offset.left-(r.width+o),top:l.offset.top};case\"right\":return{left:l.offset.left+l.width+o,top:l.offset.top};case\"center top\":return{left:l.offset.left+l.width/2-r.width/2,top:l.offset.top-(r.height+s)};case\"center bottom\":return{left:a?o:l.offset.left+l.width/2-r.width/2,top:l.offset.top+l.height+s};case\"center left\":return{left:l.offset.left-(r.width+o),top:l.offset.top+l.height/2-r.height/2};case\"center right\":return{left:l.offset.left+l.width+o+1,top:l.offset.top+l.height/2-r.height/2};case\"center\":return{left:r.windowDims.offset.left+r.windowDims.width/2-r.width/2,top:r.windowDims.offset.top+r.windowDims.height/2-r.height/2};case\"reveal\":return{left:(r.windowDims.width-r.width)/2,top:r.windowDims.offset.top+s};case\"reveal full\":return{left:r.windowDims.offset.left,top:r.windowDims.offset.top};case\"left bottom\":return{left:l.offset.left-(r.width+o),top:l.offset.top+l.height};case\"right bottom\":return{left:l.offset.left+l.width+o-r.width,top:l.offset.top+l.height};default:return{left:Foundation.rtl()?l.offset.left-r.width+l.width:l.offset.left,top:l.offset.top+l.height+s};}}Foundation.Box={ImNotTouchingYou:e,GetDimensions:i,GetOffsets:n};}(jQuery),!function(t){function e(t){var e={};for(var i in t){e[t[i]]=t[i];}return e;}var i={9:\"TAB\",13:\"ENTER\",27:\"ESCAPE\",32:\"SPACE\",37:\"ARROW_LEFT\",38:\"ARROW_UP\",39:\"ARROW_RIGHT\",40:\"ARROW_DOWN\"},n={},s={keys:e(i),parseKey:function parseKey(t){var e=i[t.which||t.keyCode]||String.fromCharCode(t.which).toUpperCase();return t.shiftKey&&(e=\"SHIFT_\"+e),t.ctrlKey&&(e=\"CTRL_\"+e),t.altKey&&(e=\"ALT_\"+e),e;},handleKey:function handleKey(e,i,s){var o,a,r,l=n[i],u=this.parseKey(e);if(!l)return console.warn(\"Component not defined!\");if(o=\"undefined\"==typeof l.ltr?l:Foundation.rtl()?t.extend({},l.ltr,l.rtl):t.extend({},l.rtl,l.ltr),a=o[u],r=s[a],r&&\"function\"==typeof r){var d=r.apply();(s.handled||\"function\"==typeof s.handled)&&s.handled(d);}else(s.unhandled||\"function\"==typeof s.unhandled)&&s.unhandled();},findFocusable:function findFocusable(e){return e.find(\"a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]\").filter(function(){return t(this).is(\":visible\")&&!(t(this).attr(\"tabindex\")<0);});},register:function register(t,e){n[t]=e;}};Foundation.Keyboard=s;}(jQuery),!function(t){function e(t){var e={};return\"string\"!=typeof t?e:(t=t.trim().slice(1,-1))?e=t.split(\"&\").reduce(function(t,e){var i=e.replace(/\\+/g,\" \").split(\"=\"),n=i[0],s=i[1];return n=decodeURIComponent(n),s=void 0===s?null:decodeURIComponent(s),t.hasOwnProperty(n)?Array.isArray(t[n])?t[n].push(s):t[n]=[t[n],s]:t[n]=s,t;},{}):e;}var i={queries:[],current:\"\",_init:function _init(){var i,n=this,s=t(\".foundation-mq\").css(\"font-family\");i=e(s);for(var o in i){i.hasOwnProperty(o)&&n.queries.push({name:o,value:\"only screen and (min-width: \"+i[o]+\")\"});}this.current=this._getCurrentSize(),this._watcher();},atLeast:function atLeast(t){var e=this.get(t);return e?window.matchMedia(e).matches:!1;},get:function get(t){for(var e in this.queries){if(this.queries.hasOwnProperty(e)){var i=this.queries[e];if(t===i.name)return i.value;}}return null;},_getCurrentSize:function _getCurrentSize(){for(var t,e=0;e<this.queries.length;e++){var i=this.queries[e];window.matchMedia(i.value).matches&&(t=i);}return\"object\"==(typeof t===\"undefined\"?\"undefined\":_typeof(t))?t.name:t;},_watcher:function _watcher(){var e=this;t(window).on(\"resize.zf.mediaquery\",function(){var i=e._getCurrentSize(),n=e.current;i!==n&&(e.current=i,t(window).trigger(\"changed.zf.mediaquery\",[i,n]));});}};Foundation.MediaQuery=i,window.matchMedia||(window.matchMedia=function(){\"use strict\";var t=window.styleMedia||window.media;if(!t){var e=document.createElement(\"style\"),i=document.getElementsByTagName(\"script\")[0],n=null;e.type=\"text/css\",e.id=\"matchmediajs-test\",i.parentNode.insertBefore(e,i),n=\"getComputedStyle\"in window&&window.getComputedStyle(e,null)||e.currentStyle,t={matchMedium:function matchMedium(t){var i=\"@media \"+t+\"{ #matchmediajs-test { width: 1px; } }\";return e.styleSheet?e.styleSheet.cssText=i:e.textContent=i,\"1px\"===n.width;}};}return function(e){return{matches:t.matchMedium(e||\"all\"),media:e||\"all\"};};}()),Foundation.MediaQuery=i;}(jQuery),!function(t){function e(t,e,i){function n(r){a||(a=window.performance.now()),o=r-a,i.apply(e),t>o?s=window.requestAnimationFrame(n,e):(window.cancelAnimationFrame(s),e.trigger(\"finished.zf.animate\",[e]).triggerHandler(\"finished.zf.animate\",[e]));}var s,o,a=null;s=window.requestAnimationFrame(n);}function i(e,i,o,a){function r(){e||i.hide(),l(),a&&a.apply(i);}function l(){i[0].style.transitionDuration=0,i.removeClass(u+\" \"+d+\" \"+o);}if(i=t(i).eq(0),i.length){var u=e?n[0]:n[1],d=e?s[0]:s[1];l(),i.addClass(o).css(\"transition\",\"none\"),requestAnimationFrame(function(){i.addClass(u),e&&i.show();}),requestAnimationFrame(function(){i[0].offsetWidth,i.css(\"transition\",\"\").addClass(d);}),i.one(Foundation.transitionend(i),r);}}var n=[\"mui-enter\",\"mui-leave\"],s=[\"mui-enter-active\",\"mui-leave-active\"],o={animateIn:function animateIn(t,e,n){i(!0,t,e,n);},animateOut:function animateOut(t,e,n){i(!1,t,e,n);}};Foundation.Move=e,Foundation.Motion=o;}(jQuery),!function(t){var e={Feather:function Feather(e){var i=arguments.length<=1||void 0===arguments[1]?\"zf\":arguments[1];e.attr(\"role\",\"menubar\");var n=e.find(\"li\").attr({role:\"menuitem\"}),s=\"is-\"+i+\"-submenu\",o=s+\"-item\",a=\"is-\"+i+\"-submenu-parent\";e.find(\"a:first\").attr(\"tabindex\",0),n.each(function(){var e=t(this),i=e.children(\"ul\");i.length&&(e.addClass(a).attr({\"aria-haspopup\":!0,\"aria-expanded\":!1,\"aria-label\":e.children(\"a:first\").text()}),i.addClass(\"submenu \"+s).attr({\"data-submenu\":\"\",\"aria-hidden\":!0,role:\"menu\"})),e.parent(\"[data-submenu]\").length&&e.addClass(\"is-submenu-item \"+o);});},Burn:function Burn(t,e){var i=(t.find(\"li\").removeAttr(\"tabindex\"),\"is-\"+e+\"-submenu\"),n=i+\"-item\",s=\"is-\"+e+\"-submenu-parent\";t.find(\"*\").removeClass(i+\" \"+n+\" \"+s+\" is-submenu-item submenu is-active\").removeAttr(\"data-submenu\").css(\"display\",\"\");}};Foundation.Nest=e;}(jQuery),!function(t){function e(t,e,i){var n,s,o=this,a=e.duration,r=Object.keys(t.data())[0]||\"timer\",l=-1;this.isPaused=!1,this.restart=function(){l=-1,clearTimeout(s),this.start();},this.start=function(){this.isPaused=!1,clearTimeout(s),l=0>=l?a:l,t.data(\"paused\",!1),n=Date.now(),s=setTimeout(function(){e.infinite&&o.restart(),i();},l),t.trigger(\"timerstart.zf.\"+r);},this.pause=function(){this.isPaused=!0,clearTimeout(s),t.data(\"paused\",!0);var e=Date.now();l-=e-n,t.trigger(\"timerpaused.zf.\"+r);};}function i(e,i){function n(){s--,0===s&&i();}var s=e.length;0===s&&i(),e.each(function(){this.complete?n():\"undefined\"!=typeof this.naturalWidth&&this.naturalWidth>0?n():t(this).one(\"load\",function(){n();});});}Foundation.Timer=e,Foundation.onImagesLoaded=i;}(jQuery),function(t){function e(){this.removeEventListener(\"touchmove\",i),this.removeEventListener(\"touchend\",e),u=!1;}function i(i){if(t.spotSwipe.preventDefault&&i.preventDefault(),u){var n,s=i.touches[0].pageX,a=(i.touches[0].pageY,o-s);l=new Date().getTime()-r,Math.abs(a)>=t.spotSwipe.moveThreshold&&l<=t.spotSwipe.timeThreshold&&(n=a>0?\"left\":\"right\"),n&&(i.preventDefault(),e.call(this),t(this).trigger(\"swipe\",n).trigger(\"swipe\"+n));}}function n(t){1==t.touches.length&&(o=t.touches[0].pageX,a=t.touches[0].pageY,u=!0,r=new Date().getTime(),this.addEventListener(\"touchmove\",i,!1),this.addEventListener(\"touchend\",e,!1));}function s(){this.addEventListener&&this.addEventListener(\"touchstart\",n,!1);}t.spotSwipe={version:\"1.0.0\",enabled:\"ontouchstart\"in document.documentElement,preventDefault:!1,moveThreshold:75,timeThreshold:200};var o,a,r,l,u=!1;t.event.special.swipe={setup:s},t.each([\"left\",\"up\",\"down\",\"right\"],function(){t.event.special[\"swipe\"+this]={setup:function setup(){t(this).on(\"swipe\",t.noop);}};});}(jQuery),!function(t){t.fn.addTouch=function(){this.each(function(i,n){t(n).bind(\"touchstart touchmove touchend touchcancel\",function(){e(event);});});var e=function e(t){var e,i=t.changedTouches,n=i[0],s={touchstart:\"mousedown\",touchmove:\"mousemove\",touchend:\"mouseup\"},o=s[t.type];\"MouseEvent\"in window&&\"function\"==typeof window.MouseEvent?e=new window.MouseEvent(o,{bubbles:!0,cancelable:!0,screenX:n.screenX,screenY:n.screenY,clientX:n.clientX,clientY:n.clientY}):(e=document.createEvent(\"MouseEvent\"),e.initMouseEvent(o,!0,!0,window,1,n.screenX,n.screenY,n.clientX,n.clientY,!1,!1,!1,!1,0,null)),n.target.dispatchEvent(e);};};}(jQuery),!function(t){function e(){o(),n(),s(),i();}function i(e){var i=t(\"[data-yeti-box]\"),n=[\"dropdown\",\"tooltip\",\"reveal\"];if(e&&(\"string\"==typeof e?n.push(e):\"object\"==(typeof e===\"undefined\"?\"undefined\":_typeof(e))&&\"string\"==typeof e[0]?n.concat(e):console.error(\"Plugin names must be strings\")),i.length){var s=n.map(function(t){return\"closeme.zf.\"+t;}).join(\" \");t(window).off(s).on(s,function(e,i){var n=e.namespace.split(\".\")[0],s=t(\"[data-\"+n+\"]\").not('[data-yeti-box=\"'+i+'\"]');s.each(function(){var e=t(this);e.triggerHandler(\"close.zf.trigger\",[e]);});});}}function n(e){var i=void 0,n=t(\"[data-resize]\");n.length&&t(window).off(\"resize.zf.trigger\").on(\"resize.zf.trigger\",function(s){i&&clearTimeout(i),i=setTimeout(function(){a||n.each(function(){t(this).triggerHandler(\"resizeme.zf.trigger\");}),n.attr(\"data-events\",\"resize\");},e||10);});}function s(e){var i=void 0,n=t(\"[data-scroll]\");n.length&&t(window).off(\"scroll.zf.trigger\").on(\"scroll.zf.trigger\",function(s){i&&clearTimeout(i),i=setTimeout(function(){a||n.each(function(){t(this).triggerHandler(\"scrollme.zf.trigger\");}),n.attr(\"data-events\",\"scroll\");},e||10);});}function o(){if(!a)return!1;var e=document.querySelectorAll(\"[data-resize], [data-scroll], [data-mutate]\"),i=function i(e){var i=t(e[0].target);switch(i.attr(\"data-events\")){case\"resize\":i.triggerHandler(\"resizeme.zf.trigger\",[i]);break;case\"scroll\":i.triggerHandler(\"scrollme.zf.trigger\",[i,window.pageYOffset]);break;default:return!1;}};if(e.length)for(var n=0;n<=e.length-1;n++){var s=new a(i);s.observe(e[n],{attributes:!0,childList:!1,characterData:!1,subtree:!1,attributeFilter:[\"data-events\"]});}}var a=function(){for(var t=[\"WebKit\",\"Moz\",\"O\",\"Ms\",\"\"],e=0;e<t.length;e++){if(t[e]+\"MutationObserver\"in window)return window[t[e]+\"MutationObserver\"];}return!1;}(),r=function r(e,i){e.data(i).split(\" \").forEach(function(n){t(\"#\"+n)[\"close\"===i?\"trigger\":\"triggerHandler\"](i+\".zf.trigger\",[e]);});};t(document).on(\"click.zf.trigger\",\"[data-open]\",function(){r(t(this),\"open\");}),t(document).on(\"click.zf.trigger\",\"[data-close]\",function(){var e=t(this).data(\"close\");e?r(t(this),\"close\"):t(this).trigger(\"close.zf.trigger\");}),t(document).on(\"click.zf.trigger\",\"[data-toggle]\",function(){r(t(this),\"toggle\");}),t(document).on(\"close.zf.trigger\",\"[data-closable]\",function(e){e.stopPropagation();var i=t(this).data(\"closable\");\"\"!==i?Foundation.Motion.animateOut(t(this),i,function(){t(this).trigger(\"closed.zf\");}):t(this).fadeOut().trigger(\"closed.zf\");}),t(document).on(\"focus.zf.trigger blur.zf.trigger\",\"[data-toggle-focus]\",function(){var e=t(this).data(\"toggle-focus\");t(\"#\"+e).triggerHandler(\"toggle.zf.trigger\",[t(this)]);}),t(window).load(function(){e();}),Foundation.IHearYou=e;}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i){var n=arguments.length<=1||void 0===arguments[1]?{}:arguments[1];_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Abide\");}return _createClass(e,[{key:\"_init\",value:function value(){this.$inputs=this.$element.find(\"input, textarea, select\"),this._events();}},{key:\"_events\",value:function value(){var e=this;this.$element.off(\".abide\").on(\"reset.zf.abide\",function(){e.resetForm();}).on(\"submit.zf.abide\",function(){return e.validateForm();}),\"fieldChange\"===this.options.validateOn&&this.$inputs.off(\"change.zf.abide\").on(\"change.zf.abide\",function(i){e.validateInput(t(i.target));}),this.options.liveValidate&&this.$inputs.off(\"input.zf.abide\").on(\"input.zf.abide\",function(i){e.validateInput(t(i.target));});}},{key:\"_reflow\",value:function value(){this._init();}},{key:\"requiredCheck\",value:function value(t){if(!t.attr(\"required\"))return!0;var e=!0;switch(t[0].type){case\"checkbox\":e=t[0].checked;break;case\"select\":case\"select-one\":case\"select-multiple\":var i=t.find(\"option:selected\");i.length&&i.val()||(e=!1);break;default:t.val()&&t.val().length||(e=!1);}return e;}},{key:\"findFormError\",value:function value(t){var e=t.siblings(this.options.formErrorSelector);return e.length||(e=t.parent().find(this.options.formErrorSelector)),e;}},{key:\"findLabel\",value:function value(t){var e=t[0].id,i=this.$element.find('label[for=\"'+e+'\"]');return i.length?i:t.closest(\"label\");}},{key:\"findRadioLabels\",value:function value(e){var i=this,n=e.map(function(e,n){var s=n.id,o=i.$element.find('label[for=\"'+s+'\"]');return o.length||(o=t(n).closest(\"label\")),o[0];});return t(n);}},{key:\"addErrorClasses\",value:function value(t){var e=this.findLabel(t),i=this.findFormError(t);e.length&&e.addClass(this.options.labelErrorClass),i.length&&i.addClass(this.options.formErrorClass),t.addClass(this.options.inputErrorClass).attr(\"data-invalid\",\"\");}},{key:\"removeRadioErrorClasses\",value:function value(t){var e=this.$element.find(':radio[name=\"'+t+'\"]'),i=this.findRadioLabels(e),n=this.findFormError(e);i.length&&i.removeClass(this.options.labelErrorClass),n.length&&n.removeClass(this.options.formErrorClass),e.removeClass(this.options.inputErrorClass).removeAttr(\"data-invalid\");}},{key:\"removeErrorClasses\",value:function value(t){if(\"radio\"==t[0].type)return this.removeRadioErrorClasses(t.attr(\"name\"));var e=this.findLabel(t),i=this.findFormError(t);e.length&&e.removeClass(this.options.labelErrorClass),i.length&&i.removeClass(this.options.formErrorClass),t.removeClass(this.options.inputErrorClass).removeAttr(\"data-invalid\");}},{key:\"validateInput\",value:function value(t){var e=this.requiredCheck(t),i=!1,n=!0,s=t.attr(\"data-validator\"),o=!0;if(t.is(\"[data-abide-ignore]\")||t.is('[type=\"hidden\"]'))return!0;switch(t[0].type){case\"radio\":i=this.validateRadio(t.attr(\"name\"));break;case\"checkbox\":i=e;break;case\"select\":case\"select-one\":case\"select-multiple\":i=e;break;default:i=this.validateText(t);}s&&(n=this.matchValidation(t,s,t.attr(\"required\"))),t.attr(\"data-equalto\")&&(o=this.options.validators.equalTo(t));var a=-1===[e,i,n,o].indexOf(!1),r=(a?\"valid\":\"invalid\")+\".zf.abide\";return this[a?\"removeErrorClasses\":\"addErrorClasses\"](t),t.trigger(r,[t]),a;}},{key:\"validateForm\",value:function value(){var e=[],i=this;this.$inputs.each(function(){e.push(i.validateInput(t(this)));});var n=-1===e.indexOf(!1);return this.$element.find(\"[data-abide-error]\").css(\"display\",n?\"none\":\"block\"),this.$element.trigger((n?\"formvalid\":\"forminvalid\")+\".zf.abide\",[this.$element]),n;}},{key:\"validateText\",value:function value(t,e){e=e||t.attr(\"pattern\")||t.attr(\"type\");var i=t.val(),n=!1;return i.length?n=this.options.patterns.hasOwnProperty(e)?this.options.patterns[e].test(i):e!==t.attr(\"type\")?new RegExp(e).test(i):!0:t.prop(\"required\")||(n=!0),n;}},{key:\"validateRadio\",value:function value(e){var i=this.$element.find(':radio[name=\"'+e+'\"]'),n=!1,s=!1;return i.each(function(e,i){t(i).attr(\"required\")&&(s=!0);}),s||(n=!0),n||i.each(function(e,i){t(i).prop(\"checked\")&&(n=!0);}),n;}},{key:\"matchValidation\",value:function value(t,e,i){var n=this;i=!!i;var s=e.split(\" \").map(function(e){return n.options.validators[e](t,i,t.parent());});return-1===s.indexOf(!1);}},{key:\"resetForm\",value:function value(){var e=this.$element,i=this.options;t(\".\"+i.labelErrorClass,e).not(\"small\").removeClass(i.labelErrorClass),t(\".\"+i.inputErrorClass,e).not(\"small\").removeClass(i.inputErrorClass),t(i.formErrorSelector+\".\"+i.formErrorClass).removeClass(i.formErrorClass),e.find(\"[data-abide-error]\").css(\"display\",\"none\"),t(\":input\",e).not(\":button, :submit, :reset, :hidden, :radio, :checkbox, [data-abide-ignore]\").val(\"\").removeAttr(\"data-invalid\"),t(\":input:radio\",e).not(\"[data-abide-ignore]\").prop(\"checked\",!1).removeAttr(\"data-invalid\"),t(\":input:checkbox\",e).not(\"[data-abide-ignore]\").prop(\"checked\",!1).removeAttr(\"data-invalid\"),e.trigger(\"formreset.zf.abide\",[e]);}},{key:\"destroy\",value:function value(){var e=this;this.$element.off(\".abide\").find(\"[data-abide-error]\").css(\"display\",\"none\"),this.$inputs.off(\".abide\").each(function(){e.removeErrorClasses(t(this));}),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={validateOn:\"fieldChange\",labelErrorClass:\"is-invalid-label\",inputErrorClass:\"is-invalid-input\",formErrorSelector:\".form-error\",formErrorClass:\"is-visible\",liveValidate:!1,patterns:{alpha:/^[a-zA-Z]+$/,alpha_numeric:/^[a-zA-Z0-9]+$/,integer:/^[-+]?\\d+$/,number:/^[-+]?\\d*(?:[\\.\\,]\\d+)?$/,card:/^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\d{3})\\d{11})$/,cvv:/^([0-9]){3,4}$/,email:/^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/,url:/^(https?|ftp|file|ssh):\\/\\/(((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-zA-Z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-zA-Z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-zA-Z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-zA-Z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-zA-Z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-zA-Z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/,domain:/^([a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,8}$/,datetime:/^([0-2][0-9]{3})\\-([0-1][0-9])\\-([0-3][0-9])T([0-5][0-9])\\:([0-5][0-9])\\:([0-5][0-9])(Z|([\\-\\+]([0-1][0-9])\\:00))$/,date:/(?:19|20)[0-9]{2}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-9])|(?:(?!02)(?:0[1-9]|1[0-2])-(?:30))|(?:(?:0[13578]|1[02])-31))$/,time:/^(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$/,dateISO:/^\\d{4}[\\/\\-]\\d{1,2}[\\/\\-]\\d{1,2}$/,month_day_year:/^(0[1-9]|1[012])[- \\/.](0[1-9]|[12][0-9]|3[01])[- \\/.]\\d{4}$/,day_month_year:/^(0[1-9]|[12][0-9]|3[01])[- \\/.](0[1-9]|1[012])[- \\/.]\\d{4}$/,color:/^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/},validators:{equalTo:function equalTo(e,i,n){return t(\"#\"+e.attr(\"data-equalto\")).val()===e.val();}}},Foundation.plugin(e,\"Abide\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Accordion\"),Foundation.Keyboard.register(\"Accordion\",{ENTER:\"toggle\",SPACE:\"toggle\",ARROW_DOWN:\"next\",ARROW_UP:\"previous\"});}return _createClass(e,[{key:\"_init\",value:function value(){this.$element.attr(\"role\",\"tablist\"),this.$tabs=this.$element.children(\"li, [data-accordion-item]\"),this.$tabs.each(function(e,i){var n=t(i),s=n.children(\"[data-tab-content]\"),o=s[0].id||Foundation.GetYoDigits(6,\"accordion\"),a=i.id||o+\"-label\";n.find(\"a:first\").attr({\"aria-controls\":o,role:\"tab\",id:a,\"aria-expanded\":!1,\"aria-selected\":!1}),s.attr({role:\"tabpanel\",\"aria-labelledby\":a,\"aria-hidden\":!0,id:o});});var e=this.$element.find(\".is-active\").children(\"[data-tab-content]\");e.length&&this.down(e,!0),this._events();}},{key:\"_events\",value:function value(){var e=this;this.$tabs.each(function(){var i=t(this),n=i.children(\"[data-tab-content]\");n.length&&i.children(\"a\").off(\"click.zf.accordion keydown.zf.accordion\").on(\"click.zf.accordion\",function(t){t.preventDefault(),i.hasClass(\"is-active\")?(e.options.allowAllClosed||i.siblings().hasClass(\"is-active\"))&&e.up(n):e.down(n);}).on(\"keydown.zf.accordion\",function(t){Foundation.Keyboard.handleKey(t,\"Accordion\",{toggle:function toggle(){e.toggle(n);},next:function next(){var t=i.next().find(\"a\").focus();e.options.multiExpand||t.trigger(\"click.zf.accordion\");},previous:function previous(){var t=i.prev().find(\"a\").focus();e.options.multiExpand||t.trigger(\"click.zf.accordion\");},handled:function handled(){t.preventDefault(),t.stopPropagation();}});});});}},{key:\"toggle\",value:function value(t){if(t.parent().hasClass(\"is-active\")){if(!this.options.allowAllClosed&&!t.parent().siblings().hasClass(\"is-active\"))return;this.up(t);}else this.down(t);}},{key:\"down\",value:function value(e,i){var n=this;if(!this.options.multiExpand&&!i){var s=this.$element.children(\".is-active\").children(\"[data-tab-content]\");s.length&&this.up(s);}e.attr(\"aria-hidden\",!1).parent(\"[data-tab-content]\").addBack().parent().addClass(\"is-active\"),e.slideDown(this.options.slideSpeed,function(){n.$element.trigger(\"down.zf.accordion\",[e]);}),t(\"#\"+e.attr(\"aria-labelledby\")).attr({\"aria-expanded\":!0,\"aria-selected\":!0});}},{key:\"up\",value:function value(e){var i=e.parent().siblings(),n=this,s=this.options.multiExpand?i.hasClass(\"is-active\"):e.parent().hasClass(\"is-active\");(this.options.allowAllClosed||s)&&(e.slideUp(n.options.slideSpeed,function(){n.$element.trigger(\"up.zf.accordion\",[e]);}),e.attr(\"aria-hidden\",!0).parent().removeClass(\"is-active\"),t(\"#\"+e.attr(\"aria-labelledby\")).attr({\"aria-expanded\":!1,\"aria-selected\":!1}));}},{key:\"destroy\",value:function value(){this.$element.find(\"[data-tab-content]\").stop(!0).slideUp(0).css(\"display\",\"\"),this.$element.find(\"a\").off(\".zf.accordion\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={slideSpeed:250,multiExpand:!1,allowAllClosed:!1},Foundation.plugin(e,\"Accordion\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),Foundation.Nest.Feather(this.$element,\"accordion\"),this._init(),Foundation.registerPlugin(this,\"AccordionMenu\"),Foundation.Keyboard.register(\"AccordionMenu\",{ENTER:\"toggle\",SPACE:\"toggle\",ARROW_RIGHT:\"open\",ARROW_UP:\"up\",ARROW_DOWN:\"down\",ARROW_LEFT:\"close\",ESCAPE:\"closeAll\",TAB:\"down\",SHIFT_TAB:\"up\"});}return _createClass(e,[{key:\"_init\",value:function value(){this.$element.find(\"[data-submenu]\").not(\".is-active\").slideUp(0),this.$element.attr({role:\"tablist\",\"aria-multiselectable\":this.options.multiOpen}),this.$menuLinks=this.$element.find(\".is-accordion-submenu-parent\"),this.$menuLinks.each(function(){var e=this.id||Foundation.GetYoDigits(6,\"acc-menu-link\"),i=t(this),n=i.children(\"[data-submenu]\"),s=n[0].id||Foundation.GetYoDigits(6,\"acc-menu\"),o=n.hasClass(\"is-active\");i.attr({\"aria-controls\":s,\"aria-expanded\":o,role:\"tab\",id:e}),n.attr({\"aria-labelledby\":e,\"aria-hidden\":!o,role:\"tabpanel\",id:s});});var e=this.$element.find(\".is-active\");if(e.length){var i=this;e.each(function(){i.down(t(this));});}this._events();}},{key:\"_events\",value:function value(){var e=this;this.$element.find(\"li\").each(function(){var i=t(this).children(\"[data-submenu]\");i.length&&t(this).children(\"a\").off(\"click.zf.accordionMenu\").on(\"click.zf.accordionMenu\",function(t){t.preventDefault(),e.toggle(i);});}).on(\"keydown.zf.accordionmenu\",function(i){var n,s,o=t(this),a=o.parent(\"ul\").children(\"li\"),r=o.children(\"[data-submenu]\");a.each(function(e){return t(this).is(o)?(n=a.eq(Math.max(0,e-1)).find(\"a\").first(),s=a.eq(Math.min(e+1,a.length-1)).find(\"a\").first(),t(this).children(\"[data-submenu]:visible\").length&&(s=o.find(\"li:first-child\").find(\"a\").first()),t(this).is(\":first-child\")?n=o.parents(\"li\").first().find(\"a\").first():n.children(\"[data-submenu]:visible\").length&&(n=n.find(\"li:last-child\").find(\"a\").first()),void(t(this).is(\":last-child\")&&(s=o.parents(\"li\").first().next(\"li\").find(\"a\").first()))):void 0;}),Foundation.Keyboard.handleKey(i,\"AccordionMenu\",{open:function open(){r.is(\":hidden\")&&(e.down(r),r.find(\"li\").first().find(\"a\").first().focus());},close:function close(){r.length&&!r.is(\":hidden\")?e.up(r):o.parent(\"[data-submenu]\").length&&(e.up(o.parent(\"[data-submenu]\")),o.parents(\"li\").first().find(\"a\").first().focus());},up:function up(){return n.attr(\"tabindex\",-1).focus(),!0;},down:function down(){return s.attr(\"tabindex\",-1).focus(),!0;},toggle:function toggle(){o.children(\"[data-submenu]\").length&&e.toggle(o.children(\"[data-submenu]\"));},closeAll:function closeAll(){e.hideAll();},handled:function handled(t){t&&i.preventDefault(),i.stopImmediatePropagation();}});});}},{key:\"hideAll\",value:function value(){this.$element.find(\"[data-submenu]\").slideUp(this.options.slideSpeed);}},{key:\"toggle\",value:function value(t){t.is(\":animated\")||(t.is(\":hidden\")?this.down(t):this.up(t));}},{key:\"down\",value:function value(t){var e=this;this.options.multiOpen||this.up(this.$element.find(\".is-active\").not(t.parentsUntil(this.$element).add(t))),t.addClass(\"is-active\").attr({\"aria-hidden\":!1}).parent(\".is-accordion-submenu-parent\").attr({\"aria-expanded\":!0}),t.slideDown(e.options.slideSpeed,function(){e.$element.trigger(\"down.zf.accordionMenu\",[t]);});}},{key:\"up\",value:function value(t){var e=this;t.slideUp(e.options.slideSpeed,function(){e.$element.trigger(\"up.zf.accordionMenu\",[t]);});var i=t.find(\"[data-submenu]\").slideUp(0).addBack().attr(\"aria-hidden\",!0);i.parent(\".is-accordion-submenu-parent\").attr(\"aria-expanded\",!1);}},{key:\"destroy\",value:function value(){this.$element.find(\"[data-submenu]\").slideDown(0).css(\"display\",\"\"),this.$element.find(\"a\").off(\"click.zf.accordionMenu\"),Foundation.Nest.Burn(this.$element,\"accordion\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={slideSpeed:250,multiOpen:!0},Foundation.plugin(e,\"AccordionMenu\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),Foundation.Nest.Feather(this.$element,\"drilldown\"),this._init(),Foundation.registerPlugin(this,\"Drilldown\"),Foundation.Keyboard.register(\"Drilldown\",{ENTER:\"open\",SPACE:\"open\",ARROW_RIGHT:\"next\",ARROW_UP:\"up\",ARROW_DOWN:\"down\",ARROW_LEFT:\"previous\",ESCAPE:\"close\",TAB:\"down\",SHIFT_TAB:\"up\"});}return _createClass(e,[{key:\"_init\",value:function value(){this.$submenuAnchors=this.$element.find(\"li.is-drilldown-submenu-parent\").children(\"a\"),this.$submenus=this.$submenuAnchors.parent(\"li\").children(\"[data-submenu]\"),this.$menuItems=this.$element.find(\"li\").not(\".js-drilldown-back\").attr(\"role\",\"menuitem\").find(\"a\"),this._prepareMenu(),this._keyboardEvents();}},{key:\"_prepareMenu\",value:function value(){var e=this;this.$submenuAnchors.each(function(){var i=t(this),n=i.parent();e.options.parentLink&&i.clone().prependTo(n.children(\"[data-submenu]\")).wrap('<li class=\"is-submenu-parent-item is-submenu-item is-drilldown-submenu-item\" role=\"menu-item\"></li>'),i.data(\"savedHref\",i.attr(\"href\")).removeAttr(\"href\"),i.children(\"[data-submenu]\").attr({\"aria-hidden\":!0,tabindex:0,role:\"menu\"}),e._events(i);}),this.$submenus.each(function(){var i=t(this),n=i.find(\".js-drilldown-back\");n.length||i.prepend(e.options.backButton),e._back(i);}),this.$element.parent().hasClass(\"is-drilldown\")||(this.$wrapper=t(this.options.wrapper).addClass(\"is-drilldown\"),this.$wrapper=this.$element.wrap(this.$wrapper).parent().css(this._getMaxDims()));}},{key:\"_events\",value:function value(e){var i=this;e.off(\"click.zf.drilldown\").on(\"click.zf.drilldown\",function(n){if(t(n.target).parentsUntil(\"ul\",\"li\").hasClass(\"is-drilldown-submenu-parent\")&&(n.stopImmediatePropagation(),n.preventDefault()),i._show(e.parent(\"li\")),i.options.closeOnClick){var s=t(\"body\");s.off(\".zf.drilldown\").on(\"click.zf.drilldown\",function(e){e.target===i.$element[0]||t.contains(i.$element[0],e.target)||(e.preventDefault(),i._hideAll(),s.off(\".zf.drilldown\"));});}});}},{key:\"_keyboardEvents\",value:function value(){var e=this;this.$menuItems.add(this.$element.find(\".js-drilldown-back > a\")).on(\"keydown.zf.drilldown\",function(i){var n,s,o=t(this),a=o.parent(\"li\").parent(\"ul\").children(\"li\").children(\"a\");a.each(function(e){return t(this).is(o)?(n=a.eq(Math.max(0,e-1)),void(s=a.eq(Math.min(e+1,a.length-1)))):void 0;}),Foundation.Keyboard.handleKey(i,\"Drilldown\",{next:function next(){return o.is(e.$submenuAnchors)?(e._show(o.parent(\"li\")),o.parent(\"li\").one(Foundation.transitionend(o),function(){o.parent(\"li\").find(\"ul li a\").filter(e.$menuItems).first().focus();}),!0):void 0;},previous:function previous(){return e._hide(o.parent(\"li\").parent(\"ul\")),o.parent(\"li\").parent(\"ul\").one(Foundation.transitionend(o),function(){setTimeout(function(){o.parent(\"li\").parent(\"ul\").parent(\"li\").children(\"a\").first().focus();},1);}),!0;},up:function up(){return n.focus(),!0;},down:function down(){return s.focus(),!0;},close:function close(){e._back();},open:function open(){return o.is(e.$menuItems)?o.is(e.$submenuAnchors)&&(e._show(o.parent(\"li\")),o.parent(\"li\").one(Foundation.transitionend(o),function(){o.parent(\"li\").find(\"ul li a\").filter(e.$menuItems).first().focus();})):(e._hide(o.parent(\"li\").parent(\"ul\")),o.parent(\"li\").parent(\"ul\").one(Foundation.transitionend(o),function(){setTimeout(function(){o.parent(\"li\").parent(\"ul\").parent(\"li\").children(\"a\").first().focus();},1);})),!0;},handled:function handled(t){t&&i.preventDefault(),i.stopImmediatePropagation();}});});}},{key:\"_hideAll\",value:function value(){var t=this.$element.find(\".is-drilldown-submenu.is-active\").addClass(\"is-closing\");t.one(Foundation.transitionend(t),function(e){t.removeClass(\"is-active is-closing\");}),this.$element.trigger(\"closed.zf.drilldown\");}},{key:\"_back\",value:function value(t){var e=this;t.off(\"click.zf.drilldown\"),t.children(\".js-drilldown-back\").on(\"click.zf.drilldown\",function(i){i.stopImmediatePropagation(),e._hide(t);});}},{key:\"_menuLinkEvents\",value:function value(){var t=this;this.$menuItems.not(\".is-drilldown-submenu-parent\").off(\"click.zf.drilldown\").on(\"click.zf.drilldown\",function(e){setTimeout(function(){t._hideAll();},0);});}},{key:\"_show\",value:function value(t){t.children(\"[data-submenu]\").addClass(\"is-active\"),this.$element.trigger(\"open.zf.drilldown\",[t]);}},{key:\"_hide\",value:function value(t){t.addClass(\"is-closing\").one(Foundation.transitionend(t),function(){t.removeClass(\"is-active is-closing\"),t.blur();}),t.trigger(\"hide.zf.drilldown\",[t]);}},{key:\"_getMaxDims\",value:function value(){var e=0,i={};return this.$submenus.add(this.$element).each(function(){var i=t(this).children(\"li\").length;e=i>e?i:e;}),i[\"min-height\"]=e*this.$menuItems[0].getBoundingClientRect().height+\"px\",i[\"max-width\"]=this.$element[0].getBoundingClientRect().width+\"px\",i;}},{key:\"destroy\",value:function value(){this._hideAll(),Foundation.Nest.Burn(this.$element,\"drilldown\"),this.$element.unwrap().find(\".js-drilldown-back, .is-submenu-parent-item\").remove().end().find(\".is-active, .is-closing, .is-drilldown-submenu\").removeClass(\"is-active is-closing is-drilldown-submenu\").end().find(\"[data-submenu]\").removeAttr(\"aria-hidden tabindex role\"),this.$submenuAnchors.each(function(){t(this).off(\".zf.drilldown\");}),this.$element.find(\"a\").each(function(){var e=t(this);e.data(\"savedHref\")&&e.attr(\"href\",e.data(\"savedHref\")).removeData(\"savedHref\");}),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={backButton:'<li class=\"js-drilldown-back\"><a tabindex=\"0\">Back</a></li>',wrapper:\"<div></div>\",parentLink:!1,closeOnClick:!1},Foundation.plugin(e,\"Drilldown\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Dropdown\"),Foundation.Keyboard.register(\"Dropdown\",{ENTER:\"open\",SPACE:\"open\",ESCAPE:\"close\",TAB:\"tab_forward\",SHIFT_TAB:\"tab_backward\"});}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element.attr(\"id\");this.$anchor=t('[data-toggle=\"'+e+'\"]')||t('[data-open=\"'+e+'\"]'),this.$anchor.attr({\"aria-controls\":e,\"data-is-focus\":!1,\"data-yeti-box\":e,\"aria-haspopup\":!0,\"aria-expanded\":!1}),this.options.positionClass=this.getPositionClass(),this.counter=4,this.usedPositions=[],this.$element.attr({\"aria-hidden\":\"true\",\"data-yeti-box\":e,\"data-resize\":e,\"aria-labelledby\":this.$anchor[0].id||Foundation.GetYoDigits(6,\"dd-anchor\")}),this._events();}},{key:\"getPositionClass\",value:function value(){var t=this.$element[0].className.match(/(top|left|right|bottom)/g);t=t?t[0]:\"\";var e=/float-(\\S+)\\s/.exec(this.$anchor[0].className);e=e?e[1]:\"\";var i=e?e+\" \"+t:t;return i;}},{key:\"_reposition\",value:function value(t){this.usedPositions.push(t?t:\"bottom\"),!t&&this.usedPositions.indexOf(\"top\")<0?this.$element.addClass(\"top\"):\"top\"===t&&this.usedPositions.indexOf(\"bottom\")<0?this.$element.removeClass(t):\"left\"===t&&this.usedPositions.indexOf(\"right\")<0?this.$element.removeClass(t).addClass(\"right\"):\"right\"===t&&this.usedPositions.indexOf(\"left\")<0?this.$element.removeClass(t).addClass(\"left\"):!t&&this.usedPositions.indexOf(\"top\")>-1&&this.usedPositions.indexOf(\"left\")<0?this.$element.addClass(\"left\"):\"top\"===t&&this.usedPositions.indexOf(\"bottom\")>-1&&this.usedPositions.indexOf(\"left\")<0?this.$element.removeClass(t).addClass(\"left\"):\"left\"===t&&this.usedPositions.indexOf(\"right\")>-1&&this.usedPositions.indexOf(\"bottom\")<0?this.$element.removeClass(t):\"right\"===t&&this.usedPositions.indexOf(\"left\")>-1&&this.usedPositions.indexOf(\"bottom\")<0?this.$element.removeClass(t):this.$element.removeClass(t),this.classChanged=!0,this.counter--;}},{key:\"_setPosition\",value:function value(){if(\"false\"===this.$anchor.attr(\"aria-expanded\"))return!1;var t=this.getPositionClass(),e=Foundation.Box.GetDimensions(this.$element),i=(Foundation.Box.GetDimensions(this.$anchor),\"left\"===t?\"left\":\"right\"===t?\"left\":\"top\"),n=\"top\"===i?\"height\":\"width\";\"height\"===n?this.options.vOffset:this.options.hOffset;if(e.width>=e.windowDims.width||!this.counter&&!Foundation.Box.ImNotTouchingYou(this.$element))return this.$element.offset(Foundation.Box.GetOffsets(this.$element,this.$anchor,\"center bottom\",this.options.vOffset,this.options.hOffset,!0)).css({width:e.windowDims.width-2*this.options.hOffset,height:\"auto\"}),this.classChanged=!0,!1;for(this.$element.offset(Foundation.Box.GetOffsets(this.$element,this.$anchor,t,this.options.vOffset,this.options.hOffset));!Foundation.Box.ImNotTouchingYou(this.$element,!1,!0)&&this.counter;){this._reposition(t),this._setPosition();}}},{key:\"_events\",value:function value(){var e=this;this.$element.on({\"open.zf.trigger\":this.open.bind(this),\"close.zf.trigger\":this.close.bind(this),\"toggle.zf.trigger\":this.toggle.bind(this),\"resizeme.zf.trigger\":this._setPosition.bind(this)}),this.options.hover&&(this.$anchor.off(\"mouseenter.zf.dropdown mouseleave.zf.dropdown\").on(\"mouseenter.zf.dropdown\",function(){clearTimeout(e.timeout),e.timeout=setTimeout(function(){e.open(),e.$anchor.data(\"hover\",!0);},e.options.hoverDelay);}).on(\"mouseleave.zf.dropdown\",function(){clearTimeout(e.timeout),e.timeout=setTimeout(function(){e.close(),e.$anchor.data(\"hover\",!1);},e.options.hoverDelay);}),this.options.hoverPane&&this.$element.off(\"mouseenter.zf.dropdown mouseleave.zf.dropdown\").on(\"mouseenter.zf.dropdown\",function(){clearTimeout(e.timeout);}).on(\"mouseleave.zf.dropdown\",function(){clearTimeout(e.timeout),e.timeout=setTimeout(function(){e.close(),e.$anchor.data(\"hover\",!1);},e.options.hoverDelay);})),this.$anchor.add(this.$element).on(\"keydown.zf.dropdown\",function(i){var n=t(this),s=Foundation.Keyboard.findFocusable(e.$element);Foundation.Keyboard.handleKey(i,\"Dropdown\",{tab_forward:function tab_forward(){e.$element.find(\":focus\").is(s.eq(-1))&&(e.options.trapFocus?(s.eq(0).focus(),i.preventDefault()):e.close());},tab_backward:function tab_backward(){(e.$element.find(\":focus\").is(s.eq(0))||e.$element.is(\":focus\"))&&(e.options.trapFocus?(s.eq(-1).focus(),i.preventDefault()):e.close());},open:function open(){n.is(e.$anchor)&&(e.open(),e.$element.attr(\"tabindex\",-1).focus(),i.preventDefault());},close:function close(){e.close(),e.$anchor.focus();}});});}},{key:\"_addBodyHandler\",value:function value(){var e=t(document.body).not(this.$element),i=this;e.off(\"click.zf.dropdown\").on(\"click.zf.dropdown\",function(t){i.$anchor.is(t.target)||i.$anchor.find(t.target).length||i.$element.find(t.target).length||(i.close(),e.off(\"click.zf.dropdown\"));});}},{key:\"open\",value:function value(){if(this.$element.trigger(\"closeme.zf.dropdown\",this.$element.attr(\"id\")),this.$anchor.addClass(\"hover\").attr({\"aria-expanded\":!0}),this._setPosition(),this.$element.addClass(\"is-open\").attr({\"aria-hidden\":!1}),this.options.autoFocus){var t=Foundation.Keyboard.findFocusable(this.$element);t.length&&t.eq(0).focus();}this.options.closeOnClick&&this._addBodyHandler(),this.$element.trigger(\"show.zf.dropdown\",[this.$element]);}},{key:\"close\",value:function value(){if(!this.$element.hasClass(\"is-open\"))return!1;if(this.$element.removeClass(\"is-open\").attr({\"aria-hidden\":!0}),this.$anchor.removeClass(\"hover\").attr(\"aria-expanded\",!1),this.classChanged){var t=this.getPositionClass();t&&this.$element.removeClass(t),this.$element.addClass(this.options.positionClass).css({height:\"\",width:\"\"}),this.classChanged=!1,this.counter=4,this.usedPositions.length=0;}this.$element.trigger(\"hide.zf.dropdown\",[this.$element]);}},{key:\"toggle\",value:function value(){if(this.$element.hasClass(\"is-open\")){if(this.$anchor.data(\"hover\"))return;this.close();}else this.open();}},{key:\"destroy\",value:function value(){this.$element.off(\".zf.trigger\").hide(),this.$anchor.off(\".zf.dropdown\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={hoverDelay:250,hover:!1,hoverPane:!1,vOffset:1,hOffset:1,positionClass:\"\",trapFocus:!1,autoFocus:!1,closeOnClick:!1},Foundation.plugin(e,\"Dropdown\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),Foundation.Nest.Feather(this.$element,\"dropdown\"),this._init(),Foundation.registerPlugin(this,\"DropdownMenu\"),Foundation.Keyboard.register(\"DropdownMenu\",{ENTER:\"open\",SPACE:\"open\",ARROW_RIGHT:\"next\",ARROW_UP:\"up\",ARROW_DOWN:\"down\",ARROW_LEFT:\"previous\",ESCAPE:\"close\"});}return _createClass(e,[{key:\"_init\",value:function value(){var t=this.$element.find(\"li.is-dropdown-submenu-parent\");this.$element.children(\".is-dropdown-submenu-parent\").children(\".is-dropdown-submenu\").addClass(\"first-sub\"),this.$menuItems=this.$element.find('[role=\"menuitem\"]'),this.$tabs=this.$element.children('[role=\"menuitem\"]'),this.$tabs.find(\"ul.is-dropdown-submenu\").addClass(this.options.verticalClass),this.$element.hasClass(this.options.rightClass)||\"right\"===this.options.alignment||Foundation.rtl()||this.$element.parents(\".top-bar-right\").is(\"*\")?(this.options.alignment=\"right\",t.addClass(\"opens-left\")):t.addClass(\"opens-right\"),this.changed=!1,this._events();}},{key:\"_events\",value:function value(){var e=this,i=\"ontouchstart\"in window||\"undefined\"!=typeof window.ontouchstart,n=\"is-dropdown-submenu-parent\",s=function s(_s){var o=t(_s.target).parentsUntil(\"ul\",\".\"+n),a=o.hasClass(n),r=\"true\"===o.attr(\"data-is-click\");o.children(\".is-dropdown-submenu\");if(a)if(r){if(!e.options.closeOnClick||!e.options.clickOpen&&!i||e.options.forceFollow&&i)return;_s.stopImmediatePropagation(),_s.preventDefault(),e._hide(o);}else _s.preventDefault(),_s.stopImmediatePropagation(),e._show(o.children(\".is-dropdown-submenu\")),o.add(o.parentsUntil(e.$element,\".\"+n)).attr(\"data-is-click\",!0);};(this.options.clickOpen||i)&&this.$menuItems.on(\"click.zf.dropdownmenu touchstart.zf.dropdownmenu\",s),this.options.disableHover||this.$menuItems.on(\"mouseenter.zf.dropdownmenu\",function(i){var s=t(this),o=s.hasClass(n);o&&(clearTimeout(e.delay),e.delay=setTimeout(function(){e._show(s.children(\".is-dropdown-submenu\"));},e.options.hoverDelay));}).on(\"mouseleave.zf.dropdownmenu\",function(i){var s=t(this),o=s.hasClass(n);if(o&&e.options.autoclose){if(\"true\"===s.attr(\"data-is-click\")&&e.options.clickOpen)return!1;clearTimeout(e.delay),e.delay=setTimeout(function(){e._hide(s);},e.options.closingTime);}}),this.$menuItems.on(\"keydown.zf.dropdownmenu\",function(i){var n,s,o=t(i.target).parentsUntil(\"ul\",'[role=\"menuitem\"]'),a=e.$tabs.index(o)>-1,r=a?e.$tabs:o.siblings(\"li\").add(o);r.each(function(e){return t(this).is(o)?(n=r.eq(e-1),void(s=r.eq(e+1))):void 0;});var l=function l(){o.is(\":last-child\")||(s.children(\"a:first\").focus(),i.preventDefault());},u=function u(){n.children(\"a:first\").focus(),i.preventDefault();},d=function d(){var t=o.children(\"ul.is-dropdown-submenu\");t.length&&(e._show(t),o.find(\"li > a:first\").focus(),i.preventDefault());},h=function h(){var t=o.parent(\"ul\").parent(\"li\");t.children(\"a:first\").focus(),e._hide(t),i.preventDefault();},c={open:d,close:function close(){e._hide(e.$element),e.$menuItems.find(\"a:first\").focus(),i.preventDefault();},handled:function handled(){i.stopImmediatePropagation();}};a?e.$element.hasClass(e.options.verticalClass)?\"left\"===e.options.alignment?t.extend(c,{down:l,up:u,next:d,previous:h}):t.extend(c,{down:l,up:u,next:h,previous:d}):t.extend(c,{next:l,previous:u,down:d,up:h}):\"left\"===e.options.alignment?t.extend(c,{next:d,previous:h,down:l,up:u}):t.extend(c,{next:h,previous:d,down:l,up:u}),Foundation.Keyboard.handleKey(i,\"DropdownMenu\",c);});}},{key:\"_addBodyHandler\",value:function value(){var e=t(document.body),i=this;e.off(\"mouseup.zf.dropdownmenu touchend.zf.dropdownmenu\").on(\"mouseup.zf.dropdownmenu touchend.zf.dropdownmenu\",function(t){var n=i.$element.find(t.target);n.length||(i._hide(),e.off(\"mouseup.zf.dropdownmenu touchend.zf.dropdownmenu\"));});}},{key:\"_show\",value:function value(e){var i=this.$tabs.index(this.$tabs.filter(function(i,n){return t(n).find(e).length>0;})),n=e.parent(\"li.is-dropdown-submenu-parent\").siblings(\"li.is-dropdown-submenu-parent\");this._hide(n,i),e.css(\"visibility\",\"hidden\").addClass(\"js-dropdown-active\").attr({\"aria-hidden\":!1}).parent(\"li.is-dropdown-submenu-parent\").addClass(\"is-active\").attr({\"aria-expanded\":!0});var s=Foundation.Box.ImNotTouchingYou(e,null,!0);if(!s){var o=\"left\"===this.options.alignment?\"-right\":\"-left\",a=e.parent(\".is-dropdown-submenu-parent\");a.removeClass(\"opens\"+o).addClass(\"opens-\"+this.options.alignment),s=Foundation.Box.ImNotTouchingYou(e,null,!0),s||a.removeClass(\"opens-\"+this.options.alignment).addClass(\"opens-inner\"),this.changed=!0;}e.css(\"visibility\",\"\"),this.options.closeOnClick&&this._addBodyHandler(),this.$element.trigger(\"show.zf.dropdownmenu\",[e]);}},{key:\"_hide\",value:function value(t,e){var i;i=t&&t.length?t:void 0!==e?this.$tabs.not(function(t,i){return t===e;}):this.$element;var n=i.hasClass(\"is-active\")||i.find(\".is-active\").length>0;if(n){if(i.find(\"li.is-active\").add(i).attr({\"aria-expanded\":!1,\"data-is-click\":!1}).removeClass(\"is-active\"),i.find(\"ul.js-dropdown-active\").attr({\"aria-hidden\":!0}).removeClass(\"js-dropdown-active\"),this.changed||i.find(\"opens-inner\").length){var s=\"left\"===this.options.alignment?\"right\":\"left\";i.find(\"li.is-dropdown-submenu-parent\").add(i).removeClass(\"opens-inner opens-\"+this.options.alignment).addClass(\"opens-\"+s),this.changed=!1;}this.$element.trigger(\"hide.zf.dropdownmenu\",[i]);}}},{key:\"destroy\",value:function value(){this.$menuItems.off(\".zf.dropdownmenu\").removeAttr(\"data-is-click\").removeClass(\"is-right-arrow is-left-arrow is-down-arrow opens-right opens-left opens-inner\"),t(document.body).off(\".zf.dropdownmenu\"),Foundation.Nest.Burn(this.$element,\"dropdown\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={disableHover:!1,autoclose:!0,hoverDelay:50,clickOpen:!1,closingTime:500,alignment:\"left\",closeOnClick:!0,verticalClass:\"vertical\",rightClass:\"align-right\",forceFollow:!0},Foundation.plugin(e,\"DropdownMenu\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Equalizer\");}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element.attr(\"data-equalizer\")||\"\",i=this.$element.find('[data-equalizer-watch=\"'+e+'\"]');this.$watched=i.length?i:this.$element.find(\"[data-equalizer-watch]\"),this.$element.attr(\"data-resize\",e||Foundation.GetYoDigits(6,\"eq\")),this.hasNested=this.$element.find(\"[data-equalizer]\").length>0,this.isNested=this.$element.parentsUntil(document.body,\"[data-equalizer]\").length>0,this.isOn=!1,this._bindHandler={onResizeMeBound:this._onResizeMe.bind(this),onPostEqualizedBound:this._onPostEqualized.bind(this)};var n,s=this.$element.find(\"img\");this.options.equalizeOn?(n=this._checkMQ(),t(window).on(\"changed.zf.mediaquery\",this._checkMQ.bind(this))):this._events(),(void 0!==n&&n===!1||void 0===n)&&(s.length?Foundation.onImagesLoaded(s,this._reflow.bind(this)):this._reflow());}},{key:\"_pauseEvents\",value:function value(){this.isOn=!1,this.$element.off({\".zf.equalizer\":this._bindHandler.onPostEqualizedBound,\"resizeme.zf.trigger\":this._bindHandler.onResizeMeBound});}},{key:\"_onResizeMe\",value:function value(t){this._reflow();}},{key:\"_onPostEqualized\",value:function value(t){t.target!==this.$element[0]&&this._reflow();}},{key:\"_events\",value:function value(){this._pauseEvents(),this.hasNested?this.$element.on(\"postequalized.zf.equalizer\",this._bindHandler.onPostEqualizedBound):this.$element.on(\"resizeme.zf.trigger\",this._bindHandler.onResizeMeBound),this.isOn=!0;}},{key:\"_checkMQ\",value:function value(){var t=!Foundation.MediaQuery.atLeast(this.options.equalizeOn);return t?this.isOn&&(this._pauseEvents(),this.$watched.css(\"height\",\"auto\")):this.isOn||this._events(),t;}},{key:\"_killswitch\",value:function value(){}},{key:\"_reflow\",value:function value(){return!this.options.equalizeOnStack&&this._isStacked()?(this.$watched.css(\"height\",\"auto\"),!1):void(this.options.equalizeByRow?this.getHeightsByRow(this.applyHeightByRow.bind(this)):this.getHeights(this.applyHeight.bind(this)));}},{key:\"_isStacked\",value:function value(){return this.$watched[0].getBoundingClientRect().top!==this.$watched[1].getBoundingClientRect().top;}},{key:\"getHeights\",value:function value(t){for(var e=[],i=0,n=this.$watched.length;n>i;i++){this.$watched[i].style.height=\"auto\",e.push(this.$watched[i].offsetHeight);}t(e);}},{key:\"getHeightsByRow\",value:function value(e){var i=this.$watched.length?this.$watched.first().offset().top:0,n=[],s=0;n[s]=[];for(var o=0,a=this.$watched.length;a>o;o++){this.$watched[o].style.height=\"auto\";var r=t(this.$watched[o]).offset().top;r!=i&&(s++,n[s]=[],i=r),n[s].push([this.$watched[o],this.$watched[o].offsetHeight]);}for(var l=0,u=n.length;u>l;l++){var d=t(n[l]).map(function(){return this[1];}).get(),h=Math.max.apply(null,d);n[l].push(h);}e(n);}},{key:\"applyHeight\",value:function value(t){var e=Math.max.apply(null,t);this.$element.trigger(\"preequalized.zf.equalizer\"),this.$watched.css(\"height\",e),this.$element.trigger(\"postequalized.zf.equalizer\");}},{key:\"applyHeightByRow\",value:function value(e){this.$element.trigger(\"preequalized.zf.equalizer\");for(var i=0,n=e.length;n>i;i++){var s=e[i].length,o=e[i][s-1];if(2>=s)t(e[i][0][0]).css({height:\"auto\"});else{this.$element.trigger(\"preequalizedrow.zf.equalizer\");for(var a=0,r=s-1;r>a;a++){t(e[i][a][0]).css({height:o});}this.$element.trigger(\"postequalizedrow.zf.equalizer\");}}this.$element.trigger(\"postequalized.zf.equalizer\");}},{key:\"destroy\",value:function value(){this._pauseEvents(),this.$watched.css(\"height\",\"auto\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={equalizeOnStack:!0,equalizeByRow:!1,equalizeOn:\"\"},Foundation.plugin(e,\"Equalizer\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,n),this.rules=[],this.currentPath=\"\",this._init(),this._events(),Foundation.registerPlugin(this,\"Interchange\");}return _createClass(e,[{key:\"_init\",value:function value(){this._addBreakpoints(),this._generateRules(),this._reflow();}},{key:\"_events\",value:function value(){t(window).on(\"resize.zf.interchange\",Foundation.util.throttle(this._reflow.bind(this),50));}},{key:\"_reflow\",value:function value(){var t;for(var e in this.rules){if(this.rules.hasOwnProperty(e)){var i=this.rules[e];window.matchMedia(i.query).matches&&(t=i);}}t&&this.replace(t.path);}},{key:\"_addBreakpoints\",value:function value(){for(var t in Foundation.MediaQuery.queries){if(Foundation.MediaQuery.queries.hasOwnProperty(t)){var i=Foundation.MediaQuery.queries[t];e.SPECIAL_QUERIES[i.name]=i.value;}}}},{key:\"_generateRules\",value:function value(t){var i,n=[];i=this.options.rules?this.options.rules:this.$element.data(\"interchange\").match(/\\[.*?\\]/g);for(var s in i){if(i.hasOwnProperty(s)){var o=i[s].slice(1,-1).split(\", \"),a=o.slice(0,-1).join(\"\"),r=o[o.length-1];e.SPECIAL_QUERIES[r]&&(r=e.SPECIAL_QUERIES[r]),n.push({path:a,query:r});}}this.rules=n;}},{key:\"replace\",value:function value(e){if(this.currentPath!==e){var i=this,n=\"replaced.zf.interchange\";\"IMG\"===this.$element[0].nodeName?this.$element.attr(\"src\",e).load(function(){i.currentPath=e;}).trigger(n):e.match(/\\.(gif|jpg|jpeg|png|svg|tiff)([?#].*)?/i)?this.$element.css({\"background-image\":\"url(\"+e+\")\"}).trigger(n):t.get(e,function(s){i.$element.html(s).trigger(n),t(s).foundation(),i.currentPath=e;});}}},{key:\"destroy\",value:function value(){}}]),e;}();e.defaults={rules:null},e.SPECIAL_QUERIES={landscape:\"screen and (orientation: landscape)\",portrait:\"screen and (orientation: portrait)\",retina:\"only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min--moz-device-pixel-ratio: 2), only screen and (-o-min-device-pixel-ratio: 2/1), only screen and (min-device-pixel-ratio: 2), only screen and (min-resolution: 192dpi), only screen and (min-resolution: 2dppx)\"},Foundation.plugin(e,\"Interchange\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Magellan\");}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element[0].id||Foundation.GetYoDigits(6,\"magellan\");this.$targets=t(\"[data-magellan-target]\"),this.$links=this.$element.find(\"a\"),this.$element.attr({\"data-resize\":e,\"data-scroll\":e,id:e}),this.$active=t(),this.scrollPos=parseInt(window.pageYOffset,10),this._events();}},{key:\"calcPoints\",value:function value(){var e=this,i=document.body,n=document.documentElement;this.points=[],this.winHeight=Math.round(Math.max(window.innerHeight,n.clientHeight)),this.docHeight=Math.round(Math.max(i.scrollHeight,i.offsetHeight,n.clientHeight,n.scrollHeight,n.offsetHeight)),this.$targets.each(function(){var i=t(this),n=Math.round(i.offset().top-e.options.threshold);i.targetPoint=n,e.points.push(n);});}},{key:\"_events\",value:function value(){var e=this;t(\"html, body\"),{duration:e.options.animationDuration,easing:e.options.animationEasing};t(window).one(\"load\",function(){e.options.deepLinking&&location.hash&&e.scrollToLoc(location.hash),e.calcPoints(),e._updateActive();}),this.$element.on({\"resizeme.zf.trigger\":this.reflow.bind(this),\"scrollme.zf.trigger\":this._updateActive.bind(this)}).on(\"click.zf.magellan\",'a[href^=\"#\"]',function(t){t.preventDefault();var i=this.getAttribute(\"href\");e.scrollToLoc(i);});}},{key:\"scrollToLoc\",value:function value(e){var i=Math.round(t(e).offset().top-this.options.threshold/2-this.options.barOffset);t(\"html, body\").stop(!0).animate({scrollTop:i},this.options.animationDuration,this.options.animationEasing);}},{key:\"reflow\",value:function value(){this.calcPoints(),this._updateActive();}},{key:\"_updateActive\",value:function value(){var t,e=parseInt(window.pageYOffset,10);if(e+this.winHeight===this.docHeight)t=this.points.length-1;else if(e<this.points[0])t=0;else{var i=this.scrollPos<e,n=this,s=this.points.filter(function(t,s){return i?t-n.options.barOffset<=e:t-n.options.barOffset-n.options.threshold<=e;});t=s.length?s.length-1:0;}if(this.$active.removeClass(this.options.activeClass),this.$active=this.$links.eq(t).addClass(this.options.activeClass),this.options.deepLinking){var o=this.$active[0].getAttribute(\"href\");window.history.pushState?window.history.pushState(null,null,o):window.location.hash=o;}this.scrollPos=e,this.$element.trigger(\"update.zf.magellan\",[this.$active]);}},{key:\"destroy\",value:function value(){if(this.$element.off(\".zf.trigger .zf.magellan\").find(\".\"+this.options.activeClass).removeClass(this.options.activeClass),this.options.deepLinking){var t=this.$active[0].getAttribute(\"href\");window.location.hash.replace(t,\"\");}Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={animationDuration:500,animationEasing:\"linear\",threshold:50,activeClass:\"active\",deepLinking:!1,barOffset:0},Foundation.plugin(e,\"Magellan\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this.$lastTrigger=t(),this.$triggers=t(),this._init(),this._events(),Foundation.registerPlugin(this,\"OffCanvas\");}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element.attr(\"id\");if(this.$element.attr(\"aria-hidden\",\"true\"),this.$triggers=t(document).find('[data-open=\"'+e+'\"], [data-close=\"'+e+'\"], [data-toggle=\"'+e+'\"]').attr(\"aria-expanded\",\"false\").attr(\"aria-controls\",e),this.options.closeOnClick)if(t(\".js-off-canvas-exit\").length)this.$exiter=t(\".js-off-canvas-exit\");else{var i=document.createElement(\"div\");i.setAttribute(\"class\",\"js-off-canvas-exit\"),t(\"[data-off-canvas-content]\").append(i),this.$exiter=t(i);}this.options.isRevealed=this.options.isRevealed||new RegExp(this.options.revealClass,\"g\").test(this.$element[0].className),this.options.isRevealed&&(this.options.revealOn=this.options.revealOn||this.$element[0].className.match(/(reveal-for-medium|reveal-for-large)/g)[0].split(\"-\")[2],this._setMQChecker()),this.options.transitionTime||(this.options.transitionTime=1e3*parseFloat(window.getComputedStyle(t(\"[data-off-canvas-wrapper]\")[0]).transitionDuration));}},{key:\"_events\",value:function value(){this.$element.off(\".zf.trigger .zf.offcanvas\").on({\"open.zf.trigger\":this.open.bind(this),\"close.zf.trigger\":this.close.bind(this),\"toggle.zf.trigger\":this.toggle.bind(this),\"keydown.zf.offcanvas\":this._handleKeyboard.bind(this)}),this.options.closeOnClick&&this.$exiter.length&&this.$exiter.on({\"click.zf.offcanvas\":this.close.bind(this)});}},{key:\"_setMQChecker\",value:function value(){var e=this;t(window).on(\"changed.zf.mediaquery\",function(){Foundation.MediaQuery.atLeast(e.options.revealOn)?e.reveal(!0):e.reveal(!1);}).one(\"load.zf.offcanvas\",function(){Foundation.MediaQuery.atLeast(e.options.revealOn)&&e.reveal(!0);});}},{key:\"reveal\",value:function value(t){var e=this.$element.find(\"[data-close]\");t?(this.close(),this.isRevealed=!0,this.$element.off(\"open.zf.trigger toggle.zf.trigger\"),e.length&&e.hide()):(this.isRevealed=!1,this.$element.on({\"open.zf.trigger\":this.open.bind(this),\"toggle.zf.trigger\":this.toggle.bind(this)}),e.length&&e.show());}},{key:\"open\",value:function value(e,i){if(!this.$element.hasClass(\"is-open\")&&!this.isRevealed){var n=this;t(document.body);this.options.forceTop&&t(\"body\").scrollTop(0),Foundation.Move(this.options.transitionTime,this.$element,function(){t(\"[data-off-canvas-wrapper]\").addClass(\"is-off-canvas-open is-open-\"+n.options.position),n.$element.addClass(\"is-open\");}),this.$triggers.attr(\"aria-expanded\",\"true\"),this.$element.attr(\"aria-hidden\",\"false\").trigger(\"opened.zf.offcanvas\"),this.options.closeOnClick&&this.$exiter.addClass(\"is-visible\"),i&&(this.$lastTrigger=i),this.options.autoFocus&&this.$element.one(Foundation.transitionend(this.$element),function(){n.$element.find(\"a, button\").eq(0).focus();}),this.options.trapFocus&&(t(\"[data-off-canvas-content]\").attr(\"tabindex\",\"-1\"),this._trapFocus());}}},{key:\"_trapFocus\",value:function value(){var t=Foundation.Keyboard.findFocusable(this.$element),e=t.eq(0),i=t.eq(-1);t.off(\".zf.offcanvas\").on(\"keydown.zf.offcanvas\",function(t){9!==t.which&&9!==t.keycode||(t.target!==i[0]||t.shiftKey||(t.preventDefault(),e.focus()),t.target===e[0]&&t.shiftKey&&(t.preventDefault(),i.focus()));});}},{key:\"close\",value:function value(e){if(this.$element.hasClass(\"is-open\")&&!this.isRevealed){var i=this;t(\"[data-off-canvas-wrapper]\").removeClass(\"is-off-canvas-open is-open-\"+i.options.position),i.$element.removeClass(\"is-open\"),this.$element.attr(\"aria-hidden\",\"true\").trigger(\"closed.zf.offcanvas\"),this.options.closeOnClick&&this.$exiter.removeClass(\"is-visible\"),this.$triggers.attr(\"aria-expanded\",\"false\"),this.options.trapFocus&&t(\"[data-off-canvas-content]\").removeAttr(\"tabindex\");}}},{key:\"toggle\",value:function value(t,e){this.$element.hasClass(\"is-open\")?this.close(t,e):this.open(t,e);}},{key:\"_handleKeyboard\",value:function value(t){27===t.which&&(t.stopPropagation(),t.preventDefault(),this.close(),this.$lastTrigger.focus());}},{key:\"destroy\",value:function value(){this.close(),this.$element.off(\".zf.trigger .zf.offcanvas\"),this.$exiter.off(\".zf.offcanvas\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={closeOnClick:!0,transitionTime:0,position:\"left\",forceTop:!0,isRevealed:!1,revealOn:null,autoFocus:!0,revealClass:\"reveal-for-\",trapFocus:!1},Foundation.plugin(e,\"OffCanvas\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Orbit\"),Foundation.Keyboard.register(\"Orbit\",{ltr:{ARROW_RIGHT:\"next\",ARROW_LEFT:\"previous\"},rtl:{ARROW_LEFT:\"next\",ARROW_RIGHT:\"previous\"}});}return _createClass(e,[{key:\"_init\",value:function value(){this.$wrapper=this.$element.find(\".\"+this.options.containerClass),this.$slides=this.$element.find(\".\"+this.options.slideClass);var t=this.$element.find(\"img\"),e=this.$slides.filter(\".is-active\");e.length||this.$slides.eq(0).addClass(\"is-active\"),this.options.useMUI||this.$slides.addClass(\"no-motionui\"),t.length?Foundation.onImagesLoaded(t,this._prepareForOrbit.bind(this)):this._prepareForOrbit(),this.options.bullets&&this._loadBullets(),this._events(),this.options.autoPlay&&this.$slides.length>1&&this.geoSync(),this.options.accessible&&this.$wrapper.attr(\"tabindex\",0);}},{key:\"_loadBullets\",value:function value(){this.$bullets=this.$element.find(\".\"+this.options.boxOfBullets).find(\"button\");}},{key:\"geoSync\",value:function value(){var t=this;this.timer=new Foundation.Timer(this.$element,{duration:this.options.timerDelay,infinite:!1},function(){t.changeSlide(!0);}),this.timer.start();}},{key:\"_prepareForOrbit\",value:function value(){var t=this;this._setWrapperHeight(function(e){t._setSlideHeight(e);});}},{key:\"_setWrapperHeight\",value:function value(e){var i,n=0,s=0;this.$slides.each(function(){i=this.getBoundingClientRect().height,t(this).attr(\"data-slide\",s),s&&t(this).css({position:\"relative\",display:\"none\"}),n=i>n?i:n,s++;}),s===this.$slides.length&&(this.$wrapper.css({height:n}),e(n));}},{key:\"_setSlideHeight\",value:function value(e){this.$slides.each(function(){t(this).css(\"max-height\",e);});}},{key:\"_events\",value:function value(){var e=this;if(this.$slides.length>1){if(this.options.swipe&&this.$slides.off(\"swipeleft.zf.orbit swiperight.zf.orbit\").on(\"swipeleft.zf.orbit\",function(t){t.preventDefault(),e.changeSlide(!0);}).on(\"swiperight.zf.orbit\",function(t){t.preventDefault(),e.changeSlide(!1);}),this.options.autoPlay&&(this.$slides.on(\"click.zf.orbit\",function(){e.$element.data(\"clickedOn\",!e.$element.data(\"clickedOn\")),e.timer[e.$element.data(\"clickedOn\")?\"pause\":\"start\"]();}),this.options.pauseOnHover&&this.$element.on(\"mouseenter.zf.orbit\",function(){e.timer.pause();}).on(\"mouseleave.zf.orbit\",function(){e.$element.data(\"clickedOn\")||e.timer.start();})),this.options.navButtons){var i=this.$element.find(\".\"+this.options.nextClass+\", .\"+this.options.prevClass);i.attr(\"tabindex\",0).on(\"click.zf.orbit touchend.zf.orbit\",function(i){i.preventDefault(),e.changeSlide(t(this).hasClass(e.options.nextClass));});}this.options.bullets&&this.$bullets.on(\"click.zf.orbit touchend.zf.orbit\",function(){if(/is-active/g.test(this.className))return!1;var i=t(this).data(\"slide\"),n=i>e.$slides.filter(\".is-active\").data(\"slide\"),s=e.$slides.eq(i);e.changeSlide(n,s,i);}),this.$wrapper.add(this.$bullets).on(\"keydown.zf.orbit\",function(i){Foundation.Keyboard.handleKey(i,\"Orbit\",{next:function next(){e.changeSlide(!0);},previous:function previous(){e.changeSlide(!1);},handled:function handled(){t(i.target).is(e.$bullets)&&e.$bullets.filter(\".is-active\").focus();}});});}}},{key:\"changeSlide\",value:function value(t,e,i){var n=this.$slides.filter(\".is-active\").eq(0);if(/mui/g.test(n[0].className))return!1;var s,o=this.$slides.first(),a=this.$slides.last(),r=t?\"Right\":\"Left\",l=t?\"Left\":\"Right\",u=this;s=e?e:t?this.options.infiniteWrap?n.next(\".\"+this.options.slideClass).length?n.next(\".\"+this.options.slideClass):o:n.next(\".\"+this.options.slideClass):this.options.infiniteWrap?n.prev(\".\"+this.options.slideClass).length?n.prev(\".\"+this.options.slideClass):a:n.prev(\".\"+this.options.slideClass),s.length&&(this.options.bullets&&(i=i||this.$slides.index(s),this._updateBullets(i)),this.options.useMUI?(Foundation.Motion.animateIn(s.addClass(\"is-active\").css({position:\"absolute\",top:0}),this.options[\"animInFrom\"+r],function(){s.css({position:\"relative\",display:\"block\"}).attr(\"aria-live\",\"polite\");}),Foundation.Motion.animateOut(n.removeClass(\"is-active\"),this.options[\"animOutTo\"+l],function(){n.removeAttr(\"aria-live\"),u.options.autoPlay&&!u.timer.isPaused&&u.timer.restart();})):(n.removeClass(\"is-active is-in\").removeAttr(\"aria-live\").hide(),s.addClass(\"is-active is-in\").attr(\"aria-live\",\"polite\").show(),this.options.autoPlay&&!this.timer.isPaused&&this.timer.restart()),this.$element.trigger(\"slidechange.zf.orbit\",[s]));}},{key:\"_updateBullets\",value:function value(t){var e=this.$element.find(\".\"+this.options.boxOfBullets).find(\".is-active\").removeClass(\"is-active\").blur(),i=e.find(\"span:last\").detach();this.$bullets.eq(t).addClass(\"is-active\").append(i);}},{key:\"destroy\",value:function value(){this.$element.off(\".zf.orbit\").find(\"*\").off(\".zf.orbit\").end().hide(),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={bullets:!0,navButtons:!0,animInFromRight:\"slide-in-right\",animOutToRight:\"slide-out-right\",animInFromLeft:\"slide-in-left\",animOutToLeft:\"slide-out-left\",autoPlay:!0,timerDelay:5e3,infiniteWrap:!0,swipe:!0,pauseOnHover:!0,accessible:!0,containerClass:\"orbit-container\",slideClass:\"orbit-slide\",boxOfBullets:\"orbit-bullets\",nextClass:\"orbit-next\",prevClass:\"orbit-previous\",useMUI:!0},Foundation.plugin(e,\"Orbit\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=t(i),this.rules=this.$element.data(\"responsive-menu\"),this.currentMq=null,this.currentPlugin=null,this._init(),this._events(),Foundation.registerPlugin(this,\"ResponsiveMenu\");}return _createClass(e,[{key:\"_init\",value:function value(){if(\"string\"==typeof this.rules){for(var e={},n=this.rules.split(\" \"),s=0;s<n.length;s++){var o=n[s].split(\"-\"),a=o.length>1?o[0]:\"small\",r=o.length>1?o[1]:o[0];null!==i[r]&&(e[a]=i[r]);}this.rules=e;}t.isEmptyObject(this.rules)||this._checkMediaQueries();}},{key:\"_events\",value:function value(){var e=this;t(window).on(\"changed.zf.mediaquery\",function(){e._checkMediaQueries();});}},{key:\"_checkMediaQueries\",value:function value(){var e,n=this;t.each(this.rules,function(t){Foundation.MediaQuery.atLeast(t)&&(e=t);}),e&&(this.currentPlugin instanceof this.rules[e].plugin||(t.each(i,function(t,e){n.$element.removeClass(e.cssClass);}),this.$element.addClass(this.rules[e].cssClass),this.currentPlugin&&this.currentPlugin.destroy(),this.currentPlugin=new this.rules[e].plugin(this.$element,{})));}},{key:\"destroy\",value:function value(){this.currentPlugin.destroy(),t(window).off(\".zf.ResponsiveMenu\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={};var i={dropdown:{cssClass:\"dropdown\",plugin:Foundation._plugins[\"dropdown-menu\"]||null},drilldown:{cssClass:\"drilldown\",plugin:Foundation._plugins.drilldown||null},accordion:{cssClass:\"accordion-menu\",plugin:Foundation._plugins[\"accordion-menu\"]||null}};Foundation.plugin(e,\"ResponsiveMenu\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=t(i),this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),this._events(),Foundation.registerPlugin(this,\"ResponsiveToggle\");}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element.data(\"responsive-toggle\");e||console.error(\"Your tab bar needs an ID of a Menu as the value of data-tab-bar.\"),this.$targetMenu=t(\"#\"+e),this.$toggler=this.$element.find(\"[data-toggle]\"),this._update();}},{key:\"_events\",value:function value(){this._updateMqHandler=this._update.bind(this),t(window).on(\"changed.zf.mediaquery\",this._updateMqHandler),this.$toggler.on(\"click.zf.responsiveToggle\",this.toggleMenu.bind(this));}},{key:\"_update\",value:function value(){Foundation.MediaQuery.atLeast(this.options.hideFor)?(this.$element.hide(),this.$targetMenu.show()):(this.$element.show(),this.$targetMenu.hide());}},{key:\"toggleMenu\",value:function value(){Foundation.MediaQuery.atLeast(this.options.hideFor)||(this.$targetMenu.toggle(0),this.$element.trigger(\"toggled.zf.responsiveToggle\"));}},{key:\"destroy\",value:function value(){this.$element.off(\".zf.responsiveToggle\"),this.$toggler.off(\".zf.responsiveToggle\"),t(window).off(\"changed.zf.mediaquery\",this._updateMqHandler),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={hideFor:\"medium\"},Foundation.plugin(e,\"ResponsiveToggle\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){function e(){return /iP(ad|hone|od).*OS/.test(window.navigator.userAgent);}function i(){return /Android/.test(window.navigator.userAgent);}function n(){return e()||i();}var s=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Reveal\"),Foundation.Keyboard.register(\"Reveal\",{ENTER:\"open\",SPACE:\"open\",ESCAPE:\"close\",TAB:\"tab_forward\",SHIFT_TAB:\"tab_backward\"});}return _createClass(e,[{key:\"_init\",value:function value(){this.id=this.$element.attr(\"id\"),this.isActive=!1,this.cached={mq:Foundation.MediaQuery.current},this.isMobile=n(),this.$anchor=t(t('[data-open=\"'+this.id+'\"]').length?'[data-open=\"'+this.id+'\"]':'[data-toggle=\"'+this.id+'\"]'),this.$anchor.attr({\"aria-controls\":this.id,\"aria-haspopup\":!0,tabindex:0}),(this.options.fullScreen||this.$element.hasClass(\"full\"))&&(this.options.fullScreen=!0,this.options.overlay=!1),this.options.overlay&&!this.$overlay&&(this.$overlay=this._makeOverlay(this.id)),this.$element.attr({role:\"dialog\",\"aria-hidden\":!0,\"data-yeti-box\":this.id,\"data-resize\":this.id}),this.$overlay?this.$element.detach().appendTo(this.$overlay):(this.$element.detach().appendTo(t(\"body\")),this.$element.addClass(\"without-overlay\")),this._events(),this.options.deepLink&&window.location.hash===\"#\"+this.id&&t(window).one(\"load.zf.reveal\",this.open.bind(this));}},{key:\"_makeOverlay\",value:function value(e){var i=t(\"<div></div>\").addClass(\"reveal-overlay\").appendTo(\"body\");return i;}},{key:\"_updatePosition\",value:function value(){var e,i,n=this.$element.outerWidth(),s=t(window).width(),o=this.$element.outerHeight(),a=t(window).height();e=\"auto\"===this.options.hOffset?parseInt((s-n)/2,10):parseInt(this.options.hOffset,10),i=\"auto\"===this.options.vOffset?o>a?parseInt(Math.min(100,a/10),10):parseInt((a-o)/4,10):parseInt(this.options.vOffset,10),this.$element.css({top:i+\"px\"}),this.$overlay&&\"auto\"===this.options.hOffset||(this.$element.css({left:e+\"px\"}),this.$element.css({margin:\"0px\"}));}},{key:\"_events\",value:function value(){var e=this,i=this;this.$element.on({\"open.zf.trigger\":this.open.bind(this),\"close.zf.trigger\":function closeZfTrigger(n,s){return n.target===i.$element[0]||t(n.target).parents(\"[data-closable]\")[0]===s?e.close.apply(e):void 0;},\"toggle.zf.trigger\":this.toggle.bind(this),\"resizeme.zf.trigger\":function resizemeZfTrigger(){i._updatePosition();}}),this.$anchor.length&&this.$anchor.on(\"keydown.zf.reveal\",function(t){13!==t.which&&32!==t.which||(t.stopPropagation(),t.preventDefault(),i.open());}),this.options.closeOnClick&&this.options.overlay&&this.$overlay.off(\".zf.reveal\").on(\"click.zf.reveal\",function(e){e.target===i.$element[0]||t.contains(i.$element[0],e.target)||i.close();}),this.options.deepLink&&t(window).on(\"popstate.zf.reveal:\"+this.id,this._handleState.bind(this));}},{key:\"_handleState\",value:function value(t){window.location.hash!==\"#\"+this.id||this.isActive?this.close():this.open();}},{key:\"open\",value:function value(){var e=this;if(this.options.deepLink){var i=\"#\"+this.id;window.history.pushState?window.history.pushState(null,null,i):window.location.hash=i;}if(this.isActive=!0,this.$element.css({visibility:\"hidden\"}).show().scrollTop(0),this.options.overlay&&this.$overlay.css({visibility:\"hidden\"}).show(),this._updatePosition(),this.$element.hide().css({visibility:\"\"}),this.$overlay&&(this.$overlay.css({visibility:\"\"}).hide(),this.$element.hasClass(\"fast\")?this.$overlay.addClass(\"fast\"):this.$element.hasClass(\"slow\")&&this.$overlay.addClass(\"slow\")),this.options.multipleOpened||this.$element.trigger(\"closeme.zf.reveal\",this.id),this.options.animationIn){var n;!function(){var t=function t(){n.$element.attr({\"aria-hidden\":!1,tabindex:-1}).focus(),console.log(\"focus\");};n=e,e.options.overlay&&Foundation.Motion.animateIn(e.$overlay,\"fade-in\"),Foundation.Motion.animateIn(e.$element,e.options.animationIn,function(){e.focusableElements=Foundation.Keyboard.findFocusable(e.$element),t();});}();}else this.options.overlay&&this.$overlay.show(0),this.$element.show(this.options.showDelay);this.$element.attr({\"aria-hidden\":!1,tabindex:-1}).focus(),this.$element.trigger(\"open.zf.reveal\"),this.isMobile?(this.originalScrollPos=window.pageYOffset,t(\"html, body\").addClass(\"is-reveal-open\")):t(\"body\").addClass(\"is-reveal-open\"),setTimeout(function(){e._extraHandlers();},0);}},{key:\"_extraHandlers\",value:function value(){var e=this;this.focusableElements=Foundation.Keyboard.findFocusable(this.$element),this.options.overlay||!this.options.closeOnClick||this.options.fullScreen||t(\"body\").on(\"click.zf.reveal\",function(i){i.target===e.$element[0]||t.contains(e.$element[0],i.target)||e.close();}),this.options.closeOnEsc&&t(window).on(\"keydown.zf.reveal\",function(t){Foundation.Keyboard.handleKey(t,\"Reveal\",{close:function close(){e.options.closeOnEsc&&(e.close(),e.$anchor.focus());}});}),this.$element.on(\"keydown.zf.reveal\",function(i){var n=t(this);Foundation.Keyboard.handleKey(i,\"Reveal\",{tab_forward:function tab_forward(){return e.$element.find(\":focus\").is(e.focusableElements.eq(-1))?(e.focusableElements.eq(0).focus(),!0):0===e.focusableElements.length?!0:void 0;},tab_backward:function tab_backward(){return e.$element.find(\":focus\").is(e.focusableElements.eq(0))||e.$element.is(\":focus\")?(e.focusableElements.eq(-1).focus(),!0):0===e.focusableElements.length?!0:void 0;},open:function open(){e.$element.find(\":focus\").is(e.$element.find(\"[data-close]\"))?setTimeout(function(){e.$anchor.focus();},1):n.is(e.focusableElements)&&e.open();},close:function close(){e.options.closeOnEsc&&(e.close(),e.$anchor.focus());},handled:function handled(t){t&&i.preventDefault();}});});}},{key:\"close\",value:function value(){function e(){i.isMobile?(t(\"html, body\").removeClass(\"is-reveal-open\"),i.originalScrollPos&&(t(\"body\").scrollTop(i.originalScrollPos),i.originalScrollPos=null)):t(\"body\").removeClass(\"is-reveal-open\"),i.$element.attr(\"aria-hidden\",!0),i.$element.trigger(\"closed.zf.reveal\");}if(!this.isActive||!this.$element.is(\":visible\"))return!1;var i=this;this.options.animationOut?(this.options.overlay?Foundation.Motion.animateOut(this.$overlay,\"fade-out\",e):e(),Foundation.Motion.animateOut(this.$element,this.options.animationOut)):(this.options.overlay?this.$overlay.hide(0,e):e(),this.$element.hide(this.options.hideDelay)),this.options.closeOnEsc&&t(window).off(\"keydown.zf.reveal\"),!this.options.overlay&&this.options.closeOnClick&&t(\"body\").off(\"click.zf.reveal\"),this.$element.off(\"keydown.zf.reveal\"),this.options.resetOnClose&&this.$element.html(this.$element.html()),this.isActive=!1,i.options.deepLink&&(window.history.replaceState?window.history.replaceState(\"\",document.title,window.location.pathname):window.location.hash=\"\");}},{key:\"toggle\",value:function value(){this.isActive?this.close():this.open();}},{key:\"destroy\",value:function value(){this.options.overlay&&(this.$element.appendTo(t(\"body\")),this.$overlay.hide().off().remove()),this.$element.hide().off(),this.$anchor.off(\".zf\"),t(window).off(\".zf.reveal:\"+this.id),Foundation.unregisterPlugin(this);}}]),e;}();s.defaults={animationIn:\"\",animationOut:\"\",showDelay:0,hideDelay:0,closeOnClick:!0,closeOnEsc:!0,multipleOpened:!1,vOffset:\"auto\",hOffset:\"auto\",fullScreen:!1,btmOffsetPct:10,overlay:!0,resetOnClose:!1,deepLink:!1},Foundation.plugin(s,\"Reveal\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){function e(t,e){return t/e;}function i(t,e,i,n){return Math.abs(t.position()[e]+t[n]()/2-i);}var n=function(){function n(e,i){_classCallCheck(this,n),this.$element=e,this.options=t.extend({},n.defaults,this.$element.data(),i),this._init(),Foundation.registerPlugin(this,\"Slider\"),Foundation.Keyboard.register(\"Slider\",{ltr:{ARROW_RIGHT:\"increase\",ARROW_UP:\"increase\",ARROW_DOWN:\"decrease\",ARROW_LEFT:\"decrease\",SHIFT_ARROW_RIGHT:\"increase_fast\",SHIFT_ARROW_UP:\"increase_fast\",SHIFT_ARROW_DOWN:\"decrease_fast\",SHIFT_ARROW_LEFT:\"decrease_fast\"},rtl:{ARROW_LEFT:\"increase\",ARROW_RIGHT:\"decrease\",SHIFT_ARROW_LEFT:\"increase_fast\",SHIFT_ARROW_RIGHT:\"decrease_fast\"}});}return _createClass(n,[{key:\"_init\",value:function value(){this.inputs=this.$element.find(\"input\"),this.handles=this.$element.find(\"[data-slider-handle]\"),this.$handle=this.handles.eq(0),this.$input=this.inputs.length?this.inputs.eq(0):t(\"#\"+this.$handle.attr(\"aria-controls\")),this.$fill=this.$element.find(\"[data-slider-fill]\").css(this.options.vertical?\"height\":\"width\",0);var e=!1,i=this;(this.options.disabled||this.$element.hasClass(this.options.disabledClass))&&(this.options.disabled=!0,this.$element.addClass(this.options.disabledClass)),this.inputs.length||(this.inputs=t().add(this.$input),this.options.binding=!0),this._setInitAttr(0),this._events(this.$handle),this.handles[1]&&(this.options.doubleSided=!0,this.$handle2=this.handles.eq(1),this.$input2=this.inputs.length>1?this.inputs.eq(1):t(\"#\"+this.$handle2.attr(\"aria-controls\")),this.inputs[1]||(this.inputs=this.inputs.add(this.$input2)),e=!0,this._setHandlePos(this.$handle,this.options.initialStart,!0,function(){i._setHandlePos(i.$handle2,i.options.initialEnd,!0);}),this._setInitAttr(1),this._events(this.$handle2)),e||this._setHandlePos(this.$handle,this.options.initialStart,!0);}},{key:\"_setHandlePos\",value:function value(t,i,n,s){if(!this.$element.hasClass(this.options.disabledClass)){i=parseFloat(i),i<this.options.start?i=this.options.start:i>this.options.end&&(i=this.options.end);var o=this.options.doubleSided;if(o)if(0===this.handles.index(t)){var a=parseFloat(this.$handle2.attr(\"aria-valuenow\"));i=i>=a?a-this.options.step:i;}else{var r=parseFloat(this.$handle.attr(\"aria-valuenow\"));i=r>=i?r+this.options.step:i;}this.options.vertical&&!n&&(i=this.options.end-i);var l=this,u=this.options.vertical,d=u?\"height\":\"width\",h=u?\"top\":\"left\",c=t[0].getBoundingClientRect()[d],f=this.$element[0].getBoundingClientRect()[d],p=e(i-this.options.start,this.options.end-this.options.start).toFixed(2),m=(f-c)*p,v=(100*e(m,f)).toFixed(this.options.decimal);i=parseFloat(i.toFixed(this.options.decimal));var g={};if(this._setValues(t,i),o){var w,y=0===this.handles.index(t),b=~~(100*e(c,f));if(y)g[h]=v+\"%\",w=parseFloat(this.$handle2[0].style[h])-v+b,s&&\"function\"==typeof s&&s();else{var $=parseFloat(this.$handle[0].style[h]);w=v-(isNaN($)?this.options.initialStart/((this.options.end-this.options.start)/100):$)+b;}g[\"min-\"+d]=w+\"%\";}this.$element.one(\"finished.zf.animate\",function(){l.$element.trigger(\"moved.zf.slider\",[t]);});var C=this.$element.data(\"dragging\")?1e3/60:this.options.moveTime;Foundation.Move(C,t,function(){t.css(h,v+\"%\"),l.options.doubleSided?l.$fill.css(g):l.$fill.css(d,100*p+\"%\");}),clearTimeout(l.timeout),l.timeout=setTimeout(function(){l.$element.trigger(\"changed.zf.slider\",[t]);},l.options.changedDelay);}}},{key:\"_setInitAttr\",value:function value(t){var e=this.inputs.eq(t).attr(\"id\")||Foundation.GetYoDigits(6,\"slider\");this.inputs.eq(t).attr({id:e,max:this.options.end,min:this.options.start,step:this.options.step}),this.handles.eq(t).attr({role:\"slider\",\"aria-controls\":e,\"aria-valuemax\":this.options.end,\"aria-valuemin\":this.options.start,\"aria-valuenow\":0===t?this.options.initialStart:this.options.initialEnd,\"aria-orientation\":this.options.vertical?\"vertical\":\"horizontal\",tabindex:0});}},{key:\"_setValues\",value:function value(t,e){var i=this.options.doubleSided?this.handles.index(t):0;this.inputs.eq(i).val(e),t.attr(\"aria-valuenow\",e);}},{key:\"_handleEvent\",value:function value(n,s,o){var a,r;if(o)a=this._adjustValue(null,o),r=!0;else{n.preventDefault();var l=this,u=this.options.vertical,d=u?\"height\":\"width\",h=u?\"top\":\"left\",c=u?n.pageY:n.pageX,f=(this.$handle[0].getBoundingClientRect()[d]/2,this.$element[0].getBoundingClientRect()[d]),p=u?t(window).scrollTop():t(window).scrollLeft(),m=this.$element.offset()[h];n.clientY===n.pageY&&(c+=p);var v,g=c-m;if(v=0>g?0:g>f?f:g,offsetPct=e(v,f),a=(this.options.end-this.options.start)*offsetPct+this.options.start,Foundation.rtl()&&!this.options.vertical&&(a=this.options.end-a),a=l._adjustValue(null,a),r=!1,!s){var w=i(this.$handle,h,v,d),y=i(this.$handle2,h,v,d);s=y>=w?this.$handle:this.$handle2;}}this._setHandlePos(s,a,r);}},{key:\"_adjustValue\",value:function value(t,e){var i,n,s,o,a=this.options.step,r=parseFloat(a/2);return i=t?parseFloat(t.attr(\"aria-valuenow\")):e,n=i%a,s=i-n,o=s+a,0===n?i:i=i>=s+r?o:s;}},{key:\"_events\",value:function value(e){var i,n=this;if(this.inputs.off(\"change.zf.slider\").on(\"change.zf.slider\",function(e){var i=n.inputs.index(t(this));n._handleEvent(e,n.handles.eq(i),t(this).val());}),this.options.clickSelect&&this.$element.off(\"click.zf.slider\").on(\"click.zf.slider\",function(e){return n.$element.data(\"dragging\")?!1:void(t(e.target).is(\"[data-slider-handle]\")||(n.options.doubleSided?n._handleEvent(e):n._handleEvent(e,n.$handle)));}),this.options.draggable){this.handles.addTouch();var s=t(\"body\");e.off(\"mousedown.zf.slider\").on(\"mousedown.zf.slider\",function(o){e.addClass(\"is-dragging\"),n.$fill.addClass(\"is-dragging\"),n.$element.data(\"dragging\",!0),i=t(o.currentTarget),s.on(\"mousemove.zf.slider\",function(t){t.preventDefault(),n._handleEvent(t,i);}).on(\"mouseup.zf.slider\",function(t){n._handleEvent(t,i),e.removeClass(\"is-dragging\"),n.$fill.removeClass(\"is-dragging\"),n.$element.data(\"dragging\",!1),s.off(\"mousemove.zf.slider mouseup.zf.slider\");});}).on(\"selectstart.zf.slider touchmove.zf.slider\",function(t){t.preventDefault();});}e.off(\"keydown.zf.slider\").on(\"keydown.zf.slider\",function(e){var i,s=t(this),o=n.options.doubleSided?n.handles.index(s):0,a=parseFloat(n.inputs.eq(o).val());Foundation.Keyboard.handleKey(e,\"Slider\",{decrease:function decrease(){i=a-n.options.step;},increase:function increase(){i=a+n.options.step;},decrease_fast:function decrease_fast(){i=a-10*n.options.step;},increase_fast:function increase_fast(){i=a+10*n.options.step;},handled:function handled(){e.preventDefault(),n._setHandlePos(s,i,!0);}});});}},{key:\"destroy\",value:function value(){this.handles.off(\".zf.slider\"),this.inputs.off(\".zf.slider\"),this.$element.off(\".zf.slider\"),Foundation.unregisterPlugin(this);}}]),n;}();n.defaults={start:0,end:100,step:1,initialStart:0,initialEnd:100,binding:!1,clickSelect:!0,vertical:!1,draggable:!0,disabled:!1,doubleSided:!1,decimal:2,moveTime:200,disabledClass:\"disabled\",invertVertical:!1,changedDelay:500},Foundation.plugin(n,\"Slider\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){function e(t){return parseInt(window.getComputedStyle(document.body,null).fontSize,10)*t;}var i=function(){function i(e,n){_classCallCheck(this,i),this.$element=e,this.options=t.extend({},i.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Sticky\");}return _createClass(i,[{key:\"_init\",value:function value(){var e=this.$element.parent(\"[data-sticky-container]\"),i=this.$element[0].id||Foundation.GetYoDigits(6,\"sticky\"),n=this;e.length||(this.wasWrapped=!0),this.$container=e.length?e:t(this.options.container).wrapInner(this.$element),this.$container.addClass(this.options.containerClass),this.$element.addClass(this.options.stickyClass).attr({\"data-resize\":i}),this.scrollCount=this.options.checkEvery,this.isStuck=!1,t(window).one(\"load.zf.sticky\",function(){\"\"!==n.options.anchor?n.$anchor=t(\"#\"+n.options.anchor):n._parsePoints(),n._setSizes(function(){n._calc(!1);}),n._events(i.split(\"-\").reverse().join(\"-\"));});}},{key:\"_parsePoints\",value:function value(){for(var e=\"\"==this.options.topAnchor?1:this.options.topAnchor,i=\"\"==this.options.btmAnchor?document.documentElement.scrollHeight:this.options.btmAnchor,n=[e,i],s={},o=0,a=n.length;a>o&&n[o];o++){var r;if(\"number\"==typeof n[o])r=n[o];else{var l=n[o].split(\":\"),u=t(\"#\"+l[0]);r=u.offset().top,l[1]&&\"bottom\"===l[1].toLowerCase()&&(r+=u[0].getBoundingClientRect().height);}s[o]=r;}this.points=s;}},{key:\"_events\",value:function value(e){var i=this,n=this.scrollListener=\"scroll.zf.\"+e;this.isOn||(this.canStick&&(this.isOn=!0,t(window).off(n).on(n,function(t){0===i.scrollCount?(i.scrollCount=i.options.checkEvery,i._setSizes(function(){i._calc(!1,window.pageYOffset);})):(i.scrollCount--,i._calc(!1,window.pageYOffset));})),this.$element.off(\"resizeme.zf.trigger\").on(\"resizeme.zf.trigger\",function(t,s){i._setSizes(function(){i._calc(!1),i.canStick?i.isOn||i._events(e):i.isOn&&i._pauseListeners(n);});}));}},{key:\"_pauseListeners\",value:function value(e){this.isOn=!1,t(window).off(e),this.$element.trigger(\"pause.zf.sticky\");}},{key:\"_calc\",value:function value(t,e){return t&&this._setSizes(),this.canStick?(e||(e=window.pageYOffset),void(e>=this.topPoint?e<=this.bottomPoint?this.isStuck||this._setSticky():this.isStuck&&this._removeSticky(!1):this.isStuck&&this._removeSticky(!0))):(this.isStuck&&this._removeSticky(!0),!1);}},{key:\"_setSticky\",value:function value(){var t=this,e=this.options.stickTo,i=\"top\"===e?\"marginTop\":\"marginBottom\",n=\"top\"===e?\"bottom\":\"top\",s={};s[i]=this.options[i]+\"em\",s[e]=0,s[n]=\"auto\",s.left=this.$container.offset().left+parseInt(window.getComputedStyle(this.$container[0])[\"padding-left\"],10),this.isStuck=!0,this.$element.removeClass(\"is-anchored is-at-\"+n).addClass(\"is-stuck is-at-\"+e).css(s).trigger(\"sticky.zf.stuckto:\"+e),this.$element.on(\"transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd\",function(){t._setSizes();});}},{key:\"_removeSticky\",value:function value(t){var e=this.options.stickTo,i=\"top\"===e,n={},s=(this.points?this.points[1]-this.points[0]:this.anchorHeight)-this.elemHeight,o=i?\"marginTop\":\"marginBottom\",a=t?\"top\":\"bottom\";n[o]=0,n.bottom=\"auto\",t?n.top=0:n.top=s,n.left=\"\",this.isStuck=!1,this.$element.removeClass(\"is-stuck is-at-\"+e).addClass(\"is-anchored is-at-\"+a).css(n).trigger(\"sticky.zf.unstuckfrom:\"+a);}},{key:\"_setSizes\",value:function value(t){this.canStick=Foundation.MediaQuery.atLeast(this.options.stickyOn),this.canStick||t();var e=this.$container[0].getBoundingClientRect().width,i=window.getComputedStyle(this.$container[0]),n=parseInt(i[\"padding-right\"],10);this.$anchor&&this.$anchor.length?this.anchorHeight=this.$anchor[0].getBoundingClientRect().height:this._parsePoints(),this.$element.css({\"max-width\":e-n+\"px\"});var s=this.$element[0].getBoundingClientRect().height||this.containerHeight;\"none\"==this.$element.css(\"display\")&&(s=0),this.containerHeight=s,this.$container.css({height:s}),this.elemHeight=s,this.isStuck&&this.$element.css({left:this.$container.offset().left+parseInt(i[\"padding-left\"],10)}),this._setBreakPoints(s,function(){t&&t();});}},{key:\"_setBreakPoints\",value:function value(t,i){if(!this.canStick){if(!i)return!1;i();}var n=e(this.options.marginTop),s=e(this.options.marginBottom),o=this.points?this.points[0]:this.$anchor.offset().top,a=this.points?this.points[1]:o+this.anchorHeight,r=window.innerHeight;\"top\"===this.options.stickTo?(o-=n,a-=t+n):\"bottom\"===this.options.stickTo&&(o-=r-(t+s),a-=r-s),this.topPoint=o,this.bottomPoint=a,i&&i();}},{key:\"destroy\",value:function value(){this._removeSticky(!0),this.$element.removeClass(this.options.stickyClass+\" is-anchored is-at-top\").css({height:\"\",top:\"\",bottom:\"\",\"max-width\":\"\"}).off(\"resizeme.zf.trigger\"),this.$anchor&&this.$anchor.length&&this.$anchor.off(\"change.zf.sticky\"),t(window).off(this.scrollListener),this.wasWrapped?this.$element.unwrap():this.$container.removeClass(this.options.containerClass).css({height:\"\"}),Foundation.unregisterPlugin(this);}}]),i;}();i.defaults={container:\"<div data-sticky-container></div>\",stickTo:\"top\",anchor:\"\",topAnchor:\"\",btmAnchor:\"\",marginTop:1,marginBottom:1,stickyOn:\"medium\",stickyClass:\"sticky\",containerClass:\"sticky-container\",checkEvery:-1},Foundation.plugin(i,\"Sticky\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this._init(),Foundation.registerPlugin(this,\"Tabs\"),Foundation.Keyboard.register(\"Tabs\",{ENTER:\"open\",SPACE:\"open\",ARROW_RIGHT:\"next\",ARROW_UP:\"previous\",ARROW_DOWN:\"next\",ARROW_LEFT:\"previous\"});}return _createClass(e,[{key:\"_init\",value:function value(){var e=this;if(this.$tabTitles=this.$element.find(\".\"+this.options.linkClass),this.$tabContent=t('[data-tabs-content=\"'+this.$element[0].id+'\"]'),this.$tabTitles.each(function(){var i=t(this),n=i.find(\"a\"),s=i.hasClass(\"is-active\"),o=n[0].hash.slice(1),a=n[0].id?n[0].id:o+\"-label\",r=t(\"#\"+o);i.attr({role:\"presentation\"}),n.attr({role:\"tab\",\"aria-controls\":o,\"aria-selected\":s,id:a}),r.attr({role:\"tabpanel\",\"aria-hidden\":!s,\"aria-labelledby\":a}),s&&e.options.autoFocus&&n.focus();}),this.options.matchHeight){var i=this.$tabContent.find(\"img\");i.length?Foundation.onImagesLoaded(i,this._setHeight.bind(this)):this._setHeight();}this._events();}},{key:\"_events\",value:function value(){this._addKeyHandler(),this._addClickHandler(),this._setHeightMqHandler=null,this.options.matchHeight&&(this._setHeightMqHandler=this._setHeight.bind(this),t(window).on(\"changed.zf.mediaquery\",this._setHeightMqHandler));}},{key:\"_addClickHandler\",value:function value(){var e=this;this.$element.off(\"click.zf.tabs\").on(\"click.zf.tabs\",\".\"+this.options.linkClass,function(i){i.preventDefault(),i.stopPropagation(),t(this).hasClass(\"is-active\")||e._handleTabChange(t(this));});}},{key:\"_addKeyHandler\",value:function value(){var e=this;e.$element.find(\"li:first-of-type\"),e.$element.find(\"li:last-of-type\");this.$tabTitles.off(\"keydown.zf.tabs\").on(\"keydown.zf.tabs\",function(i){if(9!==i.which){var n,s,o=t(this),a=o.parent(\"ul\").children(\"li\");a.each(function(i){return t(this).is(o)?void(e.options.wrapOnKeys?(n=0===i?a.last():a.eq(i-1),s=i===a.length-1?a.first():a.eq(i+1)):(n=a.eq(Math.max(0,i-1)),s=a.eq(Math.min(i+1,a.length-1)))):void 0;}),Foundation.Keyboard.handleKey(i,\"Tabs\",{open:function open(){o.find('[role=\"tab\"]').focus(),e._handleTabChange(o);},previous:function previous(){n.find('[role=\"tab\"]').focus(),e._handleTabChange(n);},next:function next(){s.find('[role=\"tab\"]').focus(),e._handleTabChange(s);},handled:function handled(){i.stopPropagation(),i.preventDefault();}});}});}},{key:\"_handleTabChange\",value:function value(e){var i=e.find('[role=\"tab\"]'),n=i[0].hash,s=this.$tabContent.find(n),o=this.$element.find(\".\"+this.options.linkClass+\".is-active\").removeClass(\"is-active\").find('[role=\"tab\"]').attr({\"aria-selected\":\"false\"});t(\"#\"+o.attr(\"aria-controls\")).removeClass(\"is-active\").attr({\"aria-hidden\":\"true\"}),e.addClass(\"is-active\"),i.attr({\"aria-selected\":\"true\"}),s.addClass(\"is-active\").attr({\"aria-hidden\":\"false\"}),this.$element.trigger(\"change.zf.tabs\",[e]);}},{key:\"selectTab\",value:function value(t){var e;e=\"object\"==(typeof t===\"undefined\"?\"undefined\":_typeof(t))?t[0].id:t,e.indexOf(\"#\")<0&&(e=\"#\"+e);var i=this.$tabTitles.find('[href=\"'+e+'\"]').parent(\".\"+this.options.linkClass);this._handleTabChange(i);}},{key:\"_setHeight\",value:function value(){var e=0;this.$tabContent.find(\".\"+this.options.panelClass).css(\"height\",\"\").each(function(){var i=t(this),n=i.hasClass(\"is-active\");n||i.css({visibility:\"hidden\",display:\"block\"});var s=this.getBoundingClientRect().height;n||i.css({visibility:\"\",display:\"\"}),e=s>e?s:e;}).css(\"height\",e+\"px\");}},{key:\"destroy\",value:function value(){this.$element.find(\".\"+this.options.linkClass).off(\".zf.tabs\").hide().end().find(\".\"+this.options.panelClass).hide(),this.options.matchHeight&&null!=this._setHeightMqHandler&&t(window).off(\"changed.zf.mediaquery\",this._setHeightMqHandler),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={autoFocus:!1,wrapOnKeys:!0,matchHeight:!1,linkClass:\"tabs-title\",panelClass:\"tabs-panel\"},Foundation.plugin(e,\"Tabs\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,i.data(),n),this.className=\"\",this._init(),this._events(),Foundation.registerPlugin(this,\"Toggler\");}return _createClass(e,[{key:\"_init\",value:function value(){var e;this.options.animate?(e=this.options.animate.split(\" \"),this.animationIn=e[0],this.animationOut=e[1]||null):(e=this.$element.data(\"toggler\"),this.className=\".\"===e[0]?e.slice(1):e);var i=this.$element[0].id;t('[data-open=\"'+i+'\"], [data-close=\"'+i+'\"], [data-toggle=\"'+i+'\"]').attr(\"aria-controls\",i),this.$element.attr(\"aria-expanded\",!this.$element.is(\":hidden\"));}},{key:\"_events\",value:function value(){this.$element.off(\"toggle.zf.trigger\").on(\"toggle.zf.trigger\",this.toggle.bind(this));}},{key:\"toggle\",value:function value(){this[this.options.animate?\"_toggleAnimate\":\"_toggleClass\"]();}},{key:\"_toggleClass\",value:function value(){this.$element.toggleClass(this.className);var t=this.$element.hasClass(this.className);t?this.$element.trigger(\"on.zf.toggler\"):this.$element.trigger(\"off.zf.toggler\"),this._updateARIA(t);}},{key:\"_toggleAnimate\",value:function value(){var t=this;this.$element.is(\":hidden\")?Foundation.Motion.animateIn(this.$element,this.animationIn,function(){t._updateARIA(!0),this.trigger(\"on.zf.toggler\");}):Foundation.Motion.animateOut(this.$element,this.animationOut,function(){t._updateARIA(!1),this.trigger(\"off.zf.toggler\");});}},{key:\"_updateARIA\",value:function value(t){this.$element.attr(\"aria-expanded\",!!t);}},{key:\"destroy\",value:function value(){this.$element.off(\".zf.toggler\"),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={animate:!1},Foundation.plugin(e,\"Toggler\");}(jQuery);var _createClass=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e;};}();!function(t){var e=function(){function e(i,n){_classCallCheck(this,e),this.$element=i,this.options=t.extend({},e.defaults,this.$element.data(),n),this.isActive=!1,this.isClick=!1,this._init(),Foundation.registerPlugin(this,\"Tooltip\");}return _createClass(e,[{key:\"_init\",value:function value(){var e=this.$element.attr(\"aria-describedby\")||Foundation.GetYoDigits(6,\"tooltip\");this.options.positionClass=this.options.positionClass||this._getPositionClass(this.$element),this.options.tipText=this.options.tipText||this.$element.attr(\"title\"),this.template=this.options.template?t(this.options.template):this._buildTemplate(e),this.template.appendTo(document.body).text(this.options.tipText).hide(),this.$element.attr({title:\"\",\"aria-describedby\":e,\"data-yeti-box\":e,\"data-toggle\":e,\"data-resize\":e}).addClass(this.triggerClass),this.usedPositions=[],this.counter=4,this.classChanged=!1,this._events();}},{key:\"_getPositionClass\",value:function value(t){if(!t)return\"\";var e=t[0].className.match(/\\b(top|left|right)\\b/g);return e=e?e[0]:\"\";}},{key:\"_buildTemplate\",value:function value(e){var i=(this.options.tooltipClass+\" \"+this.options.positionClass+\" \"+this.options.templateClasses).trim(),n=t(\"<div></div>\").addClass(i).attr({role:\"tooltip\",\"aria-hidden\":!0,\"data-is-active\":!1,\"data-is-focus\":!1,id:e});return n;}},{key:\"_reposition\",value:function value(t){this.usedPositions.push(t?t:\"bottom\"),!t&&this.usedPositions.indexOf(\"top\")<0?this.template.addClass(\"top\"):\"top\"===t&&this.usedPositions.indexOf(\"bottom\")<0?this.template.removeClass(t):\"left\"===t&&this.usedPositions.indexOf(\"right\")<0?this.template.removeClass(t).addClass(\"right\"):\"right\"===t&&this.usedPositions.indexOf(\"left\")<0?this.template.removeClass(t).addClass(\"left\"):!t&&this.usedPositions.indexOf(\"top\")>-1&&this.usedPositions.indexOf(\"left\")<0?this.template.addClass(\"left\"):\"top\"===t&&this.usedPositions.indexOf(\"bottom\")>-1&&this.usedPositions.indexOf(\"left\")<0?this.template.removeClass(t).addClass(\"left\"):\"left\"===t&&this.usedPositions.indexOf(\"right\")>-1&&this.usedPositions.indexOf(\"bottom\")<0?this.template.removeClass(t):\"right\"===t&&this.usedPositions.indexOf(\"left\")>-1&&this.usedPositions.indexOf(\"bottom\")<0?this.template.removeClass(t):this.template.removeClass(t),this.classChanged=!0,this.counter--;}},{key:\"_setPosition\",value:function value(){var t=this._getPositionClass(this.template),e=Foundation.Box.GetDimensions(this.template),i=Foundation.Box.GetDimensions(this.$element),n=\"left\"===t?\"left\":\"right\"===t?\"left\":\"top\",s=\"top\"===n?\"height\":\"width\";\"height\"===s?this.options.vOffset:this.options.hOffset;if(e.width>=e.windowDims.width||!this.counter&&!Foundation.Box.ImNotTouchingYou(this.template))return this.template.offset(Foundation.Box.GetOffsets(this.template,this.$element,\"center bottom\",this.options.vOffset,this.options.hOffset,!0)).css({width:i.windowDims.width-2*this.options.hOffset,height:\"auto\"}),!1;for(this.template.offset(Foundation.Box.GetOffsets(this.template,this.$element,\"center \"+(t||\"bottom\"),this.options.vOffset,this.options.hOffset));!Foundation.Box.ImNotTouchingYou(this.template)&&this.counter;){this._reposition(t),this._setPosition();}}},{key:\"show\",value:function value(){if(\"all\"!==this.options.showOn&&!Foundation.MediaQuery.atLeast(this.options.showOn))return!1;var t=this;this.template.css(\"visibility\",\"hidden\").show(),this._setPosition(),this.$element.trigger(\"closeme.zf.tooltip\",this.template.attr(\"id\")),this.template.attr({\"data-is-active\":!0,\"aria-hidden\":!1}),t.isActive=!0,this.template.stop().hide().css(\"visibility\",\"\").fadeIn(this.options.fadeInDuration,function(){}),this.$element.trigger(\"show.zf.tooltip\");}},{key:\"hide\",value:function value(){var t=this;this.template.stop().attr({\"aria-hidden\":!0,\"data-is-active\":!1}).fadeOut(this.options.fadeOutDuration,function(){t.isActive=!1,t.isClick=!1,t.classChanged&&(t.template.removeClass(t._getPositionClass(t.template)).addClass(t.options.positionClass),t.usedPositions=[],t.counter=4,t.classChanged=!1);}),this.$element.trigger(\"hide.zf.tooltip\");}},{key:\"_events\",value:function value(){var t=this,e=(this.template,!1);this.options.disableHover||this.$element.on(\"mouseenter.zf.tooltip\",function(e){t.isActive||(t.timeout=setTimeout(function(){t.show();},t.options.hoverDelay));}).on(\"mouseleave.zf.tooltip\",function(i){clearTimeout(t.timeout),(!e||t.isClick&&!t.options.clickOpen)&&t.hide();}),this.options.clickOpen?this.$element.on(\"mousedown.zf.tooltip\",function(e){e.stopImmediatePropagation(),t.isClick||(t.isClick=!0,!t.options.disableHover&&t.$element.attr(\"tabindex\")||t.isActive||t.show());}):this.$element.on(\"mousedown.zf.tooltip\",function(e){e.stopImmediatePropagation(),t.isClick=!0;}),this.options.disableForTouch||this.$element.on(\"tap.zf.tooltip touchend.zf.tooltip\",function(e){t.isActive?t.hide():t.show();}),this.$element.on({\"close.zf.trigger\":this.hide.bind(this)}),this.$element.on(\"focus.zf.tooltip\",function(i){return e=!0,t.isClick?(t.options.clickOpen||(e=!1),!1):void t.show();}).on(\"focusout.zf.tooltip\",function(i){e=!1,t.isClick=!1,t.hide();}).on(\"resizeme.zf.trigger\",function(){t.isActive&&t._setPosition();});}},{key:\"toggle\",value:function value(){this.isActive?this.hide():this.show();}},{key:\"destroy\",value:function value(){this.$element.attr(\"title\",this.template.text()).off(\".zf.trigger .zf.tootip\").removeAttr(\"aria-describedby\").removeAttr(\"data-yeti-box\").removeAttr(\"data-toggle\").removeAttr(\"data-resize\"),this.template.remove(),Foundation.unregisterPlugin(this);}}]),e;}();e.defaults={disableForTouch:!1,hoverDelay:200,fadeInDuration:150,fadeOutDuration:150,disableHover:!1,templateClasses:\"\",tooltipClass:\"tooltip\",triggerClass:\"has-tip\",showOn:\"small\",template:\"\",tipText:\"\",touchCloseText:\"Tap to close.\",clickOpen:!0,positionClass:\"\",vOffset:10,hOffset:12},Foundation.plugin(e,\"Tooltip\");}(jQuery);"

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';
	
	var React = __webpack_require__(8);
	var ReactDOM = __webpack_require__(165);
	
	var _require = __webpack_require__(166);
	
	var Route = _require.Route;
	var Router = _require.Router;
	var IndexRoute = _require.IndexRoute;
	var hashHistory = _require.hashHistory;
	
	
	var TodoApp = __webpack_require__(229);
	
	//load foundation
	$(document).foundation();
	
	// App css
	__webpack_require__(230);
	
	ReactDOM.render(React.createElement(TodoApp, null), document.getElementById("app"));
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = jQuery;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(9);

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule React
	 */
	
	'use strict';
	
	var ReactDOM = __webpack_require__(10);
	var ReactDOMServer = __webpack_require__(155);
	var ReactIsomorphic = __webpack_require__(159);
	
	var assign = __webpack_require__(46);
	var deprecated = __webpack_require__(164);
	
	// `version` will be added here by ReactIsomorphic.
	var React = {};
	
	assign(React, ReactIsomorphic);
	
	assign(React, {
	  // ReactDOM
	  findDOMNode: deprecated('findDOMNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.findDOMNode),
	  render: deprecated('render', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.render),
	  unmountComponentAtNode: deprecated('unmountComponentAtNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.unmountComponentAtNode),
	
	  // ReactDOMServer
	  renderToString: deprecated('renderToString', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToString),
	  renderToStaticMarkup: deprecated('renderToStaticMarkup', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToStaticMarkup)
	});
	
	React.__SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOM;
	React.__SECRET_DOM_SERVER_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOMServer;
	
	module.exports = React;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOM
	 */
	
	/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactDOMTextComponent = __webpack_require__(13);
	var ReactDefaultInjection = __webpack_require__(78);
	var ReactInstanceHandles = __webpack_require__(52);
	var ReactMount = __webpack_require__(35);
	var ReactPerf = __webpack_require__(25);
	var ReactReconciler = __webpack_require__(57);
	var ReactUpdates = __webpack_require__(61);
	var ReactVersion = __webpack_require__(153);
	
	var findDOMNode = __webpack_require__(98);
	var renderSubtreeIntoContainer = __webpack_require__(154);
	var warning = __webpack_require__(32);
	
	ReactDefaultInjection.inject();
	
	var render = ReactPerf.measure('React', 'render', ReactMount.render);
	
	var React = {
	  findDOMNode: findDOMNode,
	  render: render,
	  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
	  version: ReactVersion,
	
	  /* eslint-disable camelcase */
	  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
	  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
	};
	
	// Inject the runtime into a devtools global hook regardless of browser.
	// Allows for debugging when the hook is injected on the page.
	/* eslint-enable camelcase */
	if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
	    CurrentOwner: ReactCurrentOwner,
	    InstanceHandles: ReactInstanceHandles,
	    Mount: ReactMount,
	    Reconciler: ReactReconciler,
	    TextComponent: ReactDOMTextComponent
	  });
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var ExecutionEnvironment = __webpack_require__(16);
	  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
	
	    // First check if devtools is not installed
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
	      // If we're in Chrome or Firefox, provide a download link if not installed.
	      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
	        console.debug('Download the React DevTools for a better development experience: ' + 'https://fb.me/react-devtools');
	      }
	    }
	
	    // If we're in IE8, check to see if we are in compatibility mode and provide
	    // information on preventing compatibility mode
	    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;
	
	    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : undefined;
	
	    var expectedFeatures = [
	    // shims
	    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim,
	
	    // shams
	    Object.create, Object.freeze];
	
	    for (var i = 0; i < expectedFeatures.length; i++) {
	      if (!expectedFeatures[i]) {
	        console.error('One or more ES5 shim/shams expected by React are not available: ' + 'https://fb.me/react-warning-polyfills');
	        break;
	      }
	    }
	  }
	}
	
	module.exports = React;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 11 */
/***/ function(module, exports) {

	'use strict';
	
	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout() {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	})();
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while (len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () {
	    return '/';
	};
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function () {
	    return 0;
	};

/***/ },
/* 12 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCurrentOwner
	 */
	
	'use strict';
	
	/**
	 * Keeps track of the current owner.
	 *
	 * The current owner is the component who should own any components that are
	 * currently being constructed.
	 */
	
	var ReactCurrentOwner = {
	
	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null
	
	};
	
	module.exports = ReactCurrentOwner;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextComponent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(14);
	var DOMPropertyOperations = __webpack_require__(29);
	var ReactComponentBrowserEnvironment = __webpack_require__(33);
	var ReactMount = __webpack_require__(35);
	
	var assign = __webpack_require__(46);
	var escapeTextContentForBrowser = __webpack_require__(28);
	var setTextContent = __webpack_require__(27);
	var validateDOMNesting = __webpack_require__(77);
	
	/**
	 * Text nodes violate a couple assumptions that React makes about components:
	 *
	 *  - When mounting text into the DOM, adjacent text nodes are merged.
	 *  - Text nodes cannot be assigned a React root ID.
	 *
	 * This component is used to wrap strings in elements so that they can undergo
	 * the same reconciliation that is applied to elements.
	 *
	 * TODO: Investigate representing React components in the DOM with text nodes.
	 *
	 * @class ReactDOMTextComponent
	 * @extends ReactComponent
	 * @internal
	 */
	var ReactDOMTextComponent = function ReactDOMTextComponent(props) {
	  // This constructor and its argument is currently used by mocks.
	};
	
	assign(ReactDOMTextComponent.prototype, {
	
	  /**
	   * @param {ReactText} text
	   * @internal
	   */
	  construct: function construct(text) {
	    // TODO: This is really a ReactText (ReactNode), not a ReactElement
	    this._currentElement = text;
	    this._stringText = '' + text;
	
	    // Properties
	    this._rootNodeID = null;
	    this._mountIndex = 0;
	  },
	
	  /**
	   * Creates the markup for this text node. This node is not intended to have
	   * any features besides containing text content.
	   *
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} Markup for this text node.
	   * @internal
	   */
	  mountComponent: function mountComponent(rootID, transaction, context) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (context[validateDOMNesting.ancestorInfoContextKey]) {
	        validateDOMNesting('span', null, context[validateDOMNesting.ancestorInfoContextKey]);
	      }
	    }
	
	    this._rootNodeID = rootID;
	    if (transaction.useCreateElement) {
	      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
	      var el = ownerDocument.createElement('span');
	      DOMPropertyOperations.setAttributeForID(el, rootID);
	      // Populate node cache
	      ReactMount.getID(el);
	      setTextContent(el, this._stringText);
	      return el;
	    } else {
	      var escapedText = escapeTextContentForBrowser(this._stringText);
	
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd wrap this in a `span` for the reasons stated above, but
	        // since this is a situation where React won't take over (static pages),
	        // we can simply return the text as it is.
	        return escapedText;
	      }
	
	      return '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>';
	    }
	  },
	
	  /**
	   * Updates this component by updating the text content.
	   *
	   * @param {ReactText} nextText The next text content
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  receiveComponent: function receiveComponent(nextText, transaction) {
	    if (nextText !== this._currentElement) {
	      this._currentElement = nextText;
	      var nextStringText = '' + nextText;
	      if (nextStringText !== this._stringText) {
	        // TODO: Save this as pending props and use performUpdateIfNecessary
	        // and/or updateComponent to do the actual update for consistency with
	        // other component types?
	        this._stringText = nextStringText;
	        var node = ReactMount.getNode(this._rootNodeID);
	        DOMChildrenOperations.updateTextContent(node, nextStringText);
	      }
	    }
	  },
	
	  unmountComponent: function unmountComponent() {
	    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
	  }
	
	});
	
	module.exports = ReactDOMTextComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMChildrenOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var Danger = __webpack_require__(15);
	var ReactMultiChildUpdateTypes = __webpack_require__(23);
	var ReactPerf = __webpack_require__(25);
	
	var setInnerHTML = __webpack_require__(26);
	var setTextContent = __webpack_require__(27);
	var invariant = __webpack_require__(20);
	
	/**
	 * Inserts `childNode` as a child of `parentNode` at the `index`.
	 *
	 * @param {DOMElement} parentNode Parent node in which to insert.
	 * @param {DOMElement} childNode Child node to insert.
	 * @param {number} index Index at which to insert the child.
	 * @internal
	 */
	function insertChildAt(parentNode, childNode, index) {
	  // By exploiting arrays returning `undefined` for an undefined index, we can
	  // rely exclusively on `insertBefore(node, null)` instead of also using
	  // `appendChild(node)`. However, using `undefined` is not allowed by all
	  // browsers so we must replace it with `null`.
	
	  // fix render order error in safari
	  // IE8 will throw error when index out of list size.
	  var beforeChild = index >= parentNode.childNodes.length ? null : parentNode.childNodes.item(index);
	
	  parentNode.insertBefore(childNode, beforeChild);
	}
	
	/**
	 * Operations for updating with DOM children.
	 */
	var DOMChildrenOperations = {
	
	  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,
	
	  updateTextContent: setTextContent,
	
	  /**
	   * Updates a component's children by processing a series of updates. The
	   * update configurations are each expected to have a `parentNode` property.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @param {array<string>} markupList List of markup strings.
	   * @internal
	   */
	  processUpdates: function processUpdates(updates, markupList) {
	    var update;
	    // Mapping from parent IDs to initial child orderings.
	    var initialChildren = null;
	    // List of children that will be moved or removed.
	    var updatedChildren = null;
	
	    for (var i = 0; i < updates.length; i++) {
	      update = updates[i];
	      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
	        var updatedIndex = update.fromIndex;
	        var updatedChild = update.parentNode.childNodes[updatedIndex];
	        var parentID = update.parentID;
	
	        !updatedChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processUpdates(): Unable to find child %s of element. This ' + 'probably means the DOM was unexpectedly mutated (e.g., by the ' + 'browser), usually due to forgetting a <tbody> when using tables, ' + 'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' + 'in an <svg> parent. Try inspecting the child nodes of the element ' + 'with React ID `%s`.', updatedIndex, parentID) : invariant(false) : undefined;
	
	        initialChildren = initialChildren || {};
	        initialChildren[parentID] = initialChildren[parentID] || [];
	        initialChildren[parentID][updatedIndex] = updatedChild;
	
	        updatedChildren = updatedChildren || [];
	        updatedChildren.push(updatedChild);
	      }
	    }
	
	    var renderedMarkup;
	    // markupList is either a list of markup or just a list of elements
	    if (markupList.length && typeof markupList[0] === 'string') {
	      renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);
	    } else {
	      renderedMarkup = markupList;
	    }
	
	    // Remove updated children first so that `toIndex` is consistent.
	    if (updatedChildren) {
	      for (var j = 0; j < updatedChildren.length; j++) {
	        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
	      }
	    }
	
	    for (var k = 0; k < updates.length; k++) {
	      update = updates[k];
	      switch (update.type) {
	        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
	          insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);
	          break;
	        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
	          insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
	          break;
	        case ReactMultiChildUpdateTypes.SET_MARKUP:
	          setInnerHTML(update.parentNode, update.content);
	          break;
	        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
	          setTextContent(update.parentNode, update.content);
	          break;
	        case ReactMultiChildUpdateTypes.REMOVE_NODE:
	          // Already removed by the for-loop above.
	          break;
	      }
	    }
	  }
	
	};
	
	ReactPerf.measureMethods(DOMChildrenOperations, 'DOMChildrenOperations', {
	  updateTextContent: 'updateTextContent'
	});
	
	module.exports = DOMChildrenOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Danger
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var createNodesFromMarkup = __webpack_require__(17);
	var emptyFunction = __webpack_require__(22);
	var getMarkupWrap = __webpack_require__(21);
	var invariant = __webpack_require__(20);
	
	var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
	var RESULT_INDEX_ATTR = 'data-danger-index';
	
	/**
	 * Extracts the `nodeName` from a string of markup.
	 *
	 * NOTE: Extracting the `nodeName` does not require a regular expression match
	 * because we make assumptions about React-generated markup (i.e. there are no
	 * spaces surrounding the opening tag and there is at least one attribute).
	 *
	 * @param {string} markup String of markup.
	 * @return {string} Node name of the supplied markup.
	 * @see http://jsperf.com/extract-nodename
	 */
	function getNodeName(markup) {
	  return markup.substring(1, markup.indexOf(' '));
	}
	
	var Danger = {
	
	  /**
	   * Renders markup into an array of nodes. The markup is expected to render
	   * into a list of root nodes. Also, the length of `resultList` and
	   * `markupList` should be the same.
	   *
	   * @param {array<string>} markupList List of markup strings to render.
	   * @return {array<DOMElement>} List of rendered nodes.
	   * @internal
	   */
	  dangerouslyRenderMarkup: function dangerouslyRenderMarkup(markupList) {
	    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' + 'thread. Make sure `window` and `document` are available globally ' + 'before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString for server rendering.') : invariant(false) : undefined;
	    var nodeName;
	    var markupByNodeName = {};
	    // Group markup by `nodeName` if a wrap is necessary, else by '*'.
	    for (var i = 0; i < markupList.length; i++) {
	      !markupList[i] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Missing markup.') : invariant(false) : undefined;
	      nodeName = getNodeName(markupList[i]);
	      nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
	      markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
	      markupByNodeName[nodeName][i] = markupList[i];
	    }
	    var resultList = [];
	    var resultListAssignmentCount = 0;
	    for (nodeName in markupByNodeName) {
	      if (!markupByNodeName.hasOwnProperty(nodeName)) {
	        continue;
	      }
	      var markupListByNodeName = markupByNodeName[nodeName];
	
	      // This for-in loop skips the holes of the sparse array. The order of
	      // iteration should follow the order of assignment, which happens to match
	      // numerical index order, but we don't rely on that.
	      var resultIndex;
	      for (resultIndex in markupListByNodeName) {
	        if (markupListByNodeName.hasOwnProperty(resultIndex)) {
	          var markup = markupListByNodeName[resultIndex];
	
	          // Push the requested markup with an additional RESULT_INDEX_ATTR
	          // attribute.  If the markup does not start with a < character, it
	          // will be discarded below (with an appropriate console.error).
	          markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP,
	          // This index will be parsed back out below.
	          '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" ');
	        }
	      }
	
	      // Render each group of markup with similar wrapping `nodeName`.
	      var renderNodes = createNodesFromMarkup(markupListByNodeName.join(''), emptyFunction // Do nothing special with <script> tags.
	      );
	
	      for (var j = 0; j < renderNodes.length; ++j) {
	        var renderNode = renderNodes[j];
	        if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {
	
	          resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
	          renderNode.removeAttribute(RESULT_INDEX_ATTR);
	
	          !!resultList.hasOwnProperty(resultIndex) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Assigning to an already-occupied result index.') : invariant(false) : undefined;
	
	          resultList[resultIndex] = renderNode;
	
	          // This should match resultList.length and markupList.length when
	          // we're done.
	          resultListAssignmentCount += 1;
	        } else if (process.env.NODE_ENV !== 'production') {
	          console.error('Danger: Discarding unexpected node:', renderNode);
	        }
	      }
	    }
	
	    // Although resultList was populated out of order, it should now be a dense
	    // array.
	    !(resultListAssignmentCount === resultList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Did not assign to every index of resultList.') : invariant(false) : undefined;
	
	    !(resultList.length === markupList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Expected markup to render %s nodes, but rendered %s.', markupList.length, resultList.length) : invariant(false) : undefined;
	
	    return resultList;
	  },
	
	  /**
	   * Replaces a node with a string of markup at its current position within its
	   * parent. The markup must render into a single root node.
	   *
	   * @param {DOMElement} oldChild Child node to replace.
	   * @param {string} markup Markup to render in place of the child node.
	   * @internal
	   */
	  dangerouslyReplaceNodeWithMarkup: function dangerouslyReplaceNodeWithMarkup(oldChild, markup) {
	    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' + 'worker thread. Make sure `window` and `document` are available ' + 'globally before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;
	    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(false) : undefined;
	    !(oldChild.tagName.toLowerCase() !== 'html') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' + '<html> node. This is because browser quirks make this unreliable ' + 'and/or slow. If you want to render to the root you must use ' + 'server rendering. See ReactDOMServer.renderToString().') : invariant(false) : undefined;
	
	    var newChild;
	    if (typeof markup === 'string') {
	      newChild = createNodesFromMarkup(markup, emptyFunction)[0];
	    } else {
	      newChild = markup;
	    }
	    oldChild.parentNode.replaceChild(newChild, oldChild);
	  }
	
	};
	
	module.exports = Danger;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 16 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ExecutionEnvironment
	 */
	
	'use strict';
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {
	
	  canUseDOM: canUseDOM,
	
	  canUseWorkers: typeof Worker !== 'undefined',
	
	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
	
	  canUseViewport: canUseDOM && !!window.screen,
	
	  isInWorker: !canUseDOM // For now, this is true - might change in the future.
	
	};
	
	module.exports = ExecutionEnvironment;

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createNodesFromMarkup
	 * @typechecks
	 */
	
	/*eslint-disable fb-www/unsafe-html*/
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var createArrayFromMixed = __webpack_require__(18);
	var getMarkupWrap = __webpack_require__(21);
	var invariant = __webpack_require__(20);
	
	/**
	 * Dummy container used to render all markup.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Pattern used by `getNodeName`.
	 */
	var nodeNamePattern = /^\s*<(\w+)/;
	
	/**
	 * Extracts the `nodeName` of the first element in a string of markup.
	 *
	 * @param {string} markup String of markup.
	 * @return {?string} Node name of the supplied markup.
	 */
	function getNodeName(markup) {
	  var nodeNameMatch = markup.match(nodeNamePattern);
	  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
	}
	
	/**
	 * Creates an array containing the nodes rendered from the supplied markup. The
	 * optionally supplied `handleScript` function will be invoked once for each
	 * <script> element that is rendered. If no `handleScript` function is supplied,
	 * an exception is thrown if any <script> elements are rendered.
	 *
	 * @param {string} markup A string of valid HTML markup.
	 * @param {?function} handleScript Invoked once for each rendered <script>.
	 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
	 */
	function createNodesFromMarkup(markup, handleScript) {
	  var node = dummyNode;
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : undefined;
	  var nodeName = getNodeName(markup);
	
	  var wrap = nodeName && getMarkupWrap(nodeName);
	  if (wrap) {
	    node.innerHTML = wrap[1] + markup + wrap[2];
	
	    var wrapDepth = wrap[0];
	    while (wrapDepth--) {
	      node = node.lastChild;
	    }
	  } else {
	    node.innerHTML = markup;
	  }
	
	  var scripts = node.getElementsByTagName('script');
	  if (scripts.length) {
	    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : undefined;
	    createArrayFromMixed(scripts).forEach(handleScript);
	  }
	
	  var nodes = createArrayFromMixed(node.childNodes);
	  while (node.lastChild) {
	    node.removeChild(node.lastChild);
	  }
	  return nodes;
	}
	
	module.exports = createNodesFromMarkup;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createArrayFromMixed
	 * @typechecks
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var toArray = __webpack_require__(19);
	
	/**
	 * Perform a heuristic test to determine if an object is "array-like".
	 *
	 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
	 *   Joshu replied: "Mu."
	 *
	 * This function determines if its argument has "array nature": it returns
	 * true if the argument is an actual array, an `arguments' object, or an
	 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
	 *
	 * It will return false for other array-like objects like Filelist.
	 *
	 * @param {*} obj
	 * @return {boolean}
	 */
	function hasArrayNature(obj) {
	  return (
	    // not null/false
	    !!obj && (
	    // arrays are objects, NodeLists are functions in Safari
	    (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == 'object' || typeof obj == 'function') &&
	    // quacks like an array
	    'length' in obj &&
	    // not window
	    !('setInterval' in obj) &&
	    // no DOM node should be considered an array-like
	    // a 'select' element has 'length' and 'item' properties on IE8
	    typeof obj.nodeType != 'number' && (
	    // a real array
	    Array.isArray(obj) ||
	    // arguments
	    'callee' in obj ||
	    // HTMLCollection/NodeList
	    'item' in obj)
	  );
	}
	
	/**
	 * Ensure that the argument is an array by wrapping it in an array if it is not.
	 * Creates a copy of the argument if it is already an array.
	 *
	 * This is mostly useful idiomatically:
	 *
	 *   var createArrayFromMixed = require('createArrayFromMixed');
	 *
	 *   function takesOneOrMoreThings(things) {
	 *     things = createArrayFromMixed(things);
	 *     ...
	 *   }
	 *
	 * This allows you to treat `things' as an array, but accept scalars in the API.
	 *
	 * If you need to convert an array-like object, like `arguments`, into an array
	 * use toArray instead.
	 *
	 * @param {*} obj
	 * @return {array}
	 */
	function createArrayFromMixed(obj) {
	  if (!hasArrayNature(obj)) {
	    return [obj];
	  } else if (Array.isArray(obj)) {
	    return obj.slice();
	  } else {
	    return toArray(obj);
	  }
	}
	
	module.exports = createArrayFromMixed;

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule toArray
	 * @typechecks
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Convert array-like objects to arrays.
	 *
	 * This API assumes the caller knows the contents of the data type. For less
	 * well defined inputs use createArrayFromMixed.
	 *
	 * @param {object|function|filelist} obj
	 * @return {array}
	 */
	function toArray(obj) {
	  var length = obj.length;
	
	  // Some browse builtin objects can report typeof 'function' (e.g. NodeList in
	  // old versions of Safari).
	  !(!Array.isArray(obj) && ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : undefined;
	
	  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : undefined;
	
	  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : undefined;
	
	  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
	  // without method will throw during the slice call and skip straight to the
	  // fallback.
	  if (obj.hasOwnProperty) {
	    try {
	      return Array.prototype.slice.call(obj);
	    } catch (e) {
	      // IE < 9 does not support Array#slice on collections objects
	    }
	  }
	
	  // Fall back to copying key by key. This assumes all keys have a value,
	  // so will not preserve sparsely populated inputs.
	  var ret = Array(length);
	  for (var ii = 0; ii < length; ii++) {
	    ret[ii] = obj[ii];
	  }
	  return ret;
	}
	
	module.exports = toArray;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule invariant
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	function invariant(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}
	
	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getMarkupWrap
	 */
	
	/*eslint-disable fb-www/unsafe-html */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Dummy container used to detect which wraps are necessary.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Some browsers cannot use `innerHTML` to render certain elements standalone,
	 * so we wrap them, render the wrapped nodes, then extract the desired node.
	 *
	 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
	 */
	
	var shouldWrap = {};
	
	var selectWrap = [1, '<select multiple="true">', '</select>'];
	var tableWrap = [1, '<table>', '</table>'];
	var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];
	
	var markupWrap = {
	  '*': [1, '?<div>', '</div>'],
	
	  'area': [1, '<map>', '</map>'],
	  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
	  'legend': [1, '<fieldset>', '</fieldset>'],
	  'param': [1, '<object>', '</object>'],
	  'tr': [2, '<table><tbody>', '</tbody></table>'],
	
	  'optgroup': selectWrap,
	  'option': selectWrap,
	
	  'caption': tableWrap,
	  'colgroup': tableWrap,
	  'tbody': tableWrap,
	  'tfoot': tableWrap,
	  'thead': tableWrap,
	
	  'td': trWrap,
	  'th': trWrap
	};
	
	// Initialize the SVG elements since we know they'll always need to be wrapped
	// consistently. If they are created inside a <div> they will be initialized in
	// the wrong namespace (and will not display).
	var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
	svgElements.forEach(function (nodeName) {
	  markupWrap[nodeName] = svgWrap;
	  shouldWrap[nodeName] = true;
	});
	
	/**
	 * Gets the markup wrap configuration for the supplied `nodeName`.
	 *
	 * NOTE: This lazily detects which wraps are necessary for the current browser.
	 *
	 * @param {string} nodeName Lowercase `nodeName`.
	 * @return {?array} Markup wrap configuration, if applicable.
	 */
	function getMarkupWrap(nodeName) {
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : undefined;
	  if (!markupWrap.hasOwnProperty(nodeName)) {
	    nodeName = '*';
	  }
	  if (!shouldWrap.hasOwnProperty(nodeName)) {
	    if (nodeName === '*') {
	      dummyNode.innerHTML = '<link />';
	    } else {
	      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
	    }
	    shouldWrap[nodeName] = !dummyNode.firstChild;
	  }
	  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
	}
	
	module.exports = getMarkupWrap;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 22 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyFunction
	 */
	
	"use strict";
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	function emptyFunction() {}
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChildUpdateTypes
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(24);
	
	/**
	 * When a component's children are updated, a series of update configuration
	 * objects are created in order to batch and serialize the required changes.
	 *
	 * Enumerates all the possible types of update configurations.
	 *
	 * @internal
	 */
	var ReactMultiChildUpdateTypes = keyMirror({
	  INSERT_MARKUP: null,
	  MOVE_EXISTING: null,
	  REMOVE_NODE: null,
	  SET_MARKUP: null,
	  TEXT_CONTENT: null
	});
	
	module.exports = ReactMultiChildUpdateTypes;

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule keyMirror
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Constructs an enumeration with keys equal to their value.
	 *
	 * For example:
	 *
	 *   var COLORS = keyMirror({blue: null, red: null});
	 *   var myColor = COLORS.blue;
	 *   var isColorValid = !!COLORS[myColor];
	 *
	 * The last line could not be performed if the values of the generated enum were
	 * not equal to their keys.
	 *
	 *   Input:  {key1: val1, key2: val2}
	 *   Output: {key1: key1, key2: key2}
	 *
	 * @param {object} obj
	 * @return {object}
	 */
	var keyMirror = function keyMirror(obj) {
	  var ret = {};
	  var key;
	  !(obj instanceof Object && !Array.isArray(obj)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : undefined;
	  for (key in obj) {
	    if (!obj.hasOwnProperty(key)) {
	      continue;
	    }
	    ret[key] = key;
	  }
	  return ret;
	};
	
	module.exports = keyMirror;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPerf
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * ReactPerf is a general AOP system designed to measure performance. This
	 * module only has the hooks: see ReactDefaultPerf for the analysis tool.
	 */
	
	var ReactPerf = {
	  /**
	   * Boolean to enable/disable measurement. Set to false by default to prevent
	   * accidental logging and perf loss.
	   */
	  enableMeasure: false,
	
	  /**
	   * Holds onto the measure function in use. By default, don't measure
	   * anything, but we'll override this if we inject a measure function.
	   */
	  storedMeasure: _noMeasure,
	
	  /**
	   * @param {object} object
	   * @param {string} objectName
	   * @param {object<string>} methodNames
	   */
	  measureMethods: function measureMethods(object, objectName, methodNames) {
	    if (process.env.NODE_ENV !== 'production') {
	      for (var key in methodNames) {
	        if (!methodNames.hasOwnProperty(key)) {
	          continue;
	        }
	        object[key] = ReactPerf.measure(objectName, methodNames[key], object[key]);
	      }
	    }
	  },
	
	  /**
	   * Use this to wrap methods you want to measure. Zero overhead in production.
	   *
	   * @param {string} objName
	   * @param {string} fnName
	   * @param {function} func
	   * @return {function}
	   */
	  measure: function measure(objName, fnName, func) {
	    if (process.env.NODE_ENV !== 'production') {
	      var measuredFunc = null;
	      var wrapper = function wrapper() {
	        if (ReactPerf.enableMeasure) {
	          if (!measuredFunc) {
	            measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
	          }
	          return measuredFunc.apply(this, arguments);
	        }
	        return func.apply(this, arguments);
	      };
	      wrapper.displayName = objName + '_' + fnName;
	      return wrapper;
	    }
	    return func;
	  },
	
	  injection: {
	    /**
	     * @param {function} measure
	     */
	    injectMeasure: function injectMeasure(measure) {
	      ReactPerf.storedMeasure = measure;
	    }
	  }
	};
	
	/**
	 * Simply passes through the measured function, without measuring it.
	 *
	 * @param {string} objName
	 * @param {string} fnName
	 * @param {function} func
	 * @return {function}
	 */
	function _noMeasure(objName, fnName, func) {
	  return func;
	}
	
	module.exports = ReactPerf;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setInnerHTML
	 */
	
	/* globals MSApp */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var WHITESPACE_TEST = /^[ \r\n\t\f]/;
	var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
	
	/**
	 * Set the innerHTML property of a node, ensuring that whitespace is preserved
	 * even in IE8.
	 *
	 * @param {DOMElement} node
	 * @param {string} html
	 * @internal
	 */
	var setInnerHTML = function setInnerHTML(node, html) {
	  node.innerHTML = html;
	};
	
	// Win8 apps: Allow all html to be inserted
	if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
	  setInnerHTML = function setInnerHTML(node, html) {
	    MSApp.execUnsafeLocalFunction(function () {
	      node.innerHTML = html;
	    });
	  };
	}
	
	if (ExecutionEnvironment.canUseDOM) {
	  // IE8: When updating a just created node with innerHTML only leading
	  // whitespace is removed. When updating an existing node with innerHTML
	  // whitespace in root TextNodes is also collapsed.
	  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html
	
	  // Feature detection; only IE8 is known to behave improperly like this.
	  var testElement = document.createElement('div');
	  testElement.innerHTML = ' ';
	  if (testElement.innerHTML === '') {
	    setInnerHTML = function setInnerHTML(node, html) {
	      // Magic theory: IE8 supposedly differentiates between added and updated
	      // nodes when processing innerHTML, innerHTML on updated nodes suffers
	      // from worse whitespace behavior. Re-adding a node like this triggers
	      // the initial and more favorable whitespace behavior.
	      // TODO: What to do on a detached node?
	      if (node.parentNode) {
	        node.parentNode.replaceChild(node, node);
	      }
	
	      // We also implement a workaround for non-visible tags disappearing into
	      // thin air on IE8, this only happens if there is no visible text
	      // in-front of the non-visible tags. Piggyback on the whitespace fix
	      // and simply check if any non-visible tags appear in the source.
	      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
	        // Recover leading whitespace by temporarily prepending any character.
	        // \uFEFF has the potential advantage of being zero-width/invisible.
	        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
	        // in hopes that this is preserved even if "\uFEFF" is transformed to
	        // the actual Unicode character (by Babel, for example).
	        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
	        node.innerHTML = String.fromCharCode(0xFEFF) + html;
	
	        // deleteData leaves an empty `TextNode` which offsets the index of all
	        // children. Definitely want to avoid this.
	        var textNode = node.firstChild;
	        if (textNode.data.length === 1) {
	          node.removeChild(textNode);
	        } else {
	          textNode.deleteData(0, 1);
	        }
	      } else {
	        node.innerHTML = html;
	      }
	    };
	  }
	}
	
	module.exports = setInnerHTML;

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setTextContent
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	var escapeTextContentForBrowser = __webpack_require__(28);
	var setInnerHTML = __webpack_require__(26);
	
	/**
	 * Set the textContent property of a node, ensuring that whitespace is preserved
	 * even in IE8. innerText is a poor substitute for textContent and, among many
	 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
	 * as it should.
	 *
	 * @param {DOMElement} node
	 * @param {string} text
	 * @internal
	 */
	var setTextContent = function setTextContent(node, text) {
	  node.textContent = text;
	};
	
	if (ExecutionEnvironment.canUseDOM) {
	  if (!('textContent' in document.documentElement)) {
	    setTextContent = function setTextContent(node, text) {
	      setInnerHTML(node, escapeTextContentForBrowser(text));
	    };
	  }
	}
	
	module.exports = setTextContent;

/***/ },
/* 28 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule escapeTextContentForBrowser
	 */
	
	'use strict';
	
	var ESCAPE_LOOKUP = {
	  '&': '&amp;',
	  '>': '&gt;',
	  '<': '&lt;',
	  '"': '&quot;',
	  '\'': '&#x27;'
	};
	
	var ESCAPE_REGEX = /[&><"']/g;
	
	function escaper(match) {
	  return ESCAPE_LOOKUP[match];
	}
	
	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escapeTextContentForBrowser(text) {
	  return ('' + text).replace(ESCAPE_REGEX, escaper);
	}
	
	module.exports = escapeTextContentForBrowser;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMPropertyOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(30);
	var ReactPerf = __webpack_require__(25);
	
	var quoteAttributeValueForBrowser = __webpack_require__(31);
	var warning = __webpack_require__(32);
	
	// Simplified subset
	var VALID_ATTRIBUTE_NAME_REGEX = /^[a-zA-Z_][\w\.\-]*$/;
	var illegalAttributeNameCache = {};
	var validatedAttributeNameCache = {};
	
	function isAttributeNameSafe(attributeName) {
	  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
	    return true;
	  }
	  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
	    return false;
	  }
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
	    validatedAttributeNameCache[attributeName] = true;
	    return true;
	  }
	  illegalAttributeNameCache[attributeName] = true;
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : undefined;
	  return false;
	}
	
	function shouldIgnoreValue(propertyInfo, value) {
	  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var reactProps = {
	    children: true,
	    dangerouslySetInnerHTML: true,
	    key: true,
	    ref: true
	  };
	  var warnedProperties = {};
	
	  var warnUnknownProperty = function warnUnknownProperty(name) {
	    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	      return;
	    }
	
	    warnedProperties[name] = true;
	    var lowerCasedName = name.toLowerCase();
	
	    // data-* attributes should be lowercase; suggest the lowercase version
	    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
	
	    // For now, only warn when we have a suggested correction. This prevents
	    // logging too much when using transferPropsTo.
	    process.env.NODE_ENV !== 'production' ? warning(standardName == null, 'Unknown DOM property %s. Did you mean %s?', name, standardName) : undefined;
	  };
	}
	
	/**
	 * Operations for dealing with DOM properties.
	 */
	var DOMPropertyOperations = {
	
	  /**
	   * Creates markup for the ID property.
	   *
	   * @param {string} id Unescaped ID.
	   * @return {string} Markup string.
	   */
	  createMarkupForID: function createMarkupForID(id) {
	    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
	  },
	
	  setAttributeForID: function setAttributeForID(node, id) {
	    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
	  },
	
	  /**
	   * Creates markup for a property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {?string} Markup string, or null if the property was invalid.
	   */
	  createMarkupForProperty: function createMarkupForProperty(name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      if (shouldIgnoreValue(propertyInfo, value)) {
	        return '';
	      }
	      var attributeName = propertyInfo.attributeName;
	      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	        return attributeName + '=""';
	      }
	      return attributeName + '=' + quoteAttributeValueForBrowser(value);
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      if (value == null) {
	        return '';
	      }
	      return name + '=' + quoteAttributeValueForBrowser(value);
	    } else if (process.env.NODE_ENV !== 'production') {
	      warnUnknownProperty(name);
	    }
	    return null;
	  },
	
	  /**
	   * Creates markup for a custom property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {string} Markup string, or empty string if the property was invalid.
	   */
	  createMarkupForCustomAttribute: function createMarkupForCustomAttribute(name, value) {
	    if (!isAttributeNameSafe(name) || value == null) {
	      return '';
	    }
	    return name + '=' + quoteAttributeValueForBrowser(value);
	  },
	
	  /**
	   * Sets the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   * @param {*} value
	   */
	  setValueForProperty: function setValueForProperty(node, name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, value);
	      } else if (shouldIgnoreValue(propertyInfo, value)) {
	        this.deleteValueForProperty(node, name);
	      } else if (propertyInfo.mustUseAttribute) {
	        var attributeName = propertyInfo.attributeName;
	        var namespace = propertyInfo.attributeNamespace;
	        // `setAttribute` with objects becomes only `[object]` in IE8/9,
	        // ('' + value) makes it output the correct toString()-value.
	        if (namespace) {
	          node.setAttributeNS(namespace, attributeName, '' + value);
	        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	          node.setAttribute(attributeName, '');
	        } else {
	          node.setAttribute(attributeName, '' + value);
	        }
	      } else {
	        var propName = propertyInfo.propertyName;
	        // Must explicitly cast values for HAS_SIDE_EFFECTS-properties to the
	        // property type before comparing; only `value` does and is string.
	        if (!propertyInfo.hasSideEffects || '' + node[propName] !== '' + value) {
	          // Contrary to `setAttribute`, object properties are properly
	          // `toString`ed by IE8/9.
	          node[propName] = value;
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      DOMPropertyOperations.setValueForAttribute(node, name, value);
	    } else if (process.env.NODE_ENV !== 'production') {
	      warnUnknownProperty(name);
	    }
	  },
	
	  setValueForAttribute: function setValueForAttribute(node, name, value) {
	    if (!isAttributeNameSafe(name)) {
	      return;
	    }
	    if (value == null) {
	      node.removeAttribute(name);
	    } else {
	      node.setAttribute(name, '' + value);
	    }
	  },
	
	  /**
	   * Deletes the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForProperty: function deleteValueForProperty(node, name) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, undefined);
	      } else if (propertyInfo.mustUseAttribute) {
	        node.removeAttribute(propertyInfo.attributeName);
	      } else {
	        var propName = propertyInfo.propertyName;
	        var defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);
	        if (!propertyInfo.hasSideEffects || '' + node[propName] !== defaultValue) {
	          node[propName] = defaultValue;
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      node.removeAttribute(name);
	    } else if (process.env.NODE_ENV !== 'production') {
	      warnUnknownProperty(name);
	    }
	  }
	
	};
	
	ReactPerf.measureMethods(DOMPropertyOperations, 'DOMPropertyOperations', {
	  setValueForProperty: 'setValueForProperty',
	  setValueForAttribute: 'setValueForAttribute',
	  deleteValueForProperty: 'deleteValueForProperty'
	});
	
	module.exports = DOMPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMProperty
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	function checkMask(value, bitmask) {
	  return (value & bitmask) === bitmask;
	}
	
	var DOMPropertyInjection = {
	  /**
	   * Mapping from normalized, camelcased property names to a configuration that
	   * specifies how the associated DOM property should be accessed or rendered.
	   */
	  MUST_USE_ATTRIBUTE: 0x1,
	  MUST_USE_PROPERTY: 0x2,
	  HAS_SIDE_EFFECTS: 0x4,
	  HAS_BOOLEAN_VALUE: 0x8,
	  HAS_NUMERIC_VALUE: 0x10,
	  HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,
	  HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,
	
	  /**
	   * Inject some specialized knowledge about the DOM. This takes a config object
	   * with the following properties:
	   *
	   * isCustomAttribute: function that given an attribute name will return true
	   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
	   * attributes where it's impossible to enumerate all of the possible
	   * attribute names,
	   *
	   * Properties: object mapping DOM property name to one of the
	   * DOMPropertyInjection constants or null. If your attribute isn't in here,
	   * it won't get written to the DOM.
	   *
	   * DOMAttributeNames: object mapping React attribute name to the DOM
	   * attribute name. Attribute names not specified use the **lowercase**
	   * normalized name.
	   *
	   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
	   * attribute namespace URL. (Attribute names not specified use no namespace.)
	   *
	   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
	   * Property names not specified use the normalized name.
	   *
	   * DOMMutationMethods: Properties that require special mutation methods. If
	   * `value` is undefined, the mutation method should unset the property.
	   *
	   * @param {object} domPropertyConfig the config as described above.
	   */
	  injectDOMPropertyConfig: function injectDOMPropertyConfig(domPropertyConfig) {
	    var Injection = DOMPropertyInjection;
	    var Properties = domPropertyConfig.Properties || {};
	    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
	    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
	    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
	    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
	
	    if (domPropertyConfig.isCustomAttribute) {
	      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
	    }
	
	    for (var propName in Properties) {
	      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' + '\'%s\' which has already been injected. You may be accidentally ' + 'injecting the same DOM property config twice, or you may be ' + 'injecting two configs that have conflicting property names.', propName) : invariant(false) : undefined;
	
	      var lowerCased = propName.toLowerCase();
	      var propConfig = Properties[propName];
	
	      var propertyInfo = {
	        attributeName: lowerCased,
	        attributeNamespace: null,
	        propertyName: propName,
	        mutationMethod: null,
	
	        mustUseAttribute: checkMask(propConfig, Injection.MUST_USE_ATTRIBUTE),
	        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
	        hasSideEffects: checkMask(propConfig, Injection.HAS_SIDE_EFFECTS),
	        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
	        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
	        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
	        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
	      };
	
	      !(!propertyInfo.mustUseAttribute || !propertyInfo.mustUseProperty) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Cannot require using both attribute and property: %s', propName) : invariant(false) : undefined;
	      !(propertyInfo.mustUseProperty || !propertyInfo.hasSideEffects) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Properties that have side effects must use property: %s', propName) : invariant(false) : undefined;
	      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or ' + 'numeric value, but not a combination: %s', propName) : invariant(false) : undefined;
	
	      if (process.env.NODE_ENV !== 'production') {
	        DOMProperty.getPossibleStandardName[lowerCased] = propName;
	      }
	
	      if (DOMAttributeNames.hasOwnProperty(propName)) {
	        var attributeName = DOMAttributeNames[propName];
	        propertyInfo.attributeName = attributeName;
	        if (process.env.NODE_ENV !== 'production') {
	          DOMProperty.getPossibleStandardName[attributeName] = propName;
	        }
	      }
	
	      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
	        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
	      }
	
	      if (DOMPropertyNames.hasOwnProperty(propName)) {
	        propertyInfo.propertyName = DOMPropertyNames[propName];
	      }
	
	      if (DOMMutationMethods.hasOwnProperty(propName)) {
	        propertyInfo.mutationMethod = DOMMutationMethods[propName];
	      }
	
	      DOMProperty.properties[propName] = propertyInfo;
	    }
	  }
	};
	var defaultValueCache = {};
	
	/**
	 * DOMProperty exports lookup objects that can be used like functions:
	 *
	 *   > DOMProperty.isValid['id']
	 *   true
	 *   > DOMProperty.isValid['foobar']
	 *   undefined
	 *
	 * Although this may be confusing, it performs better in general.
	 *
	 * @see http://jsperf.com/key-exists
	 * @see http://jsperf.com/key-missing
	 */
	var DOMProperty = {
	
	  ID_ATTRIBUTE_NAME: 'data-reactid',
	
	  /**
	   * Map from property "standard name" to an object with info about how to set
	   * the property in the DOM. Each object contains:
	   *
	   * attributeName:
	   *   Used when rendering markup or with `*Attribute()`.
	   * attributeNamespace
	   * propertyName:
	   *   Used on DOM node instances. (This includes properties that mutate due to
	   *   external factors.)
	   * mutationMethod:
	   *   If non-null, used instead of the property or `setAttribute()` after
	   *   initial render.
	   * mustUseAttribute:
	   *   Whether the property must be accessed and mutated using `*Attribute()`.
	   *   (This includes anything that fails `<propName> in <element>`.)
	   * mustUseProperty:
	   *   Whether the property must be accessed and mutated as an object property.
	   * hasSideEffects:
	   *   Whether or not setting a value causes side effects such as triggering
	   *   resources to be loaded or text selection changes. If true, we read from
	   *   the DOM before updating to ensure that the value is only set if it has
	   *   changed.
	   * hasBooleanValue:
	   *   Whether the property should be removed when set to a falsey value.
	   * hasNumericValue:
	   *   Whether the property must be numeric or parse as a numeric and should be
	   *   removed when set to a falsey value.
	   * hasPositiveNumericValue:
	   *   Whether the property must be positive numeric or parse as a positive
	   *   numeric and should be removed when set to a falsey value.
	   * hasOverloadedBooleanValue:
	   *   Whether the property can be used as a flag as well as with a value.
	   *   Removed when strictly equal to false; present without a value when
	   *   strictly equal to true; present with a value otherwise.
	   */
	  properties: {},
	
	  /**
	   * Mapping from lowercase property names to the properly cased version, used
	   * to warn in the case of missing properties. Available only in __DEV__.
	   * @type {Object}
	   */
	  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? {} : null,
	
	  /**
	   * All of the isCustomAttribute() functions that have been injected.
	   */
	  _isCustomAttributeFunctions: [],
	
	  /**
	   * Checks whether a property name is a custom attribute.
	   * @method
	   */
	  isCustomAttribute: function isCustomAttribute(attributeName) {
	    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
	      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
	      if (isCustomAttributeFn(attributeName)) {
	        return true;
	      }
	    }
	    return false;
	  },
	
	  /**
	   * Returns the default property value for a DOM property (i.e., not an
	   * attribute). Most default values are '' or false, but not all. Worse yet,
	   * some (in particular, `type`) vary depending on the type of element.
	   *
	   * TODO: Is it better to grab all the possible properties when creating an
	   * element to avoid having to create the same element twice?
	   */
	  getDefaultValueForProperty: function getDefaultValueForProperty(nodeName, prop) {
	    var nodeDefaults = defaultValueCache[nodeName];
	    var testElement;
	    if (!nodeDefaults) {
	      defaultValueCache[nodeName] = nodeDefaults = {};
	    }
	    if (!(prop in nodeDefaults)) {
	      testElement = document.createElement(nodeName);
	      nodeDefaults[prop] = testElement[prop];
	    }
	    return nodeDefaults[prop];
	  },
	
	  injection: DOMPropertyInjection
	};
	
	module.exports = DOMProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule quoteAttributeValueForBrowser
	 */
	
	'use strict';
	
	var escapeTextContentForBrowser = __webpack_require__(28);
	
	/**
	 * Escapes attribute value to prevent scripting attacks.
	 *
	 * @param {*} value Value to escape.
	 * @return {string} An escaped string.
	 */
	function quoteAttributeValueForBrowser(value) {
	  return '"' + escapeTextContentForBrowser(value) + '"';
	}
	
	module.exports = quoteAttributeValueForBrowser;

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule warning
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(22);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  warning = function warning(condition, format) {
	    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      args[_key - 2] = arguments[_key];
	    }
	
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	
	    if (format.indexOf('Failed Composite propType: ') === 0) {
	      return; // Ignore CompositeComponent proptype check.
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    }
	  };
	}
	
	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentBrowserEnvironment
	 */
	
	'use strict';
	
	var ReactDOMIDOperations = __webpack_require__(34);
	var ReactMount = __webpack_require__(35);
	
	/**
	 * Abstracts away all functionality of the reconciler that requires knowledge of
	 * the browser context. TODO: These callers should be refactored to avoid the
	 * need for this injection.
	 */
	var ReactComponentBrowserEnvironment = {
	
	  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
	
	  replaceNodeWithMarkupByID: ReactDOMIDOperations.dangerouslyReplaceNodeWithMarkupByID,
	
	  /**
	   * If a particular environment requires that some resources be cleaned up,
	   * specify this in the injected Mixin. In the DOM, we would likely want to
	   * purge any cached node ID lookups.
	   *
	   * @private
	   */
	  unmountIDFromEnvironment: function unmountIDFromEnvironment(rootNodeID) {
	    ReactMount.purgeID(rootNodeID);
	  }
	
	};
	
	module.exports = ReactComponentBrowserEnvironment;

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMIDOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(14);
	var DOMPropertyOperations = __webpack_require__(29);
	var ReactMount = __webpack_require__(35);
	var ReactPerf = __webpack_require__(25);
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Errors for properties that should not be updated with `updatePropertyByID()`.
	 *
	 * @type {object}
	 * @private
	 */
	var INVALID_PROPERTY_ERRORS = {
	  dangerouslySetInnerHTML: '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
	  style: '`style` must be set using `updateStylesByID()`.'
	};
	
	/**
	 * Operations used to process updates to DOM nodes.
	 */
	var ReactDOMIDOperations = {
	
	  /**
	   * Updates a DOM node with new property values. This should only be used to
	   * update DOM properties in `DOMProperty`.
	   *
	   * @param {string} id ID of the node to update.
	   * @param {string} name A valid property name, see `DOMProperty`.
	   * @param {*} value New value of the property.
	   * @internal
	   */
	  updatePropertyByID: function updatePropertyByID(id, name, value) {
	    var node = ReactMount.getNode(id);
	    !!INVALID_PROPERTY_ERRORS.hasOwnProperty(name) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(false) : undefined;
	
	    // If we're updating to null or undefined, we should remove the property
	    // from the DOM node instead of inadvertantly setting to a string. This
	    // brings us in line with the same behavior we have on initial render.
	    if (value != null) {
	      DOMPropertyOperations.setValueForProperty(node, name, value);
	    } else {
	      DOMPropertyOperations.deleteValueForProperty(node, name);
	    }
	  },
	
	  /**
	   * Replaces a DOM node that exists in the document with markup.
	   *
	   * @param {string} id ID of child to be replaced.
	   * @param {string} markup Dangerous markup to inject in place of child.
	   * @internal
	   * @see {Danger.dangerouslyReplaceNodeWithMarkup}
	   */
	  dangerouslyReplaceNodeWithMarkupByID: function dangerouslyReplaceNodeWithMarkupByID(id, markup) {
	    var node = ReactMount.getNode(id);
	    DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
	  },
	
	  /**
	   * Updates a component's children by processing a series of updates.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @param {array<string>} markup List of markup strings.
	   * @internal
	   */
	  dangerouslyProcessChildrenUpdates: function dangerouslyProcessChildrenUpdates(updates, markup) {
	    for (var i = 0; i < updates.length; i++) {
	      updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
	    }
	    DOMChildrenOperations.processUpdates(updates, markup);
	  }
	};
	
	ReactPerf.measureMethods(ReactDOMIDOperations, 'ReactDOMIDOperations', {
	  dangerouslyReplaceNodeWithMarkupByID: 'dangerouslyReplaceNodeWithMarkupByID',
	  dangerouslyProcessChildrenUpdates: 'dangerouslyProcessChildrenUpdates'
	});
	
	module.exports = ReactDOMIDOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMount
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(30);
	var ReactBrowserEventEmitter = __webpack_require__(36);
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactDOMFeatureFlags = __webpack_require__(48);
	var ReactElement = __webpack_require__(49);
	var ReactEmptyComponentRegistry = __webpack_require__(51);
	var ReactInstanceHandles = __webpack_require__(52);
	var ReactInstanceMap = __webpack_require__(54);
	var ReactMarkupChecksum = __webpack_require__(55);
	var ReactPerf = __webpack_require__(25);
	var ReactReconciler = __webpack_require__(57);
	var ReactUpdateQueue = __webpack_require__(60);
	var ReactUpdates = __webpack_require__(61);
	
	var assign = __webpack_require__(46);
	var emptyObject = __webpack_require__(65);
	var containsNode = __webpack_require__(66);
	var instantiateReactComponent = __webpack_require__(69);
	var invariant = __webpack_require__(20);
	var setInnerHTML = __webpack_require__(26);
	var shouldUpdateReactComponent = __webpack_require__(74);
	var validateDOMNesting = __webpack_require__(77);
	var warning = __webpack_require__(32);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var nodeCache = {};
	
	var ELEMENT_NODE_TYPE = 1;
	var DOC_NODE_TYPE = 9;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	var ownerDocumentContextKey = '__ReactMount_ownerDocument$' + Math.random().toString(36).slice(2);
	
	/** Mapping from reactRootID to React component instance. */
	var instancesByReactRootID = {};
	
	/** Mapping from reactRootID to `container` nodes. */
	var containersByReactRootID = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  /** __DEV__-only mapping from reactRootID to root elements. */
	  var rootElementsByReactRootID = {};
	}
	
	// Used to store breadth-first search state in findComponentRoot.
	var findComponentRootReusableArray = [];
	
	/**
	 * Finds the index of the first character
	 * that's not common between the two given strings.
	 *
	 * @return {number} the index of the character where the strings diverge
	 */
	function firstDifferenceIndex(string1, string2) {
	  var minLen = Math.min(string1.length, string2.length);
	  for (var i = 0; i < minLen; i++) {
	    if (string1.charAt(i) !== string2.charAt(i)) {
	      return i;
	    }
	  }
	  return string1.length === string2.length ? -1 : minLen;
	}
	
	/**
	 * @param {DOMElement|DOMDocument} container DOM element that may contain
	 * a React component
	 * @return {?*} DOM element that may have the reactRoot ID, or null.
	 */
	function getReactRootElementInContainer(container) {
	  if (!container) {
	    return null;
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    return container.documentElement;
	  } else {
	    return container.firstChild;
	  }
	}
	
	/**
	 * @param {DOMElement} container DOM element that may contain a React component.
	 * @return {?string} A "reactRoot" ID, if a React component is rendered.
	 */
	function getReactRootID(container) {
	  var rootElement = getReactRootElementInContainer(container);
	  return rootElement && ReactMount.getID(rootElement);
	}
	
	/**
	 * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form
	 * element can return its control whose name or ID equals ATTR_NAME. All
	 * DOM nodes support `getAttributeNode` but this can also get called on
	 * other objects so just return '' if we're given something other than a
	 * DOM node (such as window).
	 *
	 * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.
	 * @return {string} ID of the supplied `domNode`.
	 */
	function getID(node) {
	  var id = internalGetID(node);
	  if (id) {
	    if (nodeCache.hasOwnProperty(id)) {
	      var cached = nodeCache[id];
	      if (cached !== node) {
	        !!isValid(cached, id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(false) : undefined;
	
	        nodeCache[id] = node;
	      }
	    } else {
	      nodeCache[id] = node;
	    }
	  }
	
	  return id;
	}
	
	function internalGetID(node) {
	  // If node is something like a window, document, or text node, none of
	  // which support attributes or a .getAttribute method, gracefully return
	  // the empty string, as if the attribute were missing.
	  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
	}
	
	/**
	 * Sets the React-specific ID of the given node.
	 *
	 * @param {DOMElement} node The DOM node whose ID will be set.
	 * @param {string} id The value of the ID attribute.
	 */
	function setID(node, id) {
	  var oldID = internalGetID(node);
	  if (oldID !== id) {
	    delete nodeCache[oldID];
	  }
	  node.setAttribute(ATTR_NAME, id);
	  nodeCache[id] = node;
	}
	
	/**
	 * Finds the node with the supplied React-generated DOM ID.
	 *
	 * @param {string} id A React-generated DOM ID.
	 * @return {DOMElement} DOM node with the suppled `id`.
	 * @internal
	 */
	function getNode(id) {
	  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
	    nodeCache[id] = ReactMount.findReactNodeByID(id);
	  }
	  return nodeCache[id];
	}
	
	/**
	 * Finds the node with the supplied public React instance.
	 *
	 * @param {*} instance A public React instance.
	 * @return {?DOMElement} DOM node with the suppled `id`.
	 * @internal
	 */
	function getNodeFromInstance(instance) {
	  var id = ReactInstanceMap.get(instance)._rootNodeID;
	  if (ReactEmptyComponentRegistry.isNullComponentID(id)) {
	    return null;
	  }
	  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
	    nodeCache[id] = ReactMount.findReactNodeByID(id);
	  }
	  return nodeCache[id];
	}
	
	/**
	 * A node is "valid" if it is contained by a currently mounted container.
	 *
	 * This means that the node does not have to be contained by a document in
	 * order to be considered valid.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @param {string} id The expected ID of the node.
	 * @return {boolean} Whether the node is contained by a mounted container.
	 */
	function isValid(node, id) {
	  if (node) {
	    !(internalGetID(node) === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(false) : undefined;
	
	    var container = ReactMount.findReactContainerForID(id);
	    if (container && containsNode(container, node)) {
	      return true;
	    }
	  }
	
	  return false;
	}
	
	/**
	 * Causes the cache to forget about one React-specific ID.
	 *
	 * @param {string} id The ID to forget.
	 */
	function purgeID(id) {
	  delete nodeCache[id];
	}
	
	var deepestNodeSoFar = null;
	function findDeepestCachedAncestorImpl(ancestorID) {
	  var ancestor = nodeCache[ancestorID];
	  if (ancestor && isValid(ancestor, ancestorID)) {
	    deepestNodeSoFar = ancestor;
	  } else {
	    // This node isn't populated in the cache, so presumably none of its
	    // descendants are. Break out of the loop.
	    return false;
	  }
	}
	
	/**
	 * Return the deepest cached node whose ID is a prefix of `targetID`.
	 */
	function findDeepestCachedAncestor(targetID) {
	  deepestNodeSoFar = null;
	  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);
	
	  var foundNode = deepestNodeSoFar;
	  deepestNodeSoFar = null;
	  return foundNode;
	}
	
	/**
	 * Mounts this component and inserts it into the DOM.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {string} rootID DOM ID of the root node.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {ReactReconcileTransaction} transaction
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {
	  if (ReactDOMFeatureFlags.useCreateElement) {
	    context = assign({}, context);
	    if (container.nodeType === DOC_NODE_TYPE) {
	      context[ownerDocumentContextKey] = container;
	    } else {
	      context[ownerDocumentContextKey] = container.ownerDocument;
	    }
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    if (context === emptyObject) {
	      context = {};
	    }
	    var tag = container.nodeName.toLowerCase();
	    context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(null, tag, null);
	  }
	  var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, context);
	  componentInstance._renderedComponent._topLevelWrapper = componentInstance;
	  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup, transaction);
	}
	
	/**
	 * Batched mount.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {string} rootID DOM ID of the root node.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup, context) {
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* forceHTML */shouldReuseMarkup);
	  transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	}
	
	/**
	 * Unmounts a component and removes it from the DOM.
	 *
	 * @param {ReactComponent} instance React component instance.
	 * @param {DOMElement} container DOM element to unmount from.
	 * @final
	 * @internal
	 * @see {ReactMount.unmountComponentAtNode}
	 */
	function unmountComponentFromNode(instance, container) {
	  ReactReconciler.unmountComponent(instance);
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    container = container.documentElement;
	  }
	
	  // http://jsperf.com/emptying-a-node
	  while (container.lastChild) {
	    container.removeChild(container.lastChild);
	  }
	}
	
	/**
	 * True if the supplied DOM node has a direct React-rendered child that is
	 * not a React root element. Useful for warning in `render`,
	 * `unmountComponentAtNode`, etc.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM element contains a direct child that was
	 * rendered by React but is not a root element.
	 * @internal
	 */
	function hasNonRootReactChild(node) {
	  var reactRootID = getReactRootID(node);
	  return reactRootID ? reactRootID !== ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID) : false;
	}
	
	/**
	 * Returns the first (deepest) ancestor of a node which is rendered by this copy
	 * of React.
	 */
	function findFirstReactDOMImpl(node) {
	  // This node might be from another React instance, so we make sure not to
	  // examine the node cache here
	  for (; node && node.parentNode !== node; node = node.parentNode) {
	    if (node.nodeType !== 1) {
	      // Not a DOMElement, therefore not a React component
	      continue;
	    }
	    var nodeID = internalGetID(node);
	    if (!nodeID) {
	      continue;
	    }
	    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
	
	    // If containersByReactRootID contains the container we find by crawling up
	    // the tree, we know that this instance of React rendered the node.
	    // nb. isValid's strategy (with containsNode) does not work because render
	    // trees may be nested and we don't want a false positive in that case.
	    var current = node;
	    var lastID;
	    do {
	      lastID = internalGetID(current);
	      current = current.parentNode;
	      if (current == null) {
	        // The passed-in node has been detached from the container it was
	        // originally rendered into.
	        return null;
	      }
	    } while (lastID !== reactRootID);
	
	    if (current === containersByReactRootID[reactRootID]) {
	      return node;
	    }
	  }
	  return null;
	}
	
	/**
	 * Temporary (?) hack so that we can store all top-level pending updates on
	 * composites instead of having to worry about different types of components
	 * here.
	 */
	var TopLevelWrapper = function TopLevelWrapper() {};
	TopLevelWrapper.prototype.isReactComponent = {};
	if (process.env.NODE_ENV !== 'production') {
	  TopLevelWrapper.displayName = 'TopLevelWrapper';
	}
	TopLevelWrapper.prototype.render = function () {
	  // this.props is actually a ReactElement
	  return this.props;
	};
	
	/**
	 * Mounting is the process of initializing a React component by creating its
	 * representative DOM elements and inserting them into a supplied `container`.
	 * Any prior content inside `container` is destroyed in the process.
	 *
	 *   ReactMount.render(
	 *     component,
	 *     document.getElementById('container')
	 *   );
	 *
	 *   <div id="container">                   <-- Supplied `container`.
	 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
	 *       // ...                                 component.
	 *     </div>
	 *   </div>
	 *
	 * Inside of `container`, the first element rendered is the "reactRoot".
	 */
	var ReactMount = {
	
	  TopLevelWrapper: TopLevelWrapper,
	
	  /** Exposed for debugging purposes **/
	  _instancesByReactRootID: instancesByReactRootID,
	
	  /**
	   * This is a hook provided to support rendering React components while
	   * ensuring that the apparent scroll position of its `container` does not
	   * change.
	   *
	   * @param {DOMElement} container The `container` being rendered into.
	   * @param {function} renderCallback This must be called once to do the render.
	   */
	  scrollMonitor: function scrollMonitor(container, renderCallback) {
	    renderCallback();
	  },
	
	  /**
	   * Take a component that's already mounted into the DOM and replace its props
	   * @param {ReactComponent} prevComponent component instance already in the DOM
	   * @param {ReactElement} nextElement component instance to render
	   * @param {DOMElement} container container to render into
	   * @param {?function} callback function triggered on completion
	   */
	  _updateRootComponent: function _updateRootComponent(prevComponent, nextElement, container, callback) {
	    ReactMount.scrollMonitor(container, function () {
	      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);
	      if (callback) {
	        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
	      }
	    });
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Record the root element in case it later gets transplanted.
	      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);
	    }
	
	    return prevComponent;
	  },
	
	  /**
	   * Register a component into the instance map and starts scroll value
	   * monitoring
	   * @param {ReactComponent} nextComponent component instance to render
	   * @param {DOMElement} container container to render into
	   * @return {string} reactRoot ID prefix
	   */
	  _registerComponent: function _registerComponent(nextComponent, container) {
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : undefined;
	
	    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
	
	    var reactRootID = ReactMount.registerContainer(container);
	    instancesByReactRootID[reactRootID] = nextComponent;
	    return reactRootID;
	  },
	
	  /**
	   * Render a new component into the DOM.
	   * @param {ReactElement} nextElement element to render
	   * @param {DOMElement} container container to render into
	   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
	   * @return {ReactComponent} nextComponent
	   */
	  _renderNewRootComponent: function _renderNewRootComponent(nextElement, container, shouldReuseMarkup, context) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case.
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;
	
	    var componentInstance = instantiateReactComponent(nextElement, null);
	    var reactRootID = ReactMount._registerComponent(componentInstance, container);
	
	    // The initial render is synchronous but any updates that happen during
	    // rendering, in componentWillMount or componentDidMount, will be batched
	    // according to the current batching strategy.
	
	    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup, context);
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Record the root element in case it later gets transplanted.
	      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);
	    }
	
	    return componentInstance;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  renderSubtreeIntoContainer: function renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {
	    !(parentComponent != null && parentComponent._reactInternalInstance != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : undefined;
	    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
	  },
	
	  _renderSubtreeIntoContainer: function _renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {
	    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' :
	    // Check if it quacks like an element
	    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : undefined;
	
	    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : undefined;
	
	    var nextWrappedElement = new ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);
	
	    var prevComponent = instancesByReactRootID[getReactRootID(container)];
	
	    if (prevComponent) {
	      var prevWrappedElement = prevComponent._currentElement;
	      var prevElement = prevWrappedElement.props;
	      if (shouldUpdateReactComponent(prevElement, nextElement)) {
	        var publicInst = prevComponent._renderedComponent.getPublicInstance();
	        var updatedCallback = callback && function () {
	          callback.call(publicInst);
	        };
	        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, container, updatedCallback);
	        return publicInst;
	      } else {
	        ReactMount.unmountComponentAtNode(container);
	      }
	    }
	
	    var reactRootElement = getReactRootElementInContainer(container);
	    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
	    var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : undefined;
	
	      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
	        var rootElementSibling = reactRootElement;
	        while (rootElementSibling) {
	          if (internalGetID(rootElementSibling)) {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : undefined;
	            break;
	          }
	          rootElementSibling = rootElementSibling.nextSibling;
	        }
	      }
	    }
	
	    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
	    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject)._renderedComponent.getPublicInstance();
	    if (callback) {
	      callback.call(component);
	    }
	    return component;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  render: function render(nextElement, container, callback) {
	    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
	  },
	
	  /**
	   * Registers a container node into which React components will be rendered.
	   * This also creates the "reactRoot" ID that will be assigned to the element
	   * rendered within.
	   *
	   * @param {DOMElement} container DOM element to register as a container.
	   * @return {string} The "reactRoot" ID of elements rendered within.
	   */
	  registerContainer: function registerContainer(container) {
	    var reactRootID = getReactRootID(container);
	    if (reactRootID) {
	      // If one exists, make sure it is a valid "reactRoot" ID.
	      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
	    }
	    if (!reactRootID) {
	      // No valid "reactRoot" ID found, create one.
	      reactRootID = ReactInstanceHandles.createReactRootID();
	    }
	    containersByReactRootID[reactRootID] = container;
	    return reactRootID;
	  },
	
	  /**
	   * Unmounts and destroys the React component rendered in the `container`.
	   *
	   * @param {DOMElement} container DOM element containing a React component.
	   * @return {boolean} True if a component was found in and unmounted from
	   *                   `container`
	   */
	  unmountComponentAtNode: function unmountComponentAtNode(container) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case. (Strictly speaking, unmounting won't cause a
	    // render but we still don't expect to be in a render call here.)
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;
	
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : undefined;
	
	    var reactRootID = getReactRootID(container);
	    var component = instancesByReactRootID[reactRootID];
	    if (!component) {
	      // Check if the node being unmounted was rendered by React, but isn't a
	      // root node.
	      var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	      // Check if the container itself is a React root node.
	      var containerID = internalGetID(container);
	      var isContainerReactRoot = containerID && containerID === ReactInstanceHandles.getReactRootIDFromNodeID(containerID);
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : undefined;
	      }
	
	      return false;
	    }
	    ReactUpdates.batchedUpdates(unmountComponentFromNode, component, container);
	    delete instancesByReactRootID[reactRootID];
	    delete containersByReactRootID[reactRootID];
	    if (process.env.NODE_ENV !== 'production') {
	      delete rootElementsByReactRootID[reactRootID];
	    }
	    return true;
	  },
	
	  /**
	   * Finds the container DOM element that contains React component to which the
	   * supplied DOM `id` belongs.
	   *
	   * @param {string} id The ID of an element rendered by a React component.
	   * @return {?DOMElement} DOM element that contains the `id`.
	   */
	  findReactContainerForID: function findReactContainerForID(id) {
	    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
	    var container = containersByReactRootID[reactRootID];
	
	    if (process.env.NODE_ENV !== 'production') {
	      var rootElement = rootElementsByReactRootID[reactRootID];
	      if (rootElement && rootElement.parentNode !== container) {
	        process.env.NODE_ENV !== 'production' ? warning(
	        // Call internalGetID here because getID calls isValid which calls
	        // findReactContainerForID (this function).
	        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : undefined;
	        var containerChild = container.firstChild;
	        if (containerChild && reactRootID === internalGetID(containerChild)) {
	          // If the container has a new child with the same ID as the old
	          // root element, then rootElementsByReactRootID[reactRootID] is
	          // just stale and needs to be updated. The case that deserves a
	          // warning is when the container is empty.
	          rootElementsByReactRootID[reactRootID] = containerChild;
	        } else {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container: %s', rootElement.parentNode) : undefined;
	        }
	      }
	    }
	
	    return container;
	  },
	
	  /**
	   * Finds an element rendered by React with the supplied ID.
	   *
	   * @param {string} id ID of a DOM node in the React component.
	   * @return {DOMElement} Root DOM node of the React component.
	   */
	  findReactNodeByID: function findReactNodeByID(id) {
	    var reactRoot = ReactMount.findReactContainerForID(id);
	    return ReactMount.findComponentRoot(reactRoot, id);
	  },
	
	  /**
	   * Traverses up the ancestors of the supplied node to find a node that is a
	   * DOM representation of a React component rendered by this copy of React.
	   *
	   * @param {*} node
	   * @return {?DOMEventTarget}
	   * @internal
	   */
	  getFirstReactDOM: function getFirstReactDOM(node) {
	    return findFirstReactDOMImpl(node);
	  },
	
	  /**
	   * Finds a node with the supplied `targetID` inside of the supplied
	   * `ancestorNode`.  Exploits the ID naming scheme to perform the search
	   * quickly.
	   *
	   * @param {DOMEventTarget} ancestorNode Search from this root.
	   * @pararm {string} targetID ID of the DOM representation of the component.
	   * @return {DOMEventTarget} DOM node with the supplied `targetID`.
	   * @internal
	   */
	  findComponentRoot: function findComponentRoot(ancestorNode, targetID) {
	    var firstChildren = findComponentRootReusableArray;
	    var childIndex = 0;
	
	    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This will throw on the next line; give an early warning
	      process.env.NODE_ENV !== 'production' ? warning(deepestAncestor != null, 'React can\'t find the root component node for data-reactid value ' + '`%s`. If you\'re seeing this message, it probably means that ' + 'you\'ve loaded two copies of React on the page. At this time, only ' + 'a single copy of React can be loaded at a time.', targetID) : undefined;
	    }
	
	    firstChildren[0] = deepestAncestor.firstChild;
	    firstChildren.length = 1;
	
	    while (childIndex < firstChildren.length) {
	      var child = firstChildren[childIndex++];
	      var targetChild;
	
	      while (child) {
	        var childID = ReactMount.getID(child);
	        if (childID) {
	          // Even if we find the node we're looking for, we finish looping
	          // through its siblings to ensure they're cached so that we don't have
	          // to revisit this node again. Otherwise, we make n^2 calls to getID
	          // when visiting the many children of a single node in order.
	
	          if (targetID === childID) {
	            targetChild = child;
	          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
	            // If we find a child whose ID is an ancestor of the given ID,
	            // then we can be sure that we only want to search the subtree
	            // rooted at this child, so we can throw out the rest of the
	            // search state.
	            firstChildren.length = childIndex = 0;
	            firstChildren.push(child.firstChild);
	          }
	        } else {
	          // If this child had no ID, then there's a chance that it was
	          // injected automatically by the browser, as when a `<table>`
	          // element sprouts an extra `<tbody>` child as a side effect of
	          // `.innerHTML` parsing. Optimistically continue down this
	          // branch, but not before examining the other siblings.
	          firstChildren.push(child.firstChild);
	        }
	
	        child = child.nextSibling;
	      }
	
	      if (targetChild) {
	        // Emptying firstChildren/findComponentRootReusableArray is
	        // not necessary for correctness, but it helps the GC reclaim
	        // any nodes that were left at the end of the search.
	        firstChildren.length = 0;
	
	        return targetChild;
	      }
	    }
	
	    firstChildren.length = 0;
	
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false) : undefined;
	  },
	
	  _mountImageIntoNode: function _mountImageIntoNode(markup, container, shouldReuseMarkup, transaction) {
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : undefined;
	
	    if (shouldReuseMarkup) {
	      var rootElement = getReactRootElementInContainer(container);
	      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
	        return;
	      } else {
	        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	
	        var rootMarkup = rootElement.outerHTML;
	        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
	
	        var normalizedMarkup = markup;
	        if (process.env.NODE_ENV !== 'production') {
	          // because rootMarkup is retrieved from the DOM, various normalizations
	          // will have occurred which will not be present in `markup`. Here,
	          // insert markup into a <div> or <iframe> depending on the container
	          // type to perform the same normalizations before comparing.
	          var normalizer;
	          if (container.nodeType === ELEMENT_NODE_TYPE) {
	            normalizer = document.createElement('div');
	            normalizer.innerHTML = markup;
	            normalizedMarkup = normalizer.innerHTML;
	          } else {
	            normalizer = document.createElement('iframe');
	            document.body.appendChild(normalizer);
	            normalizer.contentDocument.write(markup);
	            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
	            document.body.removeChild(normalizer);
	          }
	        }
	
	        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
	        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
	
	        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\n%s', difference) : invariant(false) : undefined;
	
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : undefined;
	        }
	      }
	    }
	
	    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but ' + 'you didn\'t use server rendering. We can\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;
	
	    if (transaction.useCreateElement) {
	      while (container.lastChild) {
	        container.removeChild(container.lastChild);
	      }
	      container.appendChild(markup);
	    } else {
	      setInnerHTML(container, markup);
	    }
	  },
	
	  ownerDocumentContextKey: ownerDocumentContextKey,
	
	  /**
	   * React ID utilities.
	   */
	
	  getReactRootID: getReactRootID,
	
	  getID: getID,
	
	  setID: setID,
	
	  getNode: getNode,
	
	  getNodeFromInstance: getNodeFromInstance,
	
	  isValid: isValid,
	
	  purgeID: purgeID
	};
	
	ReactPerf.measureMethods(ReactMount, 'ReactMount', {
	  _renderNewRootComponent: '_renderNewRootComponent',
	  _mountImageIntoNode: '_mountImageIntoNode'
	});
	
	module.exports = ReactMount;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserEventEmitter
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var EventPluginHub = __webpack_require__(38);
	var EventPluginRegistry = __webpack_require__(39);
	var ReactEventEmitterMixin = __webpack_require__(44);
	var ReactPerf = __webpack_require__(25);
	var ViewportMetrics = __webpack_require__(45);
	
	var assign = __webpack_require__(46);
	var isEventSupported = __webpack_require__(47);
	
	/**
	 * Summary of `ReactBrowserEventEmitter` event handling:
	 *
	 *  - Top-level delegation is used to trap most native browser events. This
	 *    may only occur in the main thread and is the responsibility of
	 *    ReactEventListener, which is injected and can therefore support pluggable
	 *    event sources. This is the only work that occurs in the main thread.
	 *
	 *  - We normalize and de-duplicate events to account for browser quirks. This
	 *    may be done in the worker thread.
	 *
	 *  - Forward these native events (with the associated top-level type used to
	 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
	 *    to extract any synthetic events.
	 *
	 *  - The `EventPluginHub` will then process each event by annotating them with
	 *    "dispatches", a sequence of listeners and IDs that care about that event.
	 *
	 *  - The `EventPluginHub` then dispatches the events.
	 *
	 * Overview of React and the event system:
	 *
	 * +------------+    .
	 * |    DOM     |    .
	 * +------------+    .
	 *       |           .
	 *       v           .
	 * +------------+    .
	 * | ReactEvent |    .
	 * |  Listener  |    .
	 * +------------+    .                         +-----------+
	 *       |           .               +--------+|SimpleEvent|
	 *       |           .               |         |Plugin     |
	 * +-----|------+    .               v         +-----------+
	 * |     |      |    .    +--------------+                    +------------+
	 * |     +-----------.--->|EventPluginHub|                    |    Event   |
	 * |            |    .    |              |     +-----------+  | Propagators|
	 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
	 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
	 * |            |    .    |              |     +-----------+  |  utilities |
	 * |     +-----------.--->|              |                    +------------+
	 * |     |      |    .    +--------------+
	 * +-----|------+    .                ^        +-----------+
	 *       |           .                |        |Enter/Leave|
	 *       +           .                +-------+|Plugin     |
	 * +-------------+   .                         +-----------+
	 * | application |   .
	 * |-------------|   .
	 * |             |   .
	 * |             |   .
	 * +-------------+   .
	 *                   .
	 *    React Core     .  General Purpose Event Plugin System
	 */
	
	var alreadyListeningTo = {};
	var isMonitoringScrollValue = false;
	var reactTopListenersCounter = 0;
	
	// For events like 'submit' which don't consistently bubble (which we trap at a
	// lower node than `document`), binding at `document` would cause duplicate
	// events so we don't include them here
	var topEventMapping = {
	  topAbort: 'abort',
	  topBlur: 'blur',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topChange: 'change',
	  topClick: 'click',
	  topCompositionEnd: 'compositionend',
	  topCompositionStart: 'compositionstart',
	  topCompositionUpdate: 'compositionupdate',
	  topContextMenu: 'contextmenu',
	  topCopy: 'copy',
	  topCut: 'cut',
	  topDoubleClick: 'dblclick',
	  topDrag: 'drag',
	  topDragEnd: 'dragend',
	  topDragEnter: 'dragenter',
	  topDragExit: 'dragexit',
	  topDragLeave: 'dragleave',
	  topDragOver: 'dragover',
	  topDragStart: 'dragstart',
	  topDrop: 'drop',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topFocus: 'focus',
	  topInput: 'input',
	  topKeyDown: 'keydown',
	  topKeyPress: 'keypress',
	  topKeyUp: 'keyup',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topMouseDown: 'mousedown',
	  topMouseMove: 'mousemove',
	  topMouseOut: 'mouseout',
	  topMouseOver: 'mouseover',
	  topMouseUp: 'mouseup',
	  topPaste: 'paste',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topScroll: 'scroll',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topSelectionChange: 'selectionchange',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTextInput: 'textInput',
	  topTimeUpdate: 'timeupdate',
	  topTouchCancel: 'touchcancel',
	  topTouchEnd: 'touchend',
	  topTouchMove: 'touchmove',
	  topTouchStart: 'touchstart',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting',
	  topWheel: 'wheel'
	};
	
	/**
	 * To ensure no conflicts with other potential React instances on the page
	 */
	var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
	
	function getListeningForDocument(mountAt) {
	  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
	  // directly.
	  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
	    mountAt[topListenersIDKey] = reactTopListenersCounter++;
	    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
	  }
	  return alreadyListeningTo[mountAt[topListenersIDKey]];
	}
	
	/**
	 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
	 * example:
	 *
	 *   ReactBrowserEventEmitter.putListener('myID', 'onClick', myFunction);
	 *
	 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
	 *
	 * @internal
	 */
	var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {
	
	  /**
	   * Injectable event backend
	   */
	  ReactEventListener: null,
	
	  injection: {
	    /**
	     * @param {object} ReactEventListener
	     */
	    injectReactEventListener: function injectReactEventListener(ReactEventListener) {
	      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
	      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
	    }
	  },
	
	  /**
	   * Sets whether or not any created callbacks should be enabled.
	   *
	   * @param {boolean} enabled True if callbacks should be enabled.
	   */
	  setEnabled: function setEnabled(enabled) {
	    if (ReactBrowserEventEmitter.ReactEventListener) {
	      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
	    }
	  },
	
	  /**
	   * @return {boolean} True if callbacks are enabled.
	   */
	  isEnabled: function isEnabled() {
	    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
	  },
	
	  /**
	   * We listen for bubbled touch events on the document object.
	   *
	   * Firefox v8.01 (and possibly others) exhibited strange behavior when
	   * mounting `onmousemove` events at some node that was not the document
	   * element. The symptoms were that if your mouse is not moving over something
	   * contained within that mount point (for example on the background) the
	   * top-level listeners for `onmousemove` won't be called. However, if you
	   * register the `mousemove` on the document object, then it will of course
	   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
	   * top-level listeners to the document object only, at least for these
	   * movement types of events and possibly all events.
	   *
	   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	   *
	   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
	   * they bubble to document.
	   *
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {object} contentDocumentHandle Document which owns the container
	   */
	  listenTo: function listenTo(registrationName, contentDocumentHandle) {
	    var mountAt = contentDocumentHandle;
	    var isListening = getListeningForDocument(mountAt);
	    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
	
	    var topLevelTypes = EventConstants.topLevelTypes;
	    for (var i = 0; i < dependencies.length; i++) {
	      var dependency = dependencies[i];
	      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
	        if (dependency === topLevelTypes.topWheel) {
	          if (isEventSupported('wheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
	          } else if (isEventSupported('mousewheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
	          } else {
	            // Firefox needs to capture a different mouse scroll event.
	            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
	          }
	        } else if (dependency === topLevelTypes.topScroll) {
	
	          if (isEventSupported('scroll', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
	          } else {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
	          }
	        } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {
	
	          if (isEventSupported('focus', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
	          } else if (isEventSupported('focusin')) {
	            // IE has `focusin` and `focusout` events which bubble.
	            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
	          }
	
	          // to make sure blur and focus event listeners are only attached once
	          isListening[topLevelTypes.topBlur] = true;
	          isListening[topLevelTypes.topFocus] = true;
	        } else if (topEventMapping.hasOwnProperty(dependency)) {
	          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
	        }
	
	        isListening[dependency] = true;
	      }
	    }
	  },
	
	  trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  /**
	   * Listens to window scroll and resize events. We cache scroll values so that
	   * application code can access them without triggering reflows.
	   *
	   * NOTE: Scroll events do not bubble.
	   *
	   * @see http://www.quirksmode.org/dom/events/scroll.html
	   */
	  ensureScrollValueMonitoring: function ensureScrollValueMonitoring() {
	    if (!isMonitoringScrollValue) {
	      var refresh = ViewportMetrics.refreshScrollValues;
	      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
	      isMonitoringScrollValue = true;
	    }
	  },
	
	  eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,
	
	  registrationNameModules: EventPluginHub.registrationNameModules,
	
	  putListener: EventPluginHub.putListener,
	
	  getListener: EventPluginHub.getListener,
	
	  deleteListener: EventPluginHub.deleteListener,
	
	  deleteAllListeners: EventPluginHub.deleteAllListeners
	
	});
	
	ReactPerf.measureMethods(ReactBrowserEventEmitter, 'ReactBrowserEventEmitter', {
	  putListener: 'putListener',
	  deleteListener: 'deleteListener'
	});
	
	module.exports = ReactBrowserEventEmitter;

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventConstants
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(24);
	
	var PropagationPhases = keyMirror({ bubbled: null, captured: null });
	
	/**
	 * Types of raw signals from the browser caught at the top level.
	 */
	var topLevelTypes = keyMirror({
	  topAbort: null,
	  topBlur: null,
	  topCanPlay: null,
	  topCanPlayThrough: null,
	  topChange: null,
	  topClick: null,
	  topCompositionEnd: null,
	  topCompositionStart: null,
	  topCompositionUpdate: null,
	  topContextMenu: null,
	  topCopy: null,
	  topCut: null,
	  topDoubleClick: null,
	  topDrag: null,
	  topDragEnd: null,
	  topDragEnter: null,
	  topDragExit: null,
	  topDragLeave: null,
	  topDragOver: null,
	  topDragStart: null,
	  topDrop: null,
	  topDurationChange: null,
	  topEmptied: null,
	  topEncrypted: null,
	  topEnded: null,
	  topError: null,
	  topFocus: null,
	  topInput: null,
	  topKeyDown: null,
	  topKeyPress: null,
	  topKeyUp: null,
	  topLoad: null,
	  topLoadedData: null,
	  topLoadedMetadata: null,
	  topLoadStart: null,
	  topMouseDown: null,
	  topMouseMove: null,
	  topMouseOut: null,
	  topMouseOver: null,
	  topMouseUp: null,
	  topPaste: null,
	  topPause: null,
	  topPlay: null,
	  topPlaying: null,
	  topProgress: null,
	  topRateChange: null,
	  topReset: null,
	  topScroll: null,
	  topSeeked: null,
	  topSeeking: null,
	  topSelectionChange: null,
	  topStalled: null,
	  topSubmit: null,
	  topSuspend: null,
	  topTextInput: null,
	  topTimeUpdate: null,
	  topTouchCancel: null,
	  topTouchEnd: null,
	  topTouchMove: null,
	  topTouchStart: null,
	  topVolumeChange: null,
	  topWaiting: null,
	  topWheel: null
	});
	
	var EventConstants = {
	  topLevelTypes: topLevelTypes,
	  PropagationPhases: PropagationPhases
	};
	
	module.exports = EventConstants;

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginHub
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var EventPluginRegistry = __webpack_require__(39);
	var EventPluginUtils = __webpack_require__(40);
	var ReactErrorUtils = __webpack_require__(41);
	
	var accumulateInto = __webpack_require__(42);
	var forEachAccumulated = __webpack_require__(43);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	/**
	 * Internal store for event listeners
	 */
	var listenerBank = {};
	
	/**
	 * Internal queue of events that have accumulated their dispatches and are
	 * waiting to have their dispatches executed.
	 */
	var eventQueue = null;
	
	/**
	 * Dispatches an event and releases it back into the pool, unless persistent.
	 *
	 * @param {?object} event Synthetic event to be dispatched.
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @private
	 */
	var executeDispatchesAndRelease = function executeDispatchesAndRelease(event, simulated) {
	  if (event) {
	    EventPluginUtils.executeDispatchesInOrder(event, simulated);
	
	    if (!event.isPersistent()) {
	      event.constructor.release(event);
	    }
	  }
	};
	var executeDispatchesAndReleaseSimulated = function executeDispatchesAndReleaseSimulated(e) {
	  return executeDispatchesAndRelease(e, true);
	};
	var executeDispatchesAndReleaseTopLevel = function executeDispatchesAndReleaseTopLevel(e) {
	  return executeDispatchesAndRelease(e, false);
	};
	
	/**
	 * - `InstanceHandle`: [required] Module that performs logical traversals of DOM
	 *   hierarchy given ids of the logical DOM elements involved.
	 */
	var InstanceHandle = null;
	
	function validateInstanceHandle() {
	  var valid = InstanceHandle && InstanceHandle.traverseTwoPhase && InstanceHandle.traverseEnterLeave;
	  process.env.NODE_ENV !== 'production' ? warning(valid, 'InstanceHandle not injected before use!') : undefined;
	}
	
	/**
	 * This is a unified interface for event plugins to be installed and configured.
	 *
	 * Event plugins can implement the following properties:
	 *
	 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
	 *     Required. When a top-level event is fired, this method is expected to
	 *     extract synthetic events that will in turn be queued and dispatched.
	 *
	 *   `eventTypes` {object}
	 *     Optional, plugins that fire events must publish a mapping of registration
	 *     names that are used to register listeners. Values of this mapping must
	 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
	 *
	 *   `executeDispatch` {function(object, function, string)}
	 *     Optional, allows plugins to override how an event gets dispatched. By
	 *     default, the listener is simply invoked.
	 *
	 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
	 *
	 * @public
	 */
	var EventPluginHub = {
	
	  /**
	   * Methods for injecting dependencies.
	   */
	  injection: {
	
	    /**
	     * @param {object} InjectedMount
	     * @public
	     */
	    injectMount: EventPluginUtils.injection.injectMount,
	
	    /**
	     * @param {object} InjectedInstanceHandle
	     * @public
	     */
	    injectInstanceHandle: function injectInstanceHandle(InjectedInstanceHandle) {
	      InstanceHandle = InjectedInstanceHandle;
	      if (process.env.NODE_ENV !== 'production') {
	        validateInstanceHandle();
	      }
	    },
	
	    getInstanceHandle: function getInstanceHandle() {
	      if (process.env.NODE_ENV !== 'production') {
	        validateInstanceHandle();
	      }
	      return InstanceHandle;
	    },
	
	    /**
	     * @param {array} InjectedEventPluginOrder
	     * @public
	     */
	    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
	
	    /**
	     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	     */
	    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
	
	  },
	
	  eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,
	
	  registrationNameModules: EventPluginRegistry.registrationNameModules,
	
	  /**
	   * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.
	   *
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {?function} listener The callback to store.
	   */
	  putListener: function putListener(id, registrationName, listener) {
	    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) : invariant(false) : undefined;
	
	    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
	    bankForRegistrationName[id] = listener;
	
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.didPutListener) {
	      PluginModule.didPutListener(id, registrationName, listener);
	    }
	  },
	
	  /**
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @return {?function} The stored callback.
	   */
	  getListener: function getListener(id, registrationName) {
	    var bankForRegistrationName = listenerBank[registrationName];
	    return bankForRegistrationName && bankForRegistrationName[id];
	  },
	
	  /**
	   * Deletes a listener from the registration bank.
	   *
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   */
	  deleteListener: function deleteListener(id, registrationName) {
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.willDeleteListener) {
	      PluginModule.willDeleteListener(id, registrationName);
	    }
	
	    var bankForRegistrationName = listenerBank[registrationName];
	    // TODO: This should never be null -- when is it?
	    if (bankForRegistrationName) {
	      delete bankForRegistrationName[id];
	    }
	  },
	
	  /**
	   * Deletes all listeners for the DOM element with the supplied ID.
	   *
	   * @param {string} id ID of the DOM element.
	   */
	  deleteAllListeners: function deleteAllListeners(id) {
	    for (var registrationName in listenerBank) {
	      if (!listenerBank[registrationName][id]) {
	        continue;
	      }
	
	      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	      if (PluginModule && PluginModule.willDeleteListener) {
	        PluginModule.willDeleteListener(id, registrationName);
	      }
	
	      delete listenerBank[registrationName][id];
	    }
	  },
	
	  /**
	   * Allows registered plugins an opportunity to extract events from top-level
	   * native browser events.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @internal
	   */
	  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var events;
	    var plugins = EventPluginRegistry.plugins;
	    for (var i = 0; i < plugins.length; i++) {
	      // Not every plugin in the ordering may be loaded at runtime.
	      var possiblePlugin = plugins[i];
	      if (possiblePlugin) {
	        var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
	        if (extractedEvents) {
	          events = accumulateInto(events, extractedEvents);
	        }
	      }
	    }
	    return events;
	  },
	
	  /**
	   * Enqueues a synthetic event that should be dispatched when
	   * `processEventQueue` is invoked.
	   *
	   * @param {*} events An accumulation of synthetic events.
	   * @internal
	   */
	  enqueueEvents: function enqueueEvents(events) {
	    if (events) {
	      eventQueue = accumulateInto(eventQueue, events);
	    }
	  },
	
	  /**
	   * Dispatches all synthetic events on the event queue.
	   *
	   * @internal
	   */
	  processEventQueue: function processEventQueue(simulated) {
	    // Set `eventQueue` to null before processing it so that we can tell if more
	    // events get enqueued while processing.
	    var processingEventQueue = eventQueue;
	    eventQueue = null;
	    if (simulated) {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
	    } else {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
	    }
	    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.') : invariant(false) : undefined;
	    // This would be a good time to rethrow if any of the event handlers threw.
	    ReactErrorUtils.rethrowCaughtError();
	  },
	
	  /**
	   * These are needed for tests only. Do not use!
	   */
	  __purge: function __purge() {
	    listenerBank = {};
	  },
	
	  __getListenerBank: function __getListenerBank() {
	    return listenerBank;
	  }
	
	};
	
	module.exports = EventPluginHub;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginRegistry
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Injectable ordering of event plugins.
	 */
	var EventPluginOrder = null;
	
	/**
	 * Injectable mapping from names to event plugin modules.
	 */
	var namesToPlugins = {};
	
	/**
	 * Recomputes the plugin list using the injected plugins and plugin ordering.
	 *
	 * @private
	 */
	function recomputePluginOrdering() {
	  if (!EventPluginOrder) {
	    // Wait until an `EventPluginOrder` is injected.
	    return;
	  }
	  for (var pluginName in namesToPlugins) {
	    var PluginModule = namesToPlugins[pluginName];
	    var pluginIndex = EventPluginOrder.indexOf(pluginName);
	    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(false) : undefined;
	    if (EventPluginRegistry.plugins[pluginIndex]) {
	      continue;
	    }
	    !PluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(false) : undefined;
	    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
	    var publishedEvents = PluginModule.eventTypes;
	    for (var eventName in publishedEvents) {
	      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(false) : undefined;
	    }
	  }
	}
	
	/**
	 * Publishes an event so that it can be dispatched by the supplied plugin.
	 *
	 * @param {object} dispatchConfig Dispatch configuration for the event.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @return {boolean} True if the event was successfully published.
	 * @private
	 */
	function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
	  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(false) : undefined;
	  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
	
	  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	  if (phasedRegistrationNames) {
	    for (var phaseName in phasedRegistrationNames) {
	      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
	        var phasedRegistrationName = phasedRegistrationNames[phaseName];
	        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
	      }
	    }
	    return true;
	  } else if (dispatchConfig.registrationName) {
	    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
	    return true;
	  }
	  return false;
	}
	
	/**
	 * Publishes a registration name that is used to identify dispatched events and
	 * can be used with `EventPluginHub.putListener` to register listeners.
	 *
	 * @param {string} registrationName Registration name to add.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @private
	 */
	function publishRegistrationName(registrationName, PluginModule, eventName) {
	  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(false) : undefined;
	  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
	  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
	}
	
	/**
	 * Registers plugins so that they can extract and dispatch events.
	 *
	 * @see {EventPluginHub}
	 */
	var EventPluginRegistry = {
	
	  /**
	   * Ordered list of injected plugins.
	   */
	  plugins: [],
	
	  /**
	   * Mapping from event name to dispatch config
	   */
	  eventNameDispatchConfigs: {},
	
	  /**
	   * Mapping from registration name to plugin module
	   */
	  registrationNameModules: {},
	
	  /**
	   * Mapping from registration name to event name
	   */
	  registrationNameDependencies: {},
	
	  /**
	   * Injects an ordering of plugins (by plugin name). This allows the ordering
	   * to be decoupled from injection of the actual plugins so that ordering is
	   * always deterministic regardless of packaging, on-the-fly injection, etc.
	   *
	   * @param {array} InjectedEventPluginOrder
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginOrder}
	   */
	  injectEventPluginOrder: function injectEventPluginOrder(InjectedEventPluginOrder) {
	    !!EventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(false) : undefined;
	    // Clone the ordering so it cannot be dynamically mutated.
	    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
	    recomputePluginOrdering();
	  },
	
	  /**
	   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
	   * in the ordering injected by `injectEventPluginOrder`.
	   *
	   * Plugins can be injected as part of page initialization or on-the-fly.
	   *
	   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginsByName}
	   */
	  injectEventPluginsByName: function injectEventPluginsByName(injectedNamesToPlugins) {
	    var isOrderingDirty = false;
	    for (var pluginName in injectedNamesToPlugins) {
	      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
	        continue;
	      }
	      var PluginModule = injectedNamesToPlugins[pluginName];
	      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
	        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(false) : undefined;
	        namesToPlugins[pluginName] = PluginModule;
	        isOrderingDirty = true;
	      }
	    }
	    if (isOrderingDirty) {
	      recomputePluginOrdering();
	    }
	  },
	
	  /**
	   * Looks up the plugin for the supplied event.
	   *
	   * @param {object} event A synthetic event.
	   * @return {?object} The plugin that created the supplied event.
	   * @internal
	   */
	  getPluginModuleForEvent: function getPluginModuleForEvent(event) {
	    var dispatchConfig = event.dispatchConfig;
	    if (dispatchConfig.registrationName) {
	      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
	    }
	    for (var phase in dispatchConfig.phasedRegistrationNames) {
	      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
	        continue;
	      }
	      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
	      if (PluginModule) {
	        return PluginModule;
	      }
	    }
	    return null;
	  },
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _resetEventPlugins: function _resetEventPlugins() {
	    EventPluginOrder = null;
	    for (var pluginName in namesToPlugins) {
	      if (namesToPlugins.hasOwnProperty(pluginName)) {
	        delete namesToPlugins[pluginName];
	      }
	    }
	    EventPluginRegistry.plugins.length = 0;
	
	    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
	    for (var eventName in eventNameDispatchConfigs) {
	      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
	        delete eventNameDispatchConfigs[eventName];
	      }
	    }
	
	    var registrationNameModules = EventPluginRegistry.registrationNameModules;
	    for (var registrationName in registrationNameModules) {
	      if (registrationNameModules.hasOwnProperty(registrationName)) {
	        delete registrationNameModules[registrationName];
	      }
	    }
	  }
	
	};
	
	module.exports = EventPluginRegistry;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginUtils
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var ReactErrorUtils = __webpack_require__(41);
	
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	/**
	 * Injected dependencies:
	 */
	
	/**
	 * - `Mount`: [required] Module that can convert between React dom IDs and
	 *   actual node references.
	 */
	var injection = {
	  Mount: null,
	  injectMount: function injectMount(InjectedMount) {
	    injection.Mount = InjectedMount;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(InjectedMount && InjectedMount.getNode && InjectedMount.getID, 'EventPluginUtils.injection.injectMount(...): Injected Mount ' + 'module is missing getNode or getID.') : undefined;
	    }
	  }
	};
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	function isEndish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
	}
	
	function isMoveish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
	}
	function isStartish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
	}
	
	var validateEventDispatches;
	if (process.env.NODE_ENV !== 'production') {
	  validateEventDispatches = function validateEventDispatches(event) {
	    var dispatchListeners = event._dispatchListeners;
	    var dispatchIDs = event._dispatchIDs;
	
	    var listenersIsArr = Array.isArray(dispatchListeners);
	    var idsIsArr = Array.isArray(dispatchIDs);
	    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
	    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(idsIsArr === listenersIsArr && IDsLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : undefined;
	  };
	}
	
	/**
	 * Dispatch the event to the listener.
	 * @param {SyntheticEvent} event SyntheticEvent to handle
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @param {function} listener Application-level callback
	 * @param {string} domID DOM id to pass to the callback.
	 */
	function executeDispatch(event, simulated, listener, domID) {
	  var type = event.type || 'unknown-event';
	  event.currentTarget = injection.Mount.getNode(domID);
	  if (simulated) {
	    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event, domID);
	  } else {
	    ReactErrorUtils.invokeGuardedCallback(type, listener, event, domID);
	  }
	  event.currentTarget = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches.
	 */
	function executeDispatchesInOrder(event, simulated) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchIDs = event._dispatchIDs;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and IDs are two parallel arrays that are always in sync.
	      executeDispatch(event, simulated, dispatchListeners[i], dispatchIDs[i]);
	    }
	  } else if (dispatchListeners) {
	    executeDispatch(event, simulated, dispatchListeners, dispatchIDs);
	  }
	  event._dispatchListeners = null;
	  event._dispatchIDs = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches, but stops
	 * at the first dispatch execution returning true, and returns that id.
	 *
	 * @return {?string} id of the first dispatch execution who's listener returns
	 * true, or null if no listener returned true.
	 */
	function executeDispatchesInOrderStopAtTrueImpl(event) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchIDs = event._dispatchIDs;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and IDs are two parallel arrays that are always in sync.
	      if (dispatchListeners[i](event, dispatchIDs[i])) {
	        return dispatchIDs[i];
	      }
	    }
	  } else if (dispatchListeners) {
	    if (dispatchListeners(event, dispatchIDs)) {
	      return dispatchIDs;
	    }
	  }
	  return null;
	}
	
	/**
	 * @see executeDispatchesInOrderStopAtTrueImpl
	 */
	function executeDispatchesInOrderStopAtTrue(event) {
	  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
	  event._dispatchIDs = null;
	  event._dispatchListeners = null;
	  return ret;
	}
	
	/**
	 * Execution of a "direct" dispatch - there must be at most one dispatch
	 * accumulated on the event or it is considered an error. It doesn't really make
	 * sense for an event with multiple dispatches (bubbled) to keep track of the
	 * return values at each dispatch execution, but it does tend to make sense when
	 * dealing with "direct" dispatches.
	 *
	 * @return {*} The return value of executing the single dispatch.
	 */
	function executeDirectDispatch(event) {
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  var dispatchListener = event._dispatchListeners;
	  var dispatchID = event._dispatchIDs;
	  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : invariant(false) : undefined;
	  var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
	  event._dispatchListeners = null;
	  event._dispatchIDs = null;
	  return res;
	}
	
	/**
	 * @param {SyntheticEvent} event
	 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
	 */
	function hasDispatches(event) {
	  return !!event._dispatchListeners;
	}
	
	/**
	 * General utilities that are useful in creating custom Event Plugins.
	 */
	var EventPluginUtils = {
	  isEndish: isEndish,
	  isMoveish: isMoveish,
	  isStartish: isStartish,
	
	  executeDirectDispatch: executeDirectDispatch,
	  executeDispatchesInOrder: executeDispatchesInOrder,
	  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
	  hasDispatches: hasDispatches,
	
	  getNode: function getNode(id) {
	    return injection.Mount.getNode(id);
	  },
	  getID: function getID(node) {
	    return injection.Mount.getID(node);
	  },
	
	  injection: injection
	};
	
	module.exports = EventPluginUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactErrorUtils
	 * @typechecks
	 */
	
	'use strict';
	
	var caughtError = null;
	
	/**
	 * Call a function while guarding against errors that happens within it.
	 *
	 * @param {?String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} a First argument
	 * @param {*} b Second argument
	 */
	function invokeGuardedCallback(name, func, a, b) {
	  try {
	    return func(a, b);
	  } catch (x) {
	    if (caughtError === null) {
	      caughtError = x;
	    }
	    return undefined;
	  }
	}
	
	var ReactErrorUtils = {
	  invokeGuardedCallback: invokeGuardedCallback,
	
	  /**
	   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
	   * handler are sure to be rethrown by rethrowCaughtError.
	   */
	  invokeGuardedCallbackWithCatch: invokeGuardedCallback,
	
	  /**
	   * During execution of guarded functions we will capture the first error which
	   * we will rethrow to be handled by the top level error handler.
	   */
	  rethrowCaughtError: function rethrowCaughtError() {
	    if (caughtError) {
	      var error = caughtError;
	      caughtError = null;
	      throw error;
	    }
	  }
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  /**
	   * To help development we can get better devtools integration by simulating a
	   * real browser event.
	   */
	  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
	    var fakeNode = document.createElement('react');
	    ReactErrorUtils.invokeGuardedCallback = function (name, func, a, b) {
	      var boundFunc = func.bind(null, a, b);
	      var evtType = 'react-' + name;
	      fakeNode.addEventListener(evtType, boundFunc, false);
	      var evt = document.createEvent('Event');
	      evt.initEvent(evtType, false, false);
	      fakeNode.dispatchEvent(evt);
	      fakeNode.removeEventListener(evtType, boundFunc, false);
	    };
	  }
	}
	
	module.exports = ReactErrorUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule accumulateInto
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	/**
	 *
	 * Accumulates items that must not be null or undefined into the first one. This
	 * is used to conserve memory by avoiding array allocations, and thus sacrifices
	 * API cleanness. Since `current` can be null before being passed in and not
	 * null after this function, make sure to assign it back to `current`:
	 *
	 * `a = accumulateInto(a, b);`
	 *
	 * This API should be sparingly used. Try `accumulate` for something cleaner.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */
	
	function accumulateInto(current, next) {
	  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : invariant(false) : undefined;
	  if (current == null) {
	    return next;
	  }
	
	  // Both are not empty. Warning: Never call x.concat(y) when you are not
	  // certain that x is an Array (x could be a string with concat method).
	  var currentIsArray = Array.isArray(current);
	  var nextIsArray = Array.isArray(next);
	
	  if (currentIsArray && nextIsArray) {
	    current.push.apply(current, next);
	    return current;
	  }
	
	  if (currentIsArray) {
	    current.push(next);
	    return current;
	  }
	
	  if (nextIsArray) {
	    // A bit too dangerous to mutate `next`.
	    return [current].concat(next);
	  }
	
	  return [current, next];
	}
	
	module.exports = accumulateInto;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 43 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule forEachAccumulated
	 */
	
	'use strict';
	
	/**
	 * @param {array} arr an "accumulation" of items which is either an Array or
	 * a single item. Useful when paired with the `accumulate` module. This is a
	 * simple utility that allows us to reason about a collection of items, but
	 * handling the case when there is exactly one item (and we do not need to
	 * allocate an array).
	 */
	
	var forEachAccumulated = function forEachAccumulated(arr, cb, scope) {
	  if (Array.isArray(arr)) {
	    arr.forEach(cb, scope);
	  } else if (arr) {
	    cb.call(scope, arr);
	  }
	};
	
	module.exports = forEachAccumulated;

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventEmitterMixin
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(38);
	
	function runEventQueueInBatch(events) {
	  EventPluginHub.enqueueEvents(events);
	  EventPluginHub.processEventQueue(false);
	}
	
	var ReactEventEmitterMixin = {
	
	  /**
	   * Streams a fired top-level event to `EventPluginHub` where plugins have the
	   * opportunity to create `ReactEvent`s to be dispatched.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {object} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native environment event.
	   */
	  handleTopLevel: function handleTopLevel(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
	    runEventQueueInBatch(events);
	  }
	};
	
	module.exports = ReactEventEmitterMixin;

/***/ },
/* 45 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ViewportMetrics
	 */
	
	'use strict';
	
	var ViewportMetrics = {
	
	  currentScrollLeft: 0,
	
	  currentScrollTop: 0,
	
	  refreshScrollValues: function refreshScrollValues(scrollPosition) {
	    ViewportMetrics.currentScrollLeft = scrollPosition.x;
	    ViewportMetrics.currentScrollTop = scrollPosition.y;
	  }
	
	};
	
	module.exports = ViewportMetrics;

/***/ },
/* 46 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Object.assign
	 */
	
	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign
	
	'use strict';
	
	function assign(target, sources) {
	  if (target == null) {
	    throw new TypeError('Object.assign target cannot be null or undefined');
	  }
	
	  var to = Object(target);
	  var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
	    var nextSource = arguments[nextIndex];
	    if (nextSource == null) {
	      continue;
	    }
	
	    var from = Object(nextSource);
	
	    // We don't currently support accessors nor proxies. Therefore this
	    // copy cannot throw. If we ever supported this then we must handle
	    // exceptions and side-effects. We don't support symbols so they won't
	    // be transferred.
	
	    for (var key in from) {
	      if (hasOwnProperty.call(from, key)) {
	        to[key] = from[key];
	      }
	    }
	  }
	
	  return to;
	}
	
	module.exports = assign;

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isEventSupported
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var useHasFeature;
	if (ExecutionEnvironment.canUseDOM) {
	  useHasFeature = document.implementation && document.implementation.hasFeature &&
	  // always returns true in newer browsers as per the standard.
	  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	  document.implementation.hasFeature('', '') !== true;
	}
	
	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @param {?boolean} capture Check if the capture phase is supported.
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix, capture) {
	  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
	    return false;
	  }
	
	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = eventName in document;
	
	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }
	
	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }
	
	  return isSupported;
	}
	
	module.exports = isEventSupported;

/***/ },
/* 48 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFeatureFlags
	 */
	
	'use strict';
	
	var ReactDOMFeatureFlags = {
	  useCreateElement: false
	};
	
	module.exports = ReactDOMFeatureFlags;

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElement
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactCurrentOwner = __webpack_require__(12);
	
	var assign = __webpack_require__(46);
	var canDefineProperty = __webpack_require__(50);
	
	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
	
	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};
	
	/**
	 * Base constructor for all React elements. This is only used to make this
	 * work with a dynamic instanceof check. Nothing should live on this prototype.
	 *
	 * @param {*} type
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @param {*} owner
	 * @param {*} props
	 * @internal
	 */
	var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allow us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,
	
	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,
	
	    // Record the component responsible for creating this element.
	    _owner: owner
	  };
	
	  if (process.env.NODE_ENV !== 'production') {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {};
	
	    // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.
	    if (canDefineProperty) {
	      Object.defineProperty(element._store, 'validated', {
	        configurable: false,
	        enumerable: false,
	        writable: true,
	        value: false
	      });
	      // self and source are DEV only properties.
	      Object.defineProperty(element, '_self', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: self
	      });
	      // Two elements created in two different places should be considered
	      // equal for testing purposes and therefore we hide it from enumeration.
	      Object.defineProperty(element, '_source', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: source
	      });
	    } else {
	      element._store.validated = false;
	      element._self = self;
	      element._source = source;
	    }
	    Object.freeze(element.props);
	    Object.freeze(element);
	  }
	
	  return element;
	};
	
	ReactElement.createElement = function (type, config, children) {
	  var propName;
	
	  // Reserved names are extracted
	  var props = {};
	
	  var key = null;
	  var ref = null;
	  var self = null;
	  var source = null;
	
	  if (config != null) {
	    ref = config.ref === undefined ? null : config.ref;
	    key = config.key === undefined ? null : '' + config.key;
	    self = config.__self === undefined ? null : config.__self;
	    source = config.__source === undefined ? null : config.__source;
	    // Remaining properties are added to a new props object
	    for (propName in config) {
	      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  // Resolve default props
	  if (type && type.defaultProps) {
	    var defaultProps = type.defaultProps;
	    for (propName in defaultProps) {
	      if (typeof props[propName] === 'undefined') {
	        props[propName] = defaultProps[propName];
	      }
	    }
	  }
	
	  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	};
	
	ReactElement.createFactory = function (type) {
	  var factory = ReactElement.createElement.bind(null, type);
	  // Expose the type on the factory and the prototype so that it can be
	  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
	  // This should not be named `constructor` since this may not be the function
	  // that created the element, and it may not even be a constructor.
	  // Legacy hook TODO: Warn if this is accessed
	  factory.type = type;
	  return factory;
	};
	
	ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
	  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
	
	  return newElement;
	};
	
	ReactElement.cloneAndReplaceProps = function (oldElement, newProps) {
	  var newElement = ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, newProps);
	
	  if (process.env.NODE_ENV !== 'production') {
	    // If the key on the original is valid, then the clone is valid
	    newElement._store.validated = oldElement._store.validated;
	  }
	
	  return newElement;
	};
	
	ReactElement.cloneElement = function (element, config, children) {
	  var propName;
	
	  // Original props are copied
	  var props = assign({}, element.props);
	
	  // Reserved names are extracted
	  var key = element.key;
	  var ref = element.ref;
	  // Self is preserved since the owner is preserved.
	  var self = element._self;
	  // Source is preserved since cloneElement is unlikely to be targeted by a
	  // transpiler, and the original source is probably a better indicator of the
	  // true owner.
	  var source = element._source;
	
	  // Owner will be preserved, unless ref is overridden
	  var owner = element._owner;
	
	  if (config != null) {
	    if (config.ref !== undefined) {
	      // Silently steal the ref from the parent.
	      ref = config.ref;
	      owner = ReactCurrentOwner.current;
	    }
	    if (config.key !== undefined) {
	      key = '' + config.key;
	    }
	    // Remaining properties override existing props
	    for (propName in config) {
	      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  return ReactElement(element.type, key, ref, self, source, owner, props);
	};
	
	/**
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid component.
	 * @final
	 */
	ReactElement.isValidElement = function (object) {
	  return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	};
	
	module.exports = ReactElement;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule canDefineProperty
	 */
	
	'use strict';
	
	var canDefineProperty = false;
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    Object.defineProperty({}, 'x', { get: function get() {} });
	    canDefineProperty = true;
	  } catch (x) {
	    // IE will fail on defineProperty
	  }
	}
	
	module.exports = canDefineProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 51 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEmptyComponentRegistry
	 */
	
	'use strict';
	
	// This registry keeps track of the React IDs of the components that rendered to
	// `null` (in reality a placeholder such as `noscript`)
	
	var nullComponentIDsRegistry = {};
	
	/**
	 * @param {string} id Component's `_rootNodeID`.
	 * @return {boolean} True if the component is rendered to null.
	 */
	function isNullComponentID(id) {
	  return !!nullComponentIDsRegistry[id];
	}
	
	/**
	 * Mark the component as having rendered to null.
	 * @param {string} id Component's `_rootNodeID`.
	 */
	function registerNullComponentID(id) {
	  nullComponentIDsRegistry[id] = true;
	}
	
	/**
	 * Unmark the component as having rendered to null: it renders to something now.
	 * @param {string} id Component's `_rootNodeID`.
	 */
	function deregisterNullComponentID(id) {
	  delete nullComponentIDsRegistry[id];
	}
	
	var ReactEmptyComponentRegistry = {
	  isNullComponentID: isNullComponentID,
	  registerNullComponentID: registerNullComponentID,
	  deregisterNullComponentID: deregisterNullComponentID
	};
	
	module.exports = ReactEmptyComponentRegistry;

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceHandles
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactRootIndex = __webpack_require__(53);
	
	var invariant = __webpack_require__(20);
	
	var SEPARATOR = '.';
	var SEPARATOR_LENGTH = SEPARATOR.length;
	
	/**
	 * Maximum depth of traversals before we consider the possibility of a bad ID.
	 */
	var MAX_TREE_DEPTH = 10000;
	
	/**
	 * Creates a DOM ID prefix to use when mounting React components.
	 *
	 * @param {number} index A unique integer
	 * @return {string} React root ID.
	 * @internal
	 */
	function getReactRootIDString(index) {
	  return SEPARATOR + index.toString(36);
	}
	
	/**
	 * Checks if a character in the supplied ID is a separator or the end.
	 *
	 * @param {string} id A React DOM ID.
	 * @param {number} index Index of the character to check.
	 * @return {boolean} True if the character is a separator or end of the ID.
	 * @private
	 */
	function isBoundary(id, index) {
	  return id.charAt(index) === SEPARATOR || index === id.length;
	}
	
	/**
	 * Checks if the supplied string is a valid React DOM ID.
	 *
	 * @param {string} id A React DOM ID, maybe.
	 * @return {boolean} True if the string is a valid React DOM ID.
	 * @private
	 */
	function isValidID(id) {
	  return id === '' || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;
	}
	
	/**
	 * Checks if the first ID is an ancestor of or equal to the second ID.
	 *
	 * @param {string} ancestorID
	 * @param {string} descendantID
	 * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.
	 * @internal
	 */
	function isAncestorIDOf(ancestorID, descendantID) {
	  return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);
	}
	
	/**
	 * Gets the parent ID of the supplied React DOM ID, `id`.
	 *
	 * @param {string} id ID of a component.
	 * @return {string} ID of the parent, or an empty string.
	 * @private
	 */
	function getParentID(id) {
	  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
	}
	
	/**
	 * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the
	 * supplied `destinationID`. If they are equal, the ID is returned.
	 *
	 * @param {string} ancestorID ID of an ancestor node of `destinationID`.
	 * @param {string} destinationID ID of the destination node.
	 * @return {string} Next ID on the path from `ancestorID` to `destinationID`.
	 * @private
	 */
	function getNextDescendantID(ancestorID, destinationID) {
	  !(isValidID(ancestorID) && isValidID(destinationID)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(false) : undefined;
	  !isAncestorIDOf(ancestorID, destinationID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(false) : undefined;
	  if (ancestorID === destinationID) {
	    return ancestorID;
	  }
	  // Skip over the ancestor and the immediate separator. Traverse until we hit
	  // another separator or we reach the end of `destinationID`.
	  var start = ancestorID.length + SEPARATOR_LENGTH;
	  var i;
	  for (i = start; i < destinationID.length; i++) {
	    if (isBoundary(destinationID, i)) {
	      break;
	    }
	  }
	  return destinationID.substr(0, i);
	}
	
	/**
	 * Gets the nearest common ancestor ID of two IDs.
	 *
	 * Using this ID scheme, the nearest common ancestor ID is the longest common
	 * prefix of the two IDs that immediately preceded a "marker" in both strings.
	 *
	 * @param {string} oneID
	 * @param {string} twoID
	 * @return {string} Nearest common ancestor ID, or the empty string if none.
	 * @private
	 */
	function getFirstCommonAncestorID(oneID, twoID) {
	  var minLength = Math.min(oneID.length, twoID.length);
	  if (minLength === 0) {
	    return '';
	  }
	  var lastCommonMarkerIndex = 0;
	  // Use `<=` to traverse until the "EOL" of the shorter string.
	  for (var i = 0; i <= minLength; i++) {
	    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
	      lastCommonMarkerIndex = i;
	    } else if (oneID.charAt(i) !== twoID.charAt(i)) {
	      break;
	    }
	  }
	  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
	  !isValidID(longestCommonID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(false) : undefined;
	  return longestCommonID;
	}
	
	/**
	 * Traverses the parent path between two IDs (either up or down). The IDs must
	 * not be the same, and there must exist a parent path between them. If the
	 * callback returns `false`, traversal is stopped.
	 *
	 * @param {?string} start ID at which to start traversal.
	 * @param {?string} stop ID at which to end traversal.
	 * @param {function} cb Callback to invoke each ID with.
	 * @param {*} arg Argument to invoke the callback with.
	 * @param {?boolean} skipFirst Whether or not to skip the first node.
	 * @param {?boolean} skipLast Whether or not to skip the last node.
	 * @private
	 */
	function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
	  start = start || '';
	  stop = stop || '';
	  !(start !== stop) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(false) : undefined;
	  var traverseUp = isAncestorIDOf(stop, start);
	  !(traverseUp || isAncestorIDOf(start, stop)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(false) : undefined;
	  // Traverse from `start` to `stop` one depth at a time.
	  var depth = 0;
	  var traverse = traverseUp ? getParentID : getNextDescendantID;
	  for (var id = start;; /* until break */id = traverse(id, stop)) {
	    var ret;
	    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
	      ret = cb(id, traverseUp, arg);
	    }
	    if (ret === false || id === stop) {
	      // Only break //after// visiting `stop`.
	      break;
	    }
	    !(depth++ < MAX_TREE_DEPTH) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop, id) : invariant(false) : undefined;
	  }
	}
	
	/**
	 * Manages the IDs assigned to DOM representations of React components. This
	 * uses a specific scheme in order to traverse the DOM efficiently (e.g. in
	 * order to simulate events).
	 *
	 * @internal
	 */
	var ReactInstanceHandles = {
	
	  /**
	   * Constructs a React root ID
	   * @return {string} A React root ID.
	   */
	  createReactRootID: function createReactRootID() {
	    return getReactRootIDString(ReactRootIndex.createReactRootIndex());
	  },
	
	  /**
	   * Constructs a React ID by joining a root ID with a name.
	   *
	   * @param {string} rootID Root ID of a parent component.
	   * @param {string} name A component's name (as flattened children).
	   * @return {string} A React ID.
	   * @internal
	   */
	  createReactID: function createReactID(rootID, name) {
	    return rootID + name;
	  },
	
	  /**
	   * Gets the DOM ID of the React component that is the root of the tree that
	   * contains the React component with the supplied DOM ID.
	   *
	   * @param {string} id DOM ID of a React component.
	   * @return {?string} DOM ID of the React component that is the root.
	   * @internal
	   */
	  getReactRootIDFromNodeID: function getReactRootIDFromNodeID(id) {
	    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
	      var index = id.indexOf(SEPARATOR, 1);
	      return index > -1 ? id.substr(0, index) : id;
	    }
	    return null;
	  },
	
	  /**
	   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
	   * should would receive a `mouseEnter` or `mouseLeave` event.
	   *
	   * NOTE: Does not invoke the callback on the nearest common ancestor because
	   * nothing "entered" or "left" that element.
	   *
	   * @param {string} leaveID ID being left.
	   * @param {string} enterID ID being entered.
	   * @param {function} cb Callback to invoke on each entered/left ID.
	   * @param {*} upArg Argument to invoke the callback with on left IDs.
	   * @param {*} downArg Argument to invoke the callback with on entered IDs.
	   * @internal
	   */
	  traverseEnterLeave: function traverseEnterLeave(leaveID, enterID, cb, upArg, downArg) {
	    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
	    if (ancestorID !== leaveID) {
	      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
	    }
	    if (ancestorID !== enterID) {
	      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
	    }
	  },
	
	  /**
	   * Simulates the traversal of a two-phase, capture/bubble event dispatch.
	   *
	   * NOTE: This traversal happens on IDs without touching the DOM.
	   *
	   * @param {string} targetID ID of the target node.
	   * @param {function} cb Callback to invoke.
	   * @param {*} arg Argument to invoke the callback with.
	   * @internal
	   */
	  traverseTwoPhase: function traverseTwoPhase(targetID, cb, arg) {
	    if (targetID) {
	      traverseParentPath('', targetID, cb, arg, true, false);
	      traverseParentPath(targetID, '', cb, arg, false, true);
	    }
	  },
	
	  /**
	   * Same as `traverseTwoPhase` but skips the `targetID`.
	   */
	  traverseTwoPhaseSkipTarget: function traverseTwoPhaseSkipTarget(targetID, cb, arg) {
	    if (targetID) {
	      traverseParentPath('', targetID, cb, arg, true, true);
	      traverseParentPath(targetID, '', cb, arg, true, true);
	    }
	  },
	
	  /**
	   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For
	   * example, passing `.0.$row-0.1` would result in `cb` getting called
	   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.
	   *
	   * NOTE: This traversal happens on IDs without touching the DOM.
	   *
	   * @param {string} targetID ID of the target node.
	   * @param {function} cb Callback to invoke.
	   * @param {*} arg Argument to invoke the callback with.
	   * @internal
	   */
	  traverseAncestors: function traverseAncestors(targetID, cb, arg) {
	    traverseParentPath('', targetID, cb, arg, true, false);
	  },
	
	  getFirstCommonAncestorID: getFirstCommonAncestorID,
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _getNextDescendantID: getNextDescendantID,
	
	  isAncestorIDOf: isAncestorIDOf,
	
	  SEPARATOR: SEPARATOR
	
	};
	
	module.exports = ReactInstanceHandles;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 53 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRootIndex
	 * @typechecks
	 */
	
	'use strict';
	
	var ReactRootIndexInjection = {
	  /**
	   * @param {function} _createReactRootIndex
	   */
	  injectCreateReactRootIndex: function injectCreateReactRootIndex(_createReactRootIndex) {
	    ReactRootIndex.createReactRootIndex = _createReactRootIndex;
	  }
	};
	
	var ReactRootIndex = {
	  createReactRootIndex: null,
	  injection: ReactRootIndexInjection
	};
	
	module.exports = ReactRootIndex;

/***/ },
/* 54 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceMap
	 */
	
	'use strict';
	
	/**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 */
	
	// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
	
	var ReactInstanceMap = {
	
	  /**
	   * This API should be called `delete` but we'd have to make sure to always
	   * transform these to strings for IE support. When this transform is fully
	   * supported we can rename it.
	   */
	  remove: function remove(key) {
	    key._reactInternalInstance = undefined;
	  },
	
	  get: function get(key) {
	    return key._reactInternalInstance;
	  },
	
	  has: function has(key) {
	    return key._reactInternalInstance !== undefined;
	  },
	
	  set: function set(key, value) {
	    key._reactInternalInstance = value;
	  }
	
	};
	
	module.exports = ReactInstanceMap;

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMarkupChecksum
	 */
	
	'use strict';
	
	var adler32 = __webpack_require__(56);
	
	var TAG_END = /\/?>/;
	
	var ReactMarkupChecksum = {
	  CHECKSUM_ATTR_NAME: 'data-react-checksum',
	
	  /**
	   * @param {string} markup Markup string
	   * @return {string} Markup string with checksum attribute attached
	   */
	  addChecksumToMarkup: function addChecksumToMarkup(markup) {
	    var checksum = adler32(markup);
	
	    // Add checksum (handle both parent tags and self-closing tags)
	    return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
	  },
	
	  /**
	   * @param {string} markup to use
	   * @param {DOMElement} element root React element
	   * @returns {boolean} whether or not the markup is the same
	   */
	  canReuseMarkup: function canReuseMarkup(markup, element) {
	    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
	    var markupChecksum = adler32(markup);
	    return markupChecksum === existingChecksum;
	  }
	};
	
	module.exports = ReactMarkupChecksum;

/***/ },
/* 56 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule adler32
	 */
	
	'use strict';
	
	var MOD = 65521;
	
	// adler32 is not cryptographically strong, and is only used to sanity check that
	// markup generated on the server matches the markup generated on the client.
	// This implementation (a modified version of the SheetJS version) has been optimized
	// for our use case, at the expense of conforming to the adler32 specification
	// for non-ascii inputs.
	function adler32(data) {
	  var a = 1;
	  var b = 0;
	  var i = 0;
	  var l = data.length;
	  var m = l & ~0x3;
	  while (i < m) {
	    for (; i < Math.min(i + 4096, m); i += 4) {
	      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
	    }
	    a %= MOD;
	    b %= MOD;
	  }
	  for (; i < l; i++) {
	    b += a += data.charCodeAt(i);
	  }
	  a %= MOD;
	  b %= MOD;
	  return a | b << 16;
	}
	
	module.exports = adler32;

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconciler
	 */
	
	'use strict';
	
	var ReactRef = __webpack_require__(58);
	
	/**
	 * Helper to call ReactRef.attachRefs with this composite component, split out
	 * to avoid allocations in the transaction mount-ready queue.
	 */
	function attachRefs() {
	  ReactRef.attachRefs(this, this._currentElement);
	}
	
	var ReactReconciler = {
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function mountComponent(internalInstance, rootID, transaction, context) {
	    var markup = internalInstance.mountComponent(rootID, transaction, context);
	    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	    return markup;
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function unmountComponent(internalInstance) {
	    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
	    internalInstance.unmountComponent();
	  },
	
	  /**
	   * Update a component using a new element.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @internal
	   */
	  receiveComponent: function receiveComponent(internalInstance, nextElement, transaction, context) {
	    var prevElement = internalInstance._currentElement;
	
	    if (nextElement === prevElement && context === internalInstance._context) {
	      // Since elements are immutable after the owner is rendered,
	      // we can do a cheap identity compare here to determine if this is a
	      // superfluous reconcile. It's possible for state to be mutable but such
	      // change should trigger an update of the owner which would recreate
	      // the element. We explicitly check for the existence of an owner since
	      // it's possible for an element created outside a composite to be
	      // deeply mutated and reused.
	
	      // TODO: Bailing out early is just a perf optimization right?
	      // TODO: Removing the return statement should affect correctness?
	      return;
	    }
	
	    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
	
	    if (refsChanged) {
	      ReactRef.detachRefs(internalInstance, prevElement);
	    }
	
	    internalInstance.receiveComponent(nextElement, transaction, context);
	
	    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	  },
	
	  /**
	   * Flush any dirty changes in a component.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function performUpdateIfNecessary(internalInstance, transaction) {
	    internalInstance.performUpdateIfNecessary(transaction);
	  }
	
	};
	
	module.exports = ReactReconciler;

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRef
	 */
	
	'use strict';
	
	var ReactOwner = __webpack_require__(59);
	
	var ReactRef = {};
	
	function attachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(component.getPublicInstance());
	  } else {
	    // Legacy ref
	    ReactOwner.addComponentAsRefTo(component, ref, owner);
	  }
	}
	
	function detachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(null);
	  } else {
	    // Legacy ref
	    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
	  }
	}
	
	ReactRef.attachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    attachRef(ref, instance, element._owner);
	  }
	};
	
	ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
	  // If either the owner or a `ref` has changed, make sure the newest owner
	  // has stored a reference to `this`, and the previous owner (if different)
	  // has forgotten the reference to `this`. We use the element instead
	  // of the public this.props because the post processing cannot determine
	  // a ref. The ref conceptually lives on the element.
	
	  // TODO: Should this even be possible? The owner cannot change because
	  // it's forbidden by shouldUpdateReactComponent. The ref can change
	  // if you swap the keys of but not the refs. Reconsider where this check
	  // is made. It probably belongs where the key checking and
	  // instantiateReactComponent is done.
	
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	
	  return (
	    // This has a few false positives w/r/t empty components.
	    prevEmpty || nextEmpty || nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref
	  );
	};
	
	ReactRef.detachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    detachRef(ref, instance, element._owner);
	  }
	};
	
	module.exports = ReactRef;

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactOwner
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	/**
	 * ReactOwners are capable of storing references to owned components.
	 *
	 * All components are capable of //being// referenced by owner components, but
	 * only ReactOwner components are capable of //referencing// owned components.
	 * The named reference is known as a "ref".
	 *
	 * Refs are available when mounted and updated during reconciliation.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return (
	 *         <div onClick={this.handleClick}>
	 *           <CustomComponent ref="custom" />
	 *         </div>
	 *       );
	 *     },
	 *     handleClick: function() {
	 *       this.refs.custom.handleClick();
	 *     },
	 *     componentDidMount: function() {
	 *       this.refs.custom.initialize();
	 *     }
	 *   });
	 *
	 * Refs should rarely be used. When refs are used, they should only be done to
	 * control data that is not handled by React's data flow.
	 *
	 * @class ReactOwner
	 */
	var ReactOwner = {
	
	  /**
	   * @param {?object} object
	   * @return {boolean} True if `object` is a valid owner.
	   * @final
	   */
	  isValidOwner: function isValidOwner(object) {
	    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
	  },
	
	  /**
	   * Adds a component by ref to an owner component.
	   *
	   * @param {ReactComponent} component Component to reference.
	   * @param {string} ref Name by which to refer to the component.
	   * @param {ReactOwner} owner Component on which to record the ref.
	   * @final
	   * @internal
	   */
	  addComponentAsRefTo: function addComponentAsRefTo(component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might ' + 'be adding a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
	    owner.attachRef(ref, component);
	  },
	
	  /**
	   * Removes a component by ref from an owner component.
	   *
	   * @param {ReactComponent} component Component to dereference.
	   * @param {string} ref Name of the ref to remove.
	   * @param {ReactOwner} owner Component on which the ref is recorded.
	   * @final
	   * @internal
	   */
	  removeComponentAsRefFrom: function removeComponentAsRefFrom(component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might ' + 'be removing a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
	    // Check that `component` is still the current ref because we do not want to
	    // detach the ref if another component stole it.
	    if (owner.getPublicInstance().refs[ref] === component.getPublicInstance()) {
	      owner.detachRef(ref);
	    }
	  }
	
	};
	
	module.exports = ReactOwner;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdateQueue
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactElement = __webpack_require__(49);
	var ReactInstanceMap = __webpack_require__(54);
	var ReactUpdates = __webpack_require__(61);
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	function enqueueUpdate(internalInstance) {
	  ReactUpdates.enqueueUpdate(internalInstance);
	}
	
	function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
	  var internalInstance = ReactInstanceMap.get(publicInstance);
	  if (!internalInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      // Only warn when we have a callerName. Otherwise we should be silent.
	      // We're probably calling from enqueueCallback. We don't want to warn
	      // there because we already warned for the corresponding lifecycle method.
	      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor.displayName) : undefined;
	    }
	    return null;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.', callerName) : undefined;
	  }
	
	  return internalInstance;
	}
	
	/**
	 * ReactUpdateQueue allows for state updates to be scheduled into a later
	 * reconciliation step.
	 */
	var ReactUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function isMounted(publicInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var owner = ReactCurrentOwner.current;
	      if (owner !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
	        owner._warnedAboutRefsInRender = true;
	      }
	    }
	    var internalInstance = ReactInstanceMap.get(publicInstance);
	    if (internalInstance) {
	      // During componentWillMount and render this will still be null but after
	      // that will always render to something. At least for now. So we can use
	      // this hack.
	      return !!internalInstance._renderedComponent;
	    } else {
	      return false;
	    }
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function enqueueCallback(publicInstance, callback) {
	    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
	
	    // Previously we would throw an error if we didn't have an internal
	    // instance. Since we want to make it a no-op instead, we mirror the same
	    // behavior we have in other enqueue* methods.
	    // We also need to ignore callbacks in componentWillMount. See
	    // enqueueUpdates.
	    if (!internalInstance) {
	      return null;
	    }
	
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    // TODO: The callback here is ignored when setState is called from
	    // componentWillMount. Either fix it or disallow doing so completely in
	    // favor of getInitialState. Alternatively, we can disallow
	    // componentWillMount during server-side rendering.
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueCallbackInternal: function enqueueCallbackInternal(internalInstance, callback) {
	    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingForceUpdate = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingStateQueue = [completeState];
	    internalInstance._pendingReplaceState = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function enqueueSetState(publicInstance, partialState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
	    queue.push(partialState);
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialProps Subset of the next props.
	   * @internal
	   */
	  enqueueSetProps: function enqueueSetProps(publicInstance, partialProps) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setProps');
	    if (!internalInstance) {
	      return;
	    }
	    ReactUpdateQueue.enqueueSetPropsInternal(internalInstance, partialProps);
	  },
	
	  enqueueSetPropsInternal: function enqueueSetPropsInternal(internalInstance, partialProps) {
	    var topLevelWrapper = internalInstance._topLevelWrapper;
	    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setProps(...): You called `setProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;
	
	    // Merge with the pending element if it exists, otherwise with existing
	    // element props.
	    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
	    var element = wrapElement.props;
	    var props = assign({}, element.props, partialProps);
	    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));
	
	    enqueueUpdate(topLevelWrapper);
	  },
	
	  /**
	   * Replaces all of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} props New props.
	   * @internal
	   */
	  enqueueReplaceProps: function enqueueReplaceProps(publicInstance, props) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceProps');
	    if (!internalInstance) {
	      return;
	    }
	    ReactUpdateQueue.enqueueReplacePropsInternal(internalInstance, props);
	  },
	
	  enqueueReplacePropsInternal: function enqueueReplacePropsInternal(internalInstance, props) {
	    var topLevelWrapper = internalInstance._topLevelWrapper;
	    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'replaceProps(...): You called `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;
	
	    // Merge with the pending element if it exists, otherwise with existing
	    // element props.
	    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
	    var element = wrapElement.props;
	    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));
	
	    enqueueUpdate(topLevelWrapper);
	  },
	
	  enqueueElementInternal: function enqueueElementInternal(internalInstance, newElement) {
	    internalInstance._pendingElement = newElement;
	    enqueueUpdate(internalInstance);
	  }
	
	};
	
	module.exports = ReactUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdates
	 */
	
	'use strict';
	
	var CallbackQueue = __webpack_require__(62);
	var PooledClass = __webpack_require__(63);
	var ReactPerf = __webpack_require__(25);
	var ReactReconciler = __webpack_require__(57);
	var Transaction = __webpack_require__(64);
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	
	var dirtyComponents = [];
	var asapCallbackQueue = CallbackQueue.getPooled();
	var asapEnqueued = false;
	
	var batchingStrategy = null;
	
	function ensureInjected() {
	  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(false) : undefined;
	}
	
	var NESTED_UPDATES = {
	  initialize: function initialize() {
	    this.dirtyComponentsLength = dirtyComponents.length;
	  },
	  close: function close() {
	    if (this.dirtyComponentsLength !== dirtyComponents.length) {
	      // Additional updates were enqueued by componentDidUpdate handlers or
	      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
	      // these new updates so that if A's componentDidUpdate calls setState on
	      // B, B will update before the callback A's updater provided when calling
	      // setState.
	      dirtyComponents.splice(0, this.dirtyComponentsLength);
	      flushBatchedUpdates();
	    } else {
	      dirtyComponents.length = 0;
	    }
	  }
	};
	
	var UPDATE_QUEUEING = {
	  initialize: function initialize() {
	    this.callbackQueue.reset();
	  },
	  close: function close() {
	    this.callbackQueue.notifyAll();
	  }
	};
	
	var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
	
	function ReactUpdatesFlushTransaction() {
	  this.reinitializeTransaction();
	  this.dirtyComponentsLength = null;
	  this.callbackQueue = CallbackQueue.getPooled();
	  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled( /* forceHTML */false);
	}
	
	assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  destructor: function destructor() {
	    this.dirtyComponentsLength = null;
	    CallbackQueue.release(this.callbackQueue);
	    this.callbackQueue = null;
	    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
	    this.reconcileTransaction = null;
	  },
	
	  perform: function perform(method, scope, a) {
	    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
	    // with this transaction's wrappers around it.
	    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
	  }
	});
	
	PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
	
	function batchedUpdates(callback, a, b, c, d, e) {
	  ensureInjected();
	  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
	}
	
	/**
	 * Array comparator for ReactComponents by mount ordering.
	 *
	 * @param {ReactComponent} c1 first component you're comparing
	 * @param {ReactComponent} c2 second component you're comparing
	 * @return {number} Return value usable by Array.prototype.sort().
	 */
	function mountOrderComparator(c1, c2) {
	  return c1._mountOrder - c2._mountOrder;
	}
	
	function runBatchedUpdates(transaction) {
	  var len = transaction.dirtyComponentsLength;
	  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(false) : undefined;
	
	  // Since reconciling a component higher in the owner hierarchy usually (not
	  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
	  // them before their children by sorting the array.
	  dirtyComponents.sort(mountOrderComparator);
	
	  for (var i = 0; i < len; i++) {
	    // If a component is unmounted before pending changes apply, it will still
	    // be here, but we assume that it has cleared its _pendingCallbacks and
	    // that performUpdateIfNecessary is a noop.
	    var component = dirtyComponents[i];
	
	    // If performUpdateIfNecessary happens to enqueue any new updates, we
	    // shouldn't execute the callbacks until the next render happens, so
	    // stash the callbacks first
	    var callbacks = component._pendingCallbacks;
	    component._pendingCallbacks = null;
	
	    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);
	
	    if (callbacks) {
	      for (var j = 0; j < callbacks.length; j++) {
	        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
	      }
	    }
	  }
	}
	
	var flushBatchedUpdates = function flushBatchedUpdates() {
	  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
	  // array and perform any updates enqueued by mount-ready handlers (i.e.,
	  // componentDidUpdate) but we need to check here too in order to catch
	  // updates enqueued by setState callbacks and asap calls.
	  while (dirtyComponents.length || asapEnqueued) {
	    if (dirtyComponents.length) {
	      var transaction = ReactUpdatesFlushTransaction.getPooled();
	      transaction.perform(runBatchedUpdates, null, transaction);
	      ReactUpdatesFlushTransaction.release(transaction);
	    }
	
	    if (asapEnqueued) {
	      asapEnqueued = false;
	      var queue = asapCallbackQueue;
	      asapCallbackQueue = CallbackQueue.getPooled();
	      queue.notifyAll();
	      CallbackQueue.release(queue);
	    }
	  }
	};
	flushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', flushBatchedUpdates);
	
	/**
	 * Mark a component as needing a rerender, adding an optional callback to a
	 * list of functions which will be executed once the rerender occurs.
	 */
	function enqueueUpdate(component) {
	  ensureInjected();
	
	  // Various parts of our code (such as ReactCompositeComponent's
	  // _renderValidatedComponent) assume that calls to render aren't nested;
	  // verify that that's the case. (This is called by each top-level update
	  // function, like setProps, setState, forceUpdate, etc.; creation and
	  // destruction of top-level components is guarded in ReactMount.)
	
	  if (!batchingStrategy.isBatchingUpdates) {
	    batchingStrategy.batchedUpdates(enqueueUpdate, component);
	    return;
	  }
	
	  dirtyComponents.push(component);
	}
	
	/**
	 * Enqueue a callback to be run at the end of the current batching cycle. Throws
	 * if no updates are currently being performed.
	 */
	function asap(callback, context) {
	  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(false) : undefined;
	  asapCallbackQueue.enqueue(callback, context);
	  asapEnqueued = true;
	}
	
	var ReactUpdatesInjection = {
	  injectReconcileTransaction: function injectReconcileTransaction(ReconcileTransaction) {
	    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : invariant(false) : undefined;
	    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
	  },
	
	  injectBatchingStrategy: function injectBatchingStrategy(_batchingStrategy) {
	    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : invariant(false) : undefined;
	    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : invariant(false) : undefined;
	    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(false) : undefined;
	    batchingStrategy = _batchingStrategy;
	  }
	};
	
	var ReactUpdates = {
	  /**
	   * React references `ReactReconcileTransaction` using this property in order
	   * to allow dependency injection.
	   *
	   * @internal
	   */
	  ReactReconcileTransaction: null,
	
	  batchedUpdates: batchedUpdates,
	  enqueueUpdate: enqueueUpdate,
	  flushBatchedUpdates: flushBatchedUpdates,
	  injection: ReactUpdatesInjection,
	  asap: asap
	};
	
	module.exports = ReactUpdates;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CallbackQueue
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(63);
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	
	/**
	 * A specialized pseudo-event module to help keep track of components waiting to
	 * be notified when their DOM representations are available for use.
	 *
	 * This implements `PooledClass`, so you should never need to instantiate this.
	 * Instead, use `CallbackQueue.getPooled()`.
	 *
	 * @class ReactMountReady
	 * @implements PooledClass
	 * @internal
	 */
	function CallbackQueue() {
	  this._callbacks = null;
	  this._contexts = null;
	}
	
	assign(CallbackQueue.prototype, {
	
	  /**
	   * Enqueues a callback to be invoked when `notifyAll` is invoked.
	   *
	   * @param {function} callback Invoked when `notifyAll` is invoked.
	   * @param {?object} context Context to call `callback` with.
	   * @internal
	   */
	  enqueue: function enqueue(callback, context) {
	    this._callbacks = this._callbacks || [];
	    this._contexts = this._contexts || [];
	    this._callbacks.push(callback);
	    this._contexts.push(context);
	  },
	
	  /**
	   * Invokes all enqueued callbacks and clears the queue. This is invoked after
	   * the DOM representation of a component has been created or updated.
	   *
	   * @internal
	   */
	  notifyAll: function notifyAll() {
	    var callbacks = this._callbacks;
	    var contexts = this._contexts;
	    if (callbacks) {
	      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : invariant(false) : undefined;
	      this._callbacks = null;
	      this._contexts = null;
	      for (var i = 0; i < callbacks.length; i++) {
	        callbacks[i].call(contexts[i]);
	      }
	      callbacks.length = 0;
	      contexts.length = 0;
	    }
	  },
	
	  /**
	   * Resets the internal queue.
	   *
	   * @internal
	   */
	  reset: function reset() {
	    this._callbacks = null;
	    this._contexts = null;
	  },
	
	  /**
	   * `PooledClass` looks for this.
	   */
	  destructor: function destructor() {
	    this.reset();
	  }
	
	});
	
	PooledClass.addPoolingTo(CallbackQueue);
	
	module.exports = CallbackQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule PooledClass
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function oneArgumentPooler(copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};
	
	var twoArgumentPooler = function twoArgumentPooler(a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};
	
	var threeArgumentPooler = function threeArgumentPooler(a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};
	
	var fourArgumentPooler = function fourArgumentPooler(a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};
	
	var fiveArgumentPooler = function fiveArgumentPooler(a1, a2, a3, a4, a5) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4, a5);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4, a5);
	  }
	};
	
	var standardReleaser = function standardReleaser(instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : invariant(false) : undefined;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};
	
	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;
	
	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances (optional).
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function addPoolingTo(CopyConstructor, pooler) {
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};
	
	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler,
	  fiveArgumentPooler: fiveArgumentPooler
	};
	
	module.exports = PooledClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Transaction
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	/**
	 * `Transaction` creates a black box that is able to wrap any method such that
	 * certain invariants are maintained before and after the method is invoked
	 * (Even if an exception is thrown while invoking the wrapped method). Whoever
	 * instantiates a transaction can provide enforcers of the invariants at
	 * creation time. The `Transaction` class itself will supply one additional
	 * automatic invariant for you - the invariant that any transaction instance
	 * should not be run while it is already being run. You would typically create a
	 * single instance of a `Transaction` for reuse multiple times, that potentially
	 * is used to wrap several different methods. Wrappers are extremely simple -
	 * they only require implementing two methods.
	 *
	 * <pre>
	 *                       wrappers (injected at creation time)
	 *                                      +        +
	 *                                      |        |
	 *                    +-----------------|--------|--------------+
	 *                    |                 v        |              |
	 *                    |      +---------------+   |              |
	 *                    |   +--|    wrapper1   |---|----+         |
	 *                    |   |  +---------------+   v    |         |
	 *                    |   |          +-------------+  |         |
	 *                    |   |     +----|   wrapper2  |--------+   |
	 *                    |   |     |    +-------------+  |     |   |
	 *                    |   |     |                     |     |   |
	 *                    |   v     v                     v     v   | wrapper
	 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
	 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
	 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | +---+ +---+   +---------+   +---+ +---+ |
	 *                    |  initialize                    close    |
	 *                    +-----------------------------------------+
	 * </pre>
	 *
	 * Use cases:
	 * - Preserving the input selection ranges before/after reconciliation.
	 *   Restoring selection even in the event of an unexpected error.
	 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
	 *   while guaranteeing that afterwards, the event system is reactivated.
	 * - Flushing a queue of collected DOM mutations to the main UI thread after a
	 *   reconciliation takes place in a worker thread.
	 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
	 *   content.
	 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
	 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
	 * - (Future use case): Layout calculations before and after DOM updates.
	 *
	 * Transactional plugin API:
	 * - A module that has an `initialize` method that returns any precomputation.
	 * - and a `close` method that accepts the precomputation. `close` is invoked
	 *   when the wrapped process is completed, or has failed.
	 *
	 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
	 * that implement `initialize` and `close`.
	 * @return {Transaction} Single transaction for reuse in thread.
	 *
	 * @class Transaction
	 */
	var Mixin = {
	  /**
	   * Sets up this instance so that it is prepared for collecting metrics. Does
	   * so such that this setup method may be used on an instance that is already
	   * initialized, in a way that does not consume additional memory upon reuse.
	   * That can be useful if you decide to make your subclass of this mixin a
	   * "PooledClass".
	   */
	  reinitializeTransaction: function reinitializeTransaction() {
	    this.transactionWrappers = this.getTransactionWrappers();
	    if (this.wrapperInitData) {
	      this.wrapperInitData.length = 0;
	    } else {
	      this.wrapperInitData = [];
	    }
	    this._isInTransaction = false;
	  },
	
	  _isInTransaction: false,
	
	  /**
	   * @abstract
	   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
	   */
	  getTransactionWrappers: null,
	
	  isInTransaction: function isInTransaction() {
	    return !!this._isInTransaction;
	  },
	
	  /**
	   * Executes the function within a safety window. Use this for the top level
	   * methods that result in large amounts of computation/mutations that would
	   * need to be safety checked. The optional arguments helps prevent the need
	   * to bind in many cases.
	   *
	   * @param {function} method Member of scope to call.
	   * @param {Object} scope Scope to invoke from.
	   * @param {Object?=} a Argument to pass to the method.
	   * @param {Object?=} b Argument to pass to the method.
	   * @param {Object?=} c Argument to pass to the method.
	   * @param {Object?=} d Argument to pass to the method.
	   * @param {Object?=} e Argument to pass to the method.
	   * @param {Object?=} f Argument to pass to the method.
	   *
	   * @return {*} Return value from `method`.
	   */
	  perform: function perform(method, scope, a, b, c, d, e, f) {
	    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there ' + 'is already an outstanding transaction.') : invariant(false) : undefined;
	    var errorThrown;
	    var ret;
	    try {
	      this._isInTransaction = true;
	      // Catching errors makes debugging more difficult, so we start with
	      // errorThrown set to true before setting it to false after calling
	      // close -- if it's still set to true in the finally block, it means
	      // one of these calls threw.
	      errorThrown = true;
	      this.initializeAll(0);
	      ret = method.call(scope, a, b, c, d, e, f);
	      errorThrown = false;
	    } finally {
	      try {
	        if (errorThrown) {
	          // If `method` throws, prefer to show that stack trace over any thrown
	          // by invoking `closeAll`.
	          try {
	            this.closeAll(0);
	          } catch (err) {}
	        } else {
	          // Since `method` didn't throw, we don't want to silence the exception
	          // here.
	          this.closeAll(0);
	        }
	      } finally {
	        this._isInTransaction = false;
	      }
	    }
	    return ret;
	  },
	
	  initializeAll: function initializeAll(startIndex) {
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      try {
	        // Catching errors makes debugging more difficult, so we start with the
	        // OBSERVED_ERROR state before overwriting it with the real return value
	        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
	        // block, it means wrapper.initialize threw.
	        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
	        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
	      } finally {
	        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
	          // The initializer for wrapper i threw an error; initialize the
	          // remaining wrappers but silence any exceptions from them to ensure
	          // that the first error is the one to bubble up.
	          try {
	            this.initializeAll(i + 1);
	          } catch (err) {}
	        }
	      }
	    }
	  },
	
	  /**
	   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
	   * them the respective return values of `this.transactionWrappers.init[i]`
	   * (`close`rs that correspond to initializers that failed will not be
	   * invoked).
	   */
	  closeAll: function closeAll(startIndex) {
	    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : invariant(false) : undefined;
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      var initData = this.wrapperInitData[i];
	      var errorThrown;
	      try {
	        // Catching errors makes debugging more difficult, so we start with
	        // errorThrown set to true before setting it to false after calling
	        // close -- if it's still set to true in the finally block, it means
	        // wrapper.close threw.
	        errorThrown = true;
	        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
	          wrapper.close.call(this, initData);
	        }
	        errorThrown = false;
	      } finally {
	        if (errorThrown) {
	          // The closer for wrapper i threw an error; close the remaining
	          // wrappers but silence any exceptions from them to ensure that the
	          // first error is the one to bubble up.
	          try {
	            this.closeAll(i + 1);
	          } catch (e) {}
	        }
	      }
	    }
	    this.wrapperInitData.length = 0;
	  }
	};
	
	var Transaction = {
	
	  Mixin: Mixin,
	
	  /**
	   * Token to look for to determine if an error occurred.
	   */
	  OBSERVED_ERROR: {}
	
	};
	
	module.exports = Transaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyObject
	 */
	
	'use strict';
	
	var emptyObject = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  Object.freeze(emptyObject);
	}
	
	module.exports = emptyObject;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule containsNode
	 * @typechecks
	 */
	
	'use strict';
	
	var isTextNode = __webpack_require__(67);
	
	/*eslint-disable no-bitwise */
	
	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 *
	 * @param {?DOMNode} outerNode Outer DOM node.
	 * @param {?DOMNode} innerNode Inner DOM node.
	 * @return {boolean} True if `outerNode` contains or is `innerNode`.
	 */
	function containsNode(_x, _x2) {
	  var _again = true;
	
	  _function: while (_again) {
	    var outerNode = _x,
	        innerNode = _x2;
	    _again = false;
	
	    if (!outerNode || !innerNode) {
	      return false;
	    } else if (outerNode === innerNode) {
	      return true;
	    } else if (isTextNode(outerNode)) {
	      return false;
	    } else if (isTextNode(innerNode)) {
	      _x = outerNode;
	      _x2 = innerNode.parentNode;
	      _again = true;
	      continue _function;
	    } else if (outerNode.contains) {
	      return outerNode.contains(innerNode);
	    } else if (outerNode.compareDocumentPosition) {
	      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	    } else {
	      return false;
	    }
	  }
	}
	
	module.exports = containsNode;

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextNode
	 * @typechecks
	 */
	
	'use strict';
	
	var isNode = __webpack_require__(68);
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode(object) && object.nodeType == 3;
	}
	
	module.exports = isTextNode;

/***/ },
/* 68 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isNode
	 * @typechecks
	 */
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	function isNode(object) {
	  return !!(object && (typeof Node === 'function' ? object instanceof Node : (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
	}
	
	module.exports = isNode;

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule instantiateReactComponent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactCompositeComponent = __webpack_require__(70);
	var ReactEmptyComponent = __webpack_require__(75);
	var ReactNativeComponent = __webpack_require__(76);
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	// To avoid a cyclic dependency, we create the final class in this module
	var ReactCompositeComponentWrapper = function ReactCompositeComponentWrapper() {};
	assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
	  _instantiateReactComponent: instantiateReactComponent
	});
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Check if the type reference is a known internal type. I.e. not a user
	 * provided composite type.
	 *
	 * @param {function} type
	 * @return {boolean} Returns true if this is a valid internal type.
	 */
	function isInternalComponentType(type) {
	  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
	}
	
	/**
	 * Given a ReactNode, create an instance that will actually be mounted.
	 *
	 * @param {ReactNode} node
	 * @return {object} A new instance of the element's constructor.
	 * @protected
	 */
	function instantiateReactComponent(node) {
	  var instance;
	
	  if (node === null || node === false) {
	    instance = new ReactEmptyComponent(instantiateReactComponent);
	  } else if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object') {
	    var element = node;
	    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) ' + 'or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : _typeof(element.type), getDeclarationErrorAddendum(element._owner)) : invariant(false) : undefined;
	
	    // Special case string values
	    if (typeof element.type === 'string') {
	      instance = ReactNativeComponent.createInternalComponent(element);
	    } else if (isInternalComponentType(element.type)) {
	      // This is temporarily available for custom components that are not string
	      // representations. I.e. ART. Once those are updated to use the string
	      // representation, we can drop this code path.
	      instance = new element.type(element);
	    } else {
	      instance = new ReactCompositeComponentWrapper();
	    }
	  } else if (typeof node === 'string' || typeof node === 'number') {
	    instance = ReactNativeComponent.createInstanceForText(node);
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node === 'undefined' ? 'undefined' : _typeof(node)) : invariant(false) : undefined;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(typeof instance.construct === 'function' && typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : undefined;
	  }
	
	  // Sets up the instance. This can probably just move into the constructor now.
	  instance.construct(node);
	
	  // These two fields are used by the DOM and ART diffing algorithms
	  // respectively. Instead of using expandos on components, we should be
	  // storing the state needed by the diffing algorithms elsewhere.
	  instance._mountIndex = 0;
	  instance._mountImage = null;
	
	  if (process.env.NODE_ENV !== 'production') {
	    instance._isOwnerNecessary = false;
	    instance._warnedAboutRefsInRender = false;
	  }
	
	  // Internal instances should fully constructed at this point, so they should
	  // not get any new fields added to them at this point.
	  if (process.env.NODE_ENV !== 'production') {
	    if (Object.preventExtensions) {
	      Object.preventExtensions(instance);
	    }
	  }
	
	  return instance;
	}
	
	module.exports = instantiateReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCompositeComponent
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactComponentEnvironment = __webpack_require__(71);
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactElement = __webpack_require__(49);
	var ReactInstanceMap = __webpack_require__(54);
	var ReactPerf = __webpack_require__(25);
	var ReactPropTypeLocations = __webpack_require__(72);
	var ReactPropTypeLocationNames = __webpack_require__(73);
	var ReactReconciler = __webpack_require__(57);
	var ReactUpdateQueue = __webpack_require__(60);
	
	var assign = __webpack_require__(46);
	var emptyObject = __webpack_require__(65);
	var invariant = __webpack_require__(20);
	var shouldUpdateReactComponent = __webpack_require__(74);
	var warning = __webpack_require__(32);
	
	function getDeclarationErrorAddendum(component) {
	  var owner = component._currentElement._owner || null;
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	function StatelessComponent(Component) {}
	StatelessComponent.prototype.render = function () {
	  var Component = ReactInstanceMap.get(this)._currentElement.type;
	  return Component(this.props, this.context, this.updater);
	};
	
	/**
	 * ------------------ The Life-Cycle of a Composite Component ------------------
	 *
	 * - constructor: Initialization of state. The instance is now retained.
	 *   - componentWillMount
	 *   - render
	 *   - [children's constructors]
	 *     - [children's componentWillMount and render]
	 *     - [children's componentDidMount]
	 *     - componentDidMount
	 *
	 *       Update Phases:
	 *       - componentWillReceiveProps (only called if parent updated)
	 *       - shouldComponentUpdate
	 *         - componentWillUpdate
	 *           - render
	 *           - [children's constructors or receive props phases]
	 *         - componentDidUpdate
	 *
	 *     - componentWillUnmount
	 *     - [children's componentWillUnmount]
	 *   - [children destroyed]
	 * - (destroyed): The instance is now blank, released by React and ready for GC.
	 *
	 * -----------------------------------------------------------------------------
	 */
	
	/**
	 * An incrementing ID assigned to each component when it is mounted. This is
	 * used to enforce the order in which `ReactUpdates` updates dirty components.
	 *
	 * @private
	 */
	var nextMountID = 1;
	
	/**
	 * @lends {ReactCompositeComponent.prototype}
	 */
	var ReactCompositeComponentMixin = {
	
	  /**
	   * Base constructor for all composite component.
	   *
	   * @param {ReactElement} element
	   * @final
	   * @internal
	   */
	  construct: function construct(element) {
	    this._currentElement = element;
	    this._rootNodeID = null;
	    this._instance = null;
	
	    // See ReactUpdateQueue
	    this._pendingElement = null;
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    this._renderedComponent = null;
	
	    this._context = null;
	    this._mountOrder = 0;
	    this._topLevelWrapper = null;
	
	    // See ReactUpdates and ReactUpdateQueue.
	    this._pendingCallbacks = null;
	  },
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function mountComponent(rootID, transaction, context) {
	    this._context = context;
	    this._mountOrder = nextMountID++;
	    this._rootNodeID = rootID;
	
	    var publicProps = this._processProps(this._currentElement.props);
	    var publicContext = this._processContext(context);
	
	    var Component = this._currentElement.type;
	
	    // Initialize the public class
	    var inst;
	    var renderedElement;
	
	    // This is a way to detect if Component is a stateless arrow function
	    // component, which is not newable. It might not be 100% reliable but is
	    // something we can do until we start detecting that Component extends
	    // React.Component. We already assume that typeof Component === 'function'.
	    var canInstantiate = 'prototype' in Component;
	
	    if (canInstantiate) {
	      if (process.env.NODE_ENV !== 'production') {
	        ReactCurrentOwner.current = this;
	        try {
	          inst = new Component(publicProps, publicContext, ReactUpdateQueue);
	        } finally {
	          ReactCurrentOwner.current = null;
	        }
	      } else {
	        inst = new Component(publicProps, publicContext, ReactUpdateQueue);
	      }
	    }
	
	    if (!canInstantiate || inst === null || inst === false || ReactElement.isValidElement(inst)) {
	      renderedElement = inst;
	      inst = new StatelessComponent(Component);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This will throw later in _renderValidatedComponent, but add an early
	      // warning now to help debugging
	      if (inst.render == null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`, returned ' + 'null/false from a stateless component, or tried to render an ' + 'element whose type is a function that isn\'t a React component.', Component.displayName || Component.name || 'Component') : undefined;
	      } else {
	        // We support ES6 inheriting from React.Component, the module pattern,
	        // and stateless components, but not ES6 classes that don't extend
	        process.env.NODE_ENV !== 'production' ? warning(Component.prototype && Component.prototype.isReactComponent || !canInstantiate || !(inst instanceof Component), '%s(...): React component classes must extend React.Component.', Component.displayName || Component.name || 'Component') : undefined;
	      }
	    }
	
	    // These should be set up in the constructor, but as a convenience for
	    // simpler class abstractions, we set them up after the fact.
	    inst.props = publicProps;
	    inst.context = publicContext;
	    inst.refs = emptyObject;
	    inst.updater = ReactUpdateQueue;
	
	    this._instance = inst;
	
	    // Store a reference from the instance back to the internal representation
	    ReactInstanceMap.set(inst, this);
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Since plain JS classes are defined without any special initialization
	      // logic, we can not catch common errors early. Therefore, we have to
	      // catch them here, at initialization time, instead.
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : undefined;
	    }
	
	    var initialState = inst.state;
	    if (initialState === undefined) {
	      inst.state = initialState = null;
	    }
	    !((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    if (inst.componentWillMount) {
	      inst.componentWillMount();
	      // When mounting, calls to `setState` by `componentWillMount` will set
	      // `this._pendingStateQueue` without triggering a re-render.
	      if (this._pendingStateQueue) {
	        inst.state = this._processPendingState(inst.props, inst.context);
	      }
	    }
	
	    // If not a stateless component, we now render
	    if (renderedElement === undefined) {
	      renderedElement = this._renderValidatedComponent();
	    }
	
	    this._renderedComponent = this._instantiateReactComponent(renderedElement);
	
	    var markup = ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, this._processChildContext(context));
	    if (inst.componentDidMount) {
	      transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
	    }
	
	    return markup;
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function unmountComponent() {
	    var inst = this._instance;
	
	    if (inst.componentWillUnmount) {
	      inst.componentWillUnmount();
	    }
	
	    ReactReconciler.unmountComponent(this._renderedComponent);
	    this._renderedComponent = null;
	    this._instance = null;
	
	    // Reset pending fields
	    // Even if this component is scheduled for another update in ReactUpdates,
	    // it would still be ignored because these fields are reset.
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	    this._pendingCallbacks = null;
	    this._pendingElement = null;
	
	    // These fields do not really need to be reset since this object is no
	    // longer accessible.
	    this._context = null;
	    this._rootNodeID = null;
	    this._topLevelWrapper = null;
	
	    // Delete the reference from the instance to this internal representation
	    // which allow the internals to be properly cleaned up even if the user
	    // leaks a reference to the public instance.
	    ReactInstanceMap.remove(inst);
	
	    // Some existing components rely on inst.props even after they've been
	    // destroyed (in event handlers).
	    // TODO: inst.props = null;
	    // TODO: inst.state = null;
	    // TODO: inst.context = null;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _maskContext: function _maskContext(context) {
	    var maskedContext = null;
	    var Component = this._currentElement.type;
	    var contextTypes = Component.contextTypes;
	    if (!contextTypes) {
	      return emptyObject;
	    }
	    maskedContext = {};
	    for (var contextName in contextTypes) {
	      maskedContext[contextName] = context[contextName];
	    }
	    return maskedContext;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`, and asserts that they are valid.
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _processContext: function _processContext(context) {
	    var maskedContext = this._maskContext(context);
	    if (process.env.NODE_ENV !== 'production') {
	      var Component = this._currentElement.type;
	      if (Component.contextTypes) {
	        this._checkPropTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
	      }
	    }
	    return maskedContext;
	  },
	
	  /**
	   * @param {object} currentContext
	   * @return {object}
	   * @private
	   */
	  _processChildContext: function _processChildContext(currentContext) {
	    var Component = this._currentElement.type;
	    var inst = this._instance;
	    var childContext = inst.getChildContext && inst.getChildContext();
	    if (childContext) {
	      !(_typeof(Component.childContextTypes) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	      if (process.env.NODE_ENV !== 'production') {
	        this._checkPropTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);
	      }
	      for (var name in childContext) {
	        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : invariant(false) : undefined;
	      }
	      return assign({}, currentContext, childContext);
	    }
	    return currentContext;
	  },
	
	  /**
	   * Processes props by setting default values for unspecified props and
	   * asserting that the props are valid. Does not mutate its argument; returns
	   * a new props object with defaults merged in.
	   *
	   * @param {object} newProps
	   * @return {object}
	   * @private
	   */
	  _processProps: function _processProps(newProps) {
	    if (process.env.NODE_ENV !== 'production') {
	      var Component = this._currentElement.type;
	      if (Component.propTypes) {
	        this._checkPropTypes(Component.propTypes, newProps, ReactPropTypeLocations.prop);
	      }
	    }
	    return newProps;
	  },
	
	  /**
	   * Assert that the props are valid
	   *
	   * @param {object} propTypes Map of prop name to a ReactPropType
	   * @param {object} props
	   * @param {string} location e.g. "prop", "context", "child context"
	   * @private
	   */
	  _checkPropTypes: function _checkPropTypes(propTypes, props, location) {
	    // TODO: Stop validating prop types here and only use the element
	    // validation.
	    var componentName = this.getName();
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error;
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually ' + 'from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
	          error = propTypes[propName](props, propName, componentName, location);
	        } catch (ex) {
	          error = ex;
	        }
	        if (error instanceof Error) {
	          // We may want to extend this logic for similar errors in
	          // top-level render calls, so I'm abstracting it away into
	          // a function to minimize refactoring in the future
	          var addendum = getDeclarationErrorAddendum(this);
	
	          if (location === ReactPropTypeLocations.prop) {
	            // Preface gives us something to blacklist in warning module
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Composite propType: %s%s', error.message, addendum) : undefined;
	          } else {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Context Types: %s%s', error.message, addendum) : undefined;
	          }
	        }
	      }
	    }
	  },
	
	  receiveComponent: function receiveComponent(nextElement, transaction, nextContext) {
	    var prevElement = this._currentElement;
	    var prevContext = this._context;
	
	    this._pendingElement = null;
	
	    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
	  },
	
	  /**
	   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
	   * is set, update the component.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function performUpdateIfNecessary(transaction) {
	    if (this._pendingElement != null) {
	      ReactReconciler.receiveComponent(this, this._pendingElement || this._currentElement, transaction, this._context);
	    }
	
	    if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
	      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
	    }
	  },
	
	  /**
	   * Perform an update to a mounted component. The componentWillReceiveProps and
	   * shouldComponentUpdate methods are called, then (assuming the update isn't
	   * skipped) the remaining update lifecycle methods are called and the DOM
	   * representation is updated.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevParentElement
	   * @param {ReactElement} nextParentElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function updateComponent(transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
	    var inst = this._instance;
	
	    var nextContext = this._context === nextUnmaskedContext ? inst.context : this._processContext(nextUnmaskedContext);
	    var nextProps;
	
	    // Distinguish between a props update versus a simple state update
	    if (prevParentElement === nextParentElement) {
	      // Skip checking prop types again -- we don't read inst.props to avoid
	      // warning for DOM component props in this upgrade
	      nextProps = nextParentElement.props;
	    } else {
	      nextProps = this._processProps(nextParentElement.props);
	      // An update here will schedule an update but immediately set
	      // _pendingStateQueue which will ensure that any state updates gets
	      // immediately reconciled instead of waiting for the next batch.
	
	      if (inst.componentWillReceiveProps) {
	        inst.componentWillReceiveProps(nextProps, nextContext);
	      }
	    }
	
	    var nextState = this._processPendingState(nextProps, nextContext);
	
	    var shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(typeof shouldUpdate !== 'undefined', '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : undefined;
	    }
	
	    if (shouldUpdate) {
	      this._pendingForceUpdate = false;
	      // Will set `this.props`, `this.state` and `this.context`.
	      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
	    } else {
	      // If it's determined that a component should not update, we still want
	      // to set props and state but we shortcut the rest of the update.
	      this._currentElement = nextParentElement;
	      this._context = nextUnmaskedContext;
	      inst.props = nextProps;
	      inst.state = nextState;
	      inst.context = nextContext;
	    }
	  },
	
	  _processPendingState: function _processPendingState(props, context) {
	    var inst = this._instance;
	    var queue = this._pendingStateQueue;
	    var replace = this._pendingReplaceState;
	    this._pendingReplaceState = false;
	    this._pendingStateQueue = null;
	
	    if (!queue) {
	      return inst.state;
	    }
	
	    if (replace && queue.length === 1) {
	      return queue[0];
	    }
	
	    var nextState = assign({}, replace ? queue[0] : inst.state);
	    for (var i = replace ? 1 : 0; i < queue.length; i++) {
	      var partial = queue[i];
	      assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
	    }
	
	    return nextState;
	  },
	
	  /**
	   * Merges new props and state, notifies delegate methods of update and
	   * performs update.
	   *
	   * @param {ReactElement} nextElement Next element
	   * @param {object} nextProps Next public object to set as properties.
	   * @param {?object} nextState Next object to set as state.
	   * @param {?object} nextContext Next public object to set as context.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?object} unmaskedContext
	   * @private
	   */
	  _performComponentUpdate: function _performComponentUpdate(nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
	    var inst = this._instance;
	
	    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
	    var prevProps;
	    var prevState;
	    var prevContext;
	    if (hasComponentDidUpdate) {
	      prevProps = inst.props;
	      prevState = inst.state;
	      prevContext = inst.context;
	    }
	
	    if (inst.componentWillUpdate) {
	      inst.componentWillUpdate(nextProps, nextState, nextContext);
	    }
	
	    this._currentElement = nextElement;
	    this._context = unmaskedContext;
	    inst.props = nextProps;
	    inst.state = nextState;
	    inst.context = nextContext;
	
	    this._updateRenderedComponent(transaction, unmaskedContext);
	
	    if (hasComponentDidUpdate) {
	      transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
	    }
	  },
	
	  /**
	   * Call the component's `render` method and update the DOM accordingly.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  _updateRenderedComponent: function _updateRenderedComponent(transaction, context) {
	    var prevComponentInstance = this._renderedComponent;
	    var prevRenderedElement = prevComponentInstance._currentElement;
	    var nextRenderedElement = this._renderValidatedComponent();
	    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
	      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
	    } else {
	      // These two IDs are actually the same! But nothing should rely on that.
	      var thisID = this._rootNodeID;
	      var prevComponentID = prevComponentInstance._rootNodeID;
	      ReactReconciler.unmountComponent(prevComponentInstance);
	
	      this._renderedComponent = this._instantiateReactComponent(nextRenderedElement);
	      var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, thisID, transaction, this._processChildContext(context));
	      this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
	    }
	  },
	
	  /**
	   * @protected
	   */
	  _replaceNodeWithMarkupByID: function _replaceNodeWithMarkupByID(prevComponentID, nextMarkup) {
	    ReactComponentEnvironment.replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
	  },
	
	  /**
	   * @protected
	   */
	  _renderValidatedComponentWithoutOwnerOrContext: function _renderValidatedComponentWithoutOwnerOrContext() {
	    var inst = this._instance;
	    var renderedComponent = inst.render();
	    if (process.env.NODE_ENV !== 'production') {
	      // We allow auto-mocks to proceed as if they're returning null.
	      if (typeof renderedComponent === 'undefined' && inst.render._isMockFunction) {
	        // This is probably bad practice. Consider warning here and
	        // deprecating this convenience.
	        renderedComponent = null;
	      }
	    }
	
	    return renderedComponent;
	  },
	
	  /**
	   * @private
	   */
	  _renderValidatedComponent: function _renderValidatedComponent() {
	    var renderedComponent;
	    ReactCurrentOwner.current = this;
	    try {
	      renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
	    } finally {
	      ReactCurrentOwner.current = null;
	    }
	    !(
	    // TODO: An `isValidNode` function would probably be more appropriate
	    renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	    return renderedComponent;
	  },
	
	  /**
	   * Lazily allocates the refs object and stores `component` as `ref`.
	   *
	   * @param {string} ref Reference name.
	   * @param {component} component Component to store as `ref`.
	   * @final
	   * @private
	   */
	  attachRef: function attachRef(ref, component) {
	    var inst = this.getPublicInstance();
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : invariant(false) : undefined;
	    var publicComponentInstance = component.getPublicInstance();
	    if (process.env.NODE_ENV !== 'production') {
	      var componentName = component && component.getName ? component.getName() : 'a component';
	      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : undefined;
	    }
	    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
	    refs[ref] = publicComponentInstance;
	  },
	
	  /**
	   * Detaches a reference name.
	   *
	   * @param {string} ref Name to dereference.
	   * @final
	   * @private
	   */
	  detachRef: function detachRef(ref) {
	    var refs = this.getPublicInstance().refs;
	    delete refs[ref];
	  },
	
	  /**
	   * Get a text description of the component that can be used to identify it
	   * in error messages.
	   * @return {string} The name or null.
	   * @internal
	   */
	  getName: function getName() {
	    var type = this._currentElement.type;
	    var constructor = this._instance && this._instance.constructor;
	    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
	  },
	
	  /**
	   * Get the publicly accessible representation of this component - i.e. what
	   * is exposed by refs and returned by render. Can be null for stateless
	   * components.
	   *
	   * @return {ReactComponent} the public component instance.
	   * @internal
	   */
	  getPublicInstance: function getPublicInstance() {
	    var inst = this._instance;
	    if (inst instanceof StatelessComponent) {
	      return null;
	    }
	    return inst;
	  },
	
	  // Stub
	  _instantiateReactComponent: null
	
	};
	
	ReactPerf.measureMethods(ReactCompositeComponentMixin, 'ReactCompositeComponent', {
	  mountComponent: 'mountComponent',
	  updateComponent: 'updateComponent',
	  _renderValidatedComponent: '_renderValidatedComponent'
	});
	
	var ReactCompositeComponent = {
	
	  Mixin: ReactCompositeComponentMixin
	
	};
	
	module.exports = ReactCompositeComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentEnvironment
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	var injected = false;
	
	var ReactComponentEnvironment = {
	
	  /**
	   * Optionally injectable environment dependent cleanup hook. (server vs.
	   * browser etc). Example: A browser system caches DOM nodes based on component
	   * ID and must remove that cache entry when this instance is unmounted.
	   */
	  unmountIDFromEnvironment: null,
	
	  /**
	   * Optionally injectable hook for swapping out mount images in the middle of
	   * the tree.
	   */
	  replaceNodeWithMarkupByID: null,
	
	  /**
	   * Optionally injectable hook for processing a queue of child updates. Will
	   * later move into MultiChildComponents.
	   */
	  processChildrenUpdates: null,
	
	  injection: {
	    injectEnvironment: function injectEnvironment(environment) {
	      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : invariant(false) : undefined;
	      ReactComponentEnvironment.unmountIDFromEnvironment = environment.unmountIDFromEnvironment;
	      ReactComponentEnvironment.replaceNodeWithMarkupByID = environment.replaceNodeWithMarkupByID;
	      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
	      injected = true;
	    }
	  }
	
	};
	
	module.exports = ReactComponentEnvironment;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocations
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(24);
	
	var ReactPropTypeLocations = keyMirror({
	  prop: null,
	  context: null,
	  childContext: null
	});
	
	module.exports = ReactPropTypeLocations;

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocationNames
	 */
	
	'use strict';
	
	var ReactPropTypeLocationNames = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}
	
	module.exports = ReactPropTypeLocationNames;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 74 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shouldUpdateReactComponent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Given a `prevElement` and `nextElement`, determines if the existing
	 * instance should be updated as opposed to being destroyed or replaced by a new
	 * instance. Both arguments are elements. This ensures that this logic can
	 * operate on stateless trees without any backing instance.
	 *
	 * @param {?object} prevElement
	 * @param {?object} nextElement
	 * @return {boolean} True if the existing instance should be updated.
	 * @protected
	 */
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	function shouldUpdateReactComponent(prevElement, nextElement) {
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	  if (prevEmpty || nextEmpty) {
	    return prevEmpty === nextEmpty;
	  }
	
	  var prevType = typeof prevElement === 'undefined' ? 'undefined' : _typeof(prevElement);
	  var nextType = typeof nextElement === 'undefined' ? 'undefined' : _typeof(nextElement);
	  if (prevType === 'string' || prevType === 'number') {
	    return nextType === 'string' || nextType === 'number';
	  } else {
	    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
	  }
	  return false;
	}
	
	module.exports = shouldUpdateReactComponent;

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEmptyComponent
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(49);
	var ReactEmptyComponentRegistry = __webpack_require__(51);
	var ReactReconciler = __webpack_require__(57);
	
	var assign = __webpack_require__(46);
	
	var placeholderElement;
	
	var ReactEmptyComponentInjection = {
	  injectEmptyComponent: function injectEmptyComponent(component) {
	    placeholderElement = ReactElement.createElement(component);
	  }
	};
	
	function registerNullComponentID() {
	  ReactEmptyComponentRegistry.registerNullComponentID(this._rootNodeID);
	}
	
	var ReactEmptyComponent = function ReactEmptyComponent(instantiate) {
	  this._currentElement = null;
	  this._rootNodeID = null;
	  this._renderedComponent = instantiate(placeholderElement);
	};
	assign(ReactEmptyComponent.prototype, {
	  construct: function construct(element) {},
	  mountComponent: function mountComponent(rootID, transaction, context) {
	    transaction.getReactMountReady().enqueue(registerNullComponentID, this);
	    this._rootNodeID = rootID;
	    return ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, context);
	  },
	  receiveComponent: function receiveComponent() {},
	  unmountComponent: function unmountComponent(rootID, transaction, context) {
	    ReactReconciler.unmountComponent(this._renderedComponent);
	    ReactEmptyComponentRegistry.deregisterNullComponentID(this._rootNodeID);
	    this._rootNodeID = null;
	    this._renderedComponent = null;
	  }
	});
	
	ReactEmptyComponent.injection = ReactEmptyComponentInjection;
	
	module.exports = ReactEmptyComponent;

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNativeComponent
	 */
	
	'use strict';
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	
	var autoGenerateWrapperClass = null;
	var genericComponentClass = null;
	// This registry keeps track of wrapper classes around native tags.
	var tagToComponentClass = {};
	var textComponentClass = null;
	
	var ReactNativeComponentInjection = {
	  // This accepts a class that receives the tag string. This is a catch all
	  // that can render any kind of tag.
	  injectGenericComponentClass: function injectGenericComponentClass(componentClass) {
	    genericComponentClass = componentClass;
	  },
	  // This accepts a text component class that takes the text string to be
	  // rendered as props.
	  injectTextComponentClass: function injectTextComponentClass(componentClass) {
	    textComponentClass = componentClass;
	  },
	  // This accepts a keyed object with classes as values. Each key represents a
	  // tag. That particular tag will use this class instead of the generic one.
	  injectComponentClasses: function injectComponentClasses(componentClasses) {
	    assign(tagToComponentClass, componentClasses);
	  }
	};
	
	/**
	 * Get a composite component wrapper class for a specific tag.
	 *
	 * @param {ReactElement} element The tag for which to get the class.
	 * @return {function} The React class constructor function.
	 */
	function getComponentClassForElement(element) {
	  if (typeof element.type === 'function') {
	    return element.type;
	  }
	  var tag = element.type;
	  var componentClass = tagToComponentClass[tag];
	  if (componentClass == null) {
	    tagToComponentClass[tag] = componentClass = autoGenerateWrapperClass(tag);
	  }
	  return componentClass;
	}
	
	/**
	 * Get a native internal component class for a specific tag.
	 *
	 * @param {ReactElement} element The element to create.
	 * @return {function} The internal class constructor function.
	 */
	function createInternalComponent(element) {
	  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : invariant(false) : undefined;
	  return new genericComponentClass(element.type, element.props);
	}
	
	/**
	 * @param {ReactText} text
	 * @return {ReactComponent}
	 */
	function createInstanceForText(text) {
	  return new textComponentClass(text);
	}
	
	/**
	 * @param {ReactComponent} component
	 * @return {boolean}
	 */
	function isTextComponent(component) {
	  return component instanceof textComponentClass;
	}
	
	var ReactNativeComponent = {
	  getComponentClassForElement: getComponentClassForElement,
	  createInternalComponent: createInternalComponent,
	  createInstanceForText: createInstanceForText,
	  isTextComponent: isTextComponent,
	  injection: ReactNativeComponentInjection
	};
	
	module.exports = ReactNativeComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule validateDOMNesting
	 */
	
	'use strict';
	
	var assign = __webpack_require__(46);
	var emptyFunction = __webpack_require__(22);
	var warning = __webpack_require__(32);
	
	var validateDOMNesting = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  // This validation code was written based on the HTML5 parsing spec:
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  //
	  // Note: this does not catch all invalid nesting, nor does it try to (as it's
	  // not clear what practical benefit doing so provides); instead, we warn only
	  // for cases where the parser will give a parse tree differing from what React
	  // intended. For example, <b><div></div></b> is invalid but we don't warn
	  // because it still parses correctly; we do warn for other cases like nested
	  // <p> tags where the beginning of the second element implicitly closes the
	  // first, causing a confusing mess.
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#special
	  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
	  // TODO: Distinguish by namespace here -- for <title>, including it here
	  // errs on the side of fewer warnings
	  'foreignObject', 'desc', 'title'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
	  var buttonScopeTags = inScopeTags.concat(['button']);
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
	  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
	
	  var emptyAncestorInfo = {
	    parentTag: null,
	
	    formTag: null,
	    aTagInScope: null,
	    buttonTagInScope: null,
	    nobrTagInScope: null,
	    pTagInButtonScope: null,
	
	    listItemTagAutoclosing: null,
	    dlItemTagAutoclosing: null
	  };
	
	  var updatedAncestorInfo = function updatedAncestorInfo(oldInfo, tag, instance) {
	    var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
	    var info = { tag: tag, instance: instance };
	
	    if (inScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.aTagInScope = null;
	      ancestorInfo.buttonTagInScope = null;
	      ancestorInfo.nobrTagInScope = null;
	    }
	    if (buttonScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.pTagInButtonScope = null;
	    }
	
	    // See rules for 'li', 'dd', 'dt' start tags in
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
	      ancestorInfo.listItemTagAutoclosing = null;
	      ancestorInfo.dlItemTagAutoclosing = null;
	    }
	
	    ancestorInfo.parentTag = info;
	
	    if (tag === 'form') {
	      ancestorInfo.formTag = info;
	    }
	    if (tag === 'a') {
	      ancestorInfo.aTagInScope = info;
	    }
	    if (tag === 'button') {
	      ancestorInfo.buttonTagInScope = info;
	    }
	    if (tag === 'nobr') {
	      ancestorInfo.nobrTagInScope = info;
	    }
	    if (tag === 'p') {
	      ancestorInfo.pTagInButtonScope = info;
	    }
	    if (tag === 'li') {
	      ancestorInfo.listItemTagAutoclosing = info;
	    }
	    if (tag === 'dd' || tag === 'dt') {
	      ancestorInfo.dlItemTagAutoclosing = info;
	    }
	
	    return ancestorInfo;
	  };
	
	  /**
	   * Returns whether
	   */
	  var isTagValidWithParent = function isTagValidWithParent(tag, parentTag) {
	    // First, let's check if we're in an unusual parsing mode...
	    switch (parentTag) {
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
	      case 'select':
	        return tag === 'option' || tag === 'optgroup' || tag === '#text';
	      case 'optgroup':
	        return tag === 'option' || tag === '#text';
	      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
	      // but
	      case 'option':
	        return tag === '#text';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
	      // No special behavior since these rules fall back to "in body" mode for
	      // all except special table nodes which cause bad parsing behavior anyway.
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
	      case 'tr':
	        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
	      case 'tbody':
	      case 'thead':
	      case 'tfoot':
	        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
	      case 'colgroup':
	        return tag === 'col' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
	      case 'table':
	        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
	      case 'head':
	        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
	      case 'html':
	        return tag === 'head' || tag === 'body';
	    }
	
	    // Probably in the "in body" parsing mode, so we outlaw only tag combos
	    // where the parsing rules cause implicit opens or closes to be added.
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    switch (tag) {
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
	
	      case 'rp':
	      case 'rt':
	        return impliedEndTags.indexOf(parentTag) === -1;
	
	      case 'caption':
	      case 'col':
	      case 'colgroup':
	      case 'frame':
	      case 'head':
	      case 'tbody':
	      case 'td':
	      case 'tfoot':
	      case 'th':
	      case 'thead':
	      case 'tr':
	        // These tags are only valid with a few parents that have special child
	        // parsing rules -- if we're down here, then none of those matched and
	        // so we allow it only if we don't know what the parent is, as all other
	        // cases are invalid.
	        return parentTag == null;
	    }
	
	    return true;
	  };
	
	  /**
	   * Returns whether
	   */
	  var findInvalidAncestorForTag = function findInvalidAncestorForTag(tag, ancestorInfo) {
	    switch (tag) {
	      case 'address':
	      case 'article':
	      case 'aside':
	      case 'blockquote':
	      case 'center':
	      case 'details':
	      case 'dialog':
	      case 'dir':
	      case 'div':
	      case 'dl':
	      case 'fieldset':
	      case 'figcaption':
	      case 'figure':
	      case 'footer':
	      case 'header':
	      case 'hgroup':
	      case 'main':
	      case 'menu':
	      case 'nav':
	      case 'ol':
	      case 'p':
	      case 'section':
	      case 'summary':
	      case 'ul':
	
	      case 'pre':
	      case 'listing':
	
	      case 'table':
	
	      case 'hr':
	
	      case 'xmp':
	
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return ancestorInfo.pTagInButtonScope;
	
	      case 'form':
	        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
	
	      case 'li':
	        return ancestorInfo.listItemTagAutoclosing;
	
	      case 'dd':
	      case 'dt':
	        return ancestorInfo.dlItemTagAutoclosing;
	
	      case 'button':
	        return ancestorInfo.buttonTagInScope;
	
	      case 'a':
	        // Spec says something about storing a list of markers, but it sounds
	        // equivalent to this check.
	        return ancestorInfo.aTagInScope;
	
	      case 'nobr':
	        return ancestorInfo.nobrTagInScope;
	    }
	
	    return null;
	  };
	
	  /**
	   * Given a ReactCompositeComponent instance, return a list of its recursive
	   * owners, starting at the root and ending with the instance itself.
	   */
	  var findOwnerStack = function findOwnerStack(instance) {
	    if (!instance) {
	      return [];
	    }
	
	    var stack = [];
	    /*eslint-disable space-after-keywords */
	    do {
	      /*eslint-enable space-after-keywords */
	      stack.push(instance);
	    } while (instance = instance._currentElement._owner);
	    stack.reverse();
	    return stack;
	  };
	
	  var didWarn = {};
	
	  validateDOMNesting = function validateDOMNesting(childTag, childInstance, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.parentTag;
	    var parentTag = parentInfo && parentInfo.tag;
	
	    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
	    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
	    var problematic = invalidParent || invalidAncestor;
	
	    if (problematic) {
	      var ancestorTag = problematic.tag;
	      var ancestorInstance = problematic.instance;
	
	      var childOwner = childInstance && childInstance._currentElement._owner;
	      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;
	
	      var childOwners = findOwnerStack(childOwner);
	      var ancestorOwners = findOwnerStack(ancestorOwner);
	
	      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
	      var i;
	
	      var deepestCommon = -1;
	      for (i = 0; i < minStackLen; i++) {
	        if (childOwners[i] === ancestorOwners[i]) {
	          deepestCommon = i;
	        } else {
	          break;
	        }
	      }
	
	      var UNKNOWN = '(unknown)';
	      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ownerInfo = [].concat(
	      // If the parent and child instances have a common owner ancestor, start
	      // with that -- otherwise we just start with the parent's owners.
	      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
	      // If we're warning about an invalid (non-parent) ancestry, add '...'
	      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');
	
	      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
	      if (didWarn[warnKey]) {
	        return;
	      }
	      didWarn[warnKey] = true;
	
	      if (invalidParent) {
	        var info = '';
	        if (ancestorTag === 'table' && childTag === 'tr') {
	          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
	        }
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a child of <%s>. ' + 'See %s.%s', childTag, ancestorTag, ownerInfo, info) : undefined;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a descendant of ' + '<%s>. See %s.', childTag, ancestorTag, ownerInfo) : undefined;
	      }
	    }
	  };
	
	  validateDOMNesting.ancestorInfoContextKey = '__validateDOMNesting_ancestorInfo$' + Math.random().toString(36).slice(2);
	
	  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
	
	  // For testing
	  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.parentTag;
	    var parentTag = parentInfo && parentInfo.tag;
	    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
	  };
	}
	
	module.exports = validateDOMNesting;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultInjection
	 */
	
	'use strict';
	
	var BeforeInputEventPlugin = __webpack_require__(79);
	var ChangeEventPlugin = __webpack_require__(87);
	var ClientReactRootIndex = __webpack_require__(90);
	var DefaultEventPluginOrder = __webpack_require__(91);
	var EnterLeaveEventPlugin = __webpack_require__(92);
	var ExecutionEnvironment = __webpack_require__(16);
	var HTMLDOMPropertyConfig = __webpack_require__(96);
	var ReactBrowserComponentMixin = __webpack_require__(97);
	var ReactComponentBrowserEnvironment = __webpack_require__(33);
	var ReactDefaultBatchingStrategy = __webpack_require__(99);
	var ReactDOMComponent = __webpack_require__(100);
	var ReactDOMTextComponent = __webpack_require__(13);
	var ReactEventListener = __webpack_require__(125);
	var ReactInjection = __webpack_require__(128);
	var ReactInstanceHandles = __webpack_require__(52);
	var ReactMount = __webpack_require__(35);
	var ReactReconcileTransaction = __webpack_require__(132);
	var SelectEventPlugin = __webpack_require__(137);
	var ServerReactRootIndex = __webpack_require__(138);
	var SimpleEventPlugin = __webpack_require__(139);
	var SVGDOMPropertyConfig = __webpack_require__(148);
	
	var alreadyInjected = false;
	
	function inject() {
	  if (alreadyInjected) {
	    // TODO: This is currently true because these injections are shared between
	    // the client and the server package. They should be built independently
	    // and not share any injection state. Then this problem will be solved.
	    return;
	  }
	  alreadyInjected = true;
	
	  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
	
	  /**
	   * Inject modules for resolving DOM hierarchy and plugin ordering.
	   */
	  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
	  ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
	  ReactInjection.EventPluginHub.injectMount(ReactMount);
	
	  /**
	   * Some important event plugins included by default (without having to require
	   * them).
	   */
	  ReactInjection.EventPluginHub.injectEventPluginsByName({
	    SimpleEventPlugin: SimpleEventPlugin,
	    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
	    ChangeEventPlugin: ChangeEventPlugin,
	    SelectEventPlugin: SelectEventPlugin,
	    BeforeInputEventPlugin: BeforeInputEventPlugin
	  });
	
	  ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);
	
	  ReactInjection.NativeComponent.injectTextComponentClass(ReactDOMTextComponent);
	
	  ReactInjection.Class.injectMixin(ReactBrowserComponentMixin);
	
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
	
	  ReactInjection.EmptyComponent.injectEmptyComponent('noscript');
	
	  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
	  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	
	  ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex);
	
	  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
	
	  if (process.env.NODE_ENV !== 'production') {
	    var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
	    if (/[?&]react_perf\b/.test(url)) {
	      var ReactDefaultPerf = __webpack_require__(149);
	      ReactDefaultPerf.start();
	    }
	  }
	}
	
	module.exports = {
	  inject: inject
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015 Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule BeforeInputEventPlugin
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var EventConstants = __webpack_require__(37);
	var EventPropagators = __webpack_require__(80);
	var ExecutionEnvironment = __webpack_require__(16);
	var FallbackCompositionState = __webpack_require__(81);
	var SyntheticCompositionEvent = __webpack_require__(83);
	var SyntheticInputEvent = __webpack_require__(85);
	
	var keyOf = __webpack_require__(86);
	
	var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
	var START_KEYCODE = 229;
	
	var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
	
	var documentMode = null;
	if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
	  documentMode = document.documentMode;
	}
	
	// Webkit offers a very useful `textInput` event that can be used to
	// directly represent `beforeInput`. The IE `textinput` event is not as
	// useful, so we don't use it.
	var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();
	
	// In IE9+, we have access to composition events, but the data supplied
	// by the native compositionend event may be incorrect. Japanese ideographic
	// spaces, for instance (\u3000) are not recorded correctly.
	var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
	
	/**
	 * Opera <= 12 includes TextEvent in window, but does not fire
	 * text input events. Rely on keypress instead.
	 */
	function isPresto() {
	  var opera = window.opera;
	  return (typeof opera === 'undefined' ? 'undefined' : _typeof(opera)) === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
	}
	
	var SPACEBAR_CODE = 32;
	var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	// Events and their corresponding property names.
	var eventTypes = {
	  beforeInput: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBeforeInput: null }),
	      captured: keyOf({ onBeforeInputCapture: null })
	    },
	    dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
	  },
	  compositionEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionEnd: null }),
	      captured: keyOf({ onCompositionEndCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionStart: null }),
	      captured: keyOf({ onCompositionStartCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionUpdate: null }),
	      captured: keyOf({ onCompositionUpdateCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  }
	};
	
	// Track whether we've ever handled a keypress on the space key.
	var hasSpaceKeypress = false;
	
	/**
	 * Return whether a native keypress event is assumed to be a command.
	 * This is required because Firefox fires `keypress` events for key commands
	 * (cut, copy, select-all, etc.) even though no character is inserted.
	 */
	function isKeypressCommand(nativeEvent) {
	  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
	  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
	  !(nativeEvent.ctrlKey && nativeEvent.altKey);
	}
	
	/**
	 * Translate native top level events into event types.
	 *
	 * @param {string} topLevelType
	 * @return {object}
	 */
	function getCompositionEventType(topLevelType) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionStart:
	      return eventTypes.compositionStart;
	    case topLevelTypes.topCompositionEnd:
	      return eventTypes.compositionEnd;
	    case topLevelTypes.topCompositionUpdate:
	      return eventTypes.compositionUpdate;
	  }
	}
	
	/**
	 * Does our fallback best-guess model think this event signifies that
	 * composition has begun?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionStart(topLevelType, nativeEvent) {
	  return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
	}
	
	/**
	 * Does our fallback mode think that this event is the end of composition?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionEnd(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topKeyUp:
	      // Command keys insert or clear IME input.
	      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
	    case topLevelTypes.topKeyDown:
	      // Expect IME keyCode on each keydown. If we get any other
	      // code we must have exited earlier.
	      return nativeEvent.keyCode !== START_KEYCODE;
	    case topLevelTypes.topKeyPress:
	    case topLevelTypes.topMouseDown:
	    case topLevelTypes.topBlur:
	      // Events are not possible without cancelling IME.
	      return true;
	    default:
	      return false;
	  }
	}
	
	/**
	 * Google Input Tools provides composition data via a CustomEvent,
	 * with the `data` property populated in the `detail` object. If this
	 * is available on the event object, use it. If not, this is a plain
	 * composition event and we have nothing special to extract.
	 *
	 * @param {object} nativeEvent
	 * @return {?string}
	 */
	function getDataFromCustomEvent(nativeEvent) {
	  var detail = nativeEvent.detail;
	  if ((typeof detail === 'undefined' ? 'undefined' : _typeof(detail)) === 'object' && 'data' in detail) {
	    return detail.data;
	  }
	  return null;
	}
	
	// Track the current IME composition fallback object, if any.
	var currentComposition = null;
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {DOMEventTarget} topLevelTarget The listening component root node.
	 * @param {string} topLevelTargetID ID of `topLevelTarget`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?object} A SyntheticCompositionEvent.
	 */
	function extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	  var eventType;
	  var fallbackData;
	
	  if (canUseCompositionEvent) {
	    eventType = getCompositionEventType(topLevelType);
	  } else if (!currentComposition) {
	    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
	      eventType = eventTypes.compositionStart;
	    }
	  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	    eventType = eventTypes.compositionEnd;
	  }
	
	  if (!eventType) {
	    return null;
	  }
	
	  if (useFallbackCompositionData) {
	    // The current composition is stored statically and must not be
	    // overwritten while composition continues.
	    if (!currentComposition && eventType === eventTypes.compositionStart) {
	      currentComposition = FallbackCompositionState.getPooled(topLevelTarget);
	    } else if (eventType === eventTypes.compositionEnd) {
	      if (currentComposition) {
	        fallbackData = currentComposition.getData();
	      }
	    }
	  }
	
	  var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent, nativeEventTarget);
	
	  if (fallbackData) {
	    // Inject data generated from fallback path into the synthetic event.
	    // This matches the property of native CompositionEventInterface.
	    event.data = fallbackData;
	  } else {
	    var customData = getDataFromCustomEvent(nativeEvent);
	    if (customData !== null) {
	      event.data = customData;
	    }
	  }
	
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The string corresponding to this `beforeInput` event.
	 */
	function getNativeBeforeInputChars(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionEnd:
	      return getDataFromCustomEvent(nativeEvent);
	    case topLevelTypes.topKeyPress:
	      /**
	       * If native `textInput` events are available, our goal is to make
	       * use of them. However, there is a special case: the spacebar key.
	       * In Webkit, preventing default on a spacebar `textInput` event
	       * cancels character insertion, but it *also* causes the browser
	       * to fall back to its default spacebar behavior of scrolling the
	       * page.
	       *
	       * Tracking at:
	       * https://code.google.com/p/chromium/issues/detail?id=355103
	       *
	       * To avoid this issue, use the keypress event as if no `textInput`
	       * event is available.
	       */
	      var which = nativeEvent.which;
	      if (which !== SPACEBAR_CODE) {
	        return null;
	      }
	
	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;
	
	    case topLevelTypes.topTextInput:
	      // Record the characters to be added to the DOM.
	      var chars = nativeEvent.data;
	
	      // If it's a spacebar character, assume that we have already handled
	      // it at the keypress level and bail immediately. Android Chrome
	      // doesn't give us keycodes, so we need to blacklist it.
	      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
	        return null;
	      }
	
	      return chars;
	
	    default:
	      // For other native event types, do nothing.
	      return null;
	  }
	}
	
	/**
	 * For browsers that do not provide the `textInput` event, extract the
	 * appropriate string to use for SyntheticInputEvent.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The fallback string for this `beforeInput` event.
	 */
	function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
	  // If we are currently composing (IME) and using a fallback to do so,
	  // try to extract the composed characters from the fallback object.
	  if (currentComposition) {
	    if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	      var chars = currentComposition.getData();
	      FallbackCompositionState.release(currentComposition);
	      currentComposition = null;
	      return chars;
	    }
	    return null;
	  }
	
	  switch (topLevelType) {
	    case topLevelTypes.topPaste:
	      // If a paste event occurs after a keypress, throw out the input
	      // chars. Paste events should not lead to BeforeInput events.
	      return null;
	    case topLevelTypes.topKeyPress:
	      /**
	       * As of v27, Firefox may fire keypress events even when no character
	       * will be inserted. A few possibilities:
	       *
	       * - `which` is `0`. Arrow keys, Esc key, etc.
	       *
	       * - `which` is the pressed key code, but no char is available.
	       *   Ex: 'AltGr + d` in Polish. There is no modified character for
	       *   this key combination and no character is inserted into the
	       *   document, but FF fires the keypress for char code `100` anyway.
	       *   No `input` event will occur.
	       *
	       * - `which` is the pressed key code, but a command combination is
	       *   being used. Ex: `Cmd+C`. No character is inserted, and no
	       *   `input` event will occur.
	       */
	      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
	        return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case topLevelTypes.topCompositionEnd:
	      return useFallbackCompositionData ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}
	
	/**
	 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
	 * `textInput` or fallback behavior.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {DOMEventTarget} topLevelTarget The listening component root node.
	 * @param {string} topLevelTargetID ID of `topLevelTarget`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?object} A SyntheticInputEvent.
	 */
	function extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	  var chars;
	
	  if (canUseTextInputEvent) {
	    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
	  } else {
	    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
	  }
	
	  // If no characters are being inserted, no BeforeInput event should
	  // be fired.
	  if (!chars) {
	    return null;
	  }
	
	  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent, nativeEventTarget);
	
	  event.data = chars;
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * Create an `onBeforeInput` event to match
	 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
	 *
	 * This event plugin is based on the native `textInput` event
	 * available in Chrome, Safari, Opera, and IE. This event fires after
	 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
	 *
	 * `beforeInput` is spec'd but not implemented in any browsers, and
	 * the `input` event does not provide any useful information about what has
	 * actually been added, contrary to the spec. Thus, `textInput` is the best
	 * available event to identify the characters that have actually been inserted
	 * into the target node.
	 *
	 * This plugin is also responsible for emitting `composition` events, thus
	 * allowing us to share composition fallback code for both `beforeInput` and
	 * `composition` event types.
	 */
	var BeforeInputEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    return [extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget)];
	  }
	};
	
	module.exports = BeforeInputEventPlugin;

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPropagators
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var EventPluginHub = __webpack_require__(38);
	
	var warning = __webpack_require__(32);
	
	var accumulateInto = __webpack_require__(42);
	var forEachAccumulated = __webpack_require__(43);
	
	var PropagationPhases = EventConstants.PropagationPhases;
	var getListener = EventPluginHub.getListener;
	
	/**
	 * Some event types have a notion of different registration names for different
	 * "phases" of propagation. This finds listeners by a given phase.
	 */
	function listenerAtPhase(id, event, propagationPhase) {
	  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
	  return getListener(id, registrationName);
	}
	
	/**
	 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
	 * here, allows us to not have to bind or create functions for each event.
	 * Mutating the event's members allows us to not have to create a wrapping
	 * "dispatch" object that pairs the event with the listener.
	 */
	function accumulateDirectionalDispatches(domID, upwards, event) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(domID, 'Dispatching id must not be null') : undefined;
	  }
	  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
	  var listener = listenerAtPhase(domID, event, phase);
	  if (listener) {
	    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
	  }
	}
	
	/**
	 * Collect dispatches (must be entirely collected before dispatching - see unit
	 * tests). Lazily allocate the array to conserve memory.  We must loop through
	 * each event and perform the traversal for each one. We cannot perform a
	 * single traversal for the entire collection of events because each event may
	 * have a different target.
	 */
	function accumulateTwoPhaseDispatchesSingle(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
	 */
	function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginHub.injection.getInstanceHandle().traverseTwoPhaseSkipTarget(event.dispatchMarker, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Accumulates without regard to direction, does not look for phased
	 * registration names. Same as `accumulateDirectDispatchesSingle` but without
	 * requiring that the `dispatchMarker` be the same as the dispatched ID.
	 */
	function accumulateDispatches(id, ignoredDirection, event) {
	  if (event && event.dispatchConfig.registrationName) {
	    var registrationName = event.dispatchConfig.registrationName;
	    var listener = getListener(id, registrationName);
	    if (listener) {
	      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	      event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
	    }
	  }
	}
	
	/**
	 * Accumulates dispatches on an `SyntheticEvent`, but only for the
	 * `dispatchMarker`.
	 * @param {SyntheticEvent} event
	 */
	function accumulateDirectDispatchesSingle(event) {
	  if (event && event.dispatchConfig.registrationName) {
	    accumulateDispatches(event.dispatchMarker, null, event);
	  }
	}
	
	function accumulateTwoPhaseDispatches(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
	}
	
	function accumulateTwoPhaseDispatchesSkipTarget(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
	}
	
	function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
	  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);
	}
	
	function accumulateDirectDispatches(events) {
	  forEachAccumulated(events, accumulateDirectDispatchesSingle);
	}
	
	/**
	 * A small set of propagation patterns, each of which will accept a small amount
	 * of information, and generate a set of "dispatch ready event objects" - which
	 * are sets of events that have already been annotated with a set of dispatched
	 * listener functions/ids. The API is designed this way to discourage these
	 * propagation strategies from actually executing the dispatches, since we
	 * always want to collect the entire set of dispatches before executing event a
	 * single one.
	 *
	 * @constructor EventPropagators
	 */
	var EventPropagators = {
	  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	  accumulateDirectDispatches: accumulateDirectDispatches,
	  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
	};
	
	module.exports = EventPropagators;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule FallbackCompositionState
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(63);
	
	var assign = __webpack_require__(46);
	var getTextContentAccessor = __webpack_require__(82);
	
	/**
	 * This helper class stores information about text content of a target node,
	 * allowing comparison of content before and after a given event.
	 *
	 * Identify the node where selection currently begins, then observe
	 * both its text content and its current position in the DOM. Since the
	 * browser may natively replace the target node during composition, we can
	 * use its position to find its replacement.
	 *
	 * @param {DOMEventTarget} root
	 */
	function FallbackCompositionState(root) {
	  this._root = root;
	  this._startText = this.getText();
	  this._fallbackText = null;
	}
	
	assign(FallbackCompositionState.prototype, {
	  destructor: function destructor() {
	    this._root = null;
	    this._startText = null;
	    this._fallbackText = null;
	  },
	
	  /**
	   * Get current text of input.
	   *
	   * @return {string}
	   */
	  getText: function getText() {
	    if ('value' in this._root) {
	      return this._root.value;
	    }
	    return this._root[getTextContentAccessor()];
	  },
	
	  /**
	   * Determine the differing substring between the initially stored
	   * text content and the current content.
	   *
	   * @return {string}
	   */
	  getData: function getData() {
	    if (this._fallbackText) {
	      return this._fallbackText;
	    }
	
	    var start;
	    var startValue = this._startText;
	    var startLength = startValue.length;
	    var end;
	    var endValue = this.getText();
	    var endLength = endValue.length;
	
	    for (start = 0; start < startLength; start++) {
	      if (startValue[start] !== endValue[start]) {
	        break;
	      }
	    }
	
	    var minEnd = startLength - start;
	    for (end = 1; end <= minEnd; end++) {
	      if (startValue[startLength - end] !== endValue[endLength - end]) {
	        break;
	      }
	    }
	
	    var sliceTail = end > 1 ? 1 - end : undefined;
	    this._fallbackText = endValue.slice(start, sliceTail);
	    return this._fallbackText;
	  }
	});
	
	PooledClass.addPoolingTo(FallbackCompositionState);
	
	module.exports = FallbackCompositionState;

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getTextContentAccessor
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var contentKey = null;
	
	/**
	 * Gets the key used to access text content on a DOM node.
	 *
	 * @return {?string} Key used to access text content.
	 * @internal
	 */
	function getTextContentAccessor() {
	  if (!contentKey && ExecutionEnvironment.canUseDOM) {
	    // Prefer textContent to innerText because many browsers support both but
	    // SVG <text> elements don't support innerText even when <div> does.
	    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
	  }
	  return contentKey;
	}
	
	module.exports = getTextContentAccessor;

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticCompositionEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(84);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
	 */
	var CompositionEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
	
	module.exports = SyntheticCompositionEvent;

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(63);
	
	var assign = __webpack_require__(46);
	var emptyFunction = __webpack_require__(22);
	var warning = __webpack_require__(32);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var EventInterface = {
	  type: null,
	  target: null,
	  // currentTarget is set when dispatching; no use in copying it here
	  currentTarget: emptyFunction.thatReturnsNull,
	  eventPhase: null,
	  bubbles: null,
	  cancelable: null,
	  timeStamp: function timeStamp(event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: null,
	  isTrusted: null
	};
	
	/**
	 * Synthetic events are dispatched by event plugins, typically in response to a
	 * top-level event delegation handler.
	 *
	 * These systems should generally use pooling to reduce the frequency of garbage
	 * collection. The system should check `isPersistent` to determine whether the
	 * event should be released into the pool after being dispatched. Users that
	 * need a persisted event should invoke `persist`.
	 *
	 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
	 * normalizing browser quirks. Subclasses do not necessarily have to implement a
	 * DOM interface; custom application-specific events can also subclass this.
	 *
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 */
	function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  this.dispatchConfig = dispatchConfig;
	  this.dispatchMarker = dispatchMarker;
	  this.nativeEvent = nativeEvent;
	
	  var Interface = this.constructor.Interface;
	  for (var propName in Interface) {
	    if (!Interface.hasOwnProperty(propName)) {
	      continue;
	    }
	    var normalize = Interface[propName];
	    if (normalize) {
	      this[propName] = normalize(nativeEvent);
	    } else {
	      if (propName === 'target') {
	        this.target = nativeEventTarget;
	      } else {
	        this[propName] = nativeEvent[propName];
	      }
	    }
	  }
	
	  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
	  if (defaultPrevented) {
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  } else {
	    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
	  }
	  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
	}
	
	assign(SyntheticEvent.prototype, {
	
	  preventDefault: function preventDefault() {
	    this.defaultPrevented = true;
	    var event = this.nativeEvent;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `preventDefault` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
	    }
	    if (!event) {
	      return;
	    }
	
	    if (event.preventDefault) {
	      event.preventDefault();
	    } else {
	      event.returnValue = false;
	    }
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  },
	
	  stopPropagation: function stopPropagation() {
	    var event = this.nativeEvent;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `stopPropagation` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
	    }
	    if (!event) {
	      return;
	    }
	
	    if (event.stopPropagation) {
	      event.stopPropagation();
	    } else {
	      event.cancelBubble = true;
	    }
	    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * We release all dispatched `SyntheticEvent`s after each event loop, adding
	   * them back into the pool. This allows a way to hold onto a reference that
	   * won't be added back into the pool.
	   */
	  persist: function persist() {
	    this.isPersistent = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * Checks if this event should be released back into the pool.
	   *
	   * @return {boolean} True if this should not be released, false otherwise.
	   */
	  isPersistent: emptyFunction.thatReturnsFalse,
	
	  /**
	   * `PooledClass` looks for `destructor` on each instance it releases.
	   */
	  destructor: function destructor() {
	    var Interface = this.constructor.Interface;
	    for (var propName in Interface) {
	      this[propName] = null;
	    }
	    this.dispatchConfig = null;
	    this.dispatchMarker = null;
	    this.nativeEvent = null;
	  }
	
	});
	
	SyntheticEvent.Interface = EventInterface;
	
	/**
	 * Helper to reduce boilerplate when creating subclasses.
	 *
	 * @param {function} Class
	 * @param {?object} Interface
	 */
	SyntheticEvent.augmentClass = function (Class, Interface) {
	  var Super = this;
	
	  var prototype = Object.create(Super.prototype);
	  assign(prototype, Class.prototype);
	  Class.prototype = prototype;
	  Class.prototype.constructor = Class;
	
	  Class.Interface = assign({}, Super.Interface, Interface);
	  Class.augmentClass = Super.augmentClass;
	
	  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
	};
	
	PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
	
	module.exports = SyntheticEvent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticInputEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(84);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
	 *      /#events-inputevents
	 */
	var InputEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
	
	module.exports = SyntheticInputEvent;

/***/ },
/* 86 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule keyOf
	 */
	
	/**
	 * Allows extraction of a minified key. Let's the build system minify keys
	 * without losing the ability to dynamically use key strings as values
	 * themselves. Pass in an object with a single key/val pair and it will return
	 * you the string key of that single record. Suppose you want to grab the
	 * value for a key 'className' inside of an object. Key/val minification may
	 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
	 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
	 * reuse those resolutions.
	 */
	"use strict";
	
	var keyOf = function keyOf(oneKeyObj) {
	  var key;
	  for (key in oneKeyObj) {
	    if (!oneKeyObj.hasOwnProperty(key)) {
	      continue;
	    }
	    return key;
	  }
	  return null;
	};
	
	module.exports = keyOf;

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ChangeEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var EventPluginHub = __webpack_require__(38);
	var EventPropagators = __webpack_require__(80);
	var ExecutionEnvironment = __webpack_require__(16);
	var ReactUpdates = __webpack_require__(61);
	var SyntheticEvent = __webpack_require__(84);
	
	var getEventTarget = __webpack_require__(88);
	var isEventSupported = __webpack_require__(47);
	var isTextInputElement = __webpack_require__(89);
	var keyOf = __webpack_require__(86);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  change: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onChange: null }),
	      captured: keyOf({ onChangeCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	/**
	 * For IE shims
	 */
	var activeElement = null;
	var activeElementID = null;
	var activeElementValue = null;
	var activeElementValueProp = null;
	
	/**
	 * SECTION: handle `change` event
	 */
	function shouldUseChangeEvent(elem) {
	  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
	}
	
	var doesChangeEventBubble = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // See `handleChange` comment below
	  doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
	}
	
	function manualDispatchChangeEvent(nativeEvent) {
	  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent, getEventTarget(nativeEvent));
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	
	  // If change and propertychange bubbled, we'd just bind to it like all the
	  // other events and have it go through ReactBrowserEventEmitter. Since it
	  // doesn't, we manually listen for the events and so we have to enqueue and
	  // process the abstract event manually.
	  //
	  // Batching is necessary here in order to ensure that all event handlers run
	  // before the next rerender (including event handlers attached to ancestor
	  // elements instead of directly on the input). Without this, controlled
	  // components don't work properly in conjunction with event bubbling because
	  // the component is rerendered and the value reverted before all the event
	  // handlers can run. See https://github.com/facebook/react/issues/708.
	  ReactUpdates.batchedUpdates(runEventInBatch, event);
	}
	
	function runEventInBatch(event) {
	  EventPluginHub.enqueueEvents(event);
	  EventPluginHub.processEventQueue(false);
	}
	
	function startWatchingForChangeEventIE8(target, targetID) {
	  activeElement = target;
	  activeElementID = targetID;
	  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
	}
	
	function stopWatchingForChangeEventIE8() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
	  activeElement = null;
	  activeElementID = null;
	}
	
	function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topChange) {
	    return topLevelTargetID;
	  }
	}
	function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForChangeEventIE8();
	    startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForChangeEventIE8();
	  }
	}
	
	/**
	 * SECTION: handle `input` event
	 */
	var isInputEventSupported = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // IE9 claims to support the input event but fails to trigger it when
	  // deleting text, so we ignore its input events
	  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
	}
	
	/**
	 * (For old IE.) Replacement getter/setter for the `value` property that gets
	 * set on the active element.
	 */
	var newValueProp = {
	  get: function get() {
	    return activeElementValueProp.get.call(this);
	  },
	  set: function set(val) {
	    // Cast to a string so we can do equality checks.
	    activeElementValue = '' + val;
	    activeElementValueProp.set.call(this, val);
	  }
	};
	
	/**
	 * (For old IE.) Starts tracking propertychange events on the passed-in element
	 * and override the value property so that we can distinguish user events from
	 * value changes in JS.
	 */
	function startWatchingForValueChange(target, targetID) {
	  activeElement = target;
	  activeElementID = targetID;
	  activeElementValue = target.value;
	  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
	
	  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
	  // on DOM elements
	  Object.defineProperty(activeElement, 'value', newValueProp);
	  activeElement.attachEvent('onpropertychange', handlePropertyChange);
	}
	
	/**
	 * (For old IE.) Removes the event listeners from the currently-tracked element,
	 * if any exists.
	 */
	function stopWatchingForValueChange() {
	  if (!activeElement) {
	    return;
	  }
	
	  // delete restores the original property definition
	  delete activeElement.value;
	  activeElement.detachEvent('onpropertychange', handlePropertyChange);
	
	  activeElement = null;
	  activeElementID = null;
	  activeElementValue = null;
	  activeElementValueProp = null;
	}
	
	/**
	 * (For old IE.) Handles a propertychange event, sending a `change` event if
	 * the value of the active element has changed.
	 */
	function handlePropertyChange(nativeEvent) {
	  if (nativeEvent.propertyName !== 'value') {
	    return;
	  }
	  var value = nativeEvent.srcElement.value;
	  if (value === activeElementValue) {
	    return;
	  }
	  activeElementValue = value;
	
	  manualDispatchChangeEvent(nativeEvent);
	}
	
	/**
	 * If a `change` event should be fired, returns the target's ID.
	 */
	function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topInput) {
	    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
	    // what we want so fall through here and trigger an abstract event
	    return topLevelTargetID;
	  }
	}
	
	// For IE8 and IE9.
	function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // In IE8, we can capture almost all .value changes by adding a
	    // propertychange handler and looking for events with propertyName
	    // equal to 'value'
	    // In IE9, propertychange fires for most input events but is buggy and
	    // doesn't fire when text is deleted, but conveniently, selectionchange
	    // appears to fire in all of the remaining cases so we catch those and
	    // forward the event if the value has changed
	    // In either case, we don't want to call the event handler if the value
	    // is changed from JS so we redefine a setter for `.value` that updates
	    // our activeElementValue variable, allowing us to ignore those changes
	    //
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForValueChange();
	    startWatchingForValueChange(topLevelTarget, topLevelTargetID);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForValueChange();
	  }
	}
	
	// For IE8 and IE9.
	function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
	    // On the selectionchange event, the target is just document which isn't
	    // helpful for us so just check activeElement instead.
	    //
	    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
	    // propertychange on the first input event after setting `value` from a
	    // script and fires only keydown, keypress, keyup. Catching keyup usually
	    // gets it and catching keydown lets us fire an event for the first
	    // keystroke if user does a key repeat (it'll be a little delayed: right
	    // before the second keystroke). Other input methods (e.g., paste) seem to
	    // fire selectionchange normally.
	    if (activeElement && activeElement.value !== activeElementValue) {
	      activeElementValue = activeElement.value;
	      return activeElementID;
	    }
	  }
	}
	
	/**
	 * SECTION: handle `click` event
	 */
	function shouldUseClickEvent(elem) {
	  // Use the `click` event to detect changes to checkbox and radio inputs.
	  // This approach works across all browsers, whereas `change` does not fire
	  // until `blur` in IE8.
	  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
	}
	
	function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topClick) {
	    return topLevelTargetID;
	  }
	}
	
	/**
	 * This plugin creates an `onChange` event that normalizes change events
	 * across form elements. This event fires at a time when it's possible to
	 * change the element's value without seeing a flicker.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - select
	 */
	var ChangeEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	
	    var getTargetIDFunc, handleEventFunc;
	    if (shouldUseChangeEvent(topLevelTarget)) {
	      if (doesChangeEventBubble) {
	        getTargetIDFunc = getTargetIDForChangeEvent;
	      } else {
	        handleEventFunc = handleEventsForChangeEventIE8;
	      }
	    } else if (isTextInputElement(topLevelTarget)) {
	      if (isInputEventSupported) {
	        getTargetIDFunc = getTargetIDForInputEvent;
	      } else {
	        getTargetIDFunc = getTargetIDForInputEventIE;
	        handleEventFunc = handleEventsForInputEventIE;
	      }
	    } else if (shouldUseClickEvent(topLevelTarget)) {
	      getTargetIDFunc = getTargetIDForClickEvent;
	    }
	
	    if (getTargetIDFunc) {
	      var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);
	      if (targetID) {
	        var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent, nativeEventTarget);
	        event.type = 'change';
	        EventPropagators.accumulateTwoPhaseDispatches(event);
	        return event;
	      }
	    }
	
	    if (handleEventFunc) {
	      handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID);
	    }
	  }
	
	};
	
	module.exports = ChangeEventPlugin;

/***/ },
/* 88 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventTarget
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Gets the target node from a native browser event by accounting for
	 * inconsistencies in browser DOM APIs.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {DOMEventTarget} Target node.
	 */
	
	function getEventTarget(nativeEvent) {
	  var target = nativeEvent.target || nativeEvent.srcElement || window;
	  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
	  // @see http://www.quirksmode.org/js/events_properties.html
	  return target.nodeType === 3 ? target.parentNode : target;
	}
	
	module.exports = getEventTarget;

/***/ },
/* 89 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextInputElement
	 */
	
	'use strict';
	
	/**
	 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
	 */
	
	var supportedInputTypes = {
	  'color': true,
	  'date': true,
	  'datetime': true,
	  'datetime-local': true,
	  'email': true,
	  'month': true,
	  'number': true,
	  'password': true,
	  'range': true,
	  'search': true,
	  'tel': true,
	  'text': true,
	  'time': true,
	  'url': true,
	  'week': true
	};
	
	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName && (nodeName === 'input' && supportedInputTypes[elem.type] || nodeName === 'textarea');
	}
	
	module.exports = isTextInputElement;

/***/ },
/* 90 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ClientReactRootIndex
	 * @typechecks
	 */
	
	'use strict';
	
	var nextReactRootIndex = 0;
	
	var ClientReactRootIndex = {
	  createReactRootIndex: function createReactRootIndex() {
	    return nextReactRootIndex++;
	  }
	};
	
	module.exports = ClientReactRootIndex;

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DefaultEventPluginOrder
	 */
	
	'use strict';
	
	var keyOf = __webpack_require__(86);
	
	/**
	 * Module that is injectable into `EventPluginHub`, that specifies a
	 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
	 * plugins, without having to package every one of them. This is better than
	 * having plugins be ordered in the same order that they are injected because
	 * that ordering would be influenced by the packaging order.
	 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
	 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
	 */
	var DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null })];
	
	module.exports = DefaultEventPluginOrder;

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EnterLeaveEventPlugin
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var EventPropagators = __webpack_require__(80);
	var SyntheticMouseEvent = __webpack_require__(93);
	
	var ReactMount = __webpack_require__(35);
	var keyOf = __webpack_require__(86);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	var getFirstReactDOM = ReactMount.getFirstReactDOM;
	
	var eventTypes = {
	  mouseEnter: {
	    registrationName: keyOf({ onMouseEnter: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  },
	  mouseLeave: {
	    registrationName: keyOf({ onMouseLeave: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  }
	};
	
	var extractedEvents = [null, null];
	
	var EnterLeaveEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * For almost every interaction we care about, there will be both a top-level
	   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
	   * we do not extract duplicate events. However, moving the mouse into the
	   * browser from outside will not fire a `mouseout` event. In this case, we use
	   * the `mouseover` top-level event.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
	      return null;
	    }
	    if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
	      // Must not be a mouse in or mouse out - ignoring.
	      return null;
	    }
	
	    var win;
	    if (topLevelTarget.window === topLevelTarget) {
	      // `topLevelTarget` is probably a window object.
	      win = topLevelTarget;
	    } else {
	      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	      var doc = topLevelTarget.ownerDocument;
	      if (doc) {
	        win = doc.defaultView || doc.parentWindow;
	      } else {
	        win = window;
	      }
	    }
	
	    var from;
	    var to;
	    var fromID = '';
	    var toID = '';
	    if (topLevelType === topLevelTypes.topMouseOut) {
	      from = topLevelTarget;
	      fromID = topLevelTargetID;
	      to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement);
	      if (to) {
	        toID = ReactMount.getID(to);
	      } else {
	        to = win;
	      }
	      to = to || win;
	    } else {
	      from = win;
	      to = topLevelTarget;
	      toID = topLevelTargetID;
	    }
	
	    if (from === to) {
	      // Nothing pertains to our managed components.
	      return null;
	    }
	
	    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent, nativeEventTarget);
	    leave.type = 'mouseleave';
	    leave.target = from;
	    leave.relatedTarget = to;
	
	    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent, nativeEventTarget);
	    enter.type = 'mouseenter';
	    enter.target = to;
	    enter.relatedTarget = from;
	
	    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);
	
	    extractedEvents[0] = leave;
	    extractedEvents[1] = enter;
	
	    return extractedEvents;
	  }
	
	};
	
	module.exports = EnterLeaveEventPlugin;

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticMouseEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(94);
	var ViewportMetrics = __webpack_require__(45);
	
	var getEventModifierState = __webpack_require__(95);
	
	/**
	 * @interface MouseEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var MouseEventInterface = {
	  screenX: null,
	  screenY: null,
	  clientX: null,
	  clientY: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  getModifierState: getEventModifierState,
	  button: function button(event) {
	    // Webkit, Firefox, IE9+
	    // which:  1 2 3
	    // button: 0 1 2 (standard)
	    var button = event.button;
	    if ('which' in event) {
	      return button;
	    }
	    // IE<9
	    // which:  undefined
	    // button: 0 0 0
	    // button: 1 4 2 (onmouseup)
	    return button === 2 ? 2 : button === 4 ? 1 : 0;
	  },
	  buttons: null,
	  relatedTarget: function relatedTarget(event) {
	    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
	  },
	  // "Proprietary" Interface.
	  pageX: function pageX(event) {
	    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
	  },
	  pageY: function pageY(event) {
	    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
	
	module.exports = SyntheticMouseEvent;

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticUIEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(84);
	
	var getEventTarget = __webpack_require__(88);
	
	/**
	 * @interface UIEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var UIEventInterface = {
	  view: function view(event) {
	    if (event.view) {
	      return event.view;
	    }
	
	    var target = getEventTarget(event);
	    if (target != null && target.window === target) {
	      // target is a window object
	      return target;
	    }
	
	    var doc = target.ownerDocument;
	    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	    if (doc) {
	      return doc.defaultView || doc.parentWindow;
	    } else {
	      return window;
	    }
	  },
	  detail: function detail(event) {
	    return event.detail || 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
	
	module.exports = SyntheticUIEvent;

/***/ },
/* 95 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventModifierState
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Translation from modifier key to the associated property in the event.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
	 */
	
	var modifierKeyToProp = {
	  'Alt': 'altKey',
	  'Control': 'ctrlKey',
	  'Meta': 'metaKey',
	  'Shift': 'shiftKey'
	};
	
	// IE8 does not implement getModifierState so we simply map it to the only
	// modifier keys exposed by the event itself, does not support Lock-keys.
	// Currently, all major browsers except Chrome seems to support Lock-keys.
	function modifierStateGetter(keyArg) {
	  var syntheticEvent = this;
	  var nativeEvent = syntheticEvent.nativeEvent;
	  if (nativeEvent.getModifierState) {
	    return nativeEvent.getModifierState(keyArg);
	  }
	  var keyProp = modifierKeyToProp[keyArg];
	  return keyProp ? !!nativeEvent[keyProp] : false;
	}
	
	function getEventModifierState(nativeEvent) {
	  return modifierStateGetter;
	}
	
	module.exports = getEventModifierState;

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule HTMLDOMPropertyConfig
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(30);
	var ExecutionEnvironment = __webpack_require__(16);
	
	var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
	var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
	var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
	var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
	var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
	var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
	var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
	
	var hasSVG;
	if (ExecutionEnvironment.canUseDOM) {
	  var implementation = document.implementation;
	  hasSVG = implementation && implementation.hasFeature && implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1');
	}
	
	var HTMLDOMPropertyConfig = {
	  isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/),
	  Properties: {
	    /**
	     * Standard Properties
	     */
	    accept: null,
	    acceptCharset: null,
	    accessKey: null,
	    action: null,
	    allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    allowTransparency: MUST_USE_ATTRIBUTE,
	    alt: null,
	    async: HAS_BOOLEAN_VALUE,
	    autoComplete: null,
	    // autoFocus is polyfilled/normalized by AutoFocusUtils
	    // autoFocus: HAS_BOOLEAN_VALUE,
	    autoPlay: HAS_BOOLEAN_VALUE,
	    capture: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    cellPadding: null,
	    cellSpacing: null,
	    charSet: MUST_USE_ATTRIBUTE,
	    challenge: MUST_USE_ATTRIBUTE,
	    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    classID: MUST_USE_ATTRIBUTE,
	    // To set className on SVG elements, it's necessary to use .setAttribute;
	    // this works on HTML elements too in all browsers except IE8. Conveniently,
	    // IE8 doesn't support SVG and so we can simply use the attribute in
	    // browsers that support SVG and the property in browsers that don't,
	    // regardless of whether the element is HTML or SVG.
	    className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
	    cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    colSpan: null,
	    content: null,
	    contentEditable: null,
	    contextMenu: MUST_USE_ATTRIBUTE,
	    controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    coords: null,
	    crossOrigin: null,
	    data: null, // For `<object />` acts as `src`.
	    dateTime: MUST_USE_ATTRIBUTE,
	    'default': HAS_BOOLEAN_VALUE,
	    defer: HAS_BOOLEAN_VALUE,
	    dir: null,
	    disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    download: HAS_OVERLOADED_BOOLEAN_VALUE,
	    draggable: null,
	    encType: null,
	    form: MUST_USE_ATTRIBUTE,
	    formAction: MUST_USE_ATTRIBUTE,
	    formEncType: MUST_USE_ATTRIBUTE,
	    formMethod: MUST_USE_ATTRIBUTE,
	    formNoValidate: HAS_BOOLEAN_VALUE,
	    formTarget: MUST_USE_ATTRIBUTE,
	    frameBorder: MUST_USE_ATTRIBUTE,
	    headers: null,
	    height: MUST_USE_ATTRIBUTE,
	    hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    high: null,
	    href: null,
	    hrefLang: null,
	    htmlFor: null,
	    httpEquiv: null,
	    icon: null,
	    id: MUST_USE_PROPERTY,
	    inputMode: MUST_USE_ATTRIBUTE,
	    integrity: null,
	    is: MUST_USE_ATTRIBUTE,
	    keyParams: MUST_USE_ATTRIBUTE,
	    keyType: MUST_USE_ATTRIBUTE,
	    kind: null,
	    label: null,
	    lang: null,
	    list: MUST_USE_ATTRIBUTE,
	    loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    low: null,
	    manifest: MUST_USE_ATTRIBUTE,
	    marginHeight: null,
	    marginWidth: null,
	    max: null,
	    maxLength: MUST_USE_ATTRIBUTE,
	    media: MUST_USE_ATTRIBUTE,
	    mediaGroup: null,
	    method: null,
	    min: null,
	    minLength: MUST_USE_ATTRIBUTE,
	    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    name: null,
	    nonce: MUST_USE_ATTRIBUTE,
	    noValidate: HAS_BOOLEAN_VALUE,
	    open: HAS_BOOLEAN_VALUE,
	    optimum: null,
	    pattern: null,
	    placeholder: null,
	    poster: null,
	    preload: null,
	    radioGroup: null,
	    readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    rel: null,
	    required: HAS_BOOLEAN_VALUE,
	    reversed: HAS_BOOLEAN_VALUE,
	    role: MUST_USE_ATTRIBUTE,
	    rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    rowSpan: null,
	    sandbox: null,
	    scope: null,
	    scoped: HAS_BOOLEAN_VALUE,
	    scrolling: null,
	    seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    shape: null,
	    size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    sizes: MUST_USE_ATTRIBUTE,
	    span: HAS_POSITIVE_NUMERIC_VALUE,
	    spellCheck: null,
	    src: null,
	    srcDoc: MUST_USE_PROPERTY,
	    srcLang: null,
	    srcSet: MUST_USE_ATTRIBUTE,
	    start: HAS_NUMERIC_VALUE,
	    step: null,
	    style: null,
	    summary: null,
	    tabIndex: null,
	    target: null,
	    title: null,
	    type: null,
	    useMap: null,
	    value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
	    width: MUST_USE_ATTRIBUTE,
	    wmode: MUST_USE_ATTRIBUTE,
	    wrap: null,
	
	    /**
	     * RDFa Properties
	     */
	    about: MUST_USE_ATTRIBUTE,
	    datatype: MUST_USE_ATTRIBUTE,
	    inlist: MUST_USE_ATTRIBUTE,
	    prefix: MUST_USE_ATTRIBUTE,
	    // property is also supported for OpenGraph in meta tags.
	    property: MUST_USE_ATTRIBUTE,
	    resource: MUST_USE_ATTRIBUTE,
	    'typeof': MUST_USE_ATTRIBUTE,
	    vocab: MUST_USE_ATTRIBUTE,
	
	    /**
	     * Non-standard Properties
	     */
	    // autoCapitalize and autoCorrect are supported in Mobile Safari for
	    // keyboard hints.
	    autoCapitalize: MUST_USE_ATTRIBUTE,
	    autoCorrect: MUST_USE_ATTRIBUTE,
	    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
	    autoSave: null,
	    // color is for Safari mask-icon link
	    color: null,
	    // itemProp, itemScope, itemType are for
	    // Microdata support. See http://schema.org/docs/gs.html
	    itemProp: MUST_USE_ATTRIBUTE,
	    itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    itemType: MUST_USE_ATTRIBUTE,
	    // itemID and itemRef are for Microdata support as well but
	    // only specified in the the WHATWG spec document. See
	    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
	    itemID: MUST_USE_ATTRIBUTE,
	    itemRef: MUST_USE_ATTRIBUTE,
	    // results show looking glass icon and recent searches on input
	    // search fields in WebKit/Blink
	    results: null,
	    // IE-only attribute that specifies security restrictions on an iframe
	    // as an alternative to the sandbox attribute on IE<10
	    security: MUST_USE_ATTRIBUTE,
	    // IE-only attribute that controls focus behavior
	    unselectable: MUST_USE_ATTRIBUTE
	  },
	  DOMAttributeNames: {
	    acceptCharset: 'accept-charset',
	    className: 'class',
	    htmlFor: 'for',
	    httpEquiv: 'http-equiv'
	  },
	  DOMPropertyNames: {
	    autoComplete: 'autocomplete',
	    autoFocus: 'autofocus',
	    autoPlay: 'autoplay',
	    autoSave: 'autosave',
	    // `encoding` is equivalent to `enctype`, IE8 lacks an `enctype` setter.
	    // http://www.w3.org/TR/html5/forms.html#dom-fs-encoding
	    encType: 'encoding',
	    hrefLang: 'hreflang',
	    radioGroup: 'radiogroup',
	    spellCheck: 'spellcheck',
	    srcDoc: 'srcdoc',
	    srcSet: 'srcset'
	  }
	};
	
	module.exports = HTMLDOMPropertyConfig;

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserComponentMixin
	 */
	
	'use strict';
	
	var ReactInstanceMap = __webpack_require__(54);
	
	var findDOMNode = __webpack_require__(98);
	var warning = __webpack_require__(32);
	
	var didWarnKey = '_getDOMNodeDidWarn';
	
	var ReactBrowserComponentMixin = {
	  /**
	   * Returns the DOM node rendered by this component.
	   *
	   * @return {DOMElement} The root node of this component.
	   * @final
	   * @protected
	   */
	  getDOMNode: function getDOMNode() {
	    process.env.NODE_ENV !== 'production' ? warning(this.constructor[didWarnKey], '%s.getDOMNode(...) is deprecated. Please use ' + 'ReactDOM.findDOMNode(instance) instead.', ReactInstanceMap.get(this).getName() || this.tagName || 'Unknown') : undefined;
	    this.constructor[didWarnKey] = true;
	    return findDOMNode(this);
	  }
	};
	
	module.exports = ReactBrowserComponentMixin;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule findDOMNode
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactInstanceMap = __webpack_require__(54);
	var ReactMount = __webpack_require__(35);
	
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	/**
	 * Returns the DOM node rendered by this element.
	 *
	 * @param {ReactComponent|DOMElement} componentOrElement
	 * @return {?DOMElement} The root node of this element.
	 */
	function findDOMNode(componentOrElement) {
	  if (process.env.NODE_ENV !== 'production') {
	    var owner = ReactCurrentOwner.current;
	    if (owner !== null) {
	      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing getDOMNode or findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
	      owner._warnedAboutRefsInRender = true;
	    }
	  }
	  if (componentOrElement == null) {
	    return null;
	  }
	  if (componentOrElement.nodeType === 1) {
	    return componentOrElement;
	  }
	  if (ReactInstanceMap.has(componentOrElement)) {
	    return ReactMount.getNodeFromInstance(componentOrElement);
	  }
	  !(componentOrElement.render == null || typeof componentOrElement.render !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : invariant(false) : undefined;
	   true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : invariant(false) : undefined;
	}
	
	module.exports = findDOMNode;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultBatchingStrategy
	 */
	
	'use strict';
	
	var ReactUpdates = __webpack_require__(61);
	var Transaction = __webpack_require__(64);
	
	var assign = __webpack_require__(46);
	var emptyFunction = __webpack_require__(22);
	
	var RESET_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: function close() {
	    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
	  }
	};
	
	var FLUSH_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
	};
	
	var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
	
	function ReactDefaultBatchingStrategyTransaction() {
	  this.reinitializeTransaction();
	}
	
	assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  }
	});
	
	var transaction = new ReactDefaultBatchingStrategyTransaction();
	
	var ReactDefaultBatchingStrategy = {
	  isBatchingUpdates: false,
	
	  /**
	   * Call the provided function in a context within which calls to `setState`
	   * and friends are batched such that components aren't updated unnecessarily.
	   */
	  batchedUpdates: function batchedUpdates(callback, a, b, c, d, e) {
	    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
	
	    ReactDefaultBatchingStrategy.isBatchingUpdates = true;
	
	    // The code is written this way to avoid extra allocations
	    if (alreadyBatchingUpdates) {
	      callback(a, b, c, d, e);
	    } else {
	      transaction.perform(callback, null, a, b, c, d, e);
	    }
	  }
	};
	
	module.exports = ReactDefaultBatchingStrategy;

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponent
	 * @typechecks static-only
	 */
	
	/* global hasOwnProperty:true */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var AutoFocusUtils = __webpack_require__(101);
	var CSSPropertyOperations = __webpack_require__(103);
	var DOMProperty = __webpack_require__(30);
	var DOMPropertyOperations = __webpack_require__(29);
	var EventConstants = __webpack_require__(37);
	var ReactBrowserEventEmitter = __webpack_require__(36);
	var ReactComponentBrowserEnvironment = __webpack_require__(33);
	var ReactDOMButton = __webpack_require__(111);
	var ReactDOMInput = __webpack_require__(112);
	var ReactDOMOption = __webpack_require__(116);
	var ReactDOMSelect = __webpack_require__(119);
	var ReactDOMTextarea = __webpack_require__(120);
	var ReactMount = __webpack_require__(35);
	var ReactMultiChild = __webpack_require__(121);
	var ReactPerf = __webpack_require__(25);
	var ReactUpdateQueue = __webpack_require__(60);
	
	var assign = __webpack_require__(46);
	var canDefineProperty = __webpack_require__(50);
	var escapeTextContentForBrowser = __webpack_require__(28);
	var invariant = __webpack_require__(20);
	var isEventSupported = __webpack_require__(47);
	var keyOf = __webpack_require__(86);
	var setInnerHTML = __webpack_require__(26);
	var setTextContent = __webpack_require__(27);
	var shallowEqual = __webpack_require__(124);
	var validateDOMNesting = __webpack_require__(77);
	var warning = __webpack_require__(32);
	
	var deleteListener = ReactBrowserEventEmitter.deleteListener;
	var listenTo = ReactBrowserEventEmitter.listenTo;
	var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;
	
	// For quickly matching children type, to test if can be treated as content.
	var CONTENT_TYPES = { 'string': true, 'number': true };
	
	var CHILDREN = keyOf({ children: null });
	var STYLE = keyOf({ style: null });
	var HTML = keyOf({ __html: null });
	
	var ELEMENT_NODE_TYPE = 1;
	
	function getDeclarationErrorAddendum(internalInstance) {
	  if (internalInstance) {
	    var owner = internalInstance._currentElement._owner || null;
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' This DOM node was rendered by `' + name + '`.';
	      }
	    }
	  }
	  return '';
	}
	
	var legacyPropsDescriptor;
	if (process.env.NODE_ENV !== 'production') {
	  legacyPropsDescriptor = {
	    props: {
	      enumerable: false,
	      get: function get() {
	        var component = this._reactInternalComponent;
	        process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .props of a DOM node; instead, ' + 'recreate the props as `render` did originally or read the DOM ' + 'properties/attributes directly from this node (e.g., ' + 'this.refs.box.className).%s', getDeclarationErrorAddendum(component)) : undefined;
	        return component._currentElement.props;
	      }
	    }
	  };
	}
	
	function legacyGetDOMNode() {
	  if (process.env.NODE_ENV !== 'production') {
	    var component = this._reactInternalComponent;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .getDOMNode() of a DOM node; ' + 'instead, use the node directly.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  return this;
	}
	
	function legacyIsMounted() {
	  var component = this._reactInternalComponent;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .isMounted() of a DOM node.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  return !!component;
	}
	
	function legacySetStateEtc() {
	  if (process.env.NODE_ENV !== 'production') {
	    var component = this._reactInternalComponent;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setState(), .replaceState(), or ' + '.forceUpdate() of a DOM node. This is a no-op.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	}
	
	function legacySetProps(partialProps, callback) {
	  var component = this._reactInternalComponent;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  if (!component) {
	    return;
	  }
	  ReactUpdateQueue.enqueueSetPropsInternal(component, partialProps);
	  if (callback) {
	    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
	  }
	}
	
	function legacyReplaceProps(partialProps, callback) {
	  var component = this._reactInternalComponent;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .replaceProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  if (!component) {
	    return;
	  }
	  ReactUpdateQueue.enqueueReplacePropsInternal(component, partialProps);
	  if (callback) {
	    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
	  }
	}
	
	function friendlyStringify(obj) {
	  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
	    if (Array.isArray(obj)) {
	      return '[' + obj.map(friendlyStringify).join(', ') + ']';
	    } else {
	      var pairs = [];
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
	          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
	        }
	      }
	      return '{' + pairs.join(', ') + '}';
	    }
	  } else if (typeof obj === 'string') {
	    return JSON.stringify(obj);
	  } else if (typeof obj === 'function') {
	    return '[function object]';
	  }
	  // Differs from JSON.stringify in that undefined becauses undefined and that
	  // inf and nan don't become null
	  return String(obj);
	}
	
	var styleMutationWarning = {};
	
	function checkAndWarnForMutatedStyle(style1, style2, component) {
	  if (style1 == null || style2 == null) {
	    return;
	  }
	  if (shallowEqual(style1, style2)) {
	    return;
	  }
	
	  var componentName = component._tag;
	  var owner = component._currentElement._owner;
	  var ownerName;
	  if (owner) {
	    ownerName = owner.getName();
	  }
	
	  var hash = ownerName + '|' + componentName;
	
	  if (styleMutationWarning.hasOwnProperty(hash)) {
	    return;
	  }
	
	  styleMutationWarning[hash] = true;
	
	  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : undefined;
	}
	
	/**
	 * @param {object} component
	 * @param {?object} props
	 */
	function assertValidProps(component, props) {
	  if (!props) {
	    return;
	  }
	  // Note the use of `==` which checks for null or undefined.
	  if (process.env.NODE_ENV !== 'production') {
	    if (voidElementTags[component._tag]) {
	      process.env.NODE_ENV !== 'production' ? warning(props.children == null && props.dangerouslySetInnerHTML == null, '%s is a void element tag and must not have `children` or ' + 'use `props.dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : undefined;
	    }
	  }
	  if (props.dangerouslySetInnerHTML != null) {
	    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : invariant(false) : undefined;
	    !(_typeof(props.dangerouslySetInnerHTML) === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' + 'Please visit https://fb.me/react-invariant-dangerously-set-inner-html ' + 'for more information.') : invariant(false) : undefined;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : undefined;
	    process.env.NODE_ENV !== 'production' ? warning(!props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : undefined;
	  }
	  !(props.style == null || _typeof(props.style) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, ' + 'not a string. For example, style={{marginRight: spacing + \'em\'}} when ' + 'using JSX.%s', getDeclarationErrorAddendum(component)) : invariant(false) : undefined;
	}
	
	function enqueuePutListener(id, registrationName, listener, transaction) {
	  if (process.env.NODE_ENV !== 'production') {
	    // IE8 has no API for event capturing and the `onScroll` event doesn't
	    // bubble.
	    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : undefined;
	  }
	  var container = ReactMount.findReactContainerForID(id);
	  if (container) {
	    var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
	    listenTo(registrationName, doc);
	  }
	  transaction.getReactMountReady().enqueue(putListener, {
	    id: id,
	    registrationName: registrationName,
	    listener: listener
	  });
	}
	
	function putListener() {
	  var listenerToPut = this;
	  ReactBrowserEventEmitter.putListener(listenerToPut.id, listenerToPut.registrationName, listenerToPut.listener);
	}
	
	// There are so many media events, it makes sense to just
	// maintain a list rather than create a `trapBubbledEvent` for each
	var mediaEvents = {
	  topAbort: 'abort',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTimeUpdate: 'timeupdate',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting'
	};
	
	function trapBubbledEventsLocal() {
	  var inst = this;
	  // If a component renders to null or if another component fatals and causes
	  // the state of the tree to be corrupted, `node` here can be null.
	  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : invariant(false) : undefined;
	  var node = ReactMount.getNode(inst._rootNodeID);
	  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : invariant(false) : undefined;
	
	  switch (inst._tag) {
	    case 'iframe':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'video':
	    case 'audio':
	
	      inst._wrapperState.listeners = [];
	      // create listener for each media event
	      for (var event in mediaEvents) {
	        if (mediaEvents.hasOwnProperty(event)) {
	          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
	        }
	      }
	
	      break;
	    case 'img':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'form':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];
	      break;
	  }
	}
	
	function mountReadyInputWrapper() {
	  ReactDOMInput.mountReadyWrapper(this);
	}
	
	function postUpdateSelectWrapper() {
	  ReactDOMSelect.postUpdateWrapper(this);
	}
	
	// For HTML, certain tags should omit their close tag. We keep a whitelist for
	// those special cased tags.
	
	var omittedCloseTags = {
	  'area': true,
	  'base': true,
	  'br': true,
	  'col': true,
	  'embed': true,
	  'hr': true,
	  'img': true,
	  'input': true,
	  'keygen': true,
	  'link': true,
	  'meta': true,
	  'param': true,
	  'source': true,
	  'track': true,
	  'wbr': true
	};
	
	// NOTE: menuitem's close tag should be omitted, but that causes problems.
	var newlineEatingTags = {
	  'listing': true,
	  'pre': true,
	  'textarea': true
	};
	
	// For HTML, certain tags cannot have children. This has the same purpose as
	// `omittedCloseTags` except that `menuitem` should still have its closing tag.
	
	var voidElementTags = assign({
	  'menuitem': true
	}, omittedCloseTags);
	
	// We accept any tag to be rendered but since this gets injected into arbitrary
	// HTML, we want to make sure that it's a safe tag.
	// http://www.w3.org/TR/REC-xml/#NT-Name
	
	var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
	var validatedTagCache = {};
	var hasOwnProperty = {}.hasOwnProperty;
	
	function validateDangerousTag(tag) {
	  if (!hasOwnProperty.call(validatedTagCache, tag)) {
	    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : invariant(false) : undefined;
	    validatedTagCache[tag] = true;
	  }
	}
	
	function processChildContextDev(context, inst) {
	  // Pass down our tag name to child components for validation purposes
	  context = assign({}, context);
	  var info = context[validateDOMNesting.ancestorInfoContextKey];
	  context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(info, inst._tag, inst);
	  return context;
	}
	
	function isCustomComponent(tagName, props) {
	  return tagName.indexOf('-') >= 0 || props.is != null;
	}
	
	/**
	 * Creates a new React class that is idempotent and capable of containing other
	 * React components. It accepts event listeners and DOM properties that are
	 * valid according to `DOMProperty`.
	 *
	 *  - Event listeners: `onClick`, `onMouseDown`, etc.
	 *  - DOM properties: `className`, `name`, `title`, etc.
	 *
	 * The `style` property functions differently from the DOM API. It accepts an
	 * object mapping of style properties to values.
	 *
	 * @constructor ReactDOMComponent
	 * @extends ReactMultiChild
	 */
	function ReactDOMComponent(tag) {
	  validateDangerousTag(tag);
	  this._tag = tag.toLowerCase();
	  this._renderedChildren = null;
	  this._previousStyle = null;
	  this._previousStyleCopy = null;
	  this._rootNodeID = null;
	  this._wrapperState = null;
	  this._topLevelWrapper = null;
	  this._nodeWithLegacyProperties = null;
	  if (process.env.NODE_ENV !== 'production') {
	    this._unprocessedContextDev = null;
	    this._processedContextDev = null;
	  }
	}
	
	ReactDOMComponent.displayName = 'ReactDOMComponent';
	
	ReactDOMComponent.Mixin = {
	
	  construct: function construct(element) {
	    this._currentElement = element;
	  },
	
	  /**
	   * Generates root tag markup then recurses. This method has side effects and
	   * is not idempotent.
	   *
	   * @internal
	   * @param {string} rootID The root DOM ID for this node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   * @return {string} The computed markup.
	   */
	  mountComponent: function mountComponent(rootID, transaction, context) {
	    this._rootNodeID = rootID;
	
	    var props = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'iframe':
	      case 'img':
	      case 'form':
	      case 'video':
	      case 'audio':
	        this._wrapperState = {
	          listeners: null
	        };
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'button':
	        props = ReactDOMButton.getNativeProps(this, props, context);
	        break;
	      case 'input':
	        ReactDOMInput.mountWrapper(this, props, context);
	        props = ReactDOMInput.getNativeProps(this, props, context);
	        break;
	      case 'option':
	        ReactDOMOption.mountWrapper(this, props, context);
	        props = ReactDOMOption.getNativeProps(this, props, context);
	        break;
	      case 'select':
	        ReactDOMSelect.mountWrapper(this, props, context);
	        props = ReactDOMSelect.getNativeProps(this, props, context);
	        context = ReactDOMSelect.processChildContext(this, props, context);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.mountWrapper(this, props, context);
	        props = ReactDOMTextarea.getNativeProps(this, props, context);
	        break;
	    }
	
	    assertValidProps(this, props);
	    if (process.env.NODE_ENV !== 'production') {
	      if (context[validateDOMNesting.ancestorInfoContextKey]) {
	        validateDOMNesting(this._tag, this, context[validateDOMNesting.ancestorInfoContextKey]);
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      this._unprocessedContextDev = context;
	      this._processedContextDev = processChildContextDev(context, this);
	      context = this._processedContextDev;
	    }
	
	    var mountImage;
	    if (transaction.useCreateElement) {
	      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
	      var el = ownerDocument.createElement(this._currentElement.type);
	      DOMPropertyOperations.setAttributeForID(el, this._rootNodeID);
	      // Populate node cache
	      ReactMount.getID(el);
	      this._updateDOMProperties({}, props, transaction, el);
	      this._createInitialChildren(transaction, props, context, el);
	      mountImage = el;
	    } else {
	      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
	      var tagContent = this._createContentMarkup(transaction, props, context);
	      if (!tagContent && omittedCloseTags[this._tag]) {
	        mountImage = tagOpen + '/>';
	      } else {
	        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
	      }
	    }
	
	    switch (this._tag) {
	      case 'input':
	        transaction.getReactMountReady().enqueue(mountReadyInputWrapper, this);
	      // falls through
	      case 'button':
	      case 'select':
	      case 'textarea':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	    }
	
	    return mountImage;
	  },
	
	  /**
	   * Creates markup for the open tag and all attributes.
	   *
	   * This method has side effects because events get registered.
	   *
	   * Iterating over object properties is faster than iterating over arrays.
	   * @see http://jsperf.com/obj-vs-arr-iteration
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @return {string} Markup of opening tag.
	   */
	  _createOpenTagMarkupAndPutListeners: function _createOpenTagMarkupAndPutListeners(transaction, props) {
	    var ret = '<' + this._currentElement.type;
	
	    for (var propKey in props) {
	      if (!props.hasOwnProperty(propKey)) {
	        continue;
	      }
	      var propValue = props[propKey];
	      if (propValue == null) {
	        continue;
	      }
	      if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (propValue) {
	          enqueuePutListener(this._rootNodeID, propKey, propValue, transaction);
	        }
	      } else {
	        if (propKey === STYLE) {
	          if (propValue) {
	            if (process.env.NODE_ENV !== 'production') {
	              // See `_updateDOMProperties`. style block
	              this._previousStyle = propValue;
	            }
	            propValue = this._previousStyleCopy = assign({}, props.style);
	          }
	          propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
	        }
	        var markup = null;
	        if (this._tag != null && isCustomComponent(this._tag, props)) {
	          if (propKey !== CHILDREN) {
	            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
	          }
	        } else {
	          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
	        }
	        if (markup) {
	          ret += ' ' + markup;
	        }
	      }
	    }
	
	    // For static pages, no need to put React ID and checksum. Saves lots of
	    // bytes.
	    if (transaction.renderToStaticMarkup) {
	      return ret;
	    }
	
	    var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
	    return ret + ' ' + markupForID;
	  },
	
	  /**
	   * Creates markup for the content between the tags.
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @param {object} context
	   * @return {string} Content markup.
	   */
	  _createContentMarkup: function _createContentMarkup(transaction, props, context) {
	    var ret = '';
	
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        ret = innerHTML.__html;
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[_typeof(props.children)] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        ret = escapeTextContentForBrowser(contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        ret = mountImages.join('');
	      }
	    }
	    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
	      // text/html ignores the first character in these tags if it's a newline
	      // Prefer to break application/xml over text/html (for now) by adding
	      // a newline specifically to get eaten by the parser. (Alternately for
	      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
	      // \r is normalized out by HTMLTextAreaElement#value.)
	      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
	      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
	      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
	      // See: Parsing of "textarea" "listing" and "pre" elements
	      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
	      return '\n' + ret;
	    } else {
	      return ret;
	    }
	  },
	
	  _createInitialChildren: function _createInitialChildren(transaction, props, context, el) {
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        setInnerHTML(el, innerHTML.__html);
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[_typeof(props.children)] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        setTextContent(el, contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        for (var i = 0; i < mountImages.length; i++) {
	          el.appendChild(mountImages[i]);
	        }
	      }
	    }
	  },
	
	  /**
	   * Receives a next element and updates the component.
	   *
	   * @internal
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   */
	  receiveComponent: function receiveComponent(nextElement, transaction, context) {
	    var prevElement = this._currentElement;
	    this._currentElement = nextElement;
	    this.updateComponent(transaction, prevElement, nextElement, context);
	  },
	
	  /**
	   * Updates a native DOM component after it has already been allocated and
	   * attached to the DOM. Reconciles the root DOM node, then recurses.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevElement
	   * @param {ReactElement} nextElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function updateComponent(transaction, prevElement, nextElement, context) {
	    var lastProps = prevElement.props;
	    var nextProps = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'button':
	        lastProps = ReactDOMButton.getNativeProps(this, lastProps);
	        nextProps = ReactDOMButton.getNativeProps(this, nextProps);
	        break;
	      case 'input':
	        ReactDOMInput.updateWrapper(this);
	        lastProps = ReactDOMInput.getNativeProps(this, lastProps);
	        nextProps = ReactDOMInput.getNativeProps(this, nextProps);
	        break;
	      case 'option':
	        lastProps = ReactDOMOption.getNativeProps(this, lastProps);
	        nextProps = ReactDOMOption.getNativeProps(this, nextProps);
	        break;
	      case 'select':
	        lastProps = ReactDOMSelect.getNativeProps(this, lastProps);
	        nextProps = ReactDOMSelect.getNativeProps(this, nextProps);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.updateWrapper(this);
	        lastProps = ReactDOMTextarea.getNativeProps(this, lastProps);
	        nextProps = ReactDOMTextarea.getNativeProps(this, nextProps);
	        break;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // If the context is reference-equal to the old one, pass down the same
	      // processed object so the update bailout in ReactReconciler behaves
	      // correctly (and identically in dev and prod). See #5005.
	      if (this._unprocessedContextDev !== context) {
	        this._unprocessedContextDev = context;
	        this._processedContextDev = processChildContextDev(context, this);
	      }
	      context = this._processedContextDev;
	    }
	
	    assertValidProps(this, nextProps);
	    this._updateDOMProperties(lastProps, nextProps, transaction, null);
	    this._updateDOMChildren(lastProps, nextProps, transaction, context);
	
	    if (!canDefineProperty && this._nodeWithLegacyProperties) {
	      this._nodeWithLegacyProperties.props = nextProps;
	    }
	
	    if (this._tag === 'select') {
	      // <select> value update needs to occur after <option> children
	      // reconciliation
	      transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
	    }
	  },
	
	  /**
	   * Reconciles the properties by detecting differences in property values and
	   * updating the DOM as necessary. This function is probably the single most
	   * critical path for performance optimization.
	   *
	   * TODO: Benchmark whether checking for changed values in memory actually
	   *       improves performance (especially statically positioned elements).
	   * TODO: Benchmark the effects of putting this at the top since 99% of props
	   *       do not change for a given reconciliation.
	   * TODO: Benchmark areas that can be improved with caching.
	   *
	   * @private
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?DOMElement} node
	   */
	  _updateDOMProperties: function _updateDOMProperties(lastProps, nextProps, transaction, node) {
	    var propKey;
	    var styleName;
	    var styleUpdates;
	    for (propKey in lastProps) {
	      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        var lastStyle = this._previousStyleCopy;
	        for (styleName in lastStyle) {
	          if (lastStyle.hasOwnProperty(styleName)) {
	            styleUpdates = styleUpdates || {};
	            styleUpdates[styleName] = '';
	          }
	        }
	        this._previousStyleCopy = null;
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (lastProps[propKey]) {
	          // Only call deleteListener if there was a listener previously or
	          // else willDeleteListener gets called when there wasn't actually a
	          // listener (e.g., onClick={null})
	          deleteListener(this._rootNodeID, propKey);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        DOMPropertyOperations.deleteValueForProperty(node, propKey);
	      }
	    }
	    for (propKey in nextProps) {
	      var nextProp = nextProps[propKey];
	      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps[propKey];
	      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        if (nextProp) {
	          if (process.env.NODE_ENV !== 'production') {
	            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
	            this._previousStyle = nextProp;
	          }
	          nextProp = this._previousStyleCopy = assign({}, nextProp);
	        } else {
	          this._previousStyleCopy = null;
	        }
	        if (lastProp) {
	          // Unset styles on `lastProp` but not on `nextProp`.
	          for (styleName in lastProp) {
	            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = '';
	            }
	          }
	          // Update styles that changed since `lastProp`.
	          for (styleName in nextProp) {
	            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = nextProp[styleName];
	            }
	          }
	        } else {
	          // Relies on `updateStylesByID` not mutating `styleUpdates`.
	          styleUpdates = nextProp;
	        }
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (nextProp) {
	          enqueuePutListener(this._rootNodeID, propKey, nextProp, transaction);
	        } else if (lastProp) {
	          deleteListener(this._rootNodeID, propKey);
	        }
	      } else if (isCustomComponent(this._tag, nextProps)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        if (propKey === CHILDREN) {
	          nextProp = null;
	        }
	        DOMPropertyOperations.setValueForAttribute(node, propKey, nextProp);
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        // If we're updating to null or undefined, we should remove the property
	        // from the DOM node instead of inadvertantly setting to a string. This
	        // brings us in line with the same behavior we have on initial render.
	        if (nextProp != null) {
	          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
	        } else {
	          DOMPropertyOperations.deleteValueForProperty(node, propKey);
	        }
	      }
	    }
	    if (styleUpdates) {
	      if (!node) {
	        node = ReactMount.getNode(this._rootNodeID);
	      }
	      CSSPropertyOperations.setValueForStyles(node, styleUpdates);
	    }
	  },
	
	  /**
	   * Reconciles the children with the various properties that affect the
	   * children content.
	   *
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   */
	  _updateDOMChildren: function _updateDOMChildren(lastProps, nextProps, transaction, context) {
	    var lastContent = CONTENT_TYPES[_typeof(lastProps.children)] ? lastProps.children : null;
	    var nextContent = CONTENT_TYPES[_typeof(nextProps.children)] ? nextProps.children : null;
	
	    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
	    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
	
	    // Note the use of `!=` which checks for null or undefined.
	    var lastChildren = lastContent != null ? null : lastProps.children;
	    var nextChildren = nextContent != null ? null : nextProps.children;
	
	    // If we're switching from children to content/html or vice versa, remove
	    // the old content
	    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
	    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
	    if (lastChildren != null && nextChildren == null) {
	      this.updateChildren(null, transaction, context);
	    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
	      this.updateTextContent('');
	    }
	
	    if (nextContent != null) {
	      if (lastContent !== nextContent) {
	        this.updateTextContent('' + nextContent);
	      }
	    } else if (nextHtml != null) {
	      if (lastHtml !== nextHtml) {
	        this.updateMarkup('' + nextHtml);
	      }
	    } else if (nextChildren != null) {
	      this.updateChildren(nextChildren, transaction, context);
	    }
	  },
	
	  /**
	   * Destroys all event registrations for this instance. Does not remove from
	   * the DOM. That must be done by the parent.
	   *
	   * @internal
	   */
	  unmountComponent: function unmountComponent() {
	    switch (this._tag) {
	      case 'iframe':
	      case 'img':
	      case 'form':
	      case 'video':
	      case 'audio':
	        var listeners = this._wrapperState.listeners;
	        if (listeners) {
	          for (var i = 0; i < listeners.length; i++) {
	            listeners[i].remove();
	          }
	        }
	        break;
	      case 'input':
	        ReactDOMInput.unmountWrapper(this);
	        break;
	      case 'html':
	      case 'head':
	      case 'body':
	        /**
	         * Components like <html> <head> and <body> can't be removed or added
	         * easily in a cross-browser way, however it's valuable to be able to
	         * take advantage of React's reconciliation for styling and <title>
	         * management. So we just document it and throw in dangerous cases.
	         */
	         true ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is ' + 'impossible to unmount some top-level components (eg <html>, ' + '<head>, and <body>) reliably and efficiently. To fix this, have a ' + 'single top-level component that never unmounts render these ' + 'elements.', this._tag) : invariant(false) : undefined;
	        break;
	    }
	
	    this.unmountChildren();
	    ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
	    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
	    this._rootNodeID = null;
	    this._wrapperState = null;
	    if (this._nodeWithLegacyProperties) {
	      var node = this._nodeWithLegacyProperties;
	      node._reactInternalComponent = null;
	      this._nodeWithLegacyProperties = null;
	    }
	  },
	
	  getPublicInstance: function getPublicInstance() {
	    if (!this._nodeWithLegacyProperties) {
	      var node = ReactMount.getNode(this._rootNodeID);
	
	      node._reactInternalComponent = this;
	      node.getDOMNode = legacyGetDOMNode;
	      node.isMounted = legacyIsMounted;
	      node.setState = legacySetStateEtc;
	      node.replaceState = legacySetStateEtc;
	      node.forceUpdate = legacySetStateEtc;
	      node.setProps = legacySetProps;
	      node.replaceProps = legacyReplaceProps;
	
	      if (process.env.NODE_ENV !== 'production') {
	        if (canDefineProperty) {
	          Object.defineProperties(node, legacyPropsDescriptor);
	        } else {
	          // updateComponent will update this property on subsequent renders
	          node.props = this._currentElement.props;
	        }
	      } else {
	        // updateComponent will update this property on subsequent renders
	        node.props = this._currentElement.props;
	      }
	
	      this._nodeWithLegacyProperties = node;
	    }
	    return this._nodeWithLegacyProperties;
	  }
	
	};
	
	ReactPerf.measureMethods(ReactDOMComponent, 'ReactDOMComponent', {
	  mountComponent: 'mountComponent',
	  updateComponent: 'updateComponent'
	});
	
	assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
	
	module.exports = ReactDOMComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule AutoFocusUtils
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactMount = __webpack_require__(35);
	
	var findDOMNode = __webpack_require__(98);
	var focusNode = __webpack_require__(102);
	
	var Mixin = {
	  componentDidMount: function componentDidMount() {
	    if (this.props.autoFocus) {
	      focusNode(findDOMNode(this));
	    }
	  }
	};
	
	var AutoFocusUtils = {
	  Mixin: Mixin,
	
	  focusDOMComponent: function focusDOMComponent() {
	    focusNode(ReactMount.getNode(this._rootNodeID));
	  }
	};
	
	module.exports = AutoFocusUtils;

/***/ },
/* 102 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule focusNode
	 */
	
	'use strict';
	
	/**
	 * @param {DOMElement} node input/textarea to focus
	 */
	
	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch (e) {}
	}
	
	module.exports = focusNode;

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSPropertyOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(104);
	var ExecutionEnvironment = __webpack_require__(16);
	var ReactPerf = __webpack_require__(25);
	
	var camelizeStyleName = __webpack_require__(105);
	var dangerousStyleValue = __webpack_require__(107);
	var hyphenateStyleName = __webpack_require__(108);
	var memoizeStringOnly = __webpack_require__(110);
	var warning = __webpack_require__(32);
	
	var processStyleName = memoizeStringOnly(function (styleName) {
	  return hyphenateStyleName(styleName);
	});
	
	var hasShorthandPropertyBug = false;
	var styleFloatAccessor = 'cssFloat';
	if (ExecutionEnvironment.canUseDOM) {
	  var tempStyle = document.createElement('div').style;
	  try {
	    // IE8 throws "Invalid argument." if resetting shorthand style properties.
	    tempStyle.font = '';
	  } catch (e) {
	    hasShorthandPropertyBug = true;
	  }
	  // IE8 only supports accessing cssFloat (standard) as styleFloat
	  if (document.documentElement.style.cssFloat === undefined) {
	    styleFloatAccessor = 'styleFloat';
	  }
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
	
	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;
	
	  var warnedStyleNames = {};
	  var warnedStyleValues = {};
	
	  var warnHyphenatedStyleName = function warnHyphenatedStyleName(name) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?', name, camelizeStyleName(name)) : undefined;
	  };
	
	  var warnBadVendoredStyleName = function warnBadVendoredStyleName(name) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1)) : undefined;
	  };
	
	  var warnStyleValueWithSemicolon = function warnStyleValueWithSemicolon(name, value) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }
	
	    warnedStyleValues[value] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon. ' + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, '')) : undefined;
	  };
	
	  /**
	   * @param {string} name
	   * @param {*} value
	   */
	  var warnValidStyle = function warnValidStyle(name, value) {
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value);
	    }
	  };
	}
	
	/**
	 * Operations for dealing with CSS properties.
	 */
	var CSSPropertyOperations = {
	
	  /**
	   * Serializes a mapping of style properties for use as inline styles:
	   *
	   *   > createMarkupForStyles({width: '200px', height: 0})
	   *   "width:200px;height:0;"
	   *
	   * Undefined values are ignored so that declarative programming is easier.
	   * The result should be HTML-escaped before insertion into the DOM.
	   *
	   * @param {object} styles
	   * @return {?string}
	   */
	  createMarkupForStyles: function createMarkupForStyles(styles) {
	    var serialized = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var styleValue = styles[styleName];
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styleValue);
	      }
	      if (styleValue != null) {
	        serialized += processStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue) + ';';
	      }
	    }
	    return serialized || null;
	  },
	
	  /**
	   * Sets the value for multiple styles on a node.  If a value is specified as
	   * '' (empty string), the corresponding style property will be unset.
	   *
	   * @param {DOMElement} node
	   * @param {object} styles
	   */
	  setValueForStyles: function setValueForStyles(node, styles) {
	    var style = node.style;
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styles[styleName]);
	      }
	      var styleValue = dangerousStyleValue(styleName, styles[styleName]);
	      if (styleName === 'float') {
	        styleName = styleFloatAccessor;
	      }
	      if (styleValue) {
	        style[styleName] = styleValue;
	      } else {
	        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
	        if (expansion) {
	          // Shorthand property that IE8 won't like unsetting, so unset each
	          // component to placate it
	          for (var individualStyleName in expansion) {
	            style[individualStyleName] = '';
	          }
	        } else {
	          style[styleName] = '';
	        }
	      }
	    }
	  }
	
	};
	
	ReactPerf.measureMethods(CSSPropertyOperations, 'CSSPropertyOperations', {
	  setValueForStyles: 'setValueForStyles'
	});
	
	module.exports = CSSPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 104 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSProperty
	 */
	
	'use strict';
	
	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */
	
	var isUnitlessNumber = {
	  animationIterationCount: true,
	  boxFlex: true,
	  boxFlexGroup: true,
	  boxOrdinalGroup: true,
	  columnCount: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  flexOrder: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  tabSize: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,
	
	  // SVG-related properties
	  fillOpacity: true,
	  stopOpacity: true,
	  strokeDashoffset: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};
	
	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}
	
	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
	
	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	  prefixes.forEach(function (prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});
	
	/**
	 * Most style properties can be unset by doing .style[prop] = '' but IE8
	 * doesn't like doing that with shorthand properties so for the properties that
	 * IE8 breaks on, which are listed here, we instead unset each of the
	 * individual properties. See http://bugs.jquery.com/ticket/12385.
	 * The 4-value 'clock' properties like margin, padding, border-width seem to
	 * behave without any problems. Curiously, list-style works too without any
	 * special prodding.
	 */
	var shorthandPropertyExpansions = {
	  background: {
	    backgroundAttachment: true,
	    backgroundColor: true,
	    backgroundImage: true,
	    backgroundPositionX: true,
	    backgroundPositionY: true,
	    backgroundRepeat: true
	  },
	  backgroundPosition: {
	    backgroundPositionX: true,
	    backgroundPositionY: true
	  },
	  border: {
	    borderWidth: true,
	    borderStyle: true,
	    borderColor: true
	  },
	  borderBottom: {
	    borderBottomWidth: true,
	    borderBottomStyle: true,
	    borderBottomColor: true
	  },
	  borderLeft: {
	    borderLeftWidth: true,
	    borderLeftStyle: true,
	    borderLeftColor: true
	  },
	  borderRight: {
	    borderRightWidth: true,
	    borderRightStyle: true,
	    borderRightColor: true
	  },
	  borderTop: {
	    borderTopWidth: true,
	    borderTopStyle: true,
	    borderTopColor: true
	  },
	  font: {
	    fontStyle: true,
	    fontVariant: true,
	    fontWeight: true,
	    fontSize: true,
	    lineHeight: true,
	    fontFamily: true
	  },
	  outline: {
	    outlineWidth: true,
	    outlineStyle: true,
	    outlineColor: true
	  }
	};
	
	var CSSProperty = {
	  isUnitlessNumber: isUnitlessNumber,
	  shorthandPropertyExpansions: shorthandPropertyExpansions
	};
	
	module.exports = CSSProperty;

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule camelizeStyleName
	 * @typechecks
	 */
	
	'use strict';
	
	var camelize = __webpack_require__(106);
	
	var msPattern = /^-ms-/;
	
	/**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelizeStyleName(string) {
	  return camelize(string.replace(msPattern, 'ms-'));
	}
	
	module.exports = camelizeStyleName;

/***/ },
/* 106 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule camelize
	 * @typechecks
	 */
	
	"use strict";
	
	var _hyphenPattern = /-(.)/g;
	
	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function (_, character) {
	    return character.toUpperCase();
	  });
	}
	
	module.exports = camelize;

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule dangerousStyleValue
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(104);
	
	var isUnitlessNumber = CSSProperty.isUnitlessNumber;
	
	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901
	
	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }
	
	  var isNonNumeric = isNaN(value);
	  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	    return '' + value; // cast to string
	  }
	
	  if (typeof value === 'string') {
	    value = value.trim();
	  }
	  return value + 'px';
	}
	
	module.exports = dangerousStyleValue;

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule hyphenateStyleName
	 * @typechecks
	 */
	
	'use strict';
	
	var hyphenate = __webpack_require__(109);
	
	var msPattern = /^ms-/;
	
	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}
	
	module.exports = hyphenateStyleName;

/***/ },
/* 109 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule hyphenate
	 * @typechecks
	 */
	
	'use strict';
	
	var _uppercasePattern = /([A-Z])/g;
	
	/**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenate(string) {
	  return string.replace(_uppercasePattern, '-$1').toLowerCase();
	}
	
	module.exports = hyphenate;

/***/ },
/* 110 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule memoizeStringOnly
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Memoizes the return value of a function that accepts one string argument.
	 *
	 * @param {function} callback
	 * @return {function}
	 */
	
	function memoizeStringOnly(callback) {
	  var cache = {};
	  return function (string) {
	    if (!cache.hasOwnProperty(string)) {
	      cache[string] = callback.call(this, string);
	    }
	    return cache[string];
	  };
	}
	
	module.exports = memoizeStringOnly;

/***/ },
/* 111 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMButton
	 */
	
	'use strict';
	
	var mouseListenerNames = {
	  onClick: true,
	  onDoubleClick: true,
	  onMouseDown: true,
	  onMouseMove: true,
	  onMouseUp: true,
	
	  onClickCapture: true,
	  onDoubleClickCapture: true,
	  onMouseDownCapture: true,
	  onMouseMoveCapture: true,
	  onMouseUpCapture: true
	};
	
	/**
	 * Implements a <button> native component that does not receive mouse events
	 * when `disabled` is set.
	 */
	var ReactDOMButton = {
	  getNativeProps: function getNativeProps(inst, props, context) {
	    if (!props.disabled) {
	      return props;
	    }
	
	    // Copy the props, except the mouse listeners
	    var nativeProps = {};
	    for (var key in props) {
	      if (props.hasOwnProperty(key) && !mouseListenerNames[key]) {
	        nativeProps[key] = props[key];
	      }
	    }
	
	    return nativeProps;
	  }
	};
	
	module.exports = ReactDOMButton;

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMInput
	 */
	
	'use strict';
	
	var ReactDOMIDOperations = __webpack_require__(34);
	var LinkedValueUtils = __webpack_require__(113);
	var ReactMount = __webpack_require__(35);
	var ReactUpdates = __webpack_require__(61);
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	
	var instancesByReactID = {};
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMInput.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements an <input> native component that allows setting these optional
	 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
	 *
	 * If `checked` or `value` are not supplied (or null/undefined), user actions
	 * that affect the checked state or value will trigger updates to the element.
	 *
	 * If they are supplied (and not null/undefined), the rendered element will not
	 * trigger updates to the element. Instead, the props must change in order for
	 * the rendered element to be updated.
	 *
	 * The rendered element will be initialized as unchecked (or `defaultChecked`)
	 * with an empty value (or `defaultValue`).
	 *
	 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
	 */
	var ReactDOMInput = {
	  getNativeProps: function getNativeProps(inst, props, context) {
	    var value = LinkedValueUtils.getValue(props);
	    var checked = LinkedValueUtils.getChecked(props);
	
	    var nativeProps = assign({}, props, {
	      defaultChecked: undefined,
	      defaultValue: undefined,
	      value: value != null ? value : inst._wrapperState.initialValue,
	      checked: checked != null ? checked : inst._wrapperState.initialChecked,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return nativeProps;
	  },
	
	  mountWrapper: function mountWrapper(inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
	    }
	
	    var defaultValue = props.defaultValue;
	    inst._wrapperState = {
	      initialChecked: props.defaultChecked || false,
	      initialValue: defaultValue != null ? defaultValue : null,
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  mountReadyWrapper: function mountReadyWrapper(inst) {
	    // Can't be in mountWrapper or else server rendering leaks.
	    instancesByReactID[inst._rootNodeID] = inst;
	  },
	
	  unmountWrapper: function unmountWrapper(inst) {
	    delete instancesByReactID[inst._rootNodeID];
	  },
	
	  updateWrapper: function updateWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    // TODO: Shouldn't this be getChecked(props)?
	    var checked = props.checked;
	    if (checked != null) {
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'checked', checked || false);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  // Here we use asap to wait until all updates have propagated, which
	  // is important when using controlled components within layers:
	  // https://github.com/facebook/react/issues/1698
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	
	  var name = props.name;
	  if (props.type === 'radio' && name != null) {
	    var rootNode = ReactMount.getNode(this._rootNodeID);
	    var queryRoot = rootNode;
	
	    while (queryRoot.parentNode) {
	      queryRoot = queryRoot.parentNode;
	    }
	
	    // If `rootNode.form` was non-null, then we could try `form.elements`,
	    // but that sometimes behaves strangely in IE8. We could also try using
	    // `form.getElementsByName`, but that will only return direct children
	    // and won't include inputs that use the HTML5 `form=` attribute. Since
	    // the input might not even be in a form, let's just use the global
	    // `querySelectorAll` to ensure we don't miss anything.
	    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
	
	    for (var i = 0; i < group.length; i++) {
	      var otherNode = group[i];
	      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
	        continue;
	      }
	      // This will throw if radio buttons rendered by different copies of React
	      // and the same name are rendered into the same form (same as #1939).
	      // That's probably okay; we don't support it just as we don't support
	      // mixing React with non-React.
	      var otherID = ReactMount.getID(otherNode);
	      !otherID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.') : invariant(false) : undefined;
	      var otherInstance = instancesByReactID[otherID];
	      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Unknown radio button ID %s.', otherID) : invariant(false) : undefined;
	      // If this is a controlled radio button group, forcing the input that
	      // was previously checked to update will cause it to be come re-checked
	      // as appropriate.
	      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
	    }
	  }
	
	  return returnValue;
	}
	
	module.exports = ReactDOMInput;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule LinkedValueUtils
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactPropTypes = __webpack_require__(114);
	var ReactPropTypeLocations = __webpack_require__(72);
	
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	var hasReadOnlyValue = {
	  'button': true,
	  'checkbox': true,
	  'image': true,
	  'hidden': true,
	  'radio': true,
	  'reset': true,
	  'submit': true
	};
	
	function _assertSingleLink(inputProps) {
	  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use ' + 'checkedLink, you probably don\'t want to use valueLink and vice versa.') : invariant(false) : undefined;
	}
	function _assertValueLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want ' + 'to use value or onChange, you probably don\'t want to use valueLink.') : invariant(false) : undefined;
	}
	
	function _assertCheckedLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. ' + 'If you want to use checked or onChange, you probably don\'t want to ' + 'use checkedLink') : invariant(false) : undefined;
	}
	
	var propTypes = {
	  value: function value(props, propName, componentName) {
	    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  checked: function checked(props, propName, componentName) {
	    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  onChange: ReactPropTypes.func
	};
	
	var loggedTypeFailures = {};
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Provide a linked `value` attribute for controlled forms. You should not use
	 * this outside of the ReactDOM controlled form components.
	 */
	var LinkedValueUtils = {
	  checkPropTypes: function checkPropTypes(tagName, props, owner) {
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop);
	      }
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum(owner);
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : undefined;
	      }
	    }
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current value of the input either from value prop or link.
	   */
	  getValue: function getValue(inputProps) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.value;
	    }
	    return inputProps.value;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current checked status of the input either from checked prop
	   *             or link.
	   */
	  getChecked: function getChecked(inputProps) {
	    if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.value;
	    }
	    return inputProps.checked;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @param {SyntheticEvent} event change event to handle
	   */
	  executeOnChange: function executeOnChange(inputProps, event) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.requestChange(event.target.value);
	    } else if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.requestChange(event.target.checked);
	    } else if (inputProps.onChange) {
	      return inputProps.onChange.call(undefined, event);
	    }
	  }
	};
	
	module.exports = LinkedValueUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypes
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactElement = __webpack_require__(49);
	var ReactPropTypeLocationNames = __webpack_require__(73);
	
	var emptyFunction = __webpack_require__(22);
	var getIteratorFn = __webpack_require__(115);
	
	/**
	 * Collection of methods that allow declaration and validation of props that are
	 * supplied to React components. Example usage:
	 *
	 *   var Props = require('ReactPropTypes');
	 *   var MyArticle = React.createClass({
	 *     propTypes: {
	 *       // An optional string prop named "description".
	 *       description: Props.string,
	 *
	 *       // A required enum prop named "category".
	 *       category: Props.oneOf(['News','Photos']).isRequired,
	 *
	 *       // A prop named "dialog" that requires an instance of Dialog.
	 *       dialog: Props.instanceOf(Dialog).isRequired
	 *     },
	 *     render: function() { ... }
	 *   });
	 *
	 * A more formal specification of how these methods are used:
	 *
	 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	 *   decl := ReactPropTypes.{type}(.isRequired)?
	 *
	 * Each and every declaration produces a function with the same signature. This
	 * allows the creation of custom validation functions. For example:
	 *
	 *  var MyLink = React.createClass({
	 *    propTypes: {
	 *      // An optional string or URI prop named "href".
	 *      href: function(props, propName, componentName) {
	 *        var propValue = props[propName];
	 *        if (propValue != null && typeof propValue !== 'string' &&
	 *            !(propValue instanceof URI)) {
	 *          return new Error(
	 *            'Expected a string or an URI for ' + propName + ' in ' +
	 *            componentName
	 *          );
	 *        }
	 *      }
	 *    },
	 *    render: function() {...}
	 *  });
	 *
	 * @internal
	 */
	
	var ANONYMOUS = '<<anonymous>>';
	
	var ReactPropTypes = {
	  array: createPrimitiveTypeChecker('array'),
	  bool: createPrimitiveTypeChecker('boolean'),
	  func: createPrimitiveTypeChecker('function'),
	  number: createPrimitiveTypeChecker('number'),
	  object: createPrimitiveTypeChecker('object'),
	  string: createPrimitiveTypeChecker('string'),
	
	  any: createAnyTypeChecker(),
	  arrayOf: createArrayOfTypeChecker,
	  element: createElementTypeChecker(),
	  instanceOf: createInstanceTypeChecker,
	  node: createNodeChecker(),
	  objectOf: createObjectOfTypeChecker,
	  oneOf: createEnumTypeChecker,
	  oneOfType: createUnionTypeChecker,
	  shape: createShapeTypeChecker
	};
	
	function createChainableTypeChecker(validate) {
	  function checkType(isRequired, props, propName, componentName, location, propFullName) {
	    componentName = componentName || ANONYMOUS;
	    propFullName = propFullName || propName;
	    if (props[propName] == null) {
	      var locationName = ReactPropTypeLocationNames[location];
	      if (isRequired) {
	        return new Error('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
	      }
	      return null;
	    } else {
	      return validate(props, propName, componentName, location, propFullName);
	    }
	  }
	
	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);
	
	  return chainedCheckType;
	}
	
	function createPrimitiveTypeChecker(expectedType) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== expectedType) {
	      var locationName = ReactPropTypeLocationNames[location];
	      // `propValue` being instance of, say, date/regexp, pass the 'object'
	      // check, but we can offer a more precise error message here rather than
	      // 'of type `object`'.
	      var preciseType = getPreciseType(propValue);
	
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createAnyTypeChecker() {
	  return createChainableTypeChecker(emptyFunction.thatReturns(null));
	}
	
	function createArrayOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!Array.isArray(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	    }
	    for (var i = 0; i < propValue.length; i++) {
	      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']');
	      if (error instanceof Error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createElementTypeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!ReactElement.isValidElement(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a single ReactElement.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createInstanceTypeChecker(expectedClass) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!(props[propName] instanceof expectedClass)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var expectedClassName = expectedClass.name || ANONYMOUS;
	      var actualClassName = getClassName(props[propName]);
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createEnumTypeChecker(expectedValues) {
	  if (!Array.isArray(expectedValues)) {
	    return createChainableTypeChecker(function () {
	      return new Error('Invalid argument supplied to oneOf, expected an instance of array.');
	    });
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    for (var i = 0; i < expectedValues.length; i++) {
	      if (propValue === expectedValues[i]) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    var valuesString = JSON.stringify(expectedValues);
	    return new Error('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createObjectOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	    }
	    for (var key in propValue) {
	      if (propValue.hasOwnProperty(key)) {
	        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createUnionTypeChecker(arrayOfTypeCheckers) {
	  if (!Array.isArray(arrayOfTypeCheckers)) {
	    return createChainableTypeChecker(function () {
	      return new Error('Invalid argument supplied to oneOfType, expected an instance of array.');
	    });
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (checker(props, propName, componentName, location, propFullName) == null) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createNodeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!isNode(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createShapeTypeChecker(shapeTypes) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	    }
	    for (var key in shapeTypes) {
	      var checker = shapeTypes[key];
	      if (!checker) {
	        continue;
	      }
	      var error = checker(propValue, key, componentName, location, propFullName + '.' + key);
	      if (error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function isNode(propValue) {
	  switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
	    case 'number':
	    case 'string':
	    case 'undefined':
	      return true;
	    case 'boolean':
	      return !propValue;
	    case 'object':
	      if (Array.isArray(propValue)) {
	        return propValue.every(isNode);
	      }
	      if (propValue === null || ReactElement.isValidElement(propValue)) {
	        return true;
	      }
	
	      var iteratorFn = getIteratorFn(propValue);
	      if (iteratorFn) {
	        var iterator = iteratorFn.call(propValue);
	        var step;
	        if (iteratorFn !== propValue.entries) {
	          while (!(step = iterator.next()).done) {
	            if (!isNode(step.value)) {
	              return false;
	            }
	          }
	        } else {
	          // Iterator will provide entry [k,v] tuples rather than values.
	          while (!(step = iterator.next()).done) {
	            var entry = step.value;
	            if (entry) {
	              if (!isNode(entry[1])) {
	                return false;
	              }
	            }
	          }
	        }
	      } else {
	        return false;
	      }
	
	      return true;
	    default:
	      return false;
	  }
	}
	
	// Equivalent of `typeof` but with special handling for array and regexp.
	function getPropType(propValue) {
	  var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
	  if (Array.isArray(propValue)) {
	    return 'array';
	  }
	  if (propValue instanceof RegExp) {
	    // Old webkits (at least until Android 4.0) return 'function' rather than
	    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	    // passes PropTypes.object.
	    return 'object';
	  }
	  return propType;
	}
	
	// This handles more types than `getPropType`. Only used for error messages.
	// See `createPrimitiveTypeChecker`.
	function getPreciseType(propValue) {
	  var propType = getPropType(propValue);
	  if (propType === 'object') {
	    if (propValue instanceof Date) {
	      return 'date';
	    } else if (propValue instanceof RegExp) {
	      return 'regexp';
	    }
	  }
	  return propType;
	}
	
	// Returns class name of the object, if any.
	function getClassName(propValue) {
	  if (!propValue.constructor || !propValue.constructor.name) {
	    return '<<anonymous>>';
	  }
	  return propValue.constructor.name;
	}
	
	module.exports = ReactPropTypes;

/***/ },
/* 115 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getIteratorFn
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/* global Symbol */
	
	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}
	
	module.exports = getIteratorFn;

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMOption
	 */
	
	'use strict';
	
	var ReactChildren = __webpack_require__(117);
	var ReactDOMSelect = __webpack_require__(119);
	
	var assign = __webpack_require__(46);
	var warning = __webpack_require__(32);
	
	var valueContextKey = ReactDOMSelect.valueContextKey;
	
	/**
	 * Implements an <option> native component that warns when `selected` is set.
	 */
	var ReactDOMOption = {
	  mountWrapper: function mountWrapper(inst, props, context) {
	    // TODO (yungsters): Remove support for `selected` in <option>.
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : undefined;
	    }
	
	    // Look up whether this option is 'selected' via context
	    var selectValue = context[valueContextKey];
	
	    // If context key is null (e.g., no specified value or after initial mount)
	    // or missing (e.g., for <datalist>), we don't change props.selected
	    var selected = null;
	    if (selectValue != null) {
	      selected = false;
	      if (Array.isArray(selectValue)) {
	        // multiple
	        for (var i = 0; i < selectValue.length; i++) {
	          if ('' + selectValue[i] === '' + props.value) {
	            selected = true;
	            break;
	          }
	        }
	      } else {
	        selected = '' + selectValue === '' + props.value;
	      }
	    }
	
	    inst._wrapperState = { selected: selected };
	  },
	
	  getNativeProps: function getNativeProps(inst, props, context) {
	    var nativeProps = assign({ selected: undefined, children: undefined }, props);
	
	    // Read state only from initial mount because <select> updates value
	    // manually; we need the initial state only for server rendering
	    if (inst._wrapperState.selected != null) {
	      nativeProps.selected = inst._wrapperState.selected;
	    }
	
	    var content = '';
	
	    // Flatten children and warn if they aren't strings or numbers;
	    // invalid types are ignored.
	    ReactChildren.forEach(props.children, function (child) {
	      if (child == null) {
	        return;
	      }
	      if (typeof child === 'string' || typeof child === 'number') {
	        content += child;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : undefined;
	      }
	    });
	
	    if (content) {
	      nativeProps.children = content;
	    }
	
	    return nativeProps;
	  }
	
	};
	
	module.exports = ReactDOMOption;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildren
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(63);
	var ReactElement = __webpack_require__(49);
	
	var emptyFunction = __webpack_require__(22);
	var traverseAllChildren = __webpack_require__(118);
	
	var twoArgumentPooler = PooledClass.twoArgumentPooler;
	var fourArgumentPooler = PooledClass.fourArgumentPooler;
	
	var userProvidedKeyEscapeRegex = /\/(?!\/)/g;
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, '//');
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * traversal. Allows avoiding binding callbacks.
	 *
	 * @constructor ForEachBookKeeping
	 * @param {!function} forEachFunction Function to perform traversal with.
	 * @param {?*} forEachContext Context to perform context with.
	 */
	function ForEachBookKeeping(forEachFunction, forEachContext) {
	  this.func = forEachFunction;
	  this.context = forEachContext;
	  this.count = 0;
	}
	ForEachBookKeeping.prototype.destructor = function () {
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
	
	function forEachSingleChild(bookKeeping, child, name) {
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	  func.call(context, child, bookKeeping.count++);
	}
	
	/**
	 * Iterates through children that are typically specified as `props.children`.
	 *
	 * The provided forEachFunc(child, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} forEachFunc
	 * @param {*} forEachContext Context for forEachContext.
	 */
	function forEachChildren(children, forEachFunc, forEachContext) {
	  if (children == null) {
	    return children;
	  }
	  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
	  traverseAllChildren(children, forEachSingleChild, traverseContext);
	  ForEachBookKeeping.release(traverseContext);
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * mapping. Allows avoiding binding callbacks.
	 *
	 * @constructor MapBookKeeping
	 * @param {!*} mapResult Object containing the ordered map of results.
	 * @param {!function} mapFunction Function to perform mapping with.
	 * @param {?*} mapContext Context to perform mapping with.
	 */
	function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
	  this.result = mapResult;
	  this.keyPrefix = keyPrefix;
	  this.func = mapFunction;
	  this.context = mapContext;
	  this.count = 0;
	}
	MapBookKeeping.prototype.destructor = function () {
	  this.result = null;
	  this.keyPrefix = null;
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);
	
	function mapSingleChildIntoContext(bookKeeping, child, childKey) {
	  var result = bookKeeping.result;
	  var keyPrefix = bookKeeping.keyPrefix;
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	  var mappedChild = func.call(context, child, bookKeeping.count++);
	  if (Array.isArray(mappedChild)) {
	    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
	  } else if (mappedChild != null) {
	    if (ReactElement.isValidElement(mappedChild)) {
	      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
	      // Keep both the (mapped) and old keys if they differ, just as
	      // traverseAllChildren used to do for objects as children
	      keyPrefix + (mappedChild !== child ? escapeUserProvidedKey(mappedChild.key || '') + '/' : '') + childKey);
	    }
	    result.push(mappedChild);
	  }
	}
	
	function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
	  var escapedPrefix = '';
	  if (prefix != null) {
	    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
	  }
	  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
	  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
	  MapBookKeeping.release(traverseContext);
	}
	
	/**
	 * Maps children that are typically specified as `props.children`.
	 *
	 * The provided mapFunction(child, key, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} func The map function.
	 * @param {*} context Context for mapFunction.
	 * @return {object} Object containing the ordered map of results.
	 */
	function mapChildren(children, func, context) {
	  if (children == null) {
	    return children;
	  }
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
	  return result;
	}
	
	function forEachSingleChildDummy(traverseContext, child, name) {
	  return null;
	}
	
	/**
	 * Count the number of children that are typically specified as
	 * `props.children`.
	 *
	 * @param {?*} children Children tree container.
	 * @return {number} The number of children.
	 */
	function countChildren(children, context) {
	  return traverseAllChildren(children, forEachSingleChildDummy, null);
	}
	
	/**
	 * Flatten a children object (typically specified as `props.children`) and
	 * return an array with appropriately re-keyed children.
	 */
	function toArray(children) {
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
	  return result;
	}
	
	var ReactChildren = {
	  forEach: forEachChildren,
	  map: mapChildren,
	  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
	  count: countChildren,
	  toArray: toArray
	};
	
	module.exports = ReactChildren;

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule traverseAllChildren
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactElement = __webpack_require__(49);
	var ReactInstanceHandles = __webpack_require__(52);
	
	var getIteratorFn = __webpack_require__(115);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	var SEPARATOR = ReactInstanceHandles.SEPARATOR;
	var SUBSEPARATOR = ':';
	
	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */
	
	var userProvidedKeyEscaperLookup = {
	  '=': '=0',
	  '.': '=1',
	  ':': '=2'
	};
	
	var userProvidedKeyEscapeRegex = /[=.:]/g;
	
	var didWarnAboutMaps = false;
	
	function userProvidedKeyEscaper(match) {
	  return userProvidedKeyEscaperLookup[match];
	}
	
	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  if (component && component.key != null) {
	    // Explicit key
	    return wrapUserProvidedKey(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}
	
	/**
	 * Escape a component key so that it is safe to use in a reactid.
	 *
	 * @param {*} text Component key to be escaped.
	 * @return {string} An escaped string.
	 */
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);
	}
	
	/**
	 * Wrap a `key` value explicitly provided by the user to distinguish it from
	 * implicitly-generated keys generated by a component's index in its parent.
	 *
	 * @param {string} key Value of a user-provided `key` attribute
	 * @return {string}
	 */
	function wrapUserProvidedKey(key) {
	  return '$' + escapeUserProvidedKey(key);
	}
	
	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);
	
	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }
	
	  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }
	
	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
	
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.') : undefined;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + wrapUserProvidedKey(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : invariant(false) : undefined;
	    }
	  }
	
	  return subtreeCount;
	}
	
	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }
	
	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}
	
	module.exports = traverseAllChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelect
	 */
	
	'use strict';
	
	var LinkedValueUtils = __webpack_require__(113);
	var ReactMount = __webpack_require__(35);
	var ReactUpdates = __webpack_require__(61);
	
	var assign = __webpack_require__(46);
	var warning = __webpack_require__(32);
	
	var valueContextKey = '__ReactDOMSelect_value$' + Math.random().toString(36).slice(2);
	
	function updateOptionsIfPendingUpdateAndMounted() {
	  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
	    this._wrapperState.pendingUpdate = false;
	
	    var props = this._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	
	    if (value != null) {
	      updateOptions(this, Boolean(props.multiple), value);
	    }
	  }
	}
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	var valuePropNames = ['value', 'defaultValue'];
	
	/**
	 * Validation function for `value` and `defaultValue`.
	 * @private
	 */
	function checkSelectPropTypes(inst, props) {
	  var owner = inst._currentElement._owner;
	  LinkedValueUtils.checkPropTypes('select', props, owner);
	
	  for (var i = 0; i < valuePropNames.length; i++) {
	    var propName = valuePropNames[i];
	    if (props[propName] == null) {
	      continue;
	    }
	    if (props.multiple) {
	      process.env.NODE_ENV !== 'production' ? warning(Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
	    } else {
	      process.env.NODE_ENV !== 'production' ? warning(!Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
	    }
	  }
	}
	
	/**
	 * @param {ReactDOMComponent} inst
	 * @param {boolean} multiple
	 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
	 * @private
	 */
	function updateOptions(inst, multiple, propValue) {
	  var selectedValue, i;
	  var options = ReactMount.getNode(inst._rootNodeID).options;
	
	  if (multiple) {
	    selectedValue = {};
	    for (i = 0; i < propValue.length; i++) {
	      selectedValue['' + propValue[i]] = true;
	    }
	    for (i = 0; i < options.length; i++) {
	      var selected = selectedValue.hasOwnProperty(options[i].value);
	      if (options[i].selected !== selected) {
	        options[i].selected = selected;
	      }
	    }
	  } else {
	    // Do not set `select.value` as exact behavior isn't consistent across all
	    // browsers for all cases.
	    selectedValue = '' + propValue;
	    for (i = 0; i < options.length; i++) {
	      if (options[i].value === selectedValue) {
	        options[i].selected = true;
	        return;
	      }
	    }
	    if (options.length) {
	      options[0].selected = true;
	    }
	  }
	}
	
	/**
	 * Implements a <select> native component that allows optionally setting the
	 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
	 * stringable. If `multiple` is true, the prop must be an array of stringables.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that change the
	 * selected option will trigger updates to the rendered options.
	 *
	 * If it is supplied (and not null/undefined), the rendered options will not
	 * update in response to user actions. Instead, the `value` prop must change in
	 * order for the rendered options to update.
	 *
	 * If `defaultValue` is provided, any options with the supplied values will be
	 * selected.
	 */
	var ReactDOMSelect = {
	  valueContextKey: valueContextKey,
	
	  getNativeProps: function getNativeProps(inst, props, context) {
	    return assign({}, props, {
	      onChange: inst._wrapperState.onChange,
	      value: undefined
	    });
	  },
	
	  mountWrapper: function mountWrapper(inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      checkSelectPropTypes(inst, props);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    inst._wrapperState = {
	      pendingUpdate: false,
	      initialValue: value != null ? value : props.defaultValue,
	      onChange: _handleChange.bind(inst),
	      wasMultiple: Boolean(props.multiple)
	    };
	  },
	
	  processChildContext: function processChildContext(inst, props, context) {
	    // Pass down initial value so initial generated markup has correct
	    // `selected` attributes
	    var childContext = assign({}, context);
	    childContext[valueContextKey] = inst._wrapperState.initialValue;
	    return childContext;
	  },
	
	  postUpdateWrapper: function postUpdateWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    // After the initial mount, we control selected-ness manually so don't pass
	    // the context value down
	    inst._wrapperState.initialValue = undefined;
	
	    var wasMultiple = inst._wrapperState.wasMultiple;
	    inst._wrapperState.wasMultiple = Boolean(props.multiple);
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      inst._wrapperState.pendingUpdate = false;
	      updateOptions(inst, Boolean(props.multiple), value);
	    } else if (wasMultiple !== Boolean(props.multiple)) {
	      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
	      if (props.defaultValue != null) {
	        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
	      } else {
	        // Revert the select back to its default unselected state.
	        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
	      }
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  this._wrapperState.pendingUpdate = true;
	  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMSelect;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextarea
	 */
	
	'use strict';
	
	var LinkedValueUtils = __webpack_require__(113);
	var ReactDOMIDOperations = __webpack_require__(34);
	var ReactUpdates = __webpack_require__(61);
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMTextarea.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements a <textarea> native component that allows setting `value`, and
	 * `defaultValue`. This differs from the traditional DOM API because value is
	 * usually set as PCDATA children.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that affect the
	 * value will trigger updates to the element.
	 *
	 * If `value` is supplied (and not null/undefined), the rendered element will
	 * not trigger updates to the element. Instead, the `value` prop must change in
	 * order for the rendered element to be updated.
	 *
	 * The rendered element will be initialized with an empty value, the prop
	 * `defaultValue` if specified, or the children content (deprecated).
	 */
	var ReactDOMTextarea = {
	  getNativeProps: function getNativeProps(inst, props, context) {
	    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : invariant(false) : undefined;
	
	    // Always set children to the same thing. In IE9, the selection range will
	    // get reset if `textContent` is mutated.
	    var nativeProps = assign({}, props, {
	      defaultValue: undefined,
	      value: undefined,
	      children: inst._wrapperState.initialValue,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return nativeProps;
	  },
	
	  mountWrapper: function mountWrapper(inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
	    }
	
	    var defaultValue = props.defaultValue;
	    // TODO (yungsters): Remove support for children content in <textarea>.
	    var children = props.children;
	    if (children != null) {
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : undefined;
	      }
	      !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : invariant(false) : undefined;
	      if (Array.isArray(children)) {
	        !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : invariant(false) : undefined;
	        children = children[0];
	      }
	
	      defaultValue = '' + children;
	    }
	    if (defaultValue == null) {
	      defaultValue = '';
	    }
	    var value = LinkedValueUtils.getValue(props);
	
	    inst._wrapperState = {
	      // We save the initial value so that `ReactDOMComponent` doesn't update
	      // `textContent` (unnecessary since we update value).
	      // The initial value can be a boolean or object so that's why it's
	      // forced to be a string.
	      initialValue: '' + (value != null ? value : defaultValue),
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  updateWrapper: function updateWrapper(inst) {
	    var props = inst._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMTextarea;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChild
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactComponentEnvironment = __webpack_require__(71);
	var ReactMultiChildUpdateTypes = __webpack_require__(23);
	
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactReconciler = __webpack_require__(57);
	var ReactChildReconciler = __webpack_require__(122);
	
	var flattenChildren = __webpack_require__(123);
	
	/**
	 * Updating children of a component may trigger recursive updates. The depth is
	 * used to batch recursive updates to render markup more efficiently.
	 *
	 * @type {number}
	 * @private
	 */
	var updateDepth = 0;
	
	/**
	 * Queue of update configuration objects.
	 *
	 * Each object has a `type` property that is in `ReactMultiChildUpdateTypes`.
	 *
	 * @type {array<object>}
	 * @private
	 */
	var updateQueue = [];
	
	/**
	 * Queue of markup to be rendered.
	 *
	 * @type {array<string>}
	 * @private
	 */
	var markupQueue = [];
	
	/**
	 * Enqueues markup to be rendered and inserted at a supplied index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} markup Markup that renders into an element.
	 * @param {number} toIndex Destination index.
	 * @private
	 */
	function enqueueInsertMarkup(parentID, markup, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
	    markupIndex: markupQueue.push(markup) - 1,
	    content: null,
	    fromIndex: null,
	    toIndex: toIndex
	  });
	}
	
	/**
	 * Enqueues moving an existing element to another index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {number} fromIndex Source index of the existing element.
	 * @param {number} toIndex Destination index of the element.
	 * @private
	 */
	function enqueueMove(parentID, fromIndex, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
	    markupIndex: null,
	    content: null,
	    fromIndex: fromIndex,
	    toIndex: toIndex
	  });
	}
	
	/**
	 * Enqueues removing an element at an index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {number} fromIndex Index of the element to remove.
	 * @private
	 */
	function enqueueRemove(parentID, fromIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
	    markupIndex: null,
	    content: null,
	    fromIndex: fromIndex,
	    toIndex: null
	  });
	}
	
	/**
	 * Enqueues setting the markup of a node.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} markup Markup that renders into an element.
	 * @private
	 */
	function enqueueSetMarkup(parentID, markup) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.SET_MARKUP,
	    markupIndex: null,
	    content: markup,
	    fromIndex: null,
	    toIndex: null
	  });
	}
	
	/**
	 * Enqueues setting the text content.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} textContent Text content to set.
	 * @private
	 */
	function enqueueTextContent(parentID, textContent) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
	    markupIndex: null,
	    content: textContent,
	    fromIndex: null,
	    toIndex: null
	  });
	}
	
	/**
	 * Processes any enqueued updates.
	 *
	 * @private
	 */
	function processQueue() {
	  if (updateQueue.length) {
	    ReactComponentEnvironment.processChildrenUpdates(updateQueue, markupQueue);
	    clearQueue();
	  }
	}
	
	/**
	 * Clears any enqueued updates.
	 *
	 * @private
	 */
	function clearQueue() {
	  updateQueue.length = 0;
	  markupQueue.length = 0;
	}
	
	/**
	 * ReactMultiChild are capable of reconciling multiple children.
	 *
	 * @class ReactMultiChild
	 * @internal
	 */
	var ReactMultiChild = {
	
	  /**
	   * Provides common functionality for components that must reconcile multiple
	   * children. This is used by `ReactDOMComponent` to mount, update, and
	   * unmount child components.
	   *
	   * @lends {ReactMultiChild.prototype}
	   */
	  Mixin: {
	
	    _reconcilerInstantiateChildren: function _reconcilerInstantiateChildren(nestedChildren, transaction, context) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	        }
	      }
	      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	    },
	
	    _reconcilerUpdateChildren: function _reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, transaction, context) {
	      var nextChildren;
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            nextChildren = flattenChildren(nextNestedChildrenElements);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	          return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
	        }
	      }
	      nextChildren = flattenChildren(nextNestedChildrenElements);
	      return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
	    },
	
	    /**
	     * Generates a "mount image" for each of the supplied children. In the case
	     * of `ReactDOMComponent`, a mount image is a string of markup.
	     *
	     * @param {?object} nestedChildren Nested child maps.
	     * @return {array} An array of mounted representations.
	     * @internal
	     */
	    mountChildren: function mountChildren(nestedChildren, transaction, context) {
	      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
	      this._renderedChildren = children;
	      var mountImages = [];
	      var index = 0;
	      for (var name in children) {
	        if (children.hasOwnProperty(name)) {
	          var child = children[name];
	          // Inlined for performance, see `ReactInstanceHandles.createReactID`.
	          var rootID = this._rootNodeID + name;
	          var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
	          child._mountIndex = index++;
	          mountImages.push(mountImage);
	        }
	      }
	      return mountImages;
	    },
	
	    /**
	     * Replaces any rendered children with a text content string.
	     *
	     * @param {string} nextContent String of content.
	     * @internal
	     */
	    updateTextContent: function updateTextContent(nextContent) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        var prevChildren = this._renderedChildren;
	        // Remove any rendered children.
	        ReactChildReconciler.unmountChildren(prevChildren);
	        // TODO: The setTextContent operation should be enough
	        for (var name in prevChildren) {
	          if (prevChildren.hasOwnProperty(name)) {
	            this._unmountChild(prevChildren[name]);
	          }
	        }
	        // Set new text content.
	        this.setTextContent(nextContent);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },
	
	    /**
	     * Replaces any rendered children with a markup string.
	     *
	     * @param {string} nextMarkup String of markup.
	     * @internal
	     */
	    updateMarkup: function updateMarkup(nextMarkup) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        var prevChildren = this._renderedChildren;
	        // Remove any rendered children.
	        ReactChildReconciler.unmountChildren(prevChildren);
	        for (var name in prevChildren) {
	          if (prevChildren.hasOwnProperty(name)) {
	            this._unmountChildByName(prevChildren[name], name);
	          }
	        }
	        this.setMarkup(nextMarkup);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },
	
	    /**
	     * Updates the rendered children with new children.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     */
	    updateChildren: function updateChildren(nextNestedChildrenElements, transaction, context) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        this._updateChildren(nextNestedChildrenElements, transaction, context);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },
	
	    /**
	     * Improve performance by isolating this hot code path from the try/catch
	     * block in `updateChildren`.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @final
	     * @protected
	     */
	    _updateChildren: function _updateChildren(nextNestedChildrenElements, transaction, context) {
	      var prevChildren = this._renderedChildren;
	      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, transaction, context);
	      this._renderedChildren = nextChildren;
	      if (!nextChildren && !prevChildren) {
	        return;
	      }
	      var name;
	      // `nextIndex` will increment for each child in `nextChildren`, but
	      // `lastIndex` will be the last index visited in `prevChildren`.
	      var lastIndex = 0;
	      var nextIndex = 0;
	      for (name in nextChildren) {
	        if (!nextChildren.hasOwnProperty(name)) {
	          continue;
	        }
	        var prevChild = prevChildren && prevChildren[name];
	        var nextChild = nextChildren[name];
	        if (prevChild === nextChild) {
	          this.moveChild(prevChild, nextIndex, lastIndex);
	          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	          prevChild._mountIndex = nextIndex;
	        } else {
	          if (prevChild) {
	            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
	            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	            this._unmountChild(prevChild);
	          }
	          // The child must be instantiated before it's mounted.
	          this._mountChildByNameAtIndex(nextChild, name, nextIndex, transaction, context);
	        }
	        nextIndex++;
	      }
	      // Remove children that are no longer present.
	      for (name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	          this._unmountChild(prevChildren[name]);
	        }
	      }
	    },
	
	    /**
	     * Unmounts all rendered children. This should be used to clean up children
	     * when this component is unmounted.
	     *
	     * @internal
	     */
	    unmountChildren: function unmountChildren() {
	      var renderedChildren = this._renderedChildren;
	      ReactChildReconciler.unmountChildren(renderedChildren);
	      this._renderedChildren = null;
	    },
	
	    /**
	     * Moves a child component to the supplied index.
	     *
	     * @param {ReactComponent} child Component to move.
	     * @param {number} toIndex Destination index of the element.
	     * @param {number} lastIndex Last index visited of the siblings of `child`.
	     * @protected
	     */
	    moveChild: function moveChild(child, toIndex, lastIndex) {
	      // If the index of `child` is less than `lastIndex`, then it needs to
	      // be moved. Otherwise, we do not need to move it because a child will be
	      // inserted or moved before `child`.
	      if (child._mountIndex < lastIndex) {
	        enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
	      }
	    },
	
	    /**
	     * Creates a child component.
	     *
	     * @param {ReactComponent} child Component to create.
	     * @param {string} mountImage Markup to insert.
	     * @protected
	     */
	    createChild: function createChild(child, mountImage) {
	      enqueueInsertMarkup(this._rootNodeID, mountImage, child._mountIndex);
	    },
	
	    /**
	     * Removes a child component.
	     *
	     * @param {ReactComponent} child Child to remove.
	     * @protected
	     */
	    removeChild: function removeChild(child) {
	      enqueueRemove(this._rootNodeID, child._mountIndex);
	    },
	
	    /**
	     * Sets this text content string.
	     *
	     * @param {string} textContent Text content to set.
	     * @protected
	     */
	    setTextContent: function setTextContent(textContent) {
	      enqueueTextContent(this._rootNodeID, textContent);
	    },
	
	    /**
	     * Sets this markup string.
	     *
	     * @param {string} markup Markup to set.
	     * @protected
	     */
	    setMarkup: function setMarkup(markup) {
	      enqueueSetMarkup(this._rootNodeID, markup);
	    },
	
	    /**
	     * Mounts a child with the supplied name.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to mount.
	     * @param {string} name Name of the child.
	     * @param {number} index Index at which to insert the child.
	     * @param {ReactReconcileTransaction} transaction
	     * @private
	     */
	    _mountChildByNameAtIndex: function _mountChildByNameAtIndex(child, name, index, transaction, context) {
	      // Inlined for performance, see `ReactInstanceHandles.createReactID`.
	      var rootID = this._rootNodeID + name;
	      var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
	      child._mountIndex = index;
	      this.createChild(child, mountImage);
	    },
	
	    /**
	     * Unmounts a rendered child.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to unmount.
	     * @private
	     */
	    _unmountChild: function _unmountChild(child) {
	      this.removeChild(child);
	      child._mountIndex = null;
	    }
	
	  }
	
	};
	
	module.exports = ReactMultiChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildReconciler
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactReconciler = __webpack_require__(57);
	
	var instantiateReactComponent = __webpack_require__(69);
	var shouldUpdateReactComponent = __webpack_require__(74);
	var traverseAllChildren = __webpack_require__(118);
	var warning = __webpack_require__(32);
	
	function instantiateChild(childInstances, child, name) {
	  // We found a component instance.
	  var keyUnique = childInstances[name] === undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
	  }
	  if (child != null && keyUnique) {
	    childInstances[name] = instantiateReactComponent(child, null);
	  }
	}
	
	/**
	 * ReactChildReconciler provides helpers for initializing or updating a set of
	 * children. Its output is suitable for passing it onto ReactMultiChild which
	 * does diffed reordering and insertion.
	 */
	var ReactChildReconciler = {
	  /**
	   * Generates a "mount image" for each of the supplied children. In the case
	   * of `ReactDOMComponent`, a mount image is a string of markup.
	   *
	   * @param {?object} nestedChildNodes Nested child maps.
	   * @return {?object} A set of child instances.
	   * @internal
	   */
	  instantiateChildren: function instantiateChildren(nestedChildNodes, transaction, context) {
	    if (nestedChildNodes == null) {
	      return null;
	    }
	    var childInstances = {};
	    traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
	    return childInstances;
	  },
	
	  /**
	   * Updates the rendered children and returns a new set of children.
	   *
	   * @param {?object} prevChildren Previously initialized set of children.
	   * @param {?object} nextChildren Flat child element maps.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @return {?object} A new set of child instances.
	   * @internal
	   */
	  updateChildren: function updateChildren(prevChildren, nextChildren, transaction, context) {
	    // We currently don't have a way to track moves here but if we use iterators
	    // instead of for..in we can zip the iterators and check if an item has
	    // moved.
	    // TODO: If nothing has changed, return the prevChildren object so that we
	    // can quickly bailout if nothing has changed.
	    if (!nextChildren && !prevChildren) {
	      return null;
	    }
	    var name;
	    for (name in nextChildren) {
	      if (!nextChildren.hasOwnProperty(name)) {
	        continue;
	      }
	      var prevChild = prevChildren && prevChildren[name];
	      var prevElement = prevChild && prevChild._currentElement;
	      var nextElement = nextChildren[name];
	      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
	        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
	        nextChildren[name] = prevChild;
	      } else {
	        if (prevChild) {
	          ReactReconciler.unmountComponent(prevChild, name);
	        }
	        // The child must be instantiated before it's mounted.
	        var nextChildInstance = instantiateReactComponent(nextElement, null);
	        nextChildren[name] = nextChildInstance;
	      }
	    }
	    // Unmount children that are no longer present.
	    for (name in prevChildren) {
	      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	        ReactReconciler.unmountComponent(prevChildren[name]);
	      }
	    }
	    return nextChildren;
	  },
	
	  /**
	   * Unmounts all rendered children. This should be used to clean up children
	   * when this component is unmounted.
	   *
	   * @param {?object} renderedChildren Previously initialized set of children.
	   * @internal
	   */
	  unmountChildren: function unmountChildren(renderedChildren) {
	    for (var name in renderedChildren) {
	      if (renderedChildren.hasOwnProperty(name)) {
	        var renderedChild = renderedChildren[name];
	        ReactReconciler.unmountComponent(renderedChild);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactChildReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule flattenChildren
	 */
	
	'use strict';
	
	var traverseAllChildren = __webpack_require__(118);
	var warning = __webpack_require__(32);
	
	/**
	 * @param {function} traverseContext Context passed through traversal.
	 * @param {?ReactComponent} child React child component.
	 * @param {!string} name String name of key path to child.
	 */
	function flattenSingleChildIntoContext(traverseContext, child, name) {
	  // We found a component instance.
	  var result = traverseContext;
	  var keyUnique = result[name] === undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
	  }
	  if (keyUnique && child != null) {
	    result[name] = child;
	  }
	}
	
	/**
	 * Flattens children that are typically specified as `props.children`. Any null
	 * children will not be included in the resulting object.
	 * @return {!object} flattened children keyed by name.
	 */
	function flattenChildren(children) {
	  if (children == null) {
	    return children;
	  }
	  var result = {};
	  traverseAllChildren(children, flattenSingleChildIntoContext, result);
	  return result;
	}
	
	module.exports = flattenChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 124 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shallowEqual
	 * @typechecks
	 * 
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (objA === objB) {
	    return true;
	  }
	
	  if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
	    return false;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  var bHasOwnProperty = hasOwnProperty.bind(objB);
	  for (var i = 0; i < keysA.length; i++) {
	    if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	module.exports = shallowEqual;

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventListener
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventListener = __webpack_require__(126);
	var ExecutionEnvironment = __webpack_require__(16);
	var PooledClass = __webpack_require__(63);
	var ReactInstanceHandles = __webpack_require__(52);
	var ReactMount = __webpack_require__(35);
	var ReactUpdates = __webpack_require__(61);
	
	var assign = __webpack_require__(46);
	var getEventTarget = __webpack_require__(88);
	var getUnboundedScrollPosition = __webpack_require__(127);
	
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	/**
	 * Finds the parent React component of `node`.
	 *
	 * @param {*} node
	 * @return {?DOMEventTarget} Parent container, or `null` if the specified node
	 *                           is not nested.
	 */
	function findParent(node) {
	  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
	  // traversal, but caching is difficult to do correctly without using a
	  // mutation observer to listen for all DOM changes.
	  var nodeID = ReactMount.getID(node);
	  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
	  var container = ReactMount.findReactContainerForID(rootID);
	  var parent = ReactMount.getFirstReactDOM(container);
	  return parent;
	}
	
	// Used to store ancestor hierarchy in top level callback
	function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
	  this.topLevelType = topLevelType;
	  this.nativeEvent = nativeEvent;
	  this.ancestors = [];
	}
	assign(TopLevelCallbackBookKeeping.prototype, {
	  destructor: function destructor() {
	    this.topLevelType = null;
	    this.nativeEvent = null;
	    this.ancestors.length = 0;
	  }
	});
	PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
	
	function handleTopLevelImpl(bookKeeping) {
	  // TODO: Re-enable event.path handling
	  //
	  // if (bookKeeping.nativeEvent.path && bookKeeping.nativeEvent.path.length > 1) {
	  //   // New browsers have a path attribute on native events
	  //   handleTopLevelWithPath(bookKeeping);
	  // } else {
	  //   // Legacy browsers don't have a path attribute on native events
	  //   handleTopLevelWithoutPath(bookKeeping);
	  // }
	
	  void handleTopLevelWithPath; // temporarily unused
	  handleTopLevelWithoutPath(bookKeeping);
	}
	
	// Legacy browsers don't have a path attribute on native events
	function handleTopLevelWithoutPath(bookKeeping) {
	  var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;
	
	  // Loop through the hierarchy, in case there's any nested components.
	  // It's important that we build the array of ancestors before calling any
	  // event handlers, because event handlers can modify the DOM, leading to
	  // inconsistencies with ReactMount's node cache. See #1105.
	  var ancestor = topLevelTarget;
	  while (ancestor) {
	    bookKeeping.ancestors.push(ancestor);
	    ancestor = findParent(ancestor);
	  }
	
	  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
	    topLevelTarget = bookKeeping.ancestors[i];
	    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	// New browsers have a path attribute on native events
	function handleTopLevelWithPath(bookKeeping) {
	  var path = bookKeeping.nativeEvent.path;
	  var currentNativeTarget = path[0];
	  var eventsFired = 0;
	  for (var i = 0; i < path.length; i++) {
	    var currentPathElement = path[i];
	    if (currentPathElement.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE) {
	      currentNativeTarget = path[i + 1];
	    }
	    // TODO: slow
	    var reactParent = ReactMount.getFirstReactDOM(currentPathElement);
	    if (reactParent === currentPathElement) {
	      var currentPathElementID = ReactMount.getID(currentPathElement);
	      var newRootID = ReactInstanceHandles.getReactRootIDFromNodeID(currentPathElementID);
	      bookKeeping.ancestors.push(currentPathElement);
	
	      var topLevelTargetID = ReactMount.getID(currentPathElement) || '';
	      eventsFired++;
	      ReactEventListener._handleTopLevel(bookKeeping.topLevelType, currentPathElement, topLevelTargetID, bookKeeping.nativeEvent, currentNativeTarget);
	
	      // Jump to the root of this React render tree
	      while (currentPathElementID !== newRootID) {
	        i++;
	        currentPathElement = path[i];
	        currentPathElementID = ReactMount.getID(currentPathElement);
	      }
	    }
	  }
	  if (eventsFired === 0) {
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, window, '', bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	function scrollValueMonitor(cb) {
	  var scrollPosition = getUnboundedScrollPosition(window);
	  cb(scrollPosition);
	}
	
	var ReactEventListener = {
	  _enabled: true,
	  _handleTopLevel: null,
	
	  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
	
	  setHandleTopLevel: function setHandleTopLevel(handleTopLevel) {
	    ReactEventListener._handleTopLevel = handleTopLevel;
	  },
	
	  setEnabled: function setEnabled(enabled) {
	    ReactEventListener._enabled = !!enabled;
	  },
	
	  isEnabled: function isEnabled() {
	    return ReactEventListener._enabled;
	  },
	
	  /**
	   * Traps top-level events by using event bubbling.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  /**
	   * Traps a top-level event by using event capturing.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  monitorScrollValue: function monitorScrollValue(refresh) {
	    var callback = scrollValueMonitor.bind(null, refresh);
	    EventListener.listen(window, 'scroll', callback);
	  },
	
	  dispatchEvent: function dispatchEvent(topLevelType, nativeEvent) {
	    if (!ReactEventListener._enabled) {
	      return;
	    }
	
	    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
	    try {
	      // Event queue being processed in the same cycle allows
	      // `preventDefault`.
	      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
	    } finally {
	      TopLevelCallbackBookKeeping.release(bookKeeping);
	    }
	  }
	};
	
	module.exports = ReactEventListener;

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * @providesModule EventListener
	 * @typechecks
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(22);
	
	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function listen(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function remove() {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },
	
	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function capture(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (process.env.NODE_ENV !== 'production') {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: emptyFunction
	      };
	    }
	  },
	
	  registerDefault: function registerDefault() {}
	};
	
	module.exports = EventListener;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 127 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getUnboundedScrollPosition
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Gets the scroll position of the supplied element or window.
	 *
	 * The return values are unbounded, unlike `getScrollPosition`. This means they
	 * may be negative or exceed the element boundaries (which is possible using
	 * inertial scrolling).
	 *
	 * @param {DOMWindow|DOMElement} scrollable
	 * @return {object} Map with `x` and `y` keys.
	 */
	
	function getUnboundedScrollPosition(scrollable) {
	  if (scrollable === window) {
	    return {
	      x: window.pageXOffset || document.documentElement.scrollLeft,
	      y: window.pageYOffset || document.documentElement.scrollTop
	    };
	  }
	  return {
	    x: scrollable.scrollLeft,
	    y: scrollable.scrollTop
	  };
	}
	
	module.exports = getUnboundedScrollPosition;

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInjection
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(30);
	var EventPluginHub = __webpack_require__(38);
	var ReactComponentEnvironment = __webpack_require__(71);
	var ReactClass = __webpack_require__(129);
	var ReactEmptyComponent = __webpack_require__(75);
	var ReactBrowserEventEmitter = __webpack_require__(36);
	var ReactNativeComponent = __webpack_require__(76);
	var ReactPerf = __webpack_require__(25);
	var ReactRootIndex = __webpack_require__(53);
	var ReactUpdates = __webpack_require__(61);
	
	var ReactInjection = {
	  Component: ReactComponentEnvironment.injection,
	  Class: ReactClass.injection,
	  DOMProperty: DOMProperty.injection,
	  EmptyComponent: ReactEmptyComponent.injection,
	  EventPluginHub: EventPluginHub.injection,
	  EventEmitter: ReactBrowserEventEmitter.injection,
	  NativeComponent: ReactNativeComponent.injection,
	  Perf: ReactPerf.injection,
	  RootIndex: ReactRootIndex.injection,
	  Updates: ReactUpdates.injection
	};
	
	module.exports = ReactInjection;

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactClass
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactComponent = __webpack_require__(130);
	var ReactElement = __webpack_require__(49);
	var ReactPropTypeLocations = __webpack_require__(72);
	var ReactPropTypeLocationNames = __webpack_require__(73);
	var ReactNoopUpdateQueue = __webpack_require__(131);
	
	var assign = __webpack_require__(46);
	var emptyObject = __webpack_require__(65);
	var invariant = __webpack_require__(20);
	var keyMirror = __webpack_require__(24);
	var keyOf = __webpack_require__(86);
	var warning = __webpack_require__(32);
	
	var MIXINS_KEY = keyOf({ mixins: null });
	
	/**
	 * Policies that describe methods in `ReactClassInterface`.
	 */
	var SpecPolicy = keyMirror({
	  /**
	   * These methods may be defined only once by the class specification or mixin.
	   */
	  DEFINE_ONCE: null,
	  /**
	   * These methods may be defined by both the class specification and mixins.
	   * Subsequent definitions will be chained. These methods must return void.
	   */
	  DEFINE_MANY: null,
	  /**
	   * These methods are overriding the base class.
	   */
	  OVERRIDE_BASE: null,
	  /**
	   * These methods are similar to DEFINE_MANY, except we assume they return
	   * objects. We try to merge the keys of the return values of all the mixed in
	   * functions. If there is a key conflict we throw.
	   */
	  DEFINE_MANY_MERGED: null
	});
	
	var injectedMixins = [];
	
	var warnedSetProps = false;
	function warnSetProps() {
	  if (!warnedSetProps) {
	    warnedSetProps = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'setProps(...) and replaceProps(...) are deprecated. ' + 'Instead, call render again at the top level.') : undefined;
	  }
	}
	
	/**
	 * Composite components are higher-level components that compose other composite
	 * or native components.
	 *
	 * To create a new type of `ReactClass`, pass a specification of
	 * your new class to `React.createClass`. The only requirement of your class
	 * specification is that you implement a `render` method.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return <div>Hello World</div>;
	 *     }
	 *   });
	 *
	 * The class specification supports a specific protocol of methods that have
	 * special meaning (e.g. `render`). See `ReactClassInterface` for
	 * more the comprehensive protocol. Any other properties and methods in the
	 * class specification will be available on the prototype.
	 *
	 * @interface ReactClassInterface
	 * @internal
	 */
	var ReactClassInterface = {
	
	  /**
	   * An array of Mixin objects to include when defining your component.
	   *
	   * @type {array}
	   * @optional
	   */
	  mixins: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * An object containing properties and methods that should be defined on
	   * the component's constructor instead of its prototype (static methods).
	   *
	   * @type {object}
	   * @optional
	   */
	  statics: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of prop types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  propTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  contextTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types this component sets for its children.
	   *
	   * @type {object}
	   * @optional
	   */
	  childContextTypes: SpecPolicy.DEFINE_MANY,
	
	  // ==== Definition methods ====
	
	  /**
	   * Invoked when the component is mounted. Values in the mapping will be set on
	   * `this.props` if that prop is not specified (i.e. using an `in` check).
	   *
	   * This method is invoked before `getInitialState` and therefore cannot rely
	   * on `this.state` or use `this.setState`.
	   *
	   * @return {object}
	   * @optional
	   */
	  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Invoked once before the component is mounted. The return value will be used
	   * as the initial value of `this.state`.
	   *
	   *   getInitialState: function() {
	   *     return {
	   *       isOn: false,
	   *       fooBaz: new BazFoo()
	   *     }
	   *   }
	   *
	   * @return {object}
	   * @optional
	   */
	  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * @return {object}
	   * @optional
	   */
	  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Uses props from `this.props` and state from `this.state` to render the
	   * structure of the component.
	   *
	   * No guarantees are made about when or how often this method is invoked, so
	   * it must not have side effects.
	   *
	   *   render: function() {
	   *     var name = this.props.name;
	   *     return <div>Hello, {name}!</div>;
	   *   }
	   *
	   * @return {ReactComponent}
	   * @nosideeffects
	   * @required
	   */
	  render: SpecPolicy.DEFINE_ONCE,
	
	  // ==== Delegate methods ====
	
	  /**
	   * Invoked when the component is initially created and about to be mounted.
	   * This may have side effects, but any external subscriptions or data created
	   * by this method must be cleaned up in `componentWillUnmount`.
	   *
	   * @optional
	   */
	  componentWillMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component has been mounted and has a DOM representation.
	   * However, there is no guarantee that the DOM node is in the document.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been mounted (initialized and rendered) for the first time.
	   *
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked before the component receives new props.
	   *
	   * Use this as an opportunity to react to a prop transition by updating the
	   * state using `this.setState`. Current props are accessed via `this.props`.
	   *
	   *   componentWillReceiveProps: function(nextProps, nextContext) {
	   *     this.setState({
	   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	   *     });
	   *   }
	   *
	   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	   * transition may cause a state change, but the opposite is not true. If you
	   * need it, you are probably looking for `componentWillUpdate`.
	   *
	   * @param {object} nextProps
	   * @optional
	   */
	  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked while deciding if the component should be updated as a result of
	   * receiving new props, state and/or context.
	   *
	   * Use this as an opportunity to `return false` when you're certain that the
	   * transition to the new props/state/context will not require a component
	   * update.
	   *
	   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	   *     return !equal(nextProps, this.props) ||
	   *       !equal(nextState, this.state) ||
	   *       !equal(nextContext, this.context);
	   *   }
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @return {boolean} True if the component should update.
	   * @optional
	   */
	  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,
	
	  /**
	   * Invoked when the component is about to update due to a transition from
	   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	   * and `nextContext`.
	   *
	   * Use this as an opportunity to perform preparation before an update occurs.
	   *
	   * NOTE: You **cannot** use `this.setState()` in this method.
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @param {ReactReconcileTransaction} transaction
	   * @optional
	   */
	  componentWillUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component's DOM representation has been updated.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been updated.
	   *
	   * @param {object} prevProps
	   * @param {?object} prevState
	   * @param {?object} prevContext
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component is about to be removed from its parent and have
	   * its DOM representation destroyed.
	   *
	   * Use this as an opportunity to deallocate any external resources.
	   *
	   * NOTE: There is no `componentDidUnmount` since your component will have been
	   * destroyed by that point.
	   *
	   * @optional
	   */
	  componentWillUnmount: SpecPolicy.DEFINE_MANY,
	
	  // ==== Advanced methods ====
	
	  /**
	   * Updates the component's currently mounted DOM representation.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   * @overridable
	   */
	  updateComponent: SpecPolicy.OVERRIDE_BASE
	
	};
	
	/**
	 * Mapping from class specification keys to special processing functions.
	 *
	 * Although these are declared like instance properties in the specification
	 * when defining classes using `React.createClass`, they are actually static
	 * and are accessible on the constructor instead of the prototype. Despite
	 * being static, they must be defined outside of the "statics" key under
	 * which all other static methods are defined.
	 */
	var RESERVED_SPEC_KEYS = {
	  displayName: function displayName(Constructor, _displayName) {
	    Constructor.displayName = _displayName;
	  },
	  mixins: function mixins(Constructor, _mixins) {
	    if (_mixins) {
	      for (var i = 0; i < _mixins.length; i++) {
	        mixSpecIntoComponent(Constructor, _mixins[i]);
	      }
	    }
	  },
	  childContextTypes: function childContextTypes(Constructor, _childContextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, _childContextTypes, ReactPropTypeLocations.childContext);
	    }
	    Constructor.childContextTypes = assign({}, Constructor.childContextTypes, _childContextTypes);
	  },
	  contextTypes: function contextTypes(Constructor, _contextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, _contextTypes, ReactPropTypeLocations.context);
	    }
	    Constructor.contextTypes = assign({}, Constructor.contextTypes, _contextTypes);
	  },
	  /**
	   * Special case getDefaultProps which should move into statics but requires
	   * automatic merging.
	   */
	  getDefaultProps: function getDefaultProps(Constructor, _getDefaultProps) {
	    if (Constructor.getDefaultProps) {
	      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, _getDefaultProps);
	    } else {
	      Constructor.getDefaultProps = _getDefaultProps;
	    }
	  },
	  propTypes: function propTypes(Constructor, _propTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, _propTypes, ReactPropTypeLocations.prop);
	    }
	    Constructor.propTypes = assign({}, Constructor.propTypes, _propTypes);
	  },
	  statics: function statics(Constructor, _statics) {
	    mixStaticSpecIntoComponent(Constructor, _statics);
	  },
	  autobind: function autobind() {} };
	
	// noop
	function validateTypeDef(Constructor, typeDef, location) {
	  for (var propName in typeDef) {
	    if (typeDef.hasOwnProperty(propName)) {
	      // use a warning instead of an invariant so components
	      // don't show up in prod but not in __DEV__
	      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : undefined;
	    }
	  }
	}
	
	function validateMethodOverride(proto, name) {
	  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
	
	  // Disallow overriding of base class methods unless explicitly allowed.
	  if (ReactClassMixin.hasOwnProperty(name)) {
	    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name) : invariant(false) : undefined;
	  }
	
	  // Disallow defining methods more than once unless explicitly allowed.
	  if (proto.hasOwnProperty(name)) {
	    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name) : invariant(false) : undefined;
	  }
	}
	
	/**
	 * Mixin helper which handles policy validation and reserved
	 * specification keys when building React classses.
	 */
	function mixSpecIntoComponent(Constructor, spec) {
	  if (!spec) {
	    return;
	  }
	
	  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component class as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
	  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
	
	  var proto = Constructor.prototype;
	
	  // By handling mixins before any other properties, we ensure the same
	  // chaining order is applied to methods with DEFINE_MANY policy, whether
	  // mixins are listed before or after these methods in the spec.
	  if (spec.hasOwnProperty(MIXINS_KEY)) {
	    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
	  }
	
	  for (var name in spec) {
	    if (!spec.hasOwnProperty(name)) {
	      continue;
	    }
	
	    if (name === MIXINS_KEY) {
	      // We have already handled mixins in a special case above.
	      continue;
	    }
	
	    var property = spec[name];
	    validateMethodOverride(proto, name);
	
	    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
	      RESERVED_SPEC_KEYS[name](Constructor, property);
	    } else {
	      // Setup methods on prototype:
	      // The following member methods should not be automatically bound:
	      // 1. Expected ReactClass methods (in the "interface").
	      // 2. Overridden methods (that were mixed in).
	      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
	      var isAlreadyDefined = proto.hasOwnProperty(name);
	      var isFunction = typeof property === 'function';
	      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
	
	      if (shouldAutoBind) {
	        if (!proto.__reactAutoBindMap) {
	          proto.__reactAutoBindMap = {};
	        }
	        proto.__reactAutoBindMap[name] = property;
	        proto[name] = property;
	      } else {
	        if (isAlreadyDefined) {
	          var specPolicy = ReactClassInterface[name];
	
	          // These cases should already be caught by validateMethodOverride.
	          !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name) : invariant(false) : undefined;
	
	          // For methods which are defined more than once, call the existing
	          // methods before calling the new property, merging if appropriate.
	          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
	            proto[name] = createMergedResultFunction(proto[name], property);
	          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
	            proto[name] = createChainedFunction(proto[name], property);
	          }
	        } else {
	          proto[name] = property;
	          if (process.env.NODE_ENV !== 'production') {
	            // Add verbose displayName to the function, which helps when looking
	            // at profiling tools.
	            if (typeof property === 'function' && spec.displayName) {
	              proto[name].displayName = spec.displayName + '_' + name;
	            }
	          }
	        }
	      }
	    }
	  }
	}
	
	function mixStaticSpecIntoComponent(Constructor, statics) {
	  if (!statics) {
	    return;
	  }
	  for (var name in statics) {
	    var property = statics[name];
	    if (!statics.hasOwnProperty(name)) {
	      continue;
	    }
	
	    var isReserved = name in RESERVED_SPEC_KEYS;
	    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name) : invariant(false) : undefined;
	
	    var isInherited = name in Constructor;
	    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name) : invariant(false) : undefined;
	    Constructor[name] = property;
	  }
	}
	
	/**
	 * Merge two objects, but throw if both contain the same key.
	 *
	 * @param {object} one The first object, which is mutated.
	 * @param {object} two The second object
	 * @return {object} one after it has been mutated to contain everything in two.
	 */
	function mergeIntoWithNoDuplicateKeys(one, two) {
	  !(one && two && (typeof one === 'undefined' ? 'undefined' : _typeof(one)) === 'object' && (typeof two === 'undefined' ? 'undefined' : _typeof(two)) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : invariant(false) : undefined;
	
	  for (var key in two) {
	    if (two.hasOwnProperty(key)) {
	      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key) : invariant(false) : undefined;
	      one[key] = two[key];
	    }
	  }
	  return one;
	}
	
	/**
	 * Creates a function that invokes two functions and merges their return values.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createMergedResultFunction(one, two) {
	  return function mergedResult() {
	    var a = one.apply(this, arguments);
	    var b = two.apply(this, arguments);
	    if (a == null) {
	      return b;
	    } else if (b == null) {
	      return a;
	    }
	    var c = {};
	    mergeIntoWithNoDuplicateKeys(c, a);
	    mergeIntoWithNoDuplicateKeys(c, b);
	    return c;
	  };
	}
	
	/**
	 * Creates a function that invokes two functions and ignores their return vales.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createChainedFunction(one, two) {
	  return function chainedFunction() {
	    one.apply(this, arguments);
	    two.apply(this, arguments);
	  };
	}
	
	/**
	 * Binds a method to the component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 * @param {function} method Method to be bound.
	 * @return {function} The bound method.
	 */
	function bindAutoBindMethod(component, method) {
	  var boundMethod = method.bind(component);
	  if (process.env.NODE_ENV !== 'production') {
	    boundMethod.__reactBoundContext = component;
	    boundMethod.__reactBoundMethod = method;
	    boundMethod.__reactBoundArguments = null;
	    var componentName = component.constructor.displayName;
	    var _bind = boundMethod.bind;
	    /* eslint-disable block-scoped-var, no-undef */
	    boundMethod.bind = function (newThis) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      // User is trying to bind() an autobound method; we effectively will
	      // ignore the value of "this" that the user is trying to use, so
	      // let's warn.
	      if (newThis !== component && newThis !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : undefined;
	      } else if (!args.length) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : undefined;
	        return boundMethod;
	      }
	      var reboundMethod = _bind.apply(boundMethod, arguments);
	      reboundMethod.__reactBoundContext = component;
	      reboundMethod.__reactBoundMethod = method;
	      reboundMethod.__reactBoundArguments = args;
	      return reboundMethod;
	      /* eslint-enable */
	    };
	  }
	  return boundMethod;
	}
	
	/**
	 * Binds all auto-bound methods in a component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 */
	function bindAutoBindMethods(component) {
	  for (var autoBindKey in component.__reactAutoBindMap) {
	    if (component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
	      var method = component.__reactAutoBindMap[autoBindKey];
	      component[autoBindKey] = bindAutoBindMethod(component, method);
	    }
	  }
	}
	
	/**
	 * Add more to the ReactClass base class. These are all legacy features and
	 * therefore not already part of the modern ReactComponent.
	 */
	var ReactClassMixin = {
	
	  /**
	   * TODO: This will be deprecated because state should always keep a consistent
	   * type signature and the only use case for this, is to avoid that.
	   */
	  replaceState: function replaceState(newState, callback) {
	    this.updater.enqueueReplaceState(this, newState);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  },
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function isMounted() {
	    return this.updater.isMounted(this);
	  },
	
	  /**
	   * Sets a subset of the props.
	   *
	   * @param {object} partialProps Subset of the next props.
	   * @param {?function} callback Called after props are updated.
	   * @final
	   * @public
	   * @deprecated
	   */
	  setProps: function setProps(partialProps, callback) {
	    if (process.env.NODE_ENV !== 'production') {
	      warnSetProps();
	    }
	    this.updater.enqueueSetProps(this, partialProps);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  },
	
	  /**
	   * Replace all the props.
	   *
	   * @param {object} newProps Subset of the next props.
	   * @param {?function} callback Called after props are updated.
	   * @final
	   * @public
	   * @deprecated
	   */
	  replaceProps: function replaceProps(newProps, callback) {
	    if (process.env.NODE_ENV !== 'production') {
	      warnSetProps();
	    }
	    this.updater.enqueueReplaceProps(this, newProps);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  }
	};
	
	var ReactClassComponent = function ReactClassComponent() {};
	assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
	
	/**
	 * Module for creating composite components.
	 *
	 * @class ReactClass
	 */
	var ReactClass = {
	
	  /**
	   * Creates a composite component class given a class specification.
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
	  createClass: function createClass(spec) {
	    var Constructor = function Constructor(props, context, updater) {
	      // This constructor is overridden by mocks. The argument is used
	      // by mocks to assert on what gets mounted.
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : undefined;
	      }
	
	      // Wire up auto-binding
	      if (this.__reactAutoBindMap) {
	        bindAutoBindMethods(this);
	      }
	
	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;
	
	      this.state = null;
	
	      // ReactClasses doesn't have constructors. Instead, they use the
	      // getInitialState and componentWillMount methods for initialization.
	
	      var initialState = this.getInitialState ? this.getInitialState() : null;
	      if (process.env.NODE_ENV !== 'production') {
	        // We allow auto-mocks to proceed as if they're returning null.
	        if (typeof initialState === 'undefined' && this.getInitialState._isMockFunction) {
	          // This is probably bad practice. Consider warning here and
	          // deprecating this convenience.
	          initialState = null;
	        }
	      }
	      !((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : invariant(false) : undefined;
	
	      this.state = initialState;
	    };
	    Constructor.prototype = new ReactClassComponent();
	    Constructor.prototype.constructor = Constructor;
	
	    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
	
	    mixSpecIntoComponent(Constructor, spec);
	
	    // Initialize the defaultProps property after all mixins have been merged.
	    if (Constructor.getDefaultProps) {
	      Constructor.defaultProps = Constructor.getDefaultProps();
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This is a tag to indicate that the use of these method names is ok,
	      // since it's used with createClass. If it's not, then it's likely a
	      // mistake so we'll warn you to use the static property, property
	      // initializer or constructor respectively.
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps.isReactClassApproved = {};
	      }
	      if (Constructor.prototype.getInitialState) {
	        Constructor.prototype.getInitialState.isReactClassApproved = {};
	      }
	    }
	
	    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : invariant(false) : undefined;
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : undefined;
	    }
	
	    // Reduce time spent doing lookups by setting these on the prototype.
	    for (var methodName in ReactClassInterface) {
	      if (!Constructor.prototype[methodName]) {
	        Constructor.prototype[methodName] = null;
	      }
	    }
	
	    return Constructor;
	  },
	
	  injection: {
	    injectMixin: function injectMixin(mixin) {
	      injectedMixins.push(mixin);
	    }
	  }
	
	};
	
	module.exports = ReactClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponent
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactNoopUpdateQueue = __webpack_require__(131);
	
	var canDefineProperty = __webpack_require__(50);
	var emptyObject = __webpack_require__(65);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	ReactComponent.prototype.isReactComponent = {};
	
	/**
	 * Sets a subset of the state. Always use this to mutate
	 * state. You should treat `this.state` as immutable.
	 *
	 * There is no guarantee that `this.state` will be immediately updated, so
	 * accessing `this.state` after calling this method may return the old value.
	 *
	 * There is no guarantee that calls to `setState` will run synchronously,
	 * as they may eventually be batched together.  You can provide an optional
	 * callback that will be executed when the call to setState is actually
	 * completed.
	 *
	 * When a function is provided to setState, it will be called at some point in
	 * the future (not synchronously). It will be called with the up to date
	 * component arguments (state, props, context). These values can be different
	 * from this.* because your function may be called after receiveProps but before
	 * shouldComponentUpdate, and this new state, props, and context will not yet be
	 * assigned to this.
	 *
	 * @param {object|function} partialState Next partial state or function to
	 *        produce next partial state to be merged with current state.
	 * @param {?function} callback Called after state is updated.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.setState = function (partialState, callback) {
	  !((typeof partialState === 'undefined' ? 'undefined' : _typeof(partialState)) === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.') : invariant(false) : undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : undefined;
	  }
	  this.updater.enqueueSetState(this, partialState);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback);
	  }
	};
	
	/**
	 * Forces an update. This should only be invoked when it is known with
	 * certainty that we are **not** in a DOM transaction.
	 *
	 * You may want to call this when you know that some deeper aspect of the
	 * component's state has changed but `setState` was not called.
	 *
	 * This will not invoke `shouldComponentUpdate`, but it will invoke
	 * `componentWillUpdate` and `componentDidUpdate`.
	 *
	 * @param {?function} callback Called after update is complete.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback);
	  }
	};
	
	/**
	 * Deprecated APIs. These APIs used to exist on classic React classes but since
	 * we would like to deprecate them, we're not going to move them over to this
	 * modern base class. Instead, we define a getter that warns if it's accessed.
	 */
	if (process.env.NODE_ENV !== 'production') {
	  var deprecatedAPIs = {
	    getDOMNode: ['getDOMNode', 'Use ReactDOM.findDOMNode(component) instead.'],
	    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
	    replaceProps: ['replaceProps', 'Instead, call render again at the top level.'],
	    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'],
	    setProps: ['setProps', 'Instead, call render again at the top level.']
	  };
	  var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
	    if (canDefineProperty) {
	      Object.defineProperty(ReactComponent.prototype, methodName, {
	        get: function get() {
	          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : undefined;
	          return undefined;
	        }
	      });
	    }
	  };
	  for (var fnName in deprecatedAPIs) {
	    if (deprecatedAPIs.hasOwnProperty(fnName)) {
	      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	    }
	  }
	}
	
	module.exports = ReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNoopUpdateQueue
	 */
	
	'use strict';
	
	var warning = __webpack_require__(32);
	
	function warnTDZ(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor && publicInstance.constructor.displayName || '') : undefined;
	  }
	}
	
	/**
	 * This is the abstract API for an update queue.
	 */
	var ReactNoopUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function isMounted(publicInstance) {
	    return false;
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function enqueueCallback(publicInstance, callback) {},
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {
	    warnTDZ(publicInstance, 'forceUpdate');
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState) {
	    warnTDZ(publicInstance, 'replaceState');
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function enqueueSetState(publicInstance, partialState) {
	    warnTDZ(publicInstance, 'setState');
	  },
	
	  /**
	   * Sets a subset of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialProps Subset of the next props.
	   * @internal
	   */
	  enqueueSetProps: function enqueueSetProps(publicInstance, partialProps) {
	    warnTDZ(publicInstance, 'setProps');
	  },
	
	  /**
	   * Replaces all of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} props New props.
	   * @internal
	   */
	  enqueueReplaceProps: function enqueueReplaceProps(publicInstance, props) {
	    warnTDZ(publicInstance, 'replaceProps');
	  }
	
	};
	
	module.exports = ReactNoopUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconcileTransaction
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CallbackQueue = __webpack_require__(62);
	var PooledClass = __webpack_require__(63);
	var ReactBrowserEventEmitter = __webpack_require__(36);
	var ReactDOMFeatureFlags = __webpack_require__(48);
	var ReactInputSelection = __webpack_require__(133);
	var Transaction = __webpack_require__(64);
	
	var assign = __webpack_require__(46);
	
	/**
	 * Ensures that, when possible, the selection range (currently selected text
	 * input) is not disturbed by performing the transaction.
	 */
	var SELECTION_RESTORATION = {
	  /**
	   * @return {Selection} Selection information.
	   */
	  initialize: ReactInputSelection.getSelectionInformation,
	  /**
	   * @param {Selection} sel Selection information returned from `initialize`.
	   */
	  close: ReactInputSelection.restoreSelection
	};
	
	/**
	 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
	 * high level DOM manipulations (like temporarily removing a text input from the
	 * DOM).
	 */
	var EVENT_SUPPRESSION = {
	  /**
	   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
	   * the reconciliation.
	   */
	  initialize: function initialize() {
	    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
	    ReactBrowserEventEmitter.setEnabled(false);
	    return currentlyEnabled;
	  },
	
	  /**
	   * @param {boolean} previouslyEnabled Enabled status of
	   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
	   *   restores the previous value.
	   */
	  close: function close(previouslyEnabled) {
	    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
	  }
	};
	
	/**
	 * Provides a queue for collecting `componentDidMount` and
	 * `componentDidUpdate` callbacks during the the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function initialize() {
	    this.reactMountReady.reset();
	  },
	
	  /**
	   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
	   */
	  close: function close() {
	    this.reactMountReady.notifyAll();
	  }
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
	
	/**
	 * Currently:
	 * - The order that these are listed in the transaction is critical:
	 * - Suppresses events.
	 * - Restores selection range.
	 *
	 * Future:
	 * - Restore document/overflow scroll positions that were unintentionally
	 *   modified via DOM insertions above the top viewport boundary.
	 * - Implement/integrate with customized constraint based layout system and keep
	 *   track of which dimensions must be remeasured.
	 *
	 * @class ReactReconcileTransaction
	 */
	function ReactReconcileTransaction(forceHTML) {
	  this.reinitializeTransaction();
	  // Only server-side rendering really needs this option (see
	  // `ReactServerRendering`), but server-side uses
	  // `ReactServerRenderingTransaction` instead. This option is here so that it's
	  // accessible and defaults to false when `ReactDOMComponent` and
	  // `ReactTextComponent` checks it in `mountComponent`.`
	  this.renderToStaticMarkup = false;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = !forceHTML && ReactDOMFeatureFlags.useCreateElement;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array<object>} List of operation wrap procedures.
	   *   TODO: convert to array<TransactionWrapper>
	   */
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function getReactMountReady() {
	    return this.reactMountReady;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function destructor() {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactReconcileTransaction);
	
	module.exports = ReactReconcileTransaction;

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInputSelection
	 */
	
	'use strict';
	
	var ReactDOMSelection = __webpack_require__(134);
	
	var containsNode = __webpack_require__(66);
	var focusNode = __webpack_require__(102);
	var getActiveElement = __webpack_require__(136);
	
	function isInDocument(node) {
	  return containsNode(document.documentElement, node);
	}
	
	/**
	 * @ReactInputSelection: React input selection module. Based on Selection.js,
	 * but modified to be suitable for react and has a couple of bug fixes (doesn't
	 * assume buttons have range selections allowed).
	 * Input selection module for React.
	 */
	var ReactInputSelection = {
	
	  hasSelectionCapabilities: function hasSelectionCapabilities(elem) {
	    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
	  },
	
	  getSelectionInformation: function getSelectionInformation() {
	    var focusedElem = getActiveElement();
	    return {
	      focusedElem: focusedElem,
	      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
	    };
	  },
	
	  /**
	   * @restoreSelection: If any selection information was potentially lost,
	   * restore it. This is useful when performing operations that could remove dom
	   * nodes and place them back in, resulting in focus being lost.
	   */
	  restoreSelection: function restoreSelection(priorSelectionInformation) {
	    var curFocusedElem = getActiveElement();
	    var priorFocusedElem = priorSelectionInformation.focusedElem;
	    var priorSelectionRange = priorSelectionInformation.selectionRange;
	    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
	      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
	        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
	      }
	      focusNode(priorFocusedElem);
	    }
	  },
	
	  /**
	   * @getSelection: Gets the selection bounds of a focused textarea, input or
	   * contentEditable node.
	   * -@input: Look up selection bounds of this input
	   * -@return {start: selectionStart, end: selectionEnd}
	   */
	  getSelection: function getSelection(input) {
	    var selection;
	
	    if ('selectionStart' in input) {
	      // Modern browser with input or textarea.
	      selection = {
	        start: input.selectionStart,
	        end: input.selectionEnd
	      };
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      // IE8 input.
	      var range = document.selection.createRange();
	      // There can only be one selection per document in IE, so it must
	      // be in our element.
	      if (range.parentElement() === input) {
	        selection = {
	          start: -range.moveStart('character', -input.value.length),
	          end: -range.moveEnd('character', -input.value.length)
	        };
	      }
	    } else {
	      // Content editable or old IE textarea.
	      selection = ReactDOMSelection.getOffsets(input);
	    }
	
	    return selection || { start: 0, end: 0 };
	  },
	
	  /**
	   * @setSelection: Sets the selection bounds of a textarea or input and focuses
	   * the input.
	   * -@input     Set selection bounds of this input or textarea
	   * -@offsets   Object of same form that is returned from get*
	   */
	  setSelection: function setSelection(input, offsets) {
	    var start = offsets.start;
	    var end = offsets.end;
	    if (typeof end === 'undefined') {
	      end = start;
	    }
	
	    if ('selectionStart' in input) {
	      input.selectionStart = start;
	      input.selectionEnd = Math.min(end, input.value.length);
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      var range = input.createTextRange();
	      range.collapse(true);
	      range.moveStart('character', start);
	      range.moveEnd('character', end - start);
	      range.select();
	    } else {
	      ReactDOMSelection.setOffsets(input, offsets);
	    }
	  }
	};
	
	module.exports = ReactInputSelection;

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelection
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var getNodeForCharacterOffset = __webpack_require__(135);
	var getTextContentAccessor = __webpack_require__(82);
	
	/**
	 * While `isCollapsed` is available on the Selection object and `collapsed`
	 * is available on the Range object, IE11 sometimes gets them wrong.
	 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
	 */
	function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
	  return anchorNode === focusNode && anchorOffset === focusOffset;
	}
	
	/**
	 * Get the appropriate anchor and focus node/offset pairs for IE.
	 *
	 * The catch here is that IE's selection API doesn't provide information
	 * about whether the selection is forward or backward, so we have to
	 * behave as though it's always forward.
	 *
	 * IE text differs from modern selection in that it behaves as though
	 * block elements end with a new line. This means character offsets will
	 * differ between the two APIs.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getIEOffsets(node) {
	  var selection = document.selection;
	  var selectedRange = selection.createRange();
	  var selectedLength = selectedRange.text.length;
	
	  // Duplicate selection so we can move range without breaking user selection.
	  var fromStart = selectedRange.duplicate();
	  fromStart.moveToElementText(node);
	  fromStart.setEndPoint('EndToStart', selectedRange);
	
	  var startOffset = fromStart.text.length;
	  var endOffset = startOffset + selectedLength;
	
	  return {
	    start: startOffset,
	    end: endOffset
	  };
	}
	
	/**
	 * @param {DOMElement} node
	 * @return {?object}
	 */
	function getModernOffsets(node) {
	  var selection = window.getSelection && window.getSelection();
	
	  if (!selection || selection.rangeCount === 0) {
	    return null;
	  }
	
	  var anchorNode = selection.anchorNode;
	  var anchorOffset = selection.anchorOffset;
	  var focusNode = selection.focusNode;
	  var focusOffset = selection.focusOffset;
	
	  var currentRange = selection.getRangeAt(0);
	
	  // In Firefox, range.startContainer and range.endContainer can be "anonymous
	  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
	  // divs do not seem to expose properties, triggering a "Permission denied
	  // error" if any of its properties are accessed. The only seemingly possible
	  // way to avoid erroring is to access a property that typically works for
	  // non-anonymous divs and catch any error that may otherwise arise. See
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
	  try {
	    /* eslint-disable no-unused-expressions */
	    currentRange.startContainer.nodeType;
	    currentRange.endContainer.nodeType;
	    /* eslint-enable no-unused-expressions */
	  } catch (e) {
	    return null;
	  }
	
	  // If the node and offset values are the same, the selection is collapsed.
	  // `Selection.isCollapsed` is available natively, but IE sometimes gets
	  // this value wrong.
	  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
	
	  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
	
	  var tempRange = currentRange.cloneRange();
	  tempRange.selectNodeContents(node);
	  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
	
	  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
	
	  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
	  var end = start + rangeLength;
	
	  // Detect whether the selection is backward.
	  var detectionRange = document.createRange();
	  detectionRange.setStart(anchorNode, anchorOffset);
	  detectionRange.setEnd(focusNode, focusOffset);
	  var isBackward = detectionRange.collapsed;
	
	  return {
	    start: isBackward ? end : start,
	    end: isBackward ? start : end
	  };
	}
	
	/**
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setIEOffsets(node, offsets) {
	  var range = document.selection.createRange().duplicate();
	  var start, end;
	
	  if (typeof offsets.end === 'undefined') {
	    start = offsets.start;
	    end = start;
	  } else if (offsets.start > offsets.end) {
	    start = offsets.end;
	    end = offsets.start;
	  } else {
	    start = offsets.start;
	    end = offsets.end;
	  }
	
	  range.moveToElementText(node);
	  range.moveStart('character', start);
	  range.setEndPoint('EndToStart', range);
	  range.moveEnd('character', end - start);
	  range.select();
	}
	
	/**
	 * In modern non-IE browsers, we can support both forward and backward
	 * selections.
	 *
	 * Note: IE10+ supports the Selection object, but it does not support
	 * the `extend` method, which means that even in modern IE, it's not possible
	 * to programatically create a backward selection. Thus, for all IE
	 * versions, we use the old IE API to create our selections.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setModernOffsets(node, offsets) {
	  if (!window.getSelection) {
	    return;
	  }
	
	  var selection = window.getSelection();
	  var length = node[getTextContentAccessor()].length;
	  var start = Math.min(offsets.start, length);
	  var end = typeof offsets.end === 'undefined' ? start : Math.min(offsets.end, length);
	
	  // IE 11 uses modern selection, but doesn't support the extend method.
	  // Flip backward selections, so we can set with a single range.
	  if (!selection.extend && start > end) {
	    var temp = end;
	    end = start;
	    start = temp;
	  }
	
	  var startMarker = getNodeForCharacterOffset(node, start);
	  var endMarker = getNodeForCharacterOffset(node, end);
	
	  if (startMarker && endMarker) {
	    var range = document.createRange();
	    range.setStart(startMarker.node, startMarker.offset);
	    selection.removeAllRanges();
	
	    if (start > end) {
	      selection.addRange(range);
	      selection.extend(endMarker.node, endMarker.offset);
	    } else {
	      range.setEnd(endMarker.node, endMarker.offset);
	      selection.addRange(range);
	    }
	  }
	}
	
	var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);
	
	var ReactDOMSelection = {
	  /**
	   * @param {DOMElement} node
	   */
	  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
	
	  /**
	   * @param {DOMElement|DOMTextNode} node
	   * @param {object} offsets
	   */
	  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
	};
	
	module.exports = ReactDOMSelection;

/***/ },
/* 135 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getNodeForCharacterOffset
	 */
	
	'use strict';
	
	/**
	 * Given any node return the first leaf node without children.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {DOMElement|DOMTextNode}
	 */
	
	function getLeafNode(node) {
	  while (node && node.firstChild) {
	    node = node.firstChild;
	  }
	  return node;
	}
	
	/**
	 * Get the next sibling within a container. This will walk up the
	 * DOM if a node's siblings have been exhausted.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {?DOMElement|DOMTextNode}
	 */
	function getSiblingNode(node) {
	  while (node) {
	    if (node.nextSibling) {
	      return node.nextSibling;
	    }
	    node = node.parentNode;
	  }
	}
	
	/**
	 * Get object describing the nodes which contain characters at offset.
	 *
	 * @param {DOMElement|DOMTextNode} root
	 * @param {number} offset
	 * @return {?object}
	 */
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  var nodeStart = 0;
	  var nodeEnd = 0;
	
	  while (node) {
	    if (node.nodeType === 3) {
	      nodeEnd = nodeStart + node.textContent.length;
	
	      if (nodeStart <= offset && nodeEnd >= offset) {
	        return {
	          node: node,
	          offset: offset - nodeStart
	        };
	      }
	
	      nodeStart = nodeEnd;
	    }
	
	    node = getLeafNode(getSiblingNode(node));
	  }
	}
	
	module.exports = getNodeForCharacterOffset;

/***/ },
/* 136 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getActiveElement
	 * @typechecks
	 */
	
	/* eslint-disable fb-www/typeof-undefined */
	
	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document or document body is not
	 * yet defined.
	 */
	'use strict';
	
	function getActiveElement() /*?DOMElement*/{
	  if (typeof document === 'undefined') {
	    return null;
	  }
	  try {
	    return document.activeElement || document.body;
	  } catch (e) {
	    return document.body;
	  }
	}
	
	module.exports = getActiveElement;

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SelectEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var EventPropagators = __webpack_require__(80);
	var ExecutionEnvironment = __webpack_require__(16);
	var ReactInputSelection = __webpack_require__(133);
	var SyntheticEvent = __webpack_require__(84);
	
	var getActiveElement = __webpack_require__(136);
	var isTextInputElement = __webpack_require__(89);
	var keyOf = __webpack_require__(86);
	var shallowEqual = __webpack_require__(124);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;
	
	var eventTypes = {
	  select: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSelect: null }),
	      captured: keyOf({ onSelectCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	var activeElement = null;
	var activeElementID = null;
	var lastSelection = null;
	var mouseDown = false;
	
	// Track whether a listener exists for this plugin. If none exist, we do
	// not extract events.
	var hasListener = false;
	var ON_SELECT_KEY = keyOf({ onSelect: null });
	
	/**
	 * Get an object which is a unique representation of the current selection.
	 *
	 * The return value will not be consistent across nodes or browsers, but
	 * two identical selections on the same node will return identical objects.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getSelection(node) {
	  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
	    return {
	      start: node.selectionStart,
	      end: node.selectionEnd
	    };
	  } else if (window.getSelection) {
	    var selection = window.getSelection();
	    return {
	      anchorNode: selection.anchorNode,
	      anchorOffset: selection.anchorOffset,
	      focusNode: selection.focusNode,
	      focusOffset: selection.focusOffset
	    };
	  } else if (document.selection) {
	    var range = document.selection.createRange();
	    return {
	      parentElement: range.parentElement(),
	      text: range.text,
	      top: range.boundingTop,
	      left: range.boundingLeft
	    };
	  }
	}
	
	/**
	 * Poll selection to see whether it's changed.
	 *
	 * @param {object} nativeEvent
	 * @return {?SyntheticEvent}
	 */
	function constructSelectEvent(nativeEvent, nativeEventTarget) {
	  // Ensure we have the right element, and that the user is not dragging a
	  // selection (this matches native `select` event behavior). In HTML5, select
	  // fires only on input and textarea thus if there's no focused element we
	  // won't dispatch.
	  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
	    return null;
	  }
	
	  // Only fire when selection has actually changed.
	  var currentSelection = getSelection(activeElement);
	  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
	    lastSelection = currentSelection;
	
	    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent, nativeEventTarget);
	
	    syntheticEvent.type = 'select';
	    syntheticEvent.target = activeElement;
	
	    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
	
	    return syntheticEvent;
	  }
	
	  return null;
	}
	
	/**
	 * This plugin creates an `onSelect` event that normalizes select events
	 * across form elements.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - contentEditable
	 *
	 * This differs from native browser implementations in the following ways:
	 * - Fires on contentEditable fields as well as inputs.
	 * - Fires for collapsed selection.
	 * - Fires after user input.
	 */
	var SelectEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    if (!hasListener) {
	      return null;
	    }
	
	    switch (topLevelType) {
	      // Track the input node that has focus.
	      case topLevelTypes.topFocus:
	        if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === 'true') {
	          activeElement = topLevelTarget;
	          activeElementID = topLevelTargetID;
	          lastSelection = null;
	        }
	        break;
	      case topLevelTypes.topBlur:
	        activeElement = null;
	        activeElementID = null;
	        lastSelection = null;
	        break;
	
	      // Don't fire the event while the user is dragging. This matches the
	      // semantics of the native select event.
	      case topLevelTypes.topMouseDown:
	        mouseDown = true;
	        break;
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topMouseUp:
	        mouseDown = false;
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	
	      // Chrome and IE fire non-standard event when selection is changed (and
	      // sometimes when it hasn't). IE's event fires out of order with respect
	      // to key and input events on deletion, so we discard it.
	      //
	      // Firefox doesn't support selectionchange, so check selection status
	      // after each key entry. The selection changes after keydown and before
	      // keyup, but we check on keydown as well in the case of holding down a
	      // key, when multiple keydown events are fired but only one keyup is.
	      // This is also our approach for IE handling, for the reason above.
	      case topLevelTypes.topSelectionChange:
	        if (skipSelectionChangeEvent) {
	          break;
	        }
	      // falls through
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	    }
	
	    return null;
	  },
	
	  didPutListener: function didPutListener(id, registrationName, listener) {
	    if (registrationName === ON_SELECT_KEY) {
	      hasListener = true;
	    }
	  }
	};
	
	module.exports = SelectEventPlugin;

/***/ },
/* 138 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ServerReactRootIndex
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Size of the reactRoot ID space. We generate random numbers for React root
	 * IDs and if there's a collision the events and DOM update system will
	 * get confused. In the future we need a way to generate GUIDs but for
	 * now this will work on a smaller scale.
	 */
	
	var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);
	
	var ServerReactRootIndex = {
	  createReactRootIndex: function createReactRootIndex() {
	    return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
	  }
	};
	
	module.exports = ServerReactRootIndex;

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SimpleEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var EventListener = __webpack_require__(126);
	var EventPropagators = __webpack_require__(80);
	var ReactMount = __webpack_require__(35);
	var SyntheticClipboardEvent = __webpack_require__(140);
	var SyntheticEvent = __webpack_require__(84);
	var SyntheticFocusEvent = __webpack_require__(141);
	var SyntheticKeyboardEvent = __webpack_require__(142);
	var SyntheticMouseEvent = __webpack_require__(93);
	var SyntheticDragEvent = __webpack_require__(145);
	var SyntheticTouchEvent = __webpack_require__(146);
	var SyntheticUIEvent = __webpack_require__(94);
	var SyntheticWheelEvent = __webpack_require__(147);
	
	var emptyFunction = __webpack_require__(22);
	var getEventCharCode = __webpack_require__(143);
	var invariant = __webpack_require__(20);
	var keyOf = __webpack_require__(86);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  abort: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAbort: true }),
	      captured: keyOf({ onAbortCapture: true })
	    }
	  },
	  blur: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBlur: true }),
	      captured: keyOf({ onBlurCapture: true })
	    }
	  },
	  canPlay: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlay: true }),
	      captured: keyOf({ onCanPlayCapture: true })
	    }
	  },
	  canPlayThrough: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlayThrough: true }),
	      captured: keyOf({ onCanPlayThroughCapture: true })
	    }
	  },
	  click: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onClick: true }),
	      captured: keyOf({ onClickCapture: true })
	    }
	  },
	  contextMenu: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onContextMenu: true }),
	      captured: keyOf({ onContextMenuCapture: true })
	    }
	  },
	  copy: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCopy: true }),
	      captured: keyOf({ onCopyCapture: true })
	    }
	  },
	  cut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCut: true }),
	      captured: keyOf({ onCutCapture: true })
	    }
	  },
	  doubleClick: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDoubleClick: true }),
	      captured: keyOf({ onDoubleClickCapture: true })
	    }
	  },
	  drag: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrag: true }),
	      captured: keyOf({ onDragCapture: true })
	    }
	  },
	  dragEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnd: true }),
	      captured: keyOf({ onDragEndCapture: true })
	    }
	  },
	  dragEnter: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnter: true }),
	      captured: keyOf({ onDragEnterCapture: true })
	    }
	  },
	  dragExit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragExit: true }),
	      captured: keyOf({ onDragExitCapture: true })
	    }
	  },
	  dragLeave: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragLeave: true }),
	      captured: keyOf({ onDragLeaveCapture: true })
	    }
	  },
	  dragOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragOver: true }),
	      captured: keyOf({ onDragOverCapture: true })
	    }
	  },
	  dragStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragStart: true }),
	      captured: keyOf({ onDragStartCapture: true })
	    }
	  },
	  drop: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrop: true }),
	      captured: keyOf({ onDropCapture: true })
	    }
	  },
	  durationChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDurationChange: true }),
	      captured: keyOf({ onDurationChangeCapture: true })
	    }
	  },
	  emptied: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEmptied: true }),
	      captured: keyOf({ onEmptiedCapture: true })
	    }
	  },
	  encrypted: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEncrypted: true }),
	      captured: keyOf({ onEncryptedCapture: true })
	    }
	  },
	  ended: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEnded: true }),
	      captured: keyOf({ onEndedCapture: true })
	    }
	  },
	  error: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onError: true }),
	      captured: keyOf({ onErrorCapture: true })
	    }
	  },
	  focus: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onFocus: true }),
	      captured: keyOf({ onFocusCapture: true })
	    }
	  },
	  input: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onInput: true }),
	      captured: keyOf({ onInputCapture: true })
	    }
	  },
	  keyDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyDown: true }),
	      captured: keyOf({ onKeyDownCapture: true })
	    }
	  },
	  keyPress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyPress: true }),
	      captured: keyOf({ onKeyPressCapture: true })
	    }
	  },
	  keyUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyUp: true }),
	      captured: keyOf({ onKeyUpCapture: true })
	    }
	  },
	  load: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoad: true }),
	      captured: keyOf({ onLoadCapture: true })
	    }
	  },
	  loadedData: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedData: true }),
	      captured: keyOf({ onLoadedDataCapture: true })
	    }
	  },
	  loadedMetadata: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedMetadata: true }),
	      captured: keyOf({ onLoadedMetadataCapture: true })
	    }
	  },
	  loadStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadStart: true }),
	      captured: keyOf({ onLoadStartCapture: true })
	    }
	  },
	  // Note: We do not allow listening to mouseOver events. Instead, use the
	  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
	  mouseDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseDown: true }),
	      captured: keyOf({ onMouseDownCapture: true })
	    }
	  },
	  mouseMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseMove: true }),
	      captured: keyOf({ onMouseMoveCapture: true })
	    }
	  },
	  mouseOut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOut: true }),
	      captured: keyOf({ onMouseOutCapture: true })
	    }
	  },
	  mouseOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOver: true }),
	      captured: keyOf({ onMouseOverCapture: true })
	    }
	  },
	  mouseUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseUp: true }),
	      captured: keyOf({ onMouseUpCapture: true })
	    }
	  },
	  paste: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPaste: true }),
	      captured: keyOf({ onPasteCapture: true })
	    }
	  },
	  pause: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPause: true }),
	      captured: keyOf({ onPauseCapture: true })
	    }
	  },
	  play: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlay: true }),
	      captured: keyOf({ onPlayCapture: true })
	    }
	  },
	  playing: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlaying: true }),
	      captured: keyOf({ onPlayingCapture: true })
	    }
	  },
	  progress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onProgress: true }),
	      captured: keyOf({ onProgressCapture: true })
	    }
	  },
	  rateChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onRateChange: true }),
	      captured: keyOf({ onRateChangeCapture: true })
	    }
	  },
	  reset: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onReset: true }),
	      captured: keyOf({ onResetCapture: true })
	    }
	  },
	  scroll: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onScroll: true }),
	      captured: keyOf({ onScrollCapture: true })
	    }
	  },
	  seeked: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeked: true }),
	      captured: keyOf({ onSeekedCapture: true })
	    }
	  },
	  seeking: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeking: true }),
	      captured: keyOf({ onSeekingCapture: true })
	    }
	  },
	  stalled: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onStalled: true }),
	      captured: keyOf({ onStalledCapture: true })
	    }
	  },
	  submit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSubmit: true }),
	      captured: keyOf({ onSubmitCapture: true })
	    }
	  },
	  suspend: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSuspend: true }),
	      captured: keyOf({ onSuspendCapture: true })
	    }
	  },
	  timeUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTimeUpdate: true }),
	      captured: keyOf({ onTimeUpdateCapture: true })
	    }
	  },
	  touchCancel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchCancel: true }),
	      captured: keyOf({ onTouchCancelCapture: true })
	    }
	  },
	  touchEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchEnd: true }),
	      captured: keyOf({ onTouchEndCapture: true })
	    }
	  },
	  touchMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchMove: true }),
	      captured: keyOf({ onTouchMoveCapture: true })
	    }
	  },
	  touchStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchStart: true }),
	      captured: keyOf({ onTouchStartCapture: true })
	    }
	  },
	  volumeChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onVolumeChange: true }),
	      captured: keyOf({ onVolumeChangeCapture: true })
	    }
	  },
	  waiting: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWaiting: true }),
	      captured: keyOf({ onWaitingCapture: true })
	    }
	  },
	  wheel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWheel: true }),
	      captured: keyOf({ onWheelCapture: true })
	    }
	  }
	};
	
	var topLevelEventsToDispatchConfig = {
	  topAbort: eventTypes.abort,
	  topBlur: eventTypes.blur,
	  topCanPlay: eventTypes.canPlay,
	  topCanPlayThrough: eventTypes.canPlayThrough,
	  topClick: eventTypes.click,
	  topContextMenu: eventTypes.contextMenu,
	  topCopy: eventTypes.copy,
	  topCut: eventTypes.cut,
	  topDoubleClick: eventTypes.doubleClick,
	  topDrag: eventTypes.drag,
	  topDragEnd: eventTypes.dragEnd,
	  topDragEnter: eventTypes.dragEnter,
	  topDragExit: eventTypes.dragExit,
	  topDragLeave: eventTypes.dragLeave,
	  topDragOver: eventTypes.dragOver,
	  topDragStart: eventTypes.dragStart,
	  topDrop: eventTypes.drop,
	  topDurationChange: eventTypes.durationChange,
	  topEmptied: eventTypes.emptied,
	  topEncrypted: eventTypes.encrypted,
	  topEnded: eventTypes.ended,
	  topError: eventTypes.error,
	  topFocus: eventTypes.focus,
	  topInput: eventTypes.input,
	  topKeyDown: eventTypes.keyDown,
	  topKeyPress: eventTypes.keyPress,
	  topKeyUp: eventTypes.keyUp,
	  topLoad: eventTypes.load,
	  topLoadedData: eventTypes.loadedData,
	  topLoadedMetadata: eventTypes.loadedMetadata,
	  topLoadStart: eventTypes.loadStart,
	  topMouseDown: eventTypes.mouseDown,
	  topMouseMove: eventTypes.mouseMove,
	  topMouseOut: eventTypes.mouseOut,
	  topMouseOver: eventTypes.mouseOver,
	  topMouseUp: eventTypes.mouseUp,
	  topPaste: eventTypes.paste,
	  topPause: eventTypes.pause,
	  topPlay: eventTypes.play,
	  topPlaying: eventTypes.playing,
	  topProgress: eventTypes.progress,
	  topRateChange: eventTypes.rateChange,
	  topReset: eventTypes.reset,
	  topScroll: eventTypes.scroll,
	  topSeeked: eventTypes.seeked,
	  topSeeking: eventTypes.seeking,
	  topStalled: eventTypes.stalled,
	  topSubmit: eventTypes.submit,
	  topSuspend: eventTypes.suspend,
	  topTimeUpdate: eventTypes.timeUpdate,
	  topTouchCancel: eventTypes.touchCancel,
	  topTouchEnd: eventTypes.touchEnd,
	  topTouchMove: eventTypes.touchMove,
	  topTouchStart: eventTypes.touchStart,
	  topVolumeChange: eventTypes.volumeChange,
	  topWaiting: eventTypes.waiting,
	  topWheel: eventTypes.wheel
	};
	
	for (var type in topLevelEventsToDispatchConfig) {
	  topLevelEventsToDispatchConfig[type].dependencies = [type];
	}
	
	var ON_CLICK_KEY = keyOf({ onClick: null });
	var onClickListeners = {};
	
	var SimpleEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
	    if (!dispatchConfig) {
	      return null;
	    }
	    var EventConstructor;
	    switch (topLevelType) {
	      case topLevelTypes.topAbort:
	      case topLevelTypes.topCanPlay:
	      case topLevelTypes.topCanPlayThrough:
	      case topLevelTypes.topDurationChange:
	      case topLevelTypes.topEmptied:
	      case topLevelTypes.topEncrypted:
	      case topLevelTypes.topEnded:
	      case topLevelTypes.topError:
	      case topLevelTypes.topInput:
	      case topLevelTypes.topLoad:
	      case topLevelTypes.topLoadedData:
	      case topLevelTypes.topLoadedMetadata:
	      case topLevelTypes.topLoadStart:
	      case topLevelTypes.topPause:
	      case topLevelTypes.topPlay:
	      case topLevelTypes.topPlaying:
	      case topLevelTypes.topProgress:
	      case topLevelTypes.topRateChange:
	      case topLevelTypes.topReset:
	      case topLevelTypes.topSeeked:
	      case topLevelTypes.topSeeking:
	      case topLevelTypes.topStalled:
	      case topLevelTypes.topSubmit:
	      case topLevelTypes.topSuspend:
	      case topLevelTypes.topTimeUpdate:
	      case topLevelTypes.topVolumeChange:
	      case topLevelTypes.topWaiting:
	        // HTML Events
	        // @see http://www.w3.org/TR/html5/index.html#events-0
	        EventConstructor = SyntheticEvent;
	        break;
	      case topLevelTypes.topKeyPress:
	        // FireFox creates a keypress event for function keys too. This removes
	        // the unwanted keypress events. Enter is however both printable and
	        // non-printable. One would expect Tab to be as well (but it isn't).
	        if (getEventCharCode(nativeEvent) === 0) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        EventConstructor = SyntheticKeyboardEvent;
	        break;
	      case topLevelTypes.topBlur:
	      case topLevelTypes.topFocus:
	        EventConstructor = SyntheticFocusEvent;
	        break;
	      case topLevelTypes.topClick:
	        // Firefox creates a click event on right mouse clicks. This removes the
	        // unwanted click events.
	        if (nativeEvent.button === 2) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topDoubleClick:
	      case topLevelTypes.topMouseDown:
	      case topLevelTypes.topMouseMove:
	      case topLevelTypes.topMouseOut:
	      case topLevelTypes.topMouseOver:
	      case topLevelTypes.topMouseUp:
	        EventConstructor = SyntheticMouseEvent;
	        break;
	      case topLevelTypes.topDrag:
	      case topLevelTypes.topDragEnd:
	      case topLevelTypes.topDragEnter:
	      case topLevelTypes.topDragExit:
	      case topLevelTypes.topDragLeave:
	      case topLevelTypes.topDragOver:
	      case topLevelTypes.topDragStart:
	      case topLevelTypes.topDrop:
	        EventConstructor = SyntheticDragEvent;
	        break;
	      case topLevelTypes.topTouchCancel:
	      case topLevelTypes.topTouchEnd:
	      case topLevelTypes.topTouchMove:
	      case topLevelTypes.topTouchStart:
	        EventConstructor = SyntheticTouchEvent;
	        break;
	      case topLevelTypes.topScroll:
	        EventConstructor = SyntheticUIEvent;
	        break;
	      case topLevelTypes.topWheel:
	        EventConstructor = SyntheticWheelEvent;
	        break;
	      case topLevelTypes.topCopy:
	      case topLevelTypes.topCut:
	      case topLevelTypes.topPaste:
	        EventConstructor = SyntheticClipboardEvent;
	        break;
	    }
	    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : invariant(false) : undefined;
	    var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent, nativeEventTarget);
	    EventPropagators.accumulateTwoPhaseDispatches(event);
	    return event;
	  },
	
	  didPutListener: function didPutListener(id, registrationName, listener) {
	    // Mobile Safari does not fire properly bubble click events on
	    // non-interactive elements, which means delegated click listeners do not
	    // fire. The workaround for this bug involves attaching an empty click
	    // listener on the target node.
	    if (registrationName === ON_CLICK_KEY) {
	      var node = ReactMount.getNode(id);
	      if (!onClickListeners[id]) {
	        onClickListeners[id] = EventListener.listen(node, 'click', emptyFunction);
	      }
	    }
	  },
	
	  willDeleteListener: function willDeleteListener(id, registrationName) {
	    if (registrationName === ON_CLICK_KEY) {
	      onClickListeners[id].remove();
	      delete onClickListeners[id];
	    }
	  }
	
	};
	
	module.exports = SimpleEventPlugin;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticClipboardEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(84);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/clipboard-apis/
	 */
	var ClipboardEventInterface = {
	  clipboardData: function clipboardData(event) {
	    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
	
	module.exports = SyntheticClipboardEvent;

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticFocusEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(94);
	
	/**
	 * @interface FocusEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var FocusEventInterface = {
	  relatedTarget: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
	
	module.exports = SyntheticFocusEvent;

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticKeyboardEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(94);
	
	var getEventCharCode = __webpack_require__(143);
	var getEventKey = __webpack_require__(144);
	var getEventModifierState = __webpack_require__(95);
	
	/**
	 * @interface KeyboardEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var KeyboardEventInterface = {
	  key: getEventKey,
	  location: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  repeat: null,
	  locale: null,
	  getModifierState: getEventModifierState,
	  // Legacy Interface
	  charCode: function charCode(event) {
	    // `charCode` is the result of a KeyPress event and represents the value of
	    // the actual printable character.
	
	    // KeyPress is deprecated, but its replacement is not yet final and not
	    // implemented in any major browser. Only KeyPress has charCode.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    return 0;
	  },
	  keyCode: function keyCode(event) {
	    // `keyCode` is the result of a KeyDown/Up event and represents the value of
	    // physical keyboard key.
	
	    // The actual meaning of the value depends on the users' keyboard layout
	    // which cannot be detected. Assuming that it is a US keyboard layout
	    // provides a surprisingly accurate mapping for US and European users.
	    // Due to this, it is left to the user to implement at this time.
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  },
	  which: function which(event) {
	    // `which` is an alias for either `keyCode` or `charCode` depending on the
	    // type of the event.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
	
	module.exports = SyntheticKeyboardEvent;

/***/ },
/* 143 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventCharCode
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * `charCode` represents the actual "character code" and is safe to use with
	 * `String.fromCharCode`. As such, only keys that correspond to printable
	 * characters produce a valid `charCode`, the only exception to this is Enter.
	 * The Tab-key is considered non-printable and does not have a `charCode`,
	 * presumably because it does not produce a tab-character in browsers.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {number} Normalized `charCode` property.
	 */
	
	function getEventCharCode(nativeEvent) {
	  var charCode;
	  var keyCode = nativeEvent.keyCode;
	
	  if ('charCode' in nativeEvent) {
	    charCode = nativeEvent.charCode;
	
	    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
	    if (charCode === 0 && keyCode === 13) {
	      charCode = 13;
	    }
	  } else {
	    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
	    charCode = keyCode;
	  }
	
	  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
	  // Must not discard the (non-)printable Enter-key.
	  if (charCode >= 32 || charCode === 13) {
	    return charCode;
	  }
	
	  return 0;
	}
	
	module.exports = getEventCharCode;

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventKey
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var getEventCharCode = __webpack_require__(143);
	
	/**
	 * Normalization of deprecated HTML5 `key` values
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var normalizeKey = {
	  'Esc': 'Escape',
	  'Spacebar': ' ',
	  'Left': 'ArrowLeft',
	  'Up': 'ArrowUp',
	  'Right': 'ArrowRight',
	  'Down': 'ArrowDown',
	  'Del': 'Delete',
	  'Win': 'OS',
	  'Menu': 'ContextMenu',
	  'Apps': 'ContextMenu',
	  'Scroll': 'ScrollLock',
	  'MozPrintableKey': 'Unidentified'
	};
	
	/**
	 * Translation from legacy `keyCode` to HTML5 `key`
	 * Only special keys supported, all others depend on keyboard layout or browser
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var translateToKey = {
	  8: 'Backspace',
	  9: 'Tab',
	  12: 'Clear',
	  13: 'Enter',
	  16: 'Shift',
	  17: 'Control',
	  18: 'Alt',
	  19: 'Pause',
	  20: 'CapsLock',
	  27: 'Escape',
	  32: ' ',
	  33: 'PageUp',
	  34: 'PageDown',
	  35: 'End',
	  36: 'Home',
	  37: 'ArrowLeft',
	  38: 'ArrowUp',
	  39: 'ArrowRight',
	  40: 'ArrowDown',
	  45: 'Insert',
	  46: 'Delete',
	  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
	  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
	  144: 'NumLock',
	  145: 'ScrollLock',
	  224: 'Meta'
	};
	
	/**
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `key` property.
	 */
	function getEventKey(nativeEvent) {
	  if (nativeEvent.key) {
	    // Normalize inconsistent values reported by browsers due to
	    // implementations of a working draft specification.
	
	    // FireFox implements `key` but returns `MozPrintableKey` for all
	    // printable characters (normalized to `Unidentified`), ignore it.
	    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	    if (key !== 'Unidentified') {
	      return key;
	    }
	  }
	
	  // Browser does not implement `key`, polyfill as much of it as we can.
	  if (nativeEvent.type === 'keypress') {
	    var charCode = getEventCharCode(nativeEvent);
	
	    // The enter-key is technically both printable and non-printable and can
	    // thus be captured by `keypress`, no other non-printable key should.
	    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
	  }
	  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
	    // While user keyboard layout determines the actual meaning of each
	    // `keyCode` value, almost all function keys have a universal value.
	    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
	  }
	  return '';
	}
	
	module.exports = getEventKey;

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticDragEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(93);
	
	/**
	 * @interface DragEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var DragEventInterface = {
	  dataTransfer: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
	
	module.exports = SyntheticDragEvent;

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticTouchEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(94);
	
	var getEventModifierState = __webpack_require__(95);
	
	/**
	 * @interface TouchEvent
	 * @see http://www.w3.org/TR/touch-events/
	 */
	var TouchEventInterface = {
	  touches: null,
	  targetTouches: null,
	  changedTouches: null,
	  altKey: null,
	  metaKey: null,
	  ctrlKey: null,
	  shiftKey: null,
	  getModifierState: getEventModifierState
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
	
	module.exports = SyntheticTouchEvent;

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticWheelEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(93);
	
	/**
	 * @interface WheelEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var WheelEventInterface = {
	  deltaX: function deltaX(event) {
	    return 'deltaX' in event ? event.deltaX :
	    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
	    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
	  },
	  deltaY: function deltaY(event) {
	    return 'deltaY' in event ? event.deltaY :
	    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
	    'wheelDeltaY' in event ? -event.wheelDeltaY :
	    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
	    'wheelDelta' in event ? -event.wheelDelta : 0;
	  },
	  deltaZ: null,
	
	  // Browsers without "deltaMode" is reporting in raw wheel delta where one
	  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
	  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
	  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
	  deltaMode: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticMouseEvent}
	 */
	function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
	
	module.exports = SyntheticWheelEvent;

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SVGDOMPropertyConfig
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(30);
	
	var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
	
	var NS = {
	  xlink: 'http://www.w3.org/1999/xlink',
	  xml: 'http://www.w3.org/XML/1998/namespace'
	};
	
	var SVGDOMPropertyConfig = {
	  Properties: {
	    clipPath: MUST_USE_ATTRIBUTE,
	    cx: MUST_USE_ATTRIBUTE,
	    cy: MUST_USE_ATTRIBUTE,
	    d: MUST_USE_ATTRIBUTE,
	    dx: MUST_USE_ATTRIBUTE,
	    dy: MUST_USE_ATTRIBUTE,
	    fill: MUST_USE_ATTRIBUTE,
	    fillOpacity: MUST_USE_ATTRIBUTE,
	    fontFamily: MUST_USE_ATTRIBUTE,
	    fontSize: MUST_USE_ATTRIBUTE,
	    fx: MUST_USE_ATTRIBUTE,
	    fy: MUST_USE_ATTRIBUTE,
	    gradientTransform: MUST_USE_ATTRIBUTE,
	    gradientUnits: MUST_USE_ATTRIBUTE,
	    markerEnd: MUST_USE_ATTRIBUTE,
	    markerMid: MUST_USE_ATTRIBUTE,
	    markerStart: MUST_USE_ATTRIBUTE,
	    offset: MUST_USE_ATTRIBUTE,
	    opacity: MUST_USE_ATTRIBUTE,
	    patternContentUnits: MUST_USE_ATTRIBUTE,
	    patternUnits: MUST_USE_ATTRIBUTE,
	    points: MUST_USE_ATTRIBUTE,
	    preserveAspectRatio: MUST_USE_ATTRIBUTE,
	    r: MUST_USE_ATTRIBUTE,
	    rx: MUST_USE_ATTRIBUTE,
	    ry: MUST_USE_ATTRIBUTE,
	    spreadMethod: MUST_USE_ATTRIBUTE,
	    stopColor: MUST_USE_ATTRIBUTE,
	    stopOpacity: MUST_USE_ATTRIBUTE,
	    stroke: MUST_USE_ATTRIBUTE,
	    strokeDasharray: MUST_USE_ATTRIBUTE,
	    strokeLinecap: MUST_USE_ATTRIBUTE,
	    strokeOpacity: MUST_USE_ATTRIBUTE,
	    strokeWidth: MUST_USE_ATTRIBUTE,
	    textAnchor: MUST_USE_ATTRIBUTE,
	    transform: MUST_USE_ATTRIBUTE,
	    version: MUST_USE_ATTRIBUTE,
	    viewBox: MUST_USE_ATTRIBUTE,
	    x1: MUST_USE_ATTRIBUTE,
	    x2: MUST_USE_ATTRIBUTE,
	    x: MUST_USE_ATTRIBUTE,
	    xlinkActuate: MUST_USE_ATTRIBUTE,
	    xlinkArcrole: MUST_USE_ATTRIBUTE,
	    xlinkHref: MUST_USE_ATTRIBUTE,
	    xlinkRole: MUST_USE_ATTRIBUTE,
	    xlinkShow: MUST_USE_ATTRIBUTE,
	    xlinkTitle: MUST_USE_ATTRIBUTE,
	    xlinkType: MUST_USE_ATTRIBUTE,
	    xmlBase: MUST_USE_ATTRIBUTE,
	    xmlLang: MUST_USE_ATTRIBUTE,
	    xmlSpace: MUST_USE_ATTRIBUTE,
	    y1: MUST_USE_ATTRIBUTE,
	    y2: MUST_USE_ATTRIBUTE,
	    y: MUST_USE_ATTRIBUTE
	  },
	  DOMAttributeNamespaces: {
	    xlinkActuate: NS.xlink,
	    xlinkArcrole: NS.xlink,
	    xlinkHref: NS.xlink,
	    xlinkRole: NS.xlink,
	    xlinkShow: NS.xlink,
	    xlinkTitle: NS.xlink,
	    xlinkType: NS.xlink,
	    xmlBase: NS.xml,
	    xmlLang: NS.xml,
	    xmlSpace: NS.xml
	  },
	  DOMAttributeNames: {
	    clipPath: 'clip-path',
	    fillOpacity: 'fill-opacity',
	    fontFamily: 'font-family',
	    fontSize: 'font-size',
	    gradientTransform: 'gradientTransform',
	    gradientUnits: 'gradientUnits',
	    markerEnd: 'marker-end',
	    markerMid: 'marker-mid',
	    markerStart: 'marker-start',
	    patternContentUnits: 'patternContentUnits',
	    patternUnits: 'patternUnits',
	    preserveAspectRatio: 'preserveAspectRatio',
	    spreadMethod: 'spreadMethod',
	    stopColor: 'stop-color',
	    stopOpacity: 'stop-opacity',
	    strokeDasharray: 'stroke-dasharray',
	    strokeLinecap: 'stroke-linecap',
	    strokeOpacity: 'stroke-opacity',
	    strokeWidth: 'stroke-width',
	    textAnchor: 'text-anchor',
	    viewBox: 'viewBox',
	    xlinkActuate: 'xlink:actuate',
	    xlinkArcrole: 'xlink:arcrole',
	    xlinkHref: 'xlink:href',
	    xlinkRole: 'xlink:role',
	    xlinkShow: 'xlink:show',
	    xlinkTitle: 'xlink:title',
	    xlinkType: 'xlink:type',
	    xmlBase: 'xml:base',
	    xmlLang: 'xml:lang',
	    xmlSpace: 'xml:space'
	  }
	};
	
	module.exports = SVGDOMPropertyConfig;

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultPerf
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var DOMProperty = __webpack_require__(30);
	var ReactDefaultPerfAnalysis = __webpack_require__(150);
	var ReactMount = __webpack_require__(35);
	var ReactPerf = __webpack_require__(25);
	
	var performanceNow = __webpack_require__(151);
	
	function roundFloat(val) {
	  return Math.floor(val * 100) / 100;
	}
	
	function addValue(obj, key, val) {
	  obj[key] = (obj[key] || 0) + val;
	}
	
	var ReactDefaultPerf = {
	  _allMeasurements: [], // last item in the list is the current one
	  _mountStack: [0],
	  _injected: false,
	
	  start: function start() {
	    if (!ReactDefaultPerf._injected) {
	      ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
	    }
	
	    ReactDefaultPerf._allMeasurements.length = 0;
	    ReactPerf.enableMeasure = true;
	  },
	
	  stop: function stop() {
	    ReactPerf.enableMeasure = false;
	  },
	
	  getLastMeasurements: function getLastMeasurements() {
	    return ReactDefaultPerf._allMeasurements;
	  },
	
	  printExclusive: function printExclusive(measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
	    console.table(summary.map(function (item) {
	      return {
	        'Component class name': item.componentName,
	        'Total inclusive time (ms)': roundFloat(item.inclusive),
	        'Exclusive mount time (ms)': roundFloat(item.exclusive),
	        'Exclusive render time (ms)': roundFloat(item.render),
	        'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),
	        'Render time per instance (ms)': roundFloat(item.render / item.count),
	        'Instances': item.count
	      };
	    }));
	    // TODO: ReactDefaultPerfAnalysis.getTotalTime() does not return the correct
	    // number.
	  },
	
	  printInclusive: function printInclusive(measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
	    console.table(summary.map(function (item) {
	      return {
	        'Owner > component': item.componentName,
	        'Inclusive time (ms)': roundFloat(item.time),
	        'Instances': item.count
	      };
	    }));
	    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
	  },
	
	  getMeasurementsSummaryMap: function getMeasurementsSummaryMap(measurements) {
	    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements, true);
	    return summary.map(function (item) {
	      return {
	        'Owner > component': item.componentName,
	        'Wasted time (ms)': item.time,
	        'Instances': item.count
	      };
	    });
	  },
	
	  printWasted: function printWasted(measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));
	    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
	  },
	
	  printDOM: function printDOM(measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
	    console.table(summary.map(function (item) {
	      var result = {};
	      result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
	      result.type = item.type;
	      result.args = JSON.stringify(item.args);
	      return result;
	    }));
	    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
	  },
	
	  _recordWrite: function _recordWrite(id, fnName, totalTime, args) {
	    // TODO: totalTime isn't that useful since it doesn't count paints/reflows
	    var writes = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].writes;
	    writes[id] = writes[id] || [];
	    writes[id].push({
	      type: fnName,
	      time: totalTime,
	      args: args
	    });
	  },
	
	  measure: function measure(moduleName, fnName, func) {
	    return function () {
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	
	      var totalTime;
	      var rv;
	      var start;
	
	      if (fnName === '_renderNewRootComponent' || fnName === 'flushBatchedUpdates') {
	        // A "measurement" is a set of metrics recorded for each flush. We want
	        // to group the metrics for a given flush together so we can look at the
	        // components that rendered and the DOM operations that actually
	        // happened to determine the amount of "wasted work" performed.
	        ReactDefaultPerf._allMeasurements.push({
	          exclusive: {},
	          inclusive: {},
	          render: {},
	          counts: {},
	          writes: {},
	          displayNames: {},
	          totalTime: 0,
	          created: {}
	        });
	        start = performanceNow();
	        rv = func.apply(this, args);
	        ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].totalTime = performanceNow() - start;
	        return rv;
	      } else if (fnName === '_mountImageIntoNode' || moduleName === 'ReactBrowserEventEmitter' || moduleName === 'ReactDOMIDOperations' || moduleName === 'CSSPropertyOperations' || moduleName === 'DOMChildrenOperations' || moduleName === 'DOMPropertyOperations') {
	        start = performanceNow();
	        rv = func.apply(this, args);
	        totalTime = performanceNow() - start;
	
	        if (fnName === '_mountImageIntoNode') {
	          var mountID = ReactMount.getID(args[1]);
	          ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
	        } else if (fnName === 'dangerouslyProcessChildrenUpdates') {
	          // special format
	          args[0].forEach(function (update) {
	            var writeArgs = {};
	            if (update.fromIndex !== null) {
	              writeArgs.fromIndex = update.fromIndex;
	            }
	            if (update.toIndex !== null) {
	              writeArgs.toIndex = update.toIndex;
	            }
	            if (update.textContent !== null) {
	              writeArgs.textContent = update.textContent;
	            }
	            if (update.markupIndex !== null) {
	              writeArgs.markup = args[1][update.markupIndex];
	            }
	            ReactDefaultPerf._recordWrite(update.parentID, update.type, totalTime, writeArgs);
	          });
	        } else {
	          // basic format
	          var id = args[0];
	          if ((typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object') {
	            id = ReactMount.getID(args[0]);
	          }
	          ReactDefaultPerf._recordWrite(id, fnName, totalTime, Array.prototype.slice.call(args, 1));
	        }
	        return rv;
	      } else if (moduleName === 'ReactCompositeComponent' && (fnName === 'mountComponent' || fnName === 'updateComponent' || // TODO: receiveComponent()?
	      fnName === '_renderValidatedComponent')) {
	
	        if (this._currentElement.type === ReactMount.TopLevelWrapper) {
	          return func.apply(this, args);
	        }
	
	        var rootNodeID = fnName === 'mountComponent' ? args[0] : this._rootNodeID;
	        var isRender = fnName === '_renderValidatedComponent';
	        var isMount = fnName === 'mountComponent';
	
	        var mountStack = ReactDefaultPerf._mountStack;
	        var entry = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1];
	
	        if (isRender) {
	          addValue(entry.counts, rootNodeID, 1);
	        } else if (isMount) {
	          entry.created[rootNodeID] = true;
	          mountStack.push(0);
	        }
	
	        start = performanceNow();
	        rv = func.apply(this, args);
	        totalTime = performanceNow() - start;
	
	        if (isRender) {
	          addValue(entry.render, rootNodeID, totalTime);
	        } else if (isMount) {
	          var subMountTime = mountStack.pop();
	          mountStack[mountStack.length - 1] += totalTime;
	          addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
	          addValue(entry.inclusive, rootNodeID, totalTime);
	        } else {
	          addValue(entry.inclusive, rootNodeID, totalTime);
	        }
	
	        entry.displayNames[rootNodeID] = {
	          current: this.getName(),
	          owner: this._currentElement._owner ? this._currentElement._owner.getName() : '<root>'
	        };
	
	        return rv;
	      } else {
	        return func.apply(this, args);
	      }
	    };
	  }
	};
	
	module.exports = ReactDefaultPerf;

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultPerfAnalysis
	 */
	
	'use strict';
	
	var assign = __webpack_require__(46);
	
	// Don't try to save users less than 1.2ms (a number I made up)
	var DONT_CARE_THRESHOLD = 1.2;
	var DOM_OPERATION_TYPES = {
	  '_mountImageIntoNode': 'set innerHTML',
	  INSERT_MARKUP: 'set innerHTML',
	  MOVE_EXISTING: 'move',
	  REMOVE_NODE: 'remove',
	  SET_MARKUP: 'set innerHTML',
	  TEXT_CONTENT: 'set textContent',
	  'setValueForProperty': 'update attribute',
	  'setValueForAttribute': 'update attribute',
	  'deleteValueForProperty': 'remove attribute',
	  'setValueForStyles': 'update styles',
	  'replaceNodeWithMarkup': 'replace',
	  'updateTextContent': 'set textContent'
	};
	
	function getTotalTime(measurements) {
	  // TODO: return number of DOM ops? could be misleading.
	  // TODO: measure dropped frames after reconcile?
	  // TODO: log total time of each reconcile and the top-level component
	  // class that triggered it.
	  var totalTime = 0;
	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    totalTime += measurement.totalTime;
	  }
	  return totalTime;
	}
	
	function getDOMSummary(measurements) {
	  var items = [];
	  measurements.forEach(function (measurement) {
	    Object.keys(measurement.writes).forEach(function (id) {
	      measurement.writes[id].forEach(function (write) {
	        items.push({
	          id: id,
	          type: DOM_OPERATION_TYPES[write.type] || write.type,
	          args: write.args
	        });
	      });
	    });
	  });
	  return items;
	}
	
	function getExclusiveSummary(measurements) {
	  var candidates = {};
	  var displayName;
	
	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
	
	    for (var id in allIDs) {
	      displayName = measurement.displayNames[id].current;
	
	      candidates[displayName] = candidates[displayName] || {
	        componentName: displayName,
	        inclusive: 0,
	        exclusive: 0,
	        render: 0,
	        count: 0
	      };
	      if (measurement.render[id]) {
	        candidates[displayName].render += measurement.render[id];
	      }
	      if (measurement.exclusive[id]) {
	        candidates[displayName].exclusive += measurement.exclusive[id];
	      }
	      if (measurement.inclusive[id]) {
	        candidates[displayName].inclusive += measurement.inclusive[id];
	      }
	      if (measurement.counts[id]) {
	        candidates[displayName].count += measurement.counts[id];
	      }
	    }
	  }
	
	  // Now make a sorted array with the results.
	  var arr = [];
	  for (displayName in candidates) {
	    if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
	      arr.push(candidates[displayName]);
	    }
	  }
	
	  arr.sort(function (a, b) {
	    return b.exclusive - a.exclusive;
	  });
	
	  return arr;
	}
	
	function getInclusiveSummary(measurements, onlyClean) {
	  var candidates = {};
	  var inclusiveKey;
	
	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
	    var cleanComponents;
	
	    if (onlyClean) {
	      cleanComponents = getUnchangedComponents(measurement);
	    }
	
	    for (var id in allIDs) {
	      if (onlyClean && !cleanComponents[id]) {
	        continue;
	      }
	
	      var displayName = measurement.displayNames[id];
	
	      // Inclusive time is not useful for many components without knowing where
	      // they are instantiated. So we aggregate inclusive time with both the
	      // owner and current displayName as the key.
	      inclusiveKey = displayName.owner + ' > ' + displayName.current;
	
	      candidates[inclusiveKey] = candidates[inclusiveKey] || {
	        componentName: inclusiveKey,
	        time: 0,
	        count: 0
	      };
	
	      if (measurement.inclusive[id]) {
	        candidates[inclusiveKey].time += measurement.inclusive[id];
	      }
	      if (measurement.counts[id]) {
	        candidates[inclusiveKey].count += measurement.counts[id];
	      }
	    }
	  }
	
	  // Now make a sorted array with the results.
	  var arr = [];
	  for (inclusiveKey in candidates) {
	    if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
	      arr.push(candidates[inclusiveKey]);
	    }
	  }
	
	  arr.sort(function (a, b) {
	    return b.time - a.time;
	  });
	
	  return arr;
	}
	
	function getUnchangedComponents(measurement) {
	  // For a given reconcile, look at which components did not actually
	  // render anything to the DOM and return a mapping of their ID to
	  // the amount of time it took to render the entire subtree.
	  var cleanComponents = {};
	  var dirtyLeafIDs = Object.keys(measurement.writes);
	  var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
	
	  for (var id in allIDs) {
	    var isDirty = false;
	    // For each component that rendered, see if a component that triggered
	    // a DOM op is in its subtree.
	    for (var i = 0; i < dirtyLeafIDs.length; i++) {
	      if (dirtyLeafIDs[i].indexOf(id) === 0) {
	        isDirty = true;
	        break;
	      }
	    }
	    // check if component newly created
	    if (measurement.created[id]) {
	      isDirty = true;
	    }
	    if (!isDirty && measurement.counts[id] > 0) {
	      cleanComponents[id] = true;
	    }
	  }
	  return cleanComponents;
	}
	
	var ReactDefaultPerfAnalysis = {
	  getExclusiveSummary: getExclusiveSummary,
	  getInclusiveSummary: getInclusiveSummary,
	  getDOMSummary: getDOMSummary,
	  getTotalTime: getTotalTime
	};
	
	module.exports = ReactDefaultPerfAnalysis;

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule performanceNow
	 * @typechecks
	 */
	
	'use strict';
	
	var performance = __webpack_require__(152);
	
	var performanceNow;
	
	/**
	 * Detect if we can use `window.performance.now()` and gracefully fallback to
	 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
	 * because of Facebook's testing infrastructure.
	 */
	if (performance.now) {
	  performanceNow = function performanceNow() {
	    return performance.now();
	  };
	} else {
	  performanceNow = function performanceNow() {
	    return Date.now();
	  };
	}
	
	module.exports = performanceNow;

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule performance
	 * @typechecks
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var performance;
	
	if (ExecutionEnvironment.canUseDOM) {
	  performance = window.performance || window.msPerformance || window.webkitPerformance;
	}
	
	module.exports = performance || {};

/***/ },
/* 153 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactVersion
	 */
	
	'use strict';
	
	module.exports = '0.14.8';

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	* @providesModule renderSubtreeIntoContainer
	*/
	
	'use strict';
	
	var ReactMount = __webpack_require__(35);
	
	module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMServer
	 */
	
	'use strict';
	
	var ReactDefaultInjection = __webpack_require__(78);
	var ReactServerRendering = __webpack_require__(156);
	var ReactVersion = __webpack_require__(153);
	
	ReactDefaultInjection.inject();
	
	var ReactDOMServer = {
	  renderToString: ReactServerRendering.renderToString,
	  renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,
	  version: ReactVersion
	};
	
	module.exports = ReactDOMServer;

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks static-only
	 * @providesModule ReactServerRendering
	 */
	'use strict';
	
	var ReactDefaultBatchingStrategy = __webpack_require__(99);
	var ReactElement = __webpack_require__(49);
	var ReactInstanceHandles = __webpack_require__(52);
	var ReactMarkupChecksum = __webpack_require__(55);
	var ReactServerBatchingStrategy = __webpack_require__(157);
	var ReactServerRenderingTransaction = __webpack_require__(158);
	var ReactUpdates = __webpack_require__(61);
	
	var emptyObject = __webpack_require__(65);
	var instantiateReactComponent = __webpack_require__(69);
	var invariant = __webpack_require__(20);
	
	/**
	 * @param {ReactElement} element
	 * @return {string} the HTML markup
	 */
	function renderToString(element) {
	  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToString(): You must pass a valid ReactElement.') : invariant(false) : undefined;
	
	  var transaction;
	  try {
	    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);
	
	    var id = ReactInstanceHandles.createReactRootID();
	    transaction = ReactServerRenderingTransaction.getPooled(false);
	
	    return transaction.perform(function () {
	      var componentInstance = instantiateReactComponent(element, null);
	      var markup = componentInstance.mountComponent(id, transaction, emptyObject);
	      return ReactMarkupChecksum.addChecksumToMarkup(markup);
	    }, null);
	  } finally {
	    ReactServerRenderingTransaction.release(transaction);
	    // Revert to the DOM batching strategy since these two renderers
	    // currently share these stateful modules.
	    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	  }
	}
	
	/**
	 * @param {ReactElement} element
	 * @return {string} the HTML markup, without the extra React ID and checksum
	 * (for generating static pages)
	 */
	function renderToStaticMarkup(element) {
	  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToStaticMarkup(): You must pass a valid ReactElement.') : invariant(false) : undefined;
	
	  var transaction;
	  try {
	    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);
	
	    var id = ReactInstanceHandles.createReactRootID();
	    transaction = ReactServerRenderingTransaction.getPooled(true);
	
	    return transaction.perform(function () {
	      var componentInstance = instantiateReactComponent(element, null);
	      return componentInstance.mountComponent(id, transaction, emptyObject);
	    }, null);
	  } finally {
	    ReactServerRenderingTransaction.release(transaction);
	    // Revert to the DOM batching strategy since these two renderers
	    // currently share these stateful modules.
	    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	  }
	}
	
	module.exports = {
	  renderToString: renderToString,
	  renderToStaticMarkup: renderToStaticMarkup
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 157 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerBatchingStrategy
	 * @typechecks
	 */
	
	'use strict';
	
	var ReactServerBatchingStrategy = {
	  isBatchingUpdates: false,
	  batchedUpdates: function batchedUpdates(callback) {
	    // Don't do anything here. During the server rendering we don't want to
	    // schedule any updates. We will simply ignore them.
	  }
	};
	
	module.exports = ReactServerBatchingStrategy;

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerRenderingTransaction
	 * @typechecks
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(63);
	var CallbackQueue = __webpack_require__(62);
	var Transaction = __webpack_require__(64);
	
	var assign = __webpack_require__(46);
	var emptyFunction = __webpack_require__(22);
	
	/**
	 * Provides a `CallbackQueue` queue for collecting `onDOMReady` callbacks
	 * during the performing of the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function initialize() {
	    this.reactMountReady.reset();
	  },
	
	  close: emptyFunction
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [ON_DOM_READY_QUEUEING];
	
	/**
	 * @class ReactServerRenderingTransaction
	 * @param {boolean} renderToStaticMarkup
	 */
	function ReactServerRenderingTransaction(renderToStaticMarkup) {
	  this.reinitializeTransaction();
	  this.renderToStaticMarkup = renderToStaticMarkup;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = false;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array} Empty list of operation wrap procedures.
	   */
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function getReactMountReady() {
	    return this.reactMountReady;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function destructor() {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactServerRenderingTransaction);
	
	module.exports = ReactServerRenderingTransaction;

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactIsomorphic
	 */
	
	'use strict';
	
	var ReactChildren = __webpack_require__(117);
	var ReactComponent = __webpack_require__(130);
	var ReactClass = __webpack_require__(129);
	var ReactDOMFactories = __webpack_require__(160);
	var ReactElement = __webpack_require__(49);
	var ReactElementValidator = __webpack_require__(161);
	var ReactPropTypes = __webpack_require__(114);
	var ReactVersion = __webpack_require__(153);
	
	var assign = __webpack_require__(46);
	var onlyChild = __webpack_require__(163);
	
	var createElement = ReactElement.createElement;
	var createFactory = ReactElement.createFactory;
	var cloneElement = ReactElement.cloneElement;
	
	if (process.env.NODE_ENV !== 'production') {
	  createElement = ReactElementValidator.createElement;
	  createFactory = ReactElementValidator.createFactory;
	  cloneElement = ReactElementValidator.cloneElement;
	}
	
	var React = {
	
	  // Modern
	
	  Children: {
	    map: ReactChildren.map,
	    forEach: ReactChildren.forEach,
	    count: ReactChildren.count,
	    toArray: ReactChildren.toArray,
	    only: onlyChild
	  },
	
	  Component: ReactComponent,
	
	  createElement: createElement,
	  cloneElement: cloneElement,
	  isValidElement: ReactElement.isValidElement,
	
	  // Classic
	
	  PropTypes: ReactPropTypes,
	  createClass: ReactClass.createClass,
	  createFactory: createFactory,
	  createMixin: function createMixin(mixin) {
	    // Currently a noop. Will be used to validate and trace mixins.
	    return mixin;
	  },
	
	  // This looks DOM specific but these are actually isomorphic helpers
	  // since they are just generating DOM strings.
	  DOM: ReactDOMFactories,
	
	  version: ReactVersion,
	
	  // Hook for JSX spread, don't use this for anything else.
	  __spread: assign
	};
	
	module.exports = React;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFactories
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(49);
	var ReactElementValidator = __webpack_require__(161);
	
	var mapObject = __webpack_require__(162);
	
	/**
	 * Create a factory that creates HTML tag elements.
	 *
	 * @param {string} tag Tag name (e.g. `div`).
	 * @private
	 */
	function createDOMFactory(tag) {
	  if (process.env.NODE_ENV !== 'production') {
	    return ReactElementValidator.createFactory(tag);
	  }
	  return ReactElement.createFactory(tag);
	}
	
	/**
	 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
	 * This is also accessible via `React.DOM`.
	 *
	 * @public
	 */
	var ReactDOMFactories = mapObject({
	  a: 'a',
	  abbr: 'abbr',
	  address: 'address',
	  area: 'area',
	  article: 'article',
	  aside: 'aside',
	  audio: 'audio',
	  b: 'b',
	  base: 'base',
	  bdi: 'bdi',
	  bdo: 'bdo',
	  big: 'big',
	  blockquote: 'blockquote',
	  body: 'body',
	  br: 'br',
	  button: 'button',
	  canvas: 'canvas',
	  caption: 'caption',
	  cite: 'cite',
	  code: 'code',
	  col: 'col',
	  colgroup: 'colgroup',
	  data: 'data',
	  datalist: 'datalist',
	  dd: 'dd',
	  del: 'del',
	  details: 'details',
	  dfn: 'dfn',
	  dialog: 'dialog',
	  div: 'div',
	  dl: 'dl',
	  dt: 'dt',
	  em: 'em',
	  embed: 'embed',
	  fieldset: 'fieldset',
	  figcaption: 'figcaption',
	  figure: 'figure',
	  footer: 'footer',
	  form: 'form',
	  h1: 'h1',
	  h2: 'h2',
	  h3: 'h3',
	  h4: 'h4',
	  h5: 'h5',
	  h6: 'h6',
	  head: 'head',
	  header: 'header',
	  hgroup: 'hgroup',
	  hr: 'hr',
	  html: 'html',
	  i: 'i',
	  iframe: 'iframe',
	  img: 'img',
	  input: 'input',
	  ins: 'ins',
	  kbd: 'kbd',
	  keygen: 'keygen',
	  label: 'label',
	  legend: 'legend',
	  li: 'li',
	  link: 'link',
	  main: 'main',
	  map: 'map',
	  mark: 'mark',
	  menu: 'menu',
	  menuitem: 'menuitem',
	  meta: 'meta',
	  meter: 'meter',
	  nav: 'nav',
	  noscript: 'noscript',
	  object: 'object',
	  ol: 'ol',
	  optgroup: 'optgroup',
	  option: 'option',
	  output: 'output',
	  p: 'p',
	  param: 'param',
	  picture: 'picture',
	  pre: 'pre',
	  progress: 'progress',
	  q: 'q',
	  rp: 'rp',
	  rt: 'rt',
	  ruby: 'ruby',
	  s: 's',
	  samp: 'samp',
	  script: 'script',
	  section: 'section',
	  select: 'select',
	  small: 'small',
	  source: 'source',
	  span: 'span',
	  strong: 'strong',
	  style: 'style',
	  sub: 'sub',
	  summary: 'summary',
	  sup: 'sup',
	  table: 'table',
	  tbody: 'tbody',
	  td: 'td',
	  textarea: 'textarea',
	  tfoot: 'tfoot',
	  th: 'th',
	  thead: 'thead',
	  time: 'time',
	  title: 'title',
	  tr: 'tr',
	  track: 'track',
	  u: 'u',
	  ul: 'ul',
	  'var': 'var',
	  video: 'video',
	  wbr: 'wbr',
	
	  // SVG
	  circle: 'circle',
	  clipPath: 'clipPath',
	  defs: 'defs',
	  ellipse: 'ellipse',
	  g: 'g',
	  image: 'image',
	  line: 'line',
	  linearGradient: 'linearGradient',
	  mask: 'mask',
	  path: 'path',
	  pattern: 'pattern',
	  polygon: 'polygon',
	  polyline: 'polyline',
	  radialGradient: 'radialGradient',
	  rect: 'rect',
	  stop: 'stop',
	  svg: 'svg',
	  text: 'text',
	  tspan: 'tspan'
	
	}, createDOMFactory);
	
	module.exports = ReactDOMFactories;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElementValidator
	 */
	
	/**
	 * ReactElementValidator provides a wrapper around a element factory
	 * which validates the props passed to the element. This is intended to be
	 * used only in DEV and could be replaced by a static type checker for languages
	 * that support it.
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactElement = __webpack_require__(49);
	var ReactPropTypeLocations = __webpack_require__(72);
	var ReactPropTypeLocationNames = __webpack_require__(73);
	var ReactCurrentOwner = __webpack_require__(12);
	
	var canDefineProperty = __webpack_require__(50);
	var getIteratorFn = __webpack_require__(115);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	function getDeclarationErrorAddendum() {
	  if (ReactCurrentOwner.current) {
	    var name = ReactCurrentOwner.current.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */
	var ownerHasKeyUseWarning = {};
	
	var loggedTypeFailures = {};
	
	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function validateExplicitKey(element, parentType) {
	  if (!element._store || element._store.validated || element.key != null) {
	    return;
	  }
	  element._store.validated = true;
	
	  var addenda = getAddendaForKeyUse('uniqueKey', element, parentType);
	  if (addenda === null) {
	    // we already showed the warning
	    return;
	  }
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s%s', addenda.parentOrOwner || '', addenda.childOwner || '', addenda.url || '') : undefined;
	}
	
	/**
	 * Shared warning and monitoring code for the key warnings.
	 *
	 * @internal
	 * @param {string} messageType A key used for de-duping warnings.
	 * @param {ReactElement} element Component that requires a key.
	 * @param {*} parentType element's parent's type.
	 * @returns {?object} A set of addenda to use in the warning message, or null
	 * if the warning has already been shown before (and shouldn't be shown again).
	 */
	function getAddendaForKeyUse(messageType, element, parentType) {
	  var addendum = getDeclarationErrorAddendum();
	  if (!addendum) {
	    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
	    if (parentName) {
	      addendum = ' Check the top-level render call using <' + parentName + '>.';
	    }
	  }
	
	  var memoizer = ownerHasKeyUseWarning[messageType] || (ownerHasKeyUseWarning[messageType] = {});
	  if (memoizer[addendum]) {
	    return null;
	  }
	  memoizer[addendum] = true;
	
	  var addenda = {
	    parentOrOwner: addendum,
	    url: ' See https://fb.me/react-warning-keys for more information.',
	    childOwner: null
	  };
	
	  // Usually the current owner is the offender, but if it accepts children as a
	  // property, it may be the creator of the child that's responsible for
	  // assigning it a key.
	  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
	    // Give the component that originally created this child.
	    addenda.childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
	  }
	
	  return addenda;
	}
	
	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */
	function validateChildKeys(node, parentType) {
	  if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') {
	    return;
	  }
	  if (Array.isArray(node)) {
	    for (var i = 0; i < node.length; i++) {
	      var child = node[i];
	      if (ReactElement.isValidElement(child)) {
	        validateExplicitKey(child, parentType);
	      }
	    }
	  } else if (ReactElement.isValidElement(node)) {
	    // This element was passed in a valid location.
	    if (node._store) {
	      node._store.validated = true;
	    }
	  } else if (node) {
	    var iteratorFn = getIteratorFn(node);
	    // Entry iterators provide implicit keys.
	    if (iteratorFn) {
	      if (iteratorFn !== node.entries) {
	        var iterator = iteratorFn.call(node);
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (ReactElement.isValidElement(step.value)) {
	            validateExplicitKey(step.value, parentType);
	          }
	        }
	      }
	    }
	  }
	}
	
	/**
	 * Assert that the props are valid
	 *
	 * @param {string} componentName Name of the component for error messages.
	 * @param {object} propTypes Map of prop name to a ReactPropType
	 * @param {object} props
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @private
	 */
	function checkPropTypes(componentName, propTypes, props, location) {
	  for (var propName in propTypes) {
	    if (propTypes.hasOwnProperty(propName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
	        error = propTypes[propName](props, propName, componentName, location);
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], propName, typeof error === 'undefined' ? 'undefined' : _typeof(error)) : undefined;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum();
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed propType: %s%s', error.message, addendum) : undefined;
	      }
	    }
	  }
	}
	
	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */
	function validatePropTypes(element) {
	  var componentClass = element.type;
	  if (typeof componentClass !== 'function') {
	    return;
	  }
	  var name = componentClass.displayName || componentClass.name;
	  if (componentClass.propTypes) {
	    checkPropTypes(name, componentClass.propTypes, element.props, ReactPropTypeLocations.prop);
	  }
	  if (typeof componentClass.getDefaultProps === 'function') {
	    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : undefined;
	  }
	}
	
	var ReactElementValidator = {
	
	  createElement: function createElement(type, props, children) {
	    var validType = typeof type === 'string' || typeof type === 'function';
	    // We warn in this case but don't throw. We expect the element creation to
	    // succeed and there will likely be errors in render.
	    process.env.NODE_ENV !== 'production' ? warning(validType, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : undefined;
	
	    var element = ReactElement.createElement.apply(this, arguments);
	
	    // The result can be nullish if a mock or a custom function is used.
	    // TODO: Drop this when these are no longer allowed as the type argument.
	    if (element == null) {
	      return element;
	    }
	
	    // Skip key warning if the type isn't valid since our key validation logic
	    // doesn't expect a non-string/function type and can throw confusing errors.
	    // We don't want exception behavior to differ between dev and prod.
	    // (Rendering will throw with a helpful message and as soon as the type is
	    // fixed, the key warnings will appear.)
	    if (validType) {
	      for (var i = 2; i < arguments.length; i++) {
	        validateChildKeys(arguments[i], type);
	      }
	    }
	
	    validatePropTypes(element);
	
	    return element;
	  },
	
	  createFactory: function createFactory(type) {
	    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
	    // Legacy hook TODO: Warn if this is accessed
	    validatedFactory.type = type;
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (canDefineProperty) {
	        Object.defineProperty(validatedFactory, 'type', {
	          enumerable: false,
	          get: function get() {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : undefined;
	            Object.defineProperty(this, 'type', {
	              value: type
	            });
	            return type;
	          }
	        });
	      }
	    }
	
	    return validatedFactory;
	  },
	
	  cloneElement: function cloneElement(element, props, children) {
	    var newElement = ReactElement.cloneElement.apply(this, arguments);
	    for (var i = 2; i < arguments.length; i++) {
	      validateChildKeys(arguments[i], newElement.type);
	    }
	    validatePropTypes(newElement);
	    return newElement;
	  }
	
	};
	
	module.exports = ReactElementValidator;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 162 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule mapObject
	 */
	
	'use strict';
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * Executes the provided `callback` once for each enumerable own property in the
	 * object and constructs a new object from the results. The `callback` is
	 * invoked with three arguments:
	 *
	 *  - the property value
	 *  - the property name
	 *  - the object being traversed
	 *
	 * Properties that are added after the call to `mapObject` will not be visited
	 * by `callback`. If the values of existing properties are changed, the value
	 * passed to `callback` will be the value at the time `mapObject` visits them.
	 * Properties that are deleted before being visited are not visited.
	 *
	 * @grep function objectMap()
	 * @grep function objMap()
	 *
	 * @param {?object} object
	 * @param {function} callback
	 * @param {*} context
	 * @return {?object}
	 */
	function mapObject(object, callback, context) {
	  if (!object) {
	    return null;
	  }
	  var result = {};
	  for (var name in object) {
	    if (hasOwnProperty.call(object, name)) {
	      result[name] = callback.call(context, object[name], name, object);
	    }
	  }
	  return result;
	}
	
	module.exports = mapObject;

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule onlyChild
	 */
	'use strict';
	
	var ReactElement = __webpack_require__(49);
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Returns the first child in a collection of children and verifies that there
	 * is only one child in the collection. The current implementation of this
	 * function assumes that a single child gets passed without a wrapper, but the
	 * purpose of this helper function is to abstract away the particular structure
	 * of children.
	 *
	 * @param {?object} children Child collection structure.
	 * @return {ReactComponent} The first and only `ReactComponent` contained in the
	 * structure.
	 */
	function onlyChild(children) {
	  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'onlyChild must be passed a children with exactly one child.') : invariant(false) : undefined;
	  return children;
	}
	
	module.exports = onlyChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule deprecated
	 */
	
	'use strict';
	
	var assign = __webpack_require__(46);
	var warning = __webpack_require__(32);
	
	/**
	 * This will log a single deprecation notice per function and forward the call
	 * on to the new API.
	 *
	 * @param {string} fnName The name of the function
	 * @param {string} newModule The module that fn will exist in
	 * @param {string} newPackage The module that fn will exist in
	 * @param {*} ctx The context this forwarded call should run in
	 * @param {function} fn The function to forward on to
	 * @return {function} The function that will warn once and then call fn
	 */
	function deprecated(fnName, newModule, newPackage, ctx, fn) {
	  var warned = false;
	  if (process.env.NODE_ENV !== 'production') {
	    var newFn = function newFn() {
	      process.env.NODE_ENV !== 'production' ? warning(warned,
	      // Require examples in this string must be split to prevent React's
	      // build tools from mistaking them for real requires.
	      // Otherwise the build tools will attempt to build a '%s' module.
	      'React.%s is deprecated. Please use %s.%s from require' + '(\'%s\') ' + 'instead.', fnName, newModule, fnName, newPackage) : undefined;
	      warned = true;
	      return fn.apply(ctx, arguments);
	    };
	    // We need to make sure all properties of the original fn are copied over.
	    // In particular, this is needed to support PropTypes
	    return assign(newFn, fn);
	  }
	
	  return fn;
	}
	
	module.exports = deprecated;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(10);

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.createMemoryHistory = exports.hashHistory = exports.browserHistory = exports.applyRouterMiddleware = exports.formatPattern = exports.useRouterHistory = exports.match = exports.routerShape = exports.locationShape = exports.PropTypes = exports.RoutingContext = exports.RouterContext = exports.createRoutes = exports.useRoutes = exports.RouteContext = exports.Lifecycle = exports.History = exports.Route = exports.Redirect = exports.IndexRoute = exports.IndexRedirect = exports.withRouter = exports.IndexLink = exports.Link = exports.Router = undefined;
	
	var _RouteUtils = __webpack_require__(167);
	
	Object.defineProperty(exports, 'createRoutes', {
	  enumerable: true,
	  get: function get() {
	    return _RouteUtils.createRoutes;
	  }
	});
	
	var _PropTypes2 = __webpack_require__(168);
	
	Object.defineProperty(exports, 'locationShape', {
	  enumerable: true,
	  get: function get() {
	    return _PropTypes2.locationShape;
	  }
	});
	Object.defineProperty(exports, 'routerShape', {
	  enumerable: true,
	  get: function get() {
	    return _PropTypes2.routerShape;
	  }
	});
	
	var _PatternUtils = __webpack_require__(173);
	
	Object.defineProperty(exports, 'formatPattern', {
	  enumerable: true,
	  get: function get() {
	    return _PatternUtils.formatPattern;
	  }
	});
	
	var _Router2 = __webpack_require__(175);
	
	var _Router3 = _interopRequireDefault(_Router2);
	
	var _Link2 = __webpack_require__(206);
	
	var _Link3 = _interopRequireDefault(_Link2);
	
	var _IndexLink2 = __webpack_require__(207);
	
	var _IndexLink3 = _interopRequireDefault(_IndexLink2);
	
	var _withRouter2 = __webpack_require__(208);
	
	var _withRouter3 = _interopRequireDefault(_withRouter2);
	
	var _IndexRedirect2 = __webpack_require__(210);
	
	var _IndexRedirect3 = _interopRequireDefault(_IndexRedirect2);
	
	var _IndexRoute2 = __webpack_require__(212);
	
	var _IndexRoute3 = _interopRequireDefault(_IndexRoute2);
	
	var _Redirect2 = __webpack_require__(211);
	
	var _Redirect3 = _interopRequireDefault(_Redirect2);
	
	var _Route2 = __webpack_require__(213);
	
	var _Route3 = _interopRequireDefault(_Route2);
	
	var _History2 = __webpack_require__(214);
	
	var _History3 = _interopRequireDefault(_History2);
	
	var _Lifecycle2 = __webpack_require__(215);
	
	var _Lifecycle3 = _interopRequireDefault(_Lifecycle2);
	
	var _RouteContext2 = __webpack_require__(216);
	
	var _RouteContext3 = _interopRequireDefault(_RouteContext2);
	
	var _useRoutes2 = __webpack_require__(217);
	
	var _useRoutes3 = _interopRequireDefault(_useRoutes2);
	
	var _RouterContext2 = __webpack_require__(203);
	
	var _RouterContext3 = _interopRequireDefault(_RouterContext2);
	
	var _RoutingContext2 = __webpack_require__(218);
	
	var _RoutingContext3 = _interopRequireDefault(_RoutingContext2);
	
	var _PropTypes3 = _interopRequireDefault(_PropTypes2);
	
	var _match2 = __webpack_require__(219);
	
	var _match3 = _interopRequireDefault(_match2);
	
	var _useRouterHistory2 = __webpack_require__(223);
	
	var _useRouterHistory3 = _interopRequireDefault(_useRouterHistory2);
	
	var _applyRouterMiddleware2 = __webpack_require__(224);
	
	var _applyRouterMiddleware3 = _interopRequireDefault(_applyRouterMiddleware2);
	
	var _browserHistory2 = __webpack_require__(225);
	
	var _browserHistory3 = _interopRequireDefault(_browserHistory2);
	
	var _hashHistory2 = __webpack_require__(228);
	
	var _hashHistory3 = _interopRequireDefault(_hashHistory2);
	
	var _createMemoryHistory2 = __webpack_require__(220);
	
	var _createMemoryHistory3 = _interopRequireDefault(_createMemoryHistory2);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	exports.Router = _Router3.default; /* components */
	
	exports.Link = _Link3.default;
	exports.IndexLink = _IndexLink3.default;
	exports.withRouter = _withRouter3.default;
	
	/* components (configuration) */
	
	exports.IndexRedirect = _IndexRedirect3.default;
	exports.IndexRoute = _IndexRoute3.default;
	exports.Redirect = _Redirect3.default;
	exports.Route = _Route3.default;
	
	/* mixins */
	
	exports.History = _History3.default;
	exports.Lifecycle = _Lifecycle3.default;
	exports.RouteContext = _RouteContext3.default;
	
	/* utils */
	
	exports.useRoutes = _useRoutes3.default;
	exports.RouterContext = _RouterContext3.default;
	exports.RoutingContext = _RoutingContext3.default;
	exports.PropTypes = _PropTypes3.default;
	exports.match = _match3.default;
	exports.useRouterHistory = _useRouterHistory3.default;
	exports.applyRouterMiddleware = _applyRouterMiddleware3.default;
	
	/* histories */
	
	exports.browserHistory = _browserHistory3.default;
	exports.hashHistory = _hashHistory3.default;
	exports.createMemoryHistory = _createMemoryHistory3.default;

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports.isReactChildren = isReactChildren;
	exports.createRouteFromReactElement = createRouteFromReactElement;
	exports.createRoutesFromReactChildren = createRoutesFromReactChildren;
	exports.createRoutes = createRoutes;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function isValidChild(object) {
	  return object == null || _react2.default.isValidElement(object);
	}
	
	function isReactChildren(object) {
	  return isValidChild(object) || Array.isArray(object) && object.every(isValidChild);
	}
	
	function createRoute(defaultProps, props) {
	  return _extends({}, defaultProps, props);
	}
	
	function createRouteFromReactElement(element) {
	  var type = element.type;
	  var route = createRoute(type.defaultProps, element.props);
	
	  if (route.children) {
	    var childRoutes = createRoutesFromReactChildren(route.children, route);
	
	    if (childRoutes.length) route.childRoutes = childRoutes;
	
	    delete route.children;
	  }
	
	  return route;
	}
	
	/**
	 * Creates and returns a routes object from the given ReactChildren. JSX
	 * provides a convenient way to visualize how routes in the hierarchy are
	 * nested.
	 *
	 *   import { Route, createRoutesFromReactChildren } from 'react-router'
	 *
	 *   const routes = createRoutesFromReactChildren(
	 *     <Route component={App}>
	 *       <Route path="home" component={Dashboard}/>
	 *       <Route path="news" component={NewsFeed}/>
	 *     </Route>
	 *   )
	 *
	 * Note: This method is automatically used when you provide <Route> children
	 * to a <Router> component.
	 */
	function createRoutesFromReactChildren(children, parentRoute) {
	  var routes = [];
	
	  _react2.default.Children.forEach(children, function (element) {
	    if (_react2.default.isValidElement(element)) {
	      // Component classes may have a static create* method.
	      if (element.type.createRouteFromReactElement) {
	        var route = element.type.createRouteFromReactElement(element, parentRoute);
	
	        if (route) routes.push(route);
	      } else {
	        routes.push(createRouteFromReactElement(element));
	      }
	    }
	  });
	
	  return routes;
	}
	
	/**
	 * Creates and returns an array of routes from the given object which
	 * may be a JSX route, a plain object route, or an array of either.
	 */
	function createRoutes(routes) {
	  if (isReactChildren(routes)) {
	    routes = createRoutesFromReactChildren(routes);
	  } else if (routes && !Array.isArray(routes)) {
	    routes = [routes];
	  }
	
	  return routes;
	}

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.router = exports.routes = exports.route = exports.components = exports.component = exports.location = exports.history = exports.falsy = exports.locationShape = exports.routerShape = undefined;
	
	var _react = __webpack_require__(8);
	
	var _deprecateObjectProperties = __webpack_require__(169);
	
	var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);
	
	var _InternalPropTypes = __webpack_require__(172);
	
	var InternalPropTypes = _interopRequireWildcard(_InternalPropTypes);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireWildcard(obj) {
	  if (obj && obj.__esModule) {
	    return obj;
	  } else {
	    var newObj = {};if (obj != null) {
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	      }
	    }newObj.default = obj;return newObj;
	  }
	}
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var func = _react.PropTypes.func;
	var object = _react.PropTypes.object;
	var shape = _react.PropTypes.shape;
	var string = _react.PropTypes.string;
	var routerShape = exports.routerShape = shape({
	  push: func.isRequired,
	  replace: func.isRequired,
	  go: func.isRequired,
	  goBack: func.isRequired,
	  goForward: func.isRequired,
	  setRouteLeaveHook: func.isRequired,
	  isActive: func.isRequired
	});
	
	var locationShape = exports.locationShape = shape({
	  pathname: string.isRequired,
	  search: string.isRequired,
	  state: object,
	  action: string.isRequired,
	  key: string
	});
	
	// Deprecated stuff below:
	
	var falsy = exports.falsy = InternalPropTypes.falsy;
	var history = exports.history = InternalPropTypes.history;
	var location = exports.location = locationShape;
	var component = exports.component = InternalPropTypes.component;
	var components = exports.components = InternalPropTypes.components;
	var route = exports.route = InternalPropTypes.route;
	var routes = exports.routes = InternalPropTypes.routes;
	var router = exports.router = routerShape;
	
	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var deprecatePropType = function deprecatePropType(propType, message) {
	      return function () {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, message) : void 0;
	        return propType.apply(undefined, arguments);
	      };
	    };
	
	    var deprecateInternalPropType = function deprecateInternalPropType(propType) {
	      return deprecatePropType(propType, 'This prop type is not intended for external use, and was previously exported by mistake. These internal prop types are deprecated for external use, and will be removed in a later version.');
	    };
	
	    var deprecateRenamedPropType = function deprecateRenamedPropType(propType, name) {
	      return deprecatePropType(propType, 'The `' + name + '` prop type is now exported as `' + name + 'Shape` to avoid name conflicts. This export is deprecated and will be removed in a later version.');
	    };
	
	    exports.falsy = falsy = deprecateInternalPropType(falsy);
	    exports.history = history = deprecateInternalPropType(history);
	    exports.component = component = deprecateInternalPropType(component);
	    exports.components = components = deprecateInternalPropType(components);
	    exports.route = route = deprecateInternalPropType(route);
	    exports.routes = routes = deprecateInternalPropType(routes);
	
	    exports.location = location = deprecateRenamedPropType(location, 'location');
	    exports.router = router = deprecateRenamedPropType(router, 'router');
	  })();
	}
	
	var defaultExport = {
	  falsy: falsy,
	  history: history,
	  location: location,
	  component: component,
	  components: components,
	  route: route,
	  // For some reason, routes was never here.
	  router: router
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  defaultExport = (0, _deprecateObjectProperties2.default)(defaultExport, 'The default export from `react-router/lib/PropTypes` is deprecated. Please use the named exports instead.');
	}
	
	exports.default = defaultExport;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.canUseMembrane = undefined;
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var canUseMembrane = exports.canUseMembrane = false;
	
	// No-op by default.
	var deprecateObjectProperties = function deprecateObjectProperties(object) {
	  return object;
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    if (Object.defineProperty({}, 'x', {
	      get: function get() {
	        return true;
	      }
	    }).x) {
	      exports.canUseMembrane = canUseMembrane = true;
	    }
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	
	  if (canUseMembrane) {
	    deprecateObjectProperties = function deprecateObjectProperties(object, message) {
	      // Wrap the deprecated object in a membrane to warn on property access.
	      var membrane = {};
	
	      var _loop = function _loop(prop) {
	        if (!Object.prototype.hasOwnProperty.call(object, prop)) {
	          return 'continue';
	        }
	
	        if (typeof object[prop] === 'function') {
	          // Can't use fat arrow here because of use of arguments below.
	          membrane[prop] = function () {
	            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, message) : void 0;
	            return object[prop].apply(object, arguments);
	          };
	          return 'continue';
	        }
	
	        // These properties are non-enumerable to prevent React dev tools from
	        // seeing them and causing spurious warnings when accessing them. In
	        // principle this could be done with a proxy, but support for the
	        // ownKeys trap on proxies is not universal, even among browsers that
	        // otherwise support proxies.
	        Object.defineProperty(membrane, prop, {
	          get: function get() {
	            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, message) : void 0;
	            return object[prop];
	          }
	        });
	      };
	
	      for (var prop in object) {
	        var _ret = _loop(prop);
	
	        if (_ret === 'continue') continue;
	      }
	
	      return membrane;
	    };
	  }
	}
	
	exports.default = deprecateObjectProperties;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = routerWarning;
	exports._resetWarned = _resetWarned;
	
	var _warning = __webpack_require__(171);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var warned = {};
	
	function routerWarning(falseToWarn, message) {
	  // Only issue deprecation warnings once.
	  if (message.indexOf('deprecated') !== -1) {
	    if (warned[message]) {
	      return;
	    }
	
	    warned[message] = true;
	  }
	
	  message = '[react-router] ' + message;
	
	  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    args[_key - 2] = arguments[_key];
	  }
	
	  _warning2.default.apply(undefined, [falseToWarn, message].concat(args));
	}
	
	function _resetWarned() {
	  warned = {};
	}

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = function warning() {};
	
	if (process.env.NODE_ENV !== 'production') {
	  warning = function warning(condition, format, args) {
	    var len = arguments.length;
	    args = new Array(len > 2 ? len - 2 : 0);
	    for (var key = 2; key < len; key++) {
	      args[key - 2] = arguments[key];
	    }
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	
	    if (format.length < 10 || /^[s\W]*$/.test(format)) {
	      throw new Error('The warning format should be able to uniquely identify this ' + 'warning. Please, use a more descriptive format than: ' + format);
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    }
	  };
	}
	
	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.routes = exports.route = exports.components = exports.component = exports.history = undefined;
	exports.falsy = falsy;
	
	var _react = __webpack_require__(8);
	
	var func = _react.PropTypes.func;
	var object = _react.PropTypes.object;
	var arrayOf = _react.PropTypes.arrayOf;
	var oneOfType = _react.PropTypes.oneOfType;
	var element = _react.PropTypes.element;
	var shape = _react.PropTypes.shape;
	var string = _react.PropTypes.string;
	function falsy(props, propName, componentName) {
	  if (props[propName]) return new Error('<' + componentName + '> should not have a "' + propName + '" prop');
	}
	
	var history = exports.history = shape({
	  listen: func.isRequired,
	  push: func.isRequired,
	  replace: func.isRequired,
	  go: func.isRequired,
	  goBack: func.isRequired,
	  goForward: func.isRequired
	});
	
	var component = exports.component = oneOfType([func, string]);
	var components = exports.components = oneOfType([component, object]);
	var route = exports.route = oneOfType([object, element]);
	var routes = exports.routes = oneOfType([route, arrayOf(route)]);

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.compilePattern = compilePattern;
	exports.matchPattern = matchPattern;
	exports.getParamNames = getParamNames;
	exports.getParams = getParams;
	exports.formatPattern = formatPattern;
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function escapeRegExp(string) {
	  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
	}
	
	function _compilePattern(pattern) {
	  var regexpSource = '';
	  var paramNames = [];
	  var tokens = [];
	
	  var match = void 0,
	      lastIndex = 0,
	      matcher = /:([a-zA-Z_$][a-zA-Z0-9_$]*)|\*\*|\*|\(|\)/g;
	  while (match = matcher.exec(pattern)) {
	    if (match.index !== lastIndex) {
	      tokens.push(pattern.slice(lastIndex, match.index));
	      regexpSource += escapeRegExp(pattern.slice(lastIndex, match.index));
	    }
	
	    if (match[1]) {
	      regexpSource += '([^/]+)';
	      paramNames.push(match[1]);
	    } else if (match[0] === '**') {
	      regexpSource += '(.*)';
	      paramNames.push('splat');
	    } else if (match[0] === '*') {
	      regexpSource += '(.*?)';
	      paramNames.push('splat');
	    } else if (match[0] === '(') {
	      regexpSource += '(?:';
	    } else if (match[0] === ')') {
	      regexpSource += ')?';
	    }
	
	    tokens.push(match[0]);
	
	    lastIndex = matcher.lastIndex;
	  }
	
	  if (lastIndex !== pattern.length) {
	    tokens.push(pattern.slice(lastIndex, pattern.length));
	    regexpSource += escapeRegExp(pattern.slice(lastIndex, pattern.length));
	  }
	
	  return {
	    pattern: pattern,
	    regexpSource: regexpSource,
	    paramNames: paramNames,
	    tokens: tokens
	  };
	}
	
	var CompiledPatternsCache = Object.create(null);
	
	function compilePattern(pattern) {
	  if (!CompiledPatternsCache[pattern]) CompiledPatternsCache[pattern] = _compilePattern(pattern);
	
	  return CompiledPatternsCache[pattern];
	}
	
	/**
	 * Attempts to match a pattern on the given pathname. Patterns may use
	 * the following special characters:
	 *
	 * - :paramName     Matches a URL segment up to the next /, ?, or #. The
	 *                  captured string is considered a "param"
	 * - ()             Wraps a segment of the URL that is optional
	 * - *              Consumes (non-greedy) all characters up to the next
	 *                  character in the pattern, or to the end of the URL if
	 *                  there is none
	 * - **             Consumes (greedy) all characters up to the next character
	 *                  in the pattern, or to the end of the URL if there is none
	 *
	 *  The function calls callback(error, matched) when finished.
	 * The return value is an object with the following properties:
	 *
	 * - remainingPathname
	 * - paramNames
	 * - paramValues
	 */
	function matchPattern(pattern, pathname) {
	  // Ensure pattern starts with leading slash for consistency with pathname.
	  if (pattern.charAt(0) !== '/') {
	    pattern = '/' + pattern;
	  }
	
	  var _compilePattern2 = compilePattern(pattern);
	
	  var regexpSource = _compilePattern2.regexpSource;
	  var paramNames = _compilePattern2.paramNames;
	  var tokens = _compilePattern2.tokens;
	
	  if (pattern.charAt(pattern.length - 1) !== '/') {
	    regexpSource += '/?'; // Allow optional path separator at end.
	  }
	
	  // Special-case patterns like '*' for catch-all routes.
	  if (tokens[tokens.length - 1] === '*') {
	    regexpSource += '$';
	  }
	
	  var match = pathname.match(new RegExp('^' + regexpSource, 'i'));
	  if (match == null) {
	    return null;
	  }
	
	  var matchedPath = match[0];
	  var remainingPathname = pathname.substr(matchedPath.length);
	
	  if (remainingPathname) {
	    // Require that the match ends at a path separator, if we didn't match
	    // the full path, so any remaining pathname is a new path segment.
	    if (matchedPath.charAt(matchedPath.length - 1) !== '/') {
	      return null;
	    }
	
	    // If there is a remaining pathname, treat the path separator as part of
	    // the remaining pathname for properly continuing the match.
	    remainingPathname = '/' + remainingPathname;
	  }
	
	  return {
	    remainingPathname: remainingPathname,
	    paramNames: paramNames,
	    paramValues: match.slice(1).map(function (v) {
	      return v && decodeURIComponent(v);
	    })
	  };
	}
	
	function getParamNames(pattern) {
	  return compilePattern(pattern).paramNames;
	}
	
	function getParams(pattern, pathname) {
	  var match = matchPattern(pattern, pathname);
	  if (!match) {
	    return null;
	  }
	
	  var paramNames = match.paramNames;
	  var paramValues = match.paramValues;
	
	  var params = {};
	
	  paramNames.forEach(function (paramName, index) {
	    params[paramName] = paramValues[index];
	  });
	
	  return params;
	}
	
	/**
	 * Returns a version of the given pattern with params interpolated. Throws
	 * if there is a dynamic segment of the pattern for which there is no param.
	 */
	function formatPattern(pattern, params) {
	  params = params || {};
	
	  var _compilePattern3 = compilePattern(pattern);
	
	  var tokens = _compilePattern3.tokens;
	
	  var parenCount = 0,
	      pathname = '',
	      splatIndex = 0;
	
	  var token = void 0,
	      paramName = void 0,
	      paramValue = void 0;
	  for (var i = 0, len = tokens.length; i < len; ++i) {
	    token = tokens[i];
	
	    if (token === '*' || token === '**') {
	      paramValue = Array.isArray(params.splat) ? params.splat[splatIndex++] : params.splat;
	
	      !(paramValue != null || parenCount > 0) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Missing splat #%s for path "%s"', splatIndex, pattern) : (0, _invariant2.default)(false) : void 0;
	
	      if (paramValue != null) pathname += encodeURI(paramValue);
	    } else if (token === '(') {
	      parenCount += 1;
	    } else if (token === ')') {
	      parenCount -= 1;
	    } else if (token.charAt(0) === ':') {
	      paramName = token.substring(1);
	      paramValue = params[paramName];
	
	      !(paramValue != null || parenCount > 0) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Missing "%s" parameter for path "%s"', paramName, pattern) : (0, _invariant2.default)(false) : void 0;
	
	      if (paramValue != null) pathname += encodeURIComponent(paramValue);
	    } else {
	      pathname += token;
	    }
	  }
	
	  return pathname.replace(/\/+/g, '/');
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var invariant = function invariant(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};
	
	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _createHashHistory = __webpack_require__(176);
	
	var _createHashHistory2 = _interopRequireDefault(_createHashHistory);
	
	var _useQueries = __webpack_require__(192);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _createTransitionManager = __webpack_require__(195);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _InternalPropTypes = __webpack_require__(172);
	
	var _RouterContext = __webpack_require__(203);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _RouteUtils = __webpack_require__(167);
	
	var _RouterUtils = __webpack_require__(205);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	  var target = {};for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	  }return target;
	}
	
	function isDeprecatedHistory(history) {
	  return !history || !history.__v2_compatible__;
	}
	
	/* istanbul ignore next: sanity check */
	function isUnsupportedHistory(history) {
	  // v3 histories expose getCurrentLocation, but aren't currently supported.
	  return history && history.getCurrentLocation;
	}
	
	var _React$PropTypes = _react2.default.PropTypes;
	var func = _React$PropTypes.func;
	var object = _React$PropTypes.object;
	
	/**
	 * A <Router> is a high-level API for automatically setting up
	 * a router that renders a <RouterContext> with all the props
	 * it needs each time the URL changes.
	 */
	
	var Router = _react2.default.createClass({
	  displayName: 'Router',
	
	  propTypes: {
	    history: object,
	    children: _InternalPropTypes.routes,
	    routes: _InternalPropTypes.routes, // alias for children
	    render: func,
	    createElement: func,
	    onError: func,
	    onUpdate: func,
	
	    // Deprecated:
	    parseQueryString: func,
	    stringifyQuery: func,
	
	    // PRIVATE: For client-side rehydration of server match.
	    matchContext: object
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      render: function render(props) {
	        return _react2.default.createElement(_RouterContext2.default, props);
	      }
	    };
	  },
	  getInitialState: function getInitialState() {
	    return {
	      location: null,
	      routes: null,
	      params: null,
	      components: null
	    };
	  },
	  handleError: function handleError(error) {
	    if (this.props.onError) {
	      this.props.onError.call(this, error);
	    } else {
	      // Throw errors by default so we don't silently swallow them!
	      throw error; // This error probably occurred in getChildRoutes or getComponents.
	    }
	  },
	  componentWillMount: function componentWillMount() {
	    var _this = this;
	
	    var _props = this.props;
	    var parseQueryString = _props.parseQueryString;
	    var stringifyQuery = _props.stringifyQuery;
	
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!(parseQueryString || stringifyQuery), '`parseQueryString` and `stringifyQuery` are deprecated. Please create a custom history. http://tiny.cc/router-customquerystring') : void 0;
	
	    var _createRouterObjects = this.createRouterObjects();
	
	    var history = _createRouterObjects.history;
	    var transitionManager = _createRouterObjects.transitionManager;
	    var router = _createRouterObjects.router;
	
	    this._unlisten = transitionManager.listen(function (error, state) {
	      if (error) {
	        _this.handleError(error);
	      } else {
	        _this.setState(state, _this.props.onUpdate);
	      }
	    });
	
	    this.history = history;
	    this.router = router;
	  },
	  createRouterObjects: function createRouterObjects() {
	    var matchContext = this.props.matchContext;
	
	    if (matchContext) {
	      return matchContext;
	    }
	
	    var history = this.props.history;
	    var _props2 = this.props;
	    var routes = _props2.routes;
	    var children = _props2.children;
	
	    !!isUnsupportedHistory(history) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'You have provided a history object created with history v3.x. ' + 'This version of React Router is not compatible with v3 history ' + 'objects. Please use history v2.x instead.') : (0, _invariant2.default)(false) : void 0;
	
	    if (isDeprecatedHistory(history)) {
	      history = this.wrapDeprecatedHistory(history);
	    }
	
	    var transitionManager = (0, _createTransitionManager2.default)(history, (0, _RouteUtils.createRoutes)(routes || children));
	    var router = (0, _RouterUtils.createRouterObject)(history, transitionManager);
	    var routingHistory = (0, _RouterUtils.createRoutingHistory)(history, transitionManager);
	
	    return { history: routingHistory, transitionManager: transitionManager, router: router };
	  },
	  wrapDeprecatedHistory: function wrapDeprecatedHistory(history) {
	    var _props3 = this.props;
	    var parseQueryString = _props3.parseQueryString;
	    var stringifyQuery = _props3.stringifyQuery;
	
	    var createHistory = void 0;
	    if (history) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'It appears you have provided a deprecated history object to `<Router/>`, please use a history provided by ' + 'React Router with `import { browserHistory } from \'react-router\'` or `import { hashHistory } from \'react-router\'`. ' + 'If you are using a custom history please create it with `useRouterHistory`, see http://tiny.cc/router-usinghistory for details.') : void 0;
	      createHistory = function createHistory() {
	        return history;
	      };
	    } else {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`Router` no longer defaults the history prop to hash history. Please use the `hashHistory` singleton instead. http://tiny.cc/router-defaulthistory') : void 0;
	      createHistory = _createHashHistory2.default;
	    }
	
	    return (0, _useQueries2.default)(createHistory)({ parseQueryString: parseQueryString, stringifyQuery: stringifyQuery });
	  },
	
	  /* istanbul ignore next: sanity check */
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(nextProps.history === this.props.history, 'You cannot change <Router history>; it will be ignored') : void 0;
	
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)((nextProps.routes || nextProps.children) === (this.props.routes || this.props.children), 'You cannot change <Router routes>; it will be ignored') : void 0;
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    if (this._unlisten) this._unlisten();
	  },
	  render: function render() {
	    var _state = this.state;
	    var location = _state.location;
	    var routes = _state.routes;
	    var params = _state.params;
	    var components = _state.components;
	    var _props4 = this.props;
	    var createElement = _props4.createElement;
	    var render = _props4.render;
	
	    var props = _objectWithoutProperties(_props4, ['createElement', 'render']);
	
	    if (location == null) return null; // Async match
	
	    // Only forward non-Router-specific props to routing context, as those are
	    // the only ones that might be custom routing context props.
	    Object.keys(Router.propTypes).forEach(function (propType) {
	      return delete props[propType];
	    });
	
	    return render(_extends({}, props, {
	      history: this.history,
	      router: this.router,
	      location: location,
	      routes: routes,
	      params: params,
	      components: components,
	      createElement: createElement
	    }));
	  }
	});
	
	exports.default = Router;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Actions = __webpack_require__(178);
	
	var _PathUtils = __webpack_require__(179);
	
	var _ExecutionEnvironment = __webpack_require__(180);
	
	var _DOMUtils = __webpack_require__(181);
	
	var _DOMStateStorage = __webpack_require__(182);
	
	var _createDOMHistory = __webpack_require__(183);
	
	var _createDOMHistory2 = _interopRequireDefault(_createDOMHistory);
	
	function isAbsolutePath(path) {
	  return typeof path === 'string' && path.charAt(0) === '/';
	}
	
	function ensureSlash() {
	  var path = _DOMUtils.getHashPath();
	
	  if (isAbsolutePath(path)) return true;
	
	  _DOMUtils.replaceHashPath('/' + path);
	
	  return false;
	}
	
	function addQueryStringValueToPath(path, key, value) {
	  return path + (path.indexOf('?') === -1 ? '?' : '&') + (key + '=' + value);
	}
	
	function stripQueryStringValueFromPath(path, key) {
	  return path.replace(new RegExp('[?&]?' + key + '=[a-zA-Z0-9]+'), '');
	}
	
	function getQueryStringValueFromPath(path, key) {
	  var match = path.match(new RegExp('\\?.*?\\b' + key + '=(.+?)\\b'));
	  return match && match[1];
	}
	
	var DefaultQueryKey = '_k';
	
	function createHashHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Hash history needs a DOM') : _invariant2['default'](false) : undefined;
	
	  var queryKey = options.queryKey;
	
	  if (queryKey === undefined || !!queryKey) queryKey = typeof queryKey === 'string' ? queryKey : DefaultQueryKey;
	
	  function getCurrentLocation() {
	    var path = _DOMUtils.getHashPath();
	
	    var key = undefined,
	        state = undefined;
	    if (queryKey) {
	      key = getQueryStringValueFromPath(path, queryKey);
	      path = stripQueryStringValueFromPath(path, queryKey);
	
	      if (key) {
	        state = _DOMStateStorage.readState(key);
	      } else {
	        state = null;
	        key = history.createKey();
	        _DOMUtils.replaceHashPath(addQueryStringValueToPath(path, queryKey, key));
	      }
	    } else {
	      key = state = null;
	    }
	
	    var location = _PathUtils.parsePath(path);
	
	    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
	  }
	
	  function startHashChangeListener(_ref) {
	    var transitionTo = _ref.transitionTo;
	
	    function hashChangeListener() {
	      if (!ensureSlash()) return; // Always make sure hashes are preceeded with a /.
	
	      transitionTo(getCurrentLocation());
	    }
	
	    ensureSlash();
	    _DOMUtils.addEventListener(window, 'hashchange', hashChangeListener);
	
	    return function () {
	      _DOMUtils.removeEventListener(window, 'hashchange', hashChangeListener);
	    };
	  }
	
	  function finishTransition(location) {
	    var basename = location.basename;
	    var pathname = location.pathname;
	    var search = location.search;
	    var state = location.state;
	    var action = location.action;
	    var key = location.key;
	
	    if (action === _Actions.POP) return; // Nothing to do.
	
	    var path = (basename || '') + pathname + search;
	
	    if (queryKey) {
	      path = addQueryStringValueToPath(path, queryKey, key);
	      _DOMStateStorage.saveState(key, state);
	    } else {
	      // Drop key and state.
	      location.key = location.state = null;
	    }
	
	    var currentHash = _DOMUtils.getHashPath();
	
	    if (action === _Actions.PUSH) {
	      if (currentHash !== path) {
	        window.location.hash = path;
	      } else {
	        process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'You cannot PUSH the same path using hash history') : undefined;
	      }
	    } else if (currentHash !== path) {
	      // REPLACE
	      _DOMUtils.replaceHashPath(path);
	    }
	  }
	
	  var history = _createDOMHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: _DOMStateStorage.saveState
	  }));
	
	  var listenerCount = 0,
	      stopHashChangeListener = undefined;
	
	  function listenBefore(listener) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    var unlisten = history.listenBefore(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopHashChangeListener();
	    };
	  }
	
	  function listen(listener) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    var unlisten = history.listen(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopHashChangeListener();
	    };
	  }
	
	  function push(location) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || location.state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.push(location);
	  }
	
	  function replace(location) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || location.state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.replace(location);
	  }
	
	  var goIsSupportedWithoutReload = _DOMUtils.supportsGoWithoutReloadUsingHash();
	
	  function go(n) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](goIsSupportedWithoutReload, 'Hash history go(n) causes a full page reload in this browser') : undefined;
	
	    history.go(n);
	  }
	
	  function createHref(path) {
	    return '#' + history.createHref(path);
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    history.registerTransitionHook(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    history.unregisterTransitionHook(hook);
	
	    if (--listenerCount === 0) stopHashChangeListener();
	  }
	
	  // deprecated
	  function pushState(state, path) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.pushState(state, path);
	  }
	
	  // deprecated
	  function replaceState(state, path) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.replaceState(state, path);
	  }
	
	  return _extends({}, history, {
	    listenBefore: listenBefore,
	    listen: listen,
	    push: push,
	    replace: replace,
	    go: go,
	    createHref: createHref,
	
	    registerTransitionHook: registerTransitionHook, // deprecated - warning is in createHistory
	    unregisterTransitionHook: unregisterTransitionHook, // deprecated - warning is in createHistory
	    pushState: pushState, // deprecated - warning is in createHistory
	    replaceState: replaceState // deprecated - warning is in createHistory
	  });
	}
	
	exports['default'] = createHashHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = function warning() {};
	
	if (process.env.NODE_ENV !== 'production') {
	  warning = function warning(condition, format, args) {
	    var len = arguments.length;
	    args = new Array(len > 2 ? len - 2 : 0);
	    for (var key = 2; key < len; key++) {
	      args[key - 2] = arguments[key];
	    }
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	
	    if (format.length < 10 || /^[s\W]*$/.test(format)) {
	      throw new Error('The warning format should be able to uniquely identify this ' + 'warning. Please, use a more descriptive format than: ' + format);
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    }
	  };
	}
	
	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 178 */
/***/ function(module, exports) {

	/**
	 * Indicates that navigation was caused by a call to history.push.
	 */
	'use strict';
	
	exports.__esModule = true;
	var PUSH = 'PUSH';
	
	exports.PUSH = PUSH;
	/**
	 * Indicates that navigation was caused by a call to history.replace.
	 */
	var REPLACE = 'REPLACE';
	
	exports.REPLACE = REPLACE;
	/**
	 * Indicates that navigation was caused by some other action such
	 * as using a browser's back/forward buttons and/or manually manipulating
	 * the URL in a browser's location bar. This is the default.
	 *
	 * See https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate
	 * for more information.
	 */
	var POP = 'POP';
	
	exports.POP = POP;
	exports['default'] = {
	  PUSH: PUSH,
	  REPLACE: REPLACE,
	  POP: POP
	};

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.extractPath = extractPath;
	exports.parsePath = parsePath;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function extractPath(string) {
	  var match = string.match(/^https?:\/\/[^\/]*/);
	
	  if (match == null) return string;
	
	  return string.substring(match[0].length);
	}
	
	function parsePath(path) {
	  var pathname = extractPath(path);
	  var search = '';
	  var hash = '';
	
	  process.env.NODE_ENV !== 'production' ? _warning2['default'](path === pathname, 'A path must be pathname + search + hash only, not a fully qualified URL like "%s"', path) : undefined;
	
	  var hashIndex = pathname.indexOf('#');
	  if (hashIndex !== -1) {
	    hash = pathname.substring(hashIndex);
	    pathname = pathname.substring(0, hashIndex);
	  }
	
	  var searchIndex = pathname.indexOf('?');
	  if (searchIndex !== -1) {
	    search = pathname.substring(searchIndex);
	    pathname = pathname.substring(0, searchIndex);
	  }
	
	  if (pathname === '') pathname = '/';
	
	  return {
	    pathname: pathname,
	    search: search,
	    hash: hash
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 180 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	exports.canUseDOM = canUseDOM;

/***/ },
/* 181 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports.addEventListener = addEventListener;
	exports.removeEventListener = removeEventListener;
	exports.getHashPath = getHashPath;
	exports.replaceHashPath = replaceHashPath;
	exports.getWindowPath = getWindowPath;
	exports.go = go;
	exports.getUserConfirmation = getUserConfirmation;
	exports.supportsHistory = supportsHistory;
	exports.supportsGoWithoutReloadUsingHash = supportsGoWithoutReloadUsingHash;
	
	function addEventListener(node, event, listener) {
	  if (node.addEventListener) {
	    node.addEventListener(event, listener, false);
	  } else {
	    node.attachEvent('on' + event, listener);
	  }
	}
	
	function removeEventListener(node, event, listener) {
	  if (node.removeEventListener) {
	    node.removeEventListener(event, listener, false);
	  } else {
	    node.detachEvent('on' + event, listener);
	  }
	}
	
	function getHashPath() {
	  // We can't use window.location.hash here because it's not
	  // consistent across browsers - Firefox will pre-decode it!
	  return window.location.href.split('#')[1] || '';
	}
	
	function replaceHashPath(path) {
	  window.location.replace(window.location.pathname + window.location.search + '#' + path);
	}
	
	function getWindowPath() {
	  return window.location.pathname + window.location.search + window.location.hash;
	}
	
	function go(n) {
	  if (n) window.history.go(n);
	}
	
	function getUserConfirmation(message, callback) {
	  callback(window.confirm(message));
	}
	
	/**
	 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
	 *
	 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
	 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
	 * changed to avoid false negatives for Windows Phones: https://github.com/rackt/react-router/issues/586
	 */
	
	function supportsHistory() {
	  var ua = navigator.userAgent;
	  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
	    return false;
	  }
	  return window.history && 'pushState' in window.history;
	}
	
	/**
	 * Returns false if using go(n) with hash history causes a full page reload.
	 */
	
	function supportsGoWithoutReloadUsingHash() {
	  var ua = navigator.userAgent;
	  return ua.indexOf('Firefox') === -1;
	}

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*eslint-disable no-empty */
	'use strict';
	
	exports.__esModule = true;
	exports.saveState = saveState;
	exports.readState = readState;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var KeyPrefix = '@@History/';
	var QuotaExceededErrors = ['QuotaExceededError', 'QUOTA_EXCEEDED_ERR'];
	
	var SecurityError = 'SecurityError';
	
	function createKey(key) {
	  return KeyPrefix + key;
	}
	
	function saveState(key, state) {
	  try {
	    if (state == null) {
	      window.sessionStorage.removeItem(createKey(key));
	    } else {
	      window.sessionStorage.setItem(createKey(key), JSON.stringify(state));
	    }
	  } catch (error) {
	    if (error.name === SecurityError) {
	      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
	      // attempt to access window.sessionStorage.
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to save state; sessionStorage is not available due to security settings') : undefined;
	
	      return;
	    }
	
	    if (QuotaExceededErrors.indexOf(error.name) >= 0 && window.sessionStorage.length === 0) {
	      // Safari "private mode" throws QuotaExceededError.
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to save state; sessionStorage is not available in Safari private mode') : undefined;
	
	      return;
	    }
	
	    throw error;
	  }
	}
	
	function readState(key) {
	  var json = undefined;
	  try {
	    json = window.sessionStorage.getItem(createKey(key));
	  } catch (error) {
	    if (error.name === SecurityError) {
	      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
	      // attempt to access window.sessionStorage.
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to read state; sessionStorage is not available due to security settings') : undefined;
	
	      return null;
	    }
	  }
	
	  if (json) {
	    try {
	      return JSON.parse(json);
	    } catch (error) {
	      // Ignore invalid JSON.
	    }
	  }
	
	  return null;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _ExecutionEnvironment = __webpack_require__(180);
	
	var _DOMUtils = __webpack_require__(181);
	
	var _createHistory = __webpack_require__(184);
	
	var _createHistory2 = _interopRequireDefault(_createHistory);
	
	function createDOMHistory(options) {
	  var history = _createHistory2['default'](_extends({
	    getUserConfirmation: _DOMUtils.getUserConfirmation
	  }, options, {
	    go: _DOMUtils.go
	  }));
	
	  function listen(listener) {
	    !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'DOM history needs a DOM') : _invariant2['default'](false) : undefined;
	
	    return history.listen(listener);
	  }
	
	  return _extends({}, history, {
	    listen: listen
	  });
	}
	
	exports['default'] = createDOMHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _deepEqual = __webpack_require__(185);
	
	var _deepEqual2 = _interopRequireDefault(_deepEqual);
	
	var _PathUtils = __webpack_require__(179);
	
	var _AsyncUtils = __webpack_require__(188);
	
	var _Actions = __webpack_require__(178);
	
	var _createLocation2 = __webpack_require__(189);
	
	var _createLocation3 = _interopRequireDefault(_createLocation2);
	
	var _runTransitionHook = __webpack_require__(190);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _deprecate = __webpack_require__(191);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	function createRandomKey(length) {
	  return Math.random().toString(36).substr(2, length);
	}
	
	function locationsAreEqual(a, b) {
	  return a.pathname === b.pathname && a.search === b.search &&
	  //a.action === b.action && // Different action !== location change.
	  a.key === b.key && _deepEqual2['default'](a.state, b.state);
	}
	
	var DefaultKeyLength = 6;
	
	function createHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	  var getCurrentLocation = options.getCurrentLocation;
	  var finishTransition = options.finishTransition;
	  var saveState = options.saveState;
	  var go = options.go;
	  var getUserConfirmation = options.getUserConfirmation;
	  var keyLength = options.keyLength;
	
	  if (typeof keyLength !== 'number') keyLength = DefaultKeyLength;
	
	  var transitionHooks = [];
	
	  function listenBefore(hook) {
	    transitionHooks.push(hook);
	
	    return function () {
	      transitionHooks = transitionHooks.filter(function (item) {
	        return item !== hook;
	      });
	    };
	  }
	
	  var allKeys = [];
	  var changeListeners = [];
	  var location = undefined;
	
	  function getCurrent() {
	    if (pendingLocation && pendingLocation.action === _Actions.POP) {
	      return allKeys.indexOf(pendingLocation.key);
	    } else if (location) {
	      return allKeys.indexOf(location.key);
	    } else {
	      return -1;
	    }
	  }
	
	  function updateLocation(newLocation) {
	    var current = getCurrent();
	
	    location = newLocation;
	
	    if (location.action === _Actions.PUSH) {
	      allKeys = [].concat(allKeys.slice(0, current + 1), [location.key]);
	    } else if (location.action === _Actions.REPLACE) {
	      allKeys[current] = location.key;
	    }
	
	    changeListeners.forEach(function (listener) {
	      listener(location);
	    });
	  }
	
	  function listen(listener) {
	    changeListeners.push(listener);
	
	    if (location) {
	      listener(location);
	    } else {
	      var _location = getCurrentLocation();
	      allKeys = [_location.key];
	      updateLocation(_location);
	    }
	
	    return function () {
	      changeListeners = changeListeners.filter(function (item) {
	        return item !== listener;
	      });
	    };
	  }
	
	  function confirmTransitionTo(location, callback) {
	    _AsyncUtils.loopAsync(transitionHooks.length, function (index, next, done) {
	      _runTransitionHook2['default'](transitionHooks[index], location, function (result) {
	        if (result != null) {
	          done(result);
	        } else {
	          next();
	        }
	      });
	    }, function (message) {
	      if (getUserConfirmation && typeof message === 'string') {
	        getUserConfirmation(message, function (ok) {
	          callback(ok !== false);
	        });
	      } else {
	        callback(message !== false);
	      }
	    });
	  }
	
	  var pendingLocation = undefined;
	
	  function transitionTo(nextLocation) {
	    if (location && locationsAreEqual(location, nextLocation)) return; // Nothing to do.
	
	    pendingLocation = nextLocation;
	
	    confirmTransitionTo(nextLocation, function (ok) {
	      if (pendingLocation !== nextLocation) return; // Transition was interrupted.
	
	      if (ok) {
	        // treat PUSH to current path like REPLACE to be consistent with browsers
	        if (nextLocation.action === _Actions.PUSH) {
	          var prevPath = createPath(location);
	          var nextPath = createPath(nextLocation);
	
	          if (nextPath === prevPath && _deepEqual2['default'](location.state, nextLocation.state)) nextLocation.action = _Actions.REPLACE;
	        }
	
	        if (finishTransition(nextLocation) !== false) updateLocation(nextLocation);
	      } else if (location && nextLocation.action === _Actions.POP) {
	        var prevIndex = allKeys.indexOf(location.key);
	        var nextIndex = allKeys.indexOf(nextLocation.key);
	
	        if (prevIndex !== -1 && nextIndex !== -1) go(prevIndex - nextIndex); // Restore the URL.
	      }
	    });
	  }
	
	  function push(location) {
	    transitionTo(createLocation(location, _Actions.PUSH, createKey()));
	  }
	
	  function replace(location) {
	    transitionTo(createLocation(location, _Actions.REPLACE, createKey()));
	  }
	
	  function goBack() {
	    go(-1);
	  }
	
	  function goForward() {
	    go(1);
	  }
	
	  function createKey() {
	    return createRandomKey(keyLength);
	  }
	
	  function createPath(location) {
	    if (location == null || typeof location === 'string') return location;
	
	    var pathname = location.pathname;
	    var search = location.search;
	    var hash = location.hash;
	
	    var result = pathname;
	
	    if (search) result += search;
	
	    if (hash) result += hash;
	
	    return result;
	  }
	
	  function createHref(location) {
	    return createPath(location);
	  }
	
	  function createLocation(location, action) {
	    var key = arguments.length <= 2 || arguments[2] === undefined ? createKey() : arguments[2];
	
	    if ((typeof action === 'undefined' ? 'undefined' : _typeof(action)) === 'object') {
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'The state (2nd) argument to history.createLocation is deprecated; use a ' + 'location descriptor instead') : undefined;
	
	      if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	      location = _extends({}, location, { state: action });
	
	      action = key;
	      key = arguments[3] || createKey();
	    }
	
	    return _createLocation3['default'](location, action, key);
	  }
	
	  // deprecated
	  function setState(state) {
	    if (location) {
	      updateLocationState(location, state);
	      updateLocation(location);
	    } else {
	      updateLocationState(getCurrentLocation(), state);
	    }
	  }
	
	  function updateLocationState(location, state) {
	    location.state = _extends({}, location.state, state);
	    saveState(location.key, location.state);
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (transitionHooks.indexOf(hook) === -1) transitionHooks.push(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    transitionHooks = transitionHooks.filter(function (item) {
	      return item !== hook;
	    });
	  }
	
	  // deprecated
	  function pushState(state, path) {
	    if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	    push(_extends({ state: state }, path));
	  }
	
	  // deprecated
	  function replaceState(state, path) {
	    if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	    replace(_extends({ state: state }, path));
	  }
	
	  return {
	    listenBefore: listenBefore,
	    listen: listen,
	    transitionTo: transitionTo,
	    push: push,
	    replace: replace,
	    go: go,
	    goBack: goBack,
	    goForward: goForward,
	    createKey: createKey,
	    createPath: createPath,
	    createHref: createHref,
	    createLocation: createLocation,
	
	    setState: _deprecate2['default'](setState, 'setState is deprecated; use location.key to save state instead'),
	    registerTransitionHook: _deprecate2['default'](registerTransitionHook, 'registerTransitionHook is deprecated; use listenBefore instead'),
	    unregisterTransitionHook: _deprecate2['default'](unregisterTransitionHook, 'unregisterTransitionHook is deprecated; use the callback returned from listenBefore instead'),
	    pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
	    replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
	  };
	}
	
	exports['default'] = createHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var pSlice = Array.prototype.slice;
	var objectKeys = __webpack_require__(186);
	var isArguments = __webpack_require__(187);
	
	var deepEqual = module.exports = function (actual, expected, opts) {
	  if (!opts) opts = {};
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	  } else if (actual instanceof Date && expected instanceof Date) {
	    return actual.getTime() === expected.getTime();
	
	    // 7.3. Other pairs that do not both pass typeof value == 'object',
	    // equivalence is determined by ==.
	  } else if (!actual || !expected || (typeof actual === 'undefined' ? 'undefined' : _typeof(actual)) != 'object' && (typeof expected === 'undefined' ? 'undefined' : _typeof(expected)) != 'object') {
	    return opts.strict ? actual === expected : actual == expected;
	
	    // 7.4. For all other Object pairs, including Array objects, equivalence is
	    // determined by having the same number of owned properties (as verified
	    // with Object.prototype.hasOwnProperty.call), the same set of keys
	    // (although not necessarily the same order), equivalent values for every
	    // corresponding key, and an identical 'prototype' property. Note: this
	    // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected, opts);
	  }
	};
	
	function isUndefinedOrNull(value) {
	  return value === null || value === undefined;
	}
	
	function isBuffer(x) {
	  if (!x || (typeof x === 'undefined' ? 'undefined' : _typeof(x)) !== 'object' || typeof x.length !== 'number') return false;
	  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
	    return false;
	  }
	  if (x.length > 0 && typeof x[0] !== 'number') return false;
	  return true;
	}
	
	function objEquiv(a, b, opts) {
	  var i, key;
	  if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  //~~~I've managed to break Object.keys through screwy arguments passing.
	  //   Converting to array solves the problem.
	  if (isArguments(a)) {
	    if (!isArguments(b)) {
	      return false;
	    }
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return deepEqual(a, b, opts);
	  }
	  if (isBuffer(a)) {
	    if (!isBuffer(b)) {
	      return false;
	    }
	    if (a.length !== b.length) return false;
	    for (i = 0; i < a.length; i++) {
	      if (a[i] !== b[i]) return false;
	    }
	    return true;
	  }
	  try {
	    var ka = objectKeys(a),
	        kb = objectKeys(b);
	  } catch (e) {
	    //happens when one is a string literal and the other isn't
	    return false;
	  }
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length) return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i]) return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!deepEqual(a[key], b[key], opts)) return false;
	  }
	  return (typeof a === 'undefined' ? 'undefined' : _typeof(a)) === (typeof b === 'undefined' ? 'undefined' : _typeof(b));
	}

/***/ },
/* 186 */
/***/ function(module, exports) {

	'use strict';
	
	exports = module.exports = typeof Object.keys === 'function' ? Object.keys : shim;
	
	exports.shim = shim;
	function shim(obj) {
	  var keys = [];
	  for (var key in obj) {
	    keys.push(key);
	  }return keys;
	}

/***/ },
/* 187 */
/***/ function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var supportsArgumentsClass = function () {
	  return Object.prototype.toString.call(arguments);
	}() == '[object Arguments]';
	
	exports = module.exports = supportsArgumentsClass ? supported : unsupported;
	
	exports.supported = supported;
	function supported(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	};
	
	exports.unsupported = unsupported;
	function unsupported(object) {
	  return object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) == 'object' && typeof object.length == 'number' && Object.prototype.hasOwnProperty.call(object, 'callee') && !Object.prototype.propertyIsEnumerable.call(object, 'callee') || false;
	};

/***/ },
/* 188 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	var _slice = Array.prototype.slice;
	exports.loopAsync = loopAsync;
	
	function loopAsync(turns, work, callback) {
	  var currentTurn = 0,
	      isDone = false;
	  var sync = false,
	      hasNext = false,
	      doneArgs = undefined;
	
	  function done() {
	    isDone = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      doneArgs = [].concat(_slice.call(arguments));
	      return;
	    }
	
	    callback.apply(this, arguments);
	  }
	
	  function next() {
	    if (isDone) {
	      return;
	    }
	
	    hasNext = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      return;
	    }
	
	    sync = true;
	
	    while (!isDone && currentTurn < turns && hasNext) {
	      hasNext = false;
	      work.call(this, currentTurn++, next, done);
	    }
	
	    sync = false;
	
	    if (isDone) {
	      // This means the loop finished synchronously.
	      callback.apply(this, doneArgs);
	      return;
	    }
	
	    if (currentTurn >= turns && hasNext) {
	      isDone = true;
	      callback();
	    }
	  }
	
	  next();
	}

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _Actions = __webpack_require__(178);
	
	var _PathUtils = __webpack_require__(179);
	
	function createLocation() {
	  var location = arguments.length <= 0 || arguments[0] === undefined ? '/' : arguments[0];
	  var action = arguments.length <= 1 || arguments[1] === undefined ? _Actions.POP : arguments[1];
	  var key = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	  var _fourthArg = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	
	  if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	  if ((typeof action === 'undefined' ? 'undefined' : _typeof(action)) === 'object') {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'The state (2nd) argument to createLocation is deprecated; use a ' + 'location descriptor instead') : undefined;
	
	    location = _extends({}, location, { state: action });
	
	    action = key || _Actions.POP;
	    key = _fourthArg;
	  }
	
	  var pathname = location.pathname || '/';
	  var search = location.search || '';
	  var hash = location.hash || '';
	  var state = location.state || null;
	
	  return {
	    pathname: pathname,
	    search: search,
	    hash: hash,
	    state: state,
	    action: action,
	    key: key
	  };
	}
	
	exports['default'] = createLocation;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function runTransitionHook(hook, location, callback) {
	  var result = hook(location, callback);
	
	  if (hook.length < 2) {
	    // Assume the hook runs synchronously and automatically
	    // call the callback with the return value.
	    callback(result);
	  } else {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](result === undefined, 'You should not "return" in a transition hook with a callback argument; call the callback instead') : undefined;
	  }
	}
	
	exports['default'] = runTransitionHook;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function deprecate(fn, message) {
	  return function () {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] ' + message) : undefined;
	    return fn.apply(this, arguments);
	  };
	}
	
	exports['default'] = deprecate;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _queryString = __webpack_require__(193);
	
	var _runTransitionHook = __webpack_require__(190);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _PathUtils = __webpack_require__(179);
	
	var _deprecate = __webpack_require__(191);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	var SEARCH_BASE_KEY = '$searchBase';
	
	function defaultStringifyQuery(query) {
	  return _queryString.stringify(query).replace(/%20/g, '+');
	}
	
	var defaultParseQueryString = _queryString.parse;
	
	function isNestedObject(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p) && _typeof(object[p]) === 'object' && !Array.isArray(object[p]) && object[p] !== null) return true;
	  }return false;
	}
	
	/**
	 * Returns a new createHistory function that may be used to create
	 * history objects that know how to handle URL queries.
	 */
	function useQueries(createHistory) {
	  return function () {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var history = createHistory(options);
	
	    var stringifyQuery = options.stringifyQuery;
	    var parseQueryString = options.parseQueryString;
	
	    if (typeof stringifyQuery !== 'function') stringifyQuery = defaultStringifyQuery;
	
	    if (typeof parseQueryString !== 'function') parseQueryString = defaultParseQueryString;
	
	    function addQuery(location) {
	      if (location.query == null) {
	        var search = location.search;
	
	        location.query = parseQueryString(search.substring(1));
	        location[SEARCH_BASE_KEY] = { search: search, searchBase: '' };
	      }
	
	      // TODO: Instead of all the book-keeping here, this should just strip the
	      // stringified query from the search.
	
	      return location;
	    }
	
	    function appendQuery(location, query) {
	      var _extends2;
	
	      var searchBaseSpec = location[SEARCH_BASE_KEY];
	      var queryString = query ? stringifyQuery(query) : '';
	      if (!searchBaseSpec && !queryString) {
	        return location;
	      }
	
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](stringifyQuery !== defaultStringifyQuery || !isNestedObject(query), 'useQueries does not stringify nested query objects by default; ' + 'use a custom stringifyQuery function') : undefined;
	
	      if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	      var searchBase = undefined;
	      if (searchBaseSpec && location.search === searchBaseSpec.search) {
	        searchBase = searchBaseSpec.searchBase;
	      } else {
	        searchBase = location.search || '';
	      }
	
	      var search = searchBase;
	      if (queryString) {
	        search += (search ? '&' : '?') + queryString;
	      }
	
	      return _extends({}, location, (_extends2 = {
	        search: search
	      }, _extends2[SEARCH_BASE_KEY] = { search: search, searchBase: searchBase }, _extends2));
	    }
	
	    // Override all read methods with query-aware versions.
	    function listenBefore(hook) {
	      return history.listenBefore(function (location, callback) {
	        _runTransitionHook2['default'](hook, addQuery(location), callback);
	      });
	    }
	
	    function listen(listener) {
	      return history.listen(function (location) {
	        listener(addQuery(location));
	      });
	    }
	
	    // Override all write methods with query-aware versions.
	    function push(location) {
	      history.push(appendQuery(location, location.query));
	    }
	
	    function replace(location) {
	      history.replace(appendQuery(location, location.query));
	    }
	
	    function createPath(location, query) {
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](!query, 'the query argument to createPath is deprecated; use a location descriptor instead') : undefined;
	
	      return history.createPath(appendQuery(location, query || location.query));
	    }
	
	    function createHref(location, query) {
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](!query, 'the query argument to createHref is deprecated; use a location descriptor instead') : undefined;
	
	      return history.createHref(appendQuery(location, query || location.query));
	    }
	
	    function createLocation(location) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      var fullLocation = history.createLocation.apply(history, [appendQuery(location, location.query)].concat(args));
	      if (location.query) {
	        fullLocation.query = location.query;
	      }
	      return addQuery(fullLocation);
	    }
	
	    // deprecated
	    function pushState(state, path, query) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      push(_extends({ state: state }, path, { query: query }));
	    }
	
	    // deprecated
	    function replaceState(state, path, query) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      replace(_extends({ state: state }, path, { query: query }));
	    }
	
	    return _extends({}, history, {
	      listenBefore: listenBefore,
	      listen: listen,
	      push: push,
	      replace: replace,
	      createPath: createPath,
	      createHref: createHref,
	      createLocation: createLocation,
	
	      pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
	      replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
	    });
	  };
	}
	
	exports['default'] = useQueries;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var strictUriEncode = __webpack_require__(194);
	
	exports.extract = function (str) {
		return str.split('?')[1] || '';
	};
	
	exports.parse = function (str) {
		if (typeof str !== 'string') {
			return {};
		}
	
		str = str.trim().replace(/^(\?|#|&)/, '');
	
		if (!str) {
			return {};
		}
	
		return str.split('&').reduce(function (ret, param) {
			var parts = param.replace(/\+/g, ' ').split('=');
			// Firefox (pre 40) decodes `%3D` to `=`
			// https://github.com/sindresorhus/query-string/pull/37
			var key = parts.shift();
			var val = parts.length > 0 ? parts.join('=') : undefined;
	
			key = decodeURIComponent(key);
	
			// missing `=` should be `null`:
			// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
			val = val === undefined ? null : decodeURIComponent(val);
	
			if (!ret.hasOwnProperty(key)) {
				ret[key] = val;
			} else if (Array.isArray(ret[key])) {
				ret[key].push(val);
			} else {
				ret[key] = [ret[key], val];
			}
	
			return ret;
		}, {});
	};
	
	exports.stringify = function (obj) {
		return obj ? Object.keys(obj).sort().map(function (key) {
			var val = obj[key];
	
			if (val === undefined) {
				return '';
			}
	
			if (val === null) {
				return key;
			}
	
			if (Array.isArray(val)) {
				return val.slice().sort().map(function (val2) {
					return strictUriEncode(key) + '=' + strictUriEncode(val2);
				}).join('&');
			}
	
			return strictUriEncode(key) + '=' + strictUriEncode(val);
		}).filter(function (x) {
			return x.length > 0;
		}).join('&') : '';
	};

/***/ },
/* 194 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (str) {
		return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
			return '%' + c.charCodeAt(0).toString(16).toUpperCase();
		});
	};

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports.default = createTransitionManager;
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _computeChangedRoutes2 = __webpack_require__(196);
	
	var _computeChangedRoutes3 = _interopRequireDefault(_computeChangedRoutes2);
	
	var _TransitionUtils = __webpack_require__(197);
	
	var _isActive2 = __webpack_require__(199);
	
	var _isActive3 = _interopRequireDefault(_isActive2);
	
	var _getComponents = __webpack_require__(200);
	
	var _getComponents2 = _interopRequireDefault(_getComponents);
	
	var _matchRoutes = __webpack_require__(202);
	
	var _matchRoutes2 = _interopRequireDefault(_matchRoutes);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function hasAnyProperties(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p)) return true;
	  }return false;
	}
	
	function createTransitionManager(history, routes) {
	  var state = {};
	
	  // Signature should be (location, indexOnly), but needs to support (path,
	  // query, indexOnly)
	  function isActive(location) {
	    var indexOnlyOrDeprecatedQuery = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	    var deprecatedIndexOnly = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	    var indexOnly = void 0;
	    if (indexOnlyOrDeprecatedQuery && indexOnlyOrDeprecatedQuery !== true || deprecatedIndexOnly !== null) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`isActive(pathname, query, indexOnly) is deprecated; use `isActive(location, indexOnly)` with a location descriptor instead. http://tiny.cc/router-isActivedeprecated') : void 0;
	      location = { pathname: location, query: indexOnlyOrDeprecatedQuery };
	      indexOnly = deprecatedIndexOnly || false;
	    } else {
	      location = history.createLocation(location);
	      indexOnly = indexOnlyOrDeprecatedQuery;
	    }
	
	    return (0, _isActive3.default)(location, indexOnly, state.location, state.routes, state.params);
	  }
	
	  var partialNextState = void 0;
	
	  function match(location, callback) {
	    if (partialNextState && partialNextState.location === location) {
	      // Continue from where we left off.
	      finishMatch(partialNextState, callback);
	    } else {
	      (0, _matchRoutes2.default)(routes, location, function (error, nextState) {
	        if (error) {
	          callback(error);
	        } else if (nextState) {
	          finishMatch(_extends({}, nextState, { location: location }), callback);
	        } else {
	          callback();
	        }
	      });
	    }
	  }
	
	  function finishMatch(nextState, callback) {
	    var _computeChangedRoutes = (0, _computeChangedRoutes3.default)(state, nextState);
	
	    var leaveRoutes = _computeChangedRoutes.leaveRoutes;
	    var changeRoutes = _computeChangedRoutes.changeRoutes;
	    var enterRoutes = _computeChangedRoutes.enterRoutes;
	
	    (0, _TransitionUtils.runLeaveHooks)(leaveRoutes, state);
	
	    // Tear down confirmation hooks for left routes
	    leaveRoutes.filter(function (route) {
	      return enterRoutes.indexOf(route) === -1;
	    }).forEach(removeListenBeforeHooksForRoute);
	
	    // change and enter hooks are run in series
	    (0, _TransitionUtils.runChangeHooks)(changeRoutes, state, nextState, function (error, redirectInfo) {
	      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);
	
	      (0, _TransitionUtils.runEnterHooks)(enterRoutes, nextState, finishEnterHooks);
	    });
	
	    function finishEnterHooks(error, redirectInfo) {
	      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);
	
	      // TODO: Fetch components after state is updated.
	      (0, _getComponents2.default)(nextState, function (error, components) {
	        if (error) {
	          callback(error);
	        } else {
	          // TODO: Make match a pure function and have some other API
	          // for "match and update state".
	          callback(null, null, state = _extends({}, nextState, { components: components }));
	        }
	      });
	    }
	
	    function handleErrorOrRedirect(error, redirectInfo) {
	      if (error) callback(error);else callback(null, redirectInfo);
	    }
	  }
	
	  var RouteGuid = 1;
	
	  function getRouteID(route) {
	    var create = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
	
	    return route.__id__ || create && (route.__id__ = RouteGuid++);
	  }
	
	  var RouteHooks = Object.create(null);
	
	  function getRouteHooksForRoutes(routes) {
	    return routes.reduce(function (hooks, route) {
	      hooks.push.apply(hooks, RouteHooks[getRouteID(route)]);
	      return hooks;
	    }, []);
	  }
	
	  function transitionHook(location, callback) {
	    (0, _matchRoutes2.default)(routes, location, function (error, nextState) {
	      if (nextState == null) {
	        // TODO: We didn't actually match anything, but hang
	        // onto error/nextState so we don't have to matchRoutes
	        // again in the listen callback.
	        callback();
	        return;
	      }
	
	      // Cache some state here so we don't have to
	      // matchRoutes() again in the listen callback.
	      partialNextState = _extends({}, nextState, { location: location });
	
	      var hooks = getRouteHooksForRoutes((0, _computeChangedRoutes3.default)(state, partialNextState).leaveRoutes);
	
	      var result = void 0;
	      for (var i = 0, len = hooks.length; result == null && i < len; ++i) {
	        // Passing the location arg here indicates to
	        // the user that this is a transition hook.
	        result = hooks[i](location);
	      }
	
	      callback(result);
	    });
	  }
	
	  /* istanbul ignore next: untestable with Karma */
	  function beforeUnloadHook() {
	    // Synchronously check to see if any route hooks want
	    // to prevent the current window/tab from closing.
	    if (state.routes) {
	      var hooks = getRouteHooksForRoutes(state.routes);
	
	      var message = void 0;
	      for (var i = 0, len = hooks.length; typeof message !== 'string' && i < len; ++i) {
	        // Passing no args indicates to the user that this is a
	        // beforeunload hook. We don't know the next location.
	        message = hooks[i]();
	      }
	
	      return message;
	    }
	  }
	
	  var unlistenBefore = void 0,
	      unlistenBeforeUnload = void 0;
	
	  function removeListenBeforeHooksForRoute(route) {
	    var routeID = getRouteID(route, false);
	    if (!routeID) {
	      return;
	    }
	
	    delete RouteHooks[routeID];
	
	    if (!hasAnyProperties(RouteHooks)) {
	      // teardown transition & beforeunload hooks
	      if (unlistenBefore) {
	        unlistenBefore();
	        unlistenBefore = null;
	      }
	
	      if (unlistenBeforeUnload) {
	        unlistenBeforeUnload();
	        unlistenBeforeUnload = null;
	      }
	    }
	  }
	
	  /**
	   * Registers the given hook function to run before leaving the given route.
	   *
	   * During a normal transition, the hook function receives the next location
	   * as its only argument and can return either a prompt message (string) to show the user,
	   * to make sure they want to leave the page; or `false`, to prevent the transition.
	   * Any other return value will have no effect.
	   *
	   * During the beforeunload event (in browsers) the hook receives no arguments.
	   * In this case it must return a prompt message to prevent the transition.
	   *
	   * Returns a function that may be used to unbind the listener.
	   */
	  function listenBeforeLeavingRoute(route, hook) {
	    // TODO: Warn if they register for a route that isn't currently
	    // active. They're probably doing something wrong, like re-creating
	    // route objects on every location change.
	    var routeID = getRouteID(route);
	    var hooks = RouteHooks[routeID];
	
	    if (!hooks) {
	      var thereWereNoRouteHooks = !hasAnyProperties(RouteHooks);
	
	      RouteHooks[routeID] = [hook];
	
	      if (thereWereNoRouteHooks) {
	        // setup transition & beforeunload hooks
	        unlistenBefore = history.listenBefore(transitionHook);
	
	        if (history.listenBeforeUnload) unlistenBeforeUnload = history.listenBeforeUnload(beforeUnloadHook);
	      }
	    } else {
	      if (hooks.indexOf(hook) === -1) {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'adding multiple leave hooks for the same route is deprecated; manage multiple confirmations in your own code instead') : void 0;
	
	        hooks.push(hook);
	      }
	    }
	
	    return function () {
	      var hooks = RouteHooks[routeID];
	
	      if (hooks) {
	        var newHooks = hooks.filter(function (item) {
	          return item !== hook;
	        });
	
	        if (newHooks.length === 0) {
	          removeListenBeforeHooksForRoute(route);
	        } else {
	          RouteHooks[routeID] = newHooks;
	        }
	      }
	    };
	  }
	
	  /**
	   * This is the API for stateful environments. As the location
	   * changes, we update state and call the listener. We can also
	   * gracefully handle errors and redirects.
	   */
	  function listen(listener) {
	    // TODO: Only use a single history listener. Otherwise we'll
	    // end up with multiple concurrent calls to match.
	    return history.listen(function (location) {
	      if (state.location === location) {
	        listener(null, state);
	      } else {
	        match(location, function (error, redirectLocation, nextState) {
	          if (error) {
	            listener(error);
	          } else if (redirectLocation) {
	            history.replace(redirectLocation);
	          } else if (nextState) {
	            listener(null, nextState);
	          } else {
	            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'Location "%s" did not match any routes', location.pathname + location.search + location.hash) : void 0;
	          }
	        });
	      }
	    });
	  }
	
	  return {
	    isActive: isActive,
	    match: match,
	    listenBeforeLeavingRoute: listenBeforeLeavingRoute,
	    listen: listen
	  };
	}
	
	//export default useRoutes
	
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _PatternUtils = __webpack_require__(173);
	
	function routeParamsChanged(route, prevState, nextState) {
	  if (!route.path) return false;
	
	  var paramNames = (0, _PatternUtils.getParamNames)(route.path);
	
	  return paramNames.some(function (paramName) {
	    return prevState.params[paramName] !== nextState.params[paramName];
	  });
	}
	
	/**
	 * Returns an object of { leaveRoutes, changeRoutes, enterRoutes } determined by
	 * the change from prevState to nextState. We leave routes if either
	 * 1) they are not in the next state or 2) they are in the next state
	 * but their params have changed (i.e. /users/123 => /users/456).
	 *
	 * leaveRoutes are ordered starting at the leaf route of the tree
	 * we're leaving up to the common parent route. enterRoutes are ordered
	 * from the top of the tree we're entering down to the leaf route.
	 *
	 * changeRoutes are any routes that didn't leave or enter during
	 * the transition.
	 */
	function computeChangedRoutes(prevState, nextState) {
	  var prevRoutes = prevState && prevState.routes;
	  var nextRoutes = nextState.routes;
	
	  var leaveRoutes = void 0,
	      changeRoutes = void 0,
	      enterRoutes = void 0;
	  if (prevRoutes) {
	    (function () {
	      var parentIsLeaving = false;
	      leaveRoutes = prevRoutes.filter(function (route) {
	        if (parentIsLeaving) {
	          return true;
	        } else {
	          var isLeaving = nextRoutes.indexOf(route) === -1 || routeParamsChanged(route, prevState, nextState);
	          if (isLeaving) parentIsLeaving = true;
	          return isLeaving;
	        }
	      });
	
	      // onLeave hooks start at the leaf route.
	      leaveRoutes.reverse();
	
	      enterRoutes = [];
	      changeRoutes = [];
	
	      nextRoutes.forEach(function (route) {
	        var isNew = prevRoutes.indexOf(route) === -1;
	        var paramsChanged = leaveRoutes.indexOf(route) !== -1;
	
	        if (isNew || paramsChanged) enterRoutes.push(route);else changeRoutes.push(route);
	      });
	    })();
	  } else {
	    leaveRoutes = [];
	    changeRoutes = [];
	    enterRoutes = nextRoutes;
	  }
	
	  return {
	    leaveRoutes: leaveRoutes,
	    changeRoutes: changeRoutes,
	    enterRoutes: enterRoutes
	  };
	}
	
	exports.default = computeChangedRoutes;
	module.exports = exports['default'];

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.runEnterHooks = runEnterHooks;
	exports.runChangeHooks = runChangeHooks;
	exports.runLeaveHooks = runLeaveHooks;
	
	var _AsyncUtils = __webpack_require__(198);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function createTransitionHook(hook, route, asyncArity) {
	  return function () {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    hook.apply(route, args);
	
	    if (hook.length < asyncArity) {
	      var callback = args[args.length - 1];
	      // Assume hook executes synchronously and
	      // automatically call the callback.
	      callback();
	    }
	  };
	}
	
	function getEnterHooks(routes) {
	  return routes.reduce(function (hooks, route) {
	    if (route.onEnter) hooks.push(createTransitionHook(route.onEnter, route, 3));
	
	    return hooks;
	  }, []);
	}
	
	function getChangeHooks(routes) {
	  return routes.reduce(function (hooks, route) {
	    if (route.onChange) hooks.push(createTransitionHook(route.onChange, route, 4));
	    return hooks;
	  }, []);
	}
	
	function runTransitionHooks(length, iter, callback) {
	  if (!length) {
	    callback();
	    return;
	  }
	
	  var redirectInfo = void 0;
	  function replace(location, deprecatedPathname, deprecatedQuery) {
	    if (deprecatedPathname) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`replaceState(state, pathname, query) is deprecated; use `replace(location)` with a location descriptor instead. http://tiny.cc/router-isActivedeprecated') : void 0;
	      redirectInfo = {
	        pathname: deprecatedPathname,
	        query: deprecatedQuery,
	        state: location
	      };
	
	      return;
	    }
	
	    redirectInfo = location;
	  }
	
	  (0, _AsyncUtils.loopAsync)(length, function (index, next, done) {
	    iter(index, replace, function (error) {
	      if (error || redirectInfo) {
	        done(error, redirectInfo); // No need to continue.
	      } else {
	        next();
	      }
	    });
	  }, callback);
	}
	
	/**
	 * Runs all onEnter hooks in the given array of routes in order
	 * with onEnter(nextState, replace, callback) and calls
	 * callback(error, redirectInfo) when finished. The first hook
	 * to use replace short-circuits the loop.
	 *
	 * If a hook needs to run asynchronously, it may use the callback
	 * function. However, doing so will cause the transition to pause,
	 * which could lead to a non-responsive UI if the hook is slow.
	 */
	function runEnterHooks(routes, nextState, callback) {
	  var hooks = getEnterHooks(routes);
	  return runTransitionHooks(hooks.length, function (index, replace, next) {
	    hooks[index](nextState, replace, next);
	  }, callback);
	}
	
	/**
	 * Runs all onChange hooks in the given array of routes in order
	 * with onChange(prevState, nextState, replace, callback) and calls
	 * callback(error, redirectInfo) when finished. The first hook
	 * to use replace short-circuits the loop.
	 *
	 * If a hook needs to run asynchronously, it may use the callback
	 * function. However, doing so will cause the transition to pause,
	 * which could lead to a non-responsive UI if the hook is slow.
	 */
	function runChangeHooks(routes, state, nextState, callback) {
	  var hooks = getChangeHooks(routes);
	  return runTransitionHooks(hooks.length, function (index, replace, next) {
	    hooks[index](state, nextState, replace, next);
	  }, callback);
	}
	
	/**
	 * Runs all onLeave hooks in the given array of routes in order.
	 */
	function runLeaveHooks(routes, prevState) {
	  for (var i = 0, len = routes.length; i < len; ++i) {
	    if (routes[i].onLeave) routes[i].onLeave.call(routes[i], prevState);
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 198 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports.loopAsync = loopAsync;
	exports.mapAsync = mapAsync;
	function loopAsync(turns, work, callback) {
	  var currentTurn = 0,
	      isDone = false;
	  var sync = false,
	      hasNext = false,
	      doneArgs = void 0;
	
	  function done() {
	    isDone = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      doneArgs = [].concat(Array.prototype.slice.call(arguments));
	      return;
	    }
	
	    callback.apply(this, arguments);
	  }
	
	  function next() {
	    if (isDone) {
	      return;
	    }
	
	    hasNext = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      return;
	    }
	
	    sync = true;
	
	    while (!isDone && currentTurn < turns && hasNext) {
	      hasNext = false;
	      work.call(this, currentTurn++, next, done);
	    }
	
	    sync = false;
	
	    if (isDone) {
	      // This means the loop finished synchronously.
	      callback.apply(this, doneArgs);
	      return;
	    }
	
	    if (currentTurn >= turns && hasNext) {
	      isDone = true;
	      callback();
	    }
	  }
	
	  next();
	}
	
	function mapAsync(array, work, callback) {
	  var length = array.length;
	  var values = [];
	
	  if (length === 0) return callback(null, values);
	
	  var isDone = false,
	      doneCount = 0;
	
	  function done(index, error, value) {
	    if (isDone) return;
	
	    if (error) {
	      isDone = true;
	      callback(error);
	    } else {
	      values[index] = value;
	
	      isDone = ++doneCount === length;
	
	      if (isDone) callback(null, values);
	    }
	  }
	
	  array.forEach(function (item, index) {
	    work(item, index, function (error, value) {
	      done(index, error, value);
	    });
	  });
	}

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};
	
	exports.default = isActive;
	
	var _PatternUtils = __webpack_require__(173);
	
	function deepEqual(a, b) {
	  if (a == b) return true;
	
	  if (a == null || b == null) return false;
	
	  if (Array.isArray(a)) {
	    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
	      return deepEqual(item, b[index]);
	    });
	  }
	
	  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') {
	    for (var p in a) {
	      if (!Object.prototype.hasOwnProperty.call(a, p)) {
	        continue;
	      }
	
	      if (a[p] === undefined) {
	        if (b[p] !== undefined) {
	          return false;
	        }
	      } else if (!Object.prototype.hasOwnProperty.call(b, p)) {
	        return false;
	      } else if (!deepEqual(a[p], b[p])) {
	        return false;
	      }
	    }
	
	    return true;
	  }
	
	  return String(a) === String(b);
	}
	
	/**
	 * Returns true if the current pathname matches the supplied one, net of
	 * leading and trailing slash normalization. This is sufficient for an
	 * indexOnly route match.
	 */
	function pathIsActive(pathname, currentPathname) {
	  // Normalize leading slash for consistency. Leading slash on pathname has
	  // already been normalized in isActive. See caveat there.
	  if (currentPathname.charAt(0) !== '/') {
	    currentPathname = '/' + currentPathname;
	  }
	
	  // Normalize the end of both path names too. Maybe `/foo/` shouldn't show
	  // `/foo` as active, but in this case, we would already have failed the
	  // match.
	  if (pathname.charAt(pathname.length - 1) !== '/') {
	    pathname += '/';
	  }
	  if (currentPathname.charAt(currentPathname.length - 1) !== '/') {
	    currentPathname += '/';
	  }
	
	  return currentPathname === pathname;
	}
	
	/**
	 * Returns true if the given pathname matches the active routes and params.
	 */
	function routeIsActive(pathname, routes, params) {
	  var remainingPathname = pathname,
	      paramNames = [],
	      paramValues = [];
	
	  // for...of would work here but it's probably slower post-transpilation.
	  for (var i = 0, len = routes.length; i < len; ++i) {
	    var route = routes[i];
	    var pattern = route.path || '';
	
	    if (pattern.charAt(0) === '/') {
	      remainingPathname = pathname;
	      paramNames = [];
	      paramValues = [];
	    }
	
	    if (remainingPathname !== null && pattern) {
	      var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);
	      if (matched) {
	        remainingPathname = matched.remainingPathname;
	        paramNames = [].concat(paramNames, matched.paramNames);
	        paramValues = [].concat(paramValues, matched.paramValues);
	      } else {
	        remainingPathname = null;
	      }
	
	      if (remainingPathname === '') {
	        // We have an exact match on the route. Just check that all the params
	        // match.
	        // FIXME: This doesn't work on repeated params.
	        return paramNames.every(function (paramName, index) {
	          return String(paramValues[index]) === String(params[paramName]);
	        });
	      }
	    }
	  }
	
	  return false;
	}
	
	/**
	 * Returns true if all key/value pairs in the given query are
	 * currently active.
	 */
	function queryIsActive(query, activeQuery) {
	  if (activeQuery == null) return query == null;
	
	  if (query == null) return true;
	
	  return deepEqual(query, activeQuery);
	}
	
	/**
	 * Returns true if a <Link> to the given pathname/query combination is
	 * currently active.
	 */
	function isActive(_ref, indexOnly, currentLocation, routes, params) {
	  var pathname = _ref.pathname;
	  var query = _ref.query;
	
	  if (currentLocation == null) return false;
	
	  // TODO: This is a bit ugly. It keeps around support for treating pathnames
	  // without preceding slashes as absolute paths, but possibly also works
	  // around the same quirks with basenames as in matchRoutes.
	  if (pathname.charAt(0) !== '/') {
	    pathname = '/' + pathname;
	  }
	
	  if (!pathIsActive(pathname, currentLocation.pathname)) {
	    // The path check is necessary and sufficient for indexOnly, but otherwise
	    // we still need to check the routes.
	    if (indexOnly || !routeIsActive(pathname, routes, params)) {
	      return false;
	    }
	  }
	
	  return queryIsActive(query, currentLocation.query);
	}
	module.exports = exports['default'];

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _AsyncUtils = __webpack_require__(198);
	
	var _makeStateWithLocation = __webpack_require__(201);
	
	var _makeStateWithLocation2 = _interopRequireDefault(_makeStateWithLocation);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function getComponentsForRoute(nextState, route, callback) {
	  if (route.component || route.components) {
	    callback(null, route.component || route.components);
	    return;
	  }
	
	  var getComponent = route.getComponent || route.getComponents;
	  if (!getComponent) {
	    callback();
	    return;
	  }
	
	  var location = nextState.location;
	
	  var nextStateWithLocation = (0, _makeStateWithLocation2.default)(nextState, location);
	
	  getComponent.call(route, nextStateWithLocation, callback);
	}
	
	/**
	 * Asynchronously fetches all components needed for the given router
	 * state and calls callback(error, components) when finished.
	 *
	 * Note: This operation may finish synchronously if no routes have an
	 * asynchronous getComponents method.
	 */
	function getComponents(nextState, callback) {
	  (0, _AsyncUtils.mapAsync)(nextState.routes, function (route, index, callback) {
	    getComponentsForRoute(nextState, route, callback);
	  }, callback);
	}
	
	exports.default = getComponents;
	module.exports = exports['default'];

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports.default = makeStateWithLocation;
	
	var _deprecateObjectProperties = __webpack_require__(169);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function makeStateWithLocation(state, location) {
	  if (process.env.NODE_ENV !== 'production' && _deprecateObjectProperties.canUseMembrane) {
	    var stateWithLocation = _extends({}, state);
	
	    // I don't use deprecateObjectProperties here because I want to keep the
	    // same code path between development and production, in that we just
	    // assign extra properties to the copy of the state object in both cases.
	
	    var _loop = function _loop(prop) {
	      if (!Object.prototype.hasOwnProperty.call(location, prop)) {
	        return 'continue';
	      }
	
	      Object.defineProperty(stateWithLocation, prop, {
	        get: function get() {
	          process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'Accessing location properties directly from the first argument to `getComponent`, `getComponents`, `getChildRoutes`, and `getIndexRoute` is deprecated. That argument is now the router state (`nextState` or `partialNextState`) rather than the location. To access the location, use `nextState.location` or `partialNextState.location`.') : void 0;
	          return location[prop];
	        }
	      });
	    };
	
	    for (var prop in location) {
	      var _ret = _loop(prop);
	
	      if (_ret === 'continue') continue;
	    }
	
	    return stateWithLocation;
	  }
	
	  return _extends({}, state, location);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};
	
	exports.default = matchRoutes;
	
	var _AsyncUtils = __webpack_require__(198);
	
	var _makeStateWithLocation = __webpack_require__(201);
	
	var _makeStateWithLocation2 = _interopRequireDefault(_makeStateWithLocation);
	
	var _PatternUtils = __webpack_require__(173);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _RouteUtils = __webpack_require__(167);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function getChildRoutes(route, location, paramNames, paramValues, callback) {
	  if (route.childRoutes) {
	    return [null, route.childRoutes];
	  }
	  if (!route.getChildRoutes) {
	    return [];
	  }
	
	  var sync = true,
	      result = void 0;
	
	  var partialNextState = {
	    location: location,
	    params: createParams(paramNames, paramValues)
	  };
	
	  var partialNextStateWithLocation = (0, _makeStateWithLocation2.default)(partialNextState, location);
	
	  route.getChildRoutes(partialNextStateWithLocation, function (error, childRoutes) {
	    childRoutes = !error && (0, _RouteUtils.createRoutes)(childRoutes);
	    if (sync) {
	      result = [error, childRoutes];
	      return;
	    }
	
	    callback(error, childRoutes);
	  });
	
	  sync = false;
	  return result; // Might be undefined.
	}
	
	function getIndexRoute(route, location, paramNames, paramValues, callback) {
	  if (route.indexRoute) {
	    callback(null, route.indexRoute);
	  } else if (route.getIndexRoute) {
	    var partialNextState = {
	      location: location,
	      params: createParams(paramNames, paramValues)
	    };
	
	    var partialNextStateWithLocation = (0, _makeStateWithLocation2.default)(partialNextState, location);
	
	    route.getIndexRoute(partialNextStateWithLocation, function (error, indexRoute) {
	      callback(error, !error && (0, _RouteUtils.createRoutes)(indexRoute)[0]);
	    });
	  } else if (route.childRoutes) {
	    (function () {
	      var pathless = route.childRoutes.filter(function (childRoute) {
	        return !childRoute.path;
	      });
	
	      (0, _AsyncUtils.loopAsync)(pathless.length, function (index, next, done) {
	        getIndexRoute(pathless[index], location, paramNames, paramValues, function (error, indexRoute) {
	          if (error || indexRoute) {
	            var routes = [pathless[index]].concat(Array.isArray(indexRoute) ? indexRoute : [indexRoute]);
	            done(error, routes);
	          } else {
	            next();
	          }
	        });
	      }, function (err, routes) {
	        callback(null, routes);
	      });
	    })();
	  } else {
	    callback();
	  }
	}
	
	function assignParams(params, paramNames, paramValues) {
	  return paramNames.reduce(function (params, paramName, index) {
	    var paramValue = paramValues && paramValues[index];
	
	    if (Array.isArray(params[paramName])) {
	      params[paramName].push(paramValue);
	    } else if (paramName in params) {
	      params[paramName] = [params[paramName], paramValue];
	    } else {
	      params[paramName] = paramValue;
	    }
	
	    return params;
	  }, params);
	}
	
	function createParams(paramNames, paramValues) {
	  return assignParams({}, paramNames, paramValues);
	}
	
	function matchRouteDeep(route, location, remainingPathname, paramNames, paramValues, callback) {
	  var pattern = route.path || '';
	
	  if (pattern.charAt(0) === '/') {
	    remainingPathname = location.pathname;
	    paramNames = [];
	    paramValues = [];
	  }
	
	  // Only try to match the path if the route actually has a pattern, and if
	  // we're not just searching for potential nested absolute paths.
	  if (remainingPathname !== null && pattern) {
	    try {
	      var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);
	      if (matched) {
	        remainingPathname = matched.remainingPathname;
	        paramNames = [].concat(paramNames, matched.paramNames);
	        paramValues = [].concat(paramValues, matched.paramValues);
	      } else {
	        remainingPathname = null;
	      }
	    } catch (error) {
	      callback(error);
	    }
	
	    // By assumption, pattern is non-empty here, which is the prerequisite for
	    // actually terminating a match.
	    if (remainingPathname === '') {
	      var _ret2 = function () {
	        var match = {
	          routes: [route],
	          params: createParams(paramNames, paramValues)
	        };
	
	        getIndexRoute(route, location, paramNames, paramValues, function (error, indexRoute) {
	          if (error) {
	            callback(error);
	          } else {
	            if (Array.isArray(indexRoute)) {
	              var _match$routes;
	
	              process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(indexRoute.every(function (route) {
	                return !route.path;
	              }), 'Index routes should not have paths') : void 0;
	              (_match$routes = match.routes).push.apply(_match$routes, indexRoute);
	            } else if (indexRoute) {
	              process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!indexRoute.path, 'Index routes should not have paths') : void 0;
	              match.routes.push(indexRoute);
	            }
	
	            callback(null, match);
	          }
	        });
	
	        return {
	          v: void 0
	        };
	      }();
	
	      if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
	    }
	  }
	
	  if (remainingPathname != null || route.childRoutes) {
	    // Either a) this route matched at least some of the path or b)
	    // we don't have to load this route's children asynchronously. In
	    // either case continue checking for matches in the subtree.
	    var onChildRoutes = function onChildRoutes(error, childRoutes) {
	      if (error) {
	        callback(error);
	      } else if (childRoutes) {
	        // Check the child routes to see if any of them match.
	        matchRoutes(childRoutes, location, function (error, match) {
	          if (error) {
	            callback(error);
	          } else if (match) {
	            // A child route matched! Augment the match and pass it up the stack.
	            match.routes.unshift(route);
	            callback(null, match);
	          } else {
	            callback();
	          }
	        }, remainingPathname, paramNames, paramValues);
	      } else {
	        callback();
	      }
	    };
	
	    var result = getChildRoutes(route, location, paramNames, paramValues, onChildRoutes);
	    if (result) {
	      onChildRoutes.apply(undefined, result);
	    }
	  } else {
	    callback();
	  }
	}
	
	/**
	 * Asynchronously matches the given location to a set of routes and calls
	 * callback(error, state) when finished. The state object will have the
	 * following properties:
	 *
	 * - routes       An array of routes that matched, in hierarchical order
	 * - params       An object of URL parameters
	 *
	 * Note: This operation may finish synchronously if no routes have an
	 * asynchronous getChildRoutes method.
	 */
	function matchRoutes(routes, location, callback, remainingPathname) {
	  var paramNames = arguments.length <= 4 || arguments[4] === undefined ? [] : arguments[4];
	  var paramValues = arguments.length <= 5 || arguments[5] === undefined ? [] : arguments[5];
	
	  if (remainingPathname === undefined) {
	    // TODO: This is a little bit ugly, but it works around a quirk in history
	    // that strips the leading slash from pathnames when using basenames with
	    // trailing slashes.
	    if (location.pathname.charAt(0) !== '/') {
	      location = _extends({}, location, {
	        pathname: '/' + location.pathname
	      });
	    }
	    remainingPathname = location.pathname;
	  }
	
	  (0, _AsyncUtils.loopAsync)(routes.length, function (index, next, done) {
	    matchRouteDeep(routes[index], location, remainingPathname, paramNames, paramValues, function (error, match) {
	      if (error || match) {
	        done(error, match);
	      } else {
	        next();
	      }
	    });
	  }, callback);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _deprecateObjectProperties = __webpack_require__(169);
	
	var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);
	
	var _getRouteParams = __webpack_require__(204);
	
	var _getRouteParams2 = _interopRequireDefault(_getRouteParams);
	
	var _RouteUtils = __webpack_require__(167);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var _React$PropTypes = _react2.default.PropTypes;
	var array = _React$PropTypes.array;
	var func = _React$PropTypes.func;
	var object = _React$PropTypes.object;
	
	/**
	 * A <RouterContext> renders the component tree for a given router state
	 * and sets the history object and the current location in context.
	 */
	
	var RouterContext = _react2.default.createClass({
	  displayName: 'RouterContext',
	
	  propTypes: {
	    history: object,
	    router: object.isRequired,
	    location: object.isRequired,
	    routes: array.isRequired,
	    params: object.isRequired,
	    components: array.isRequired,
	    createElement: func.isRequired
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      createElement: _react2.default.createElement
	    };
	  },
	
	  childContextTypes: {
	    history: object,
	    location: object.isRequired,
	    router: object.isRequired
	  },
	
	  getChildContext: function getChildContext() {
	    var _props = this.props;
	    var router = _props.router;
	    var history = _props.history;
	    var location = _props.location;
	
	    if (!router) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`<RouterContext>` expects a `router` rather than a `history`') : void 0;
	
	      router = _extends({}, history, {
	        setRouteLeaveHook: history.listenBeforeLeavingRoute
	      });
	      delete router.listenBeforeLeavingRoute;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      location = (0, _deprecateObjectProperties2.default)(location, '`context.location` is deprecated, please use a route component\'s `props.location` instead. http://tiny.cc/router-accessinglocation');
	    }
	
	    return { history: history, location: location, router: router };
	  },
	  createElement: function createElement(component, props) {
	    return component == null ? null : this.props.createElement(component, props);
	  },
	  render: function render() {
	    var _this = this;
	
	    var _props2 = this.props;
	    var history = _props2.history;
	    var location = _props2.location;
	    var routes = _props2.routes;
	    var params = _props2.params;
	    var components = _props2.components;
	
	    var element = null;
	
	    if (components) {
	      element = components.reduceRight(function (element, components, index) {
	        if (components == null) return element; // Don't create new children; use the grandchildren.
	
	        var route = routes[index];
	        var routeParams = (0, _getRouteParams2.default)(route, params);
	        var props = {
	          history: history,
	          location: location,
	          params: params,
	          route: route,
	          routeParams: routeParams,
	          routes: routes
	        };
	
	        if ((0, _RouteUtils.isReactChildren)(element)) {
	          props.children = element;
	        } else if (element) {
	          for (var prop in element) {
	            if (Object.prototype.hasOwnProperty.call(element, prop)) props[prop] = element[prop];
	          }
	        }
	
	        if ((typeof components === 'undefined' ? 'undefined' : _typeof(components)) === 'object') {
	          var elements = {};
	
	          for (var key in components) {
	            if (Object.prototype.hasOwnProperty.call(components, key)) {
	              // Pass through the key as a prop to createElement to allow
	              // custom createElement functions to know which named component
	              // they're rendering, for e.g. matching up to fetched data.
	              elements[key] = _this.createElement(components[key], _extends({
	                key: key }, props));
	            }
	          }
	
	          return elements;
	        }
	
	        return _this.createElement(components, props);
	      }, element);
	    }
	
	    !(element === null || element === false || _react2.default.isValidElement(element)) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'The root route must render a single element') : (0, _invariant2.default)(false) : void 0;
	
	    return element;
	  }
	});
	
	exports.default = RouterContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _PatternUtils = __webpack_require__(173);
	
	/**
	 * Extracts an object of params the given route cares about from
	 * the given params object.
	 */
	function getRouteParams(route, params) {
	  var routeParams = {};
	
	  if (!route.path) return routeParams;
	
	  (0, _PatternUtils.getParamNames)(route.path).forEach(function (p) {
	    if (Object.prototype.hasOwnProperty.call(params, p)) {
	      routeParams[p] = params[p];
	    }
	  });
	
	  return routeParams;
	}
	
	exports.default = getRouteParams;
	module.exports = exports['default'];

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports.createRouterObject = createRouterObject;
	exports.createRoutingHistory = createRoutingHistory;
	
	var _deprecateObjectProperties = __webpack_require__(169);
	
	var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function createRouterObject(history, transitionManager) {
	  return _extends({}, history, {
	    setRouteLeaveHook: transitionManager.listenBeforeLeavingRoute,
	    isActive: transitionManager.isActive
	  });
	}
	
	// deprecated
	function createRoutingHistory(history, transitionManager) {
	  history = _extends({}, history, transitionManager);
	
	  if (process.env.NODE_ENV !== 'production') {
	    history = (0, _deprecateObjectProperties2.default)(history, '`props.history` and `context.history` are deprecated. Please use `context.router`. http://tiny.cc/router-contextchanges');
	  }
	
	  return history;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _PropTypes = __webpack_require__(168);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	  var target = {};for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	  }return target;
	}
	
	var _React$PropTypes = _react2.default.PropTypes;
	var bool = _React$PropTypes.bool;
	var object = _React$PropTypes.object;
	var string = _React$PropTypes.string;
	var func = _React$PropTypes.func;
	var oneOfType = _React$PropTypes.oneOfType;
	
	function isLeftClickEvent(event) {
	  return event.button === 0;
	}
	
	function isModifiedEvent(event) {
	  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
	}
	
	// TODO: De-duplicate against hasAnyProperties in createTransitionManager.
	function isEmptyObject(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p)) return false;
	  }return true;
	}
	
	function createLocationDescriptor(to, _ref) {
	  var query = _ref.query;
	  var hash = _ref.hash;
	  var state = _ref.state;
	
	  if (query || hash || state) {
	    return { pathname: to, query: query, hash: hash, state: state };
	  }
	
	  return to;
	}
	
	/**
	 * A <Link> is used to create an <a> element that links to a route.
	 * When that route is active, the link gets the value of its
	 * activeClassName prop.
	 *
	 * For example, assuming you have the following route:
	 *
	 *   <Route path="/posts/:postID" component={Post} />
	 *
	 * You could use the following component to link to that route:
	 *
	 *   <Link to={`/posts/${post.id}`} />
	 *
	 * Links may pass along location state and/or query string parameters
	 * in the state/query props, respectively.
	 *
	 *   <Link ... query={{ show: true }} state={{ the: 'state' }} />
	 */
	var Link = _react2.default.createClass({
	  displayName: 'Link',
	
	  contextTypes: {
	    router: _PropTypes.routerShape
	  },
	
	  propTypes: {
	    to: oneOfType([string, object]),
	    query: object,
	    hash: string,
	    state: object,
	    activeStyle: object,
	    activeClassName: string,
	    onlyActiveOnIndex: bool.isRequired,
	    onClick: func,
	    target: string
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      onlyActiveOnIndex: false,
	      style: {}
	    };
	  },
	  handleClick: function handleClick(event) {
	    if (this.props.onClick) this.props.onClick(event);
	
	    if (event.defaultPrevented) return;
	
	    !this.context.router ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Link>s rendered outside of a router context cannot navigate.') : (0, _invariant2.default)(false) : void 0;
	
	    if (isModifiedEvent(event) || !isLeftClickEvent(event)) return;
	
	    // If target prop is set (e.g. to "_blank"), let browser handle link.
	    /* istanbul ignore if: untestable with Karma */
	    if (this.props.target) return;
	
	    event.preventDefault();
	
	    var _props = this.props;
	    var to = _props.to;
	    var query = _props.query;
	    var hash = _props.hash;
	    var state = _props.state;
	
	    var location = createLocationDescriptor(to, { query: query, hash: hash, state: state });
	
	    this.context.router.push(location);
	  },
	  render: function render() {
	    var _props2 = this.props;
	    var to = _props2.to;
	    var query = _props2.query;
	    var hash = _props2.hash;
	    var state = _props2.state;
	    var activeClassName = _props2.activeClassName;
	    var activeStyle = _props2.activeStyle;
	    var onlyActiveOnIndex = _props2.onlyActiveOnIndex;
	
	    var props = _objectWithoutProperties(_props2, ['to', 'query', 'hash', 'state', 'activeClassName', 'activeStyle', 'onlyActiveOnIndex']);
	
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!(query || hash || state), 'the `query`, `hash`, and `state` props on `<Link>` are deprecated, use `<Link to={{ pathname, query, hash, state }}/>. http://tiny.cc/router-isActivedeprecated') : void 0;
	
	    // Ignore if rendered outside the context of router, simplifies unit testing.
	    var router = this.context.router;
	
	    if (router) {
	      // If user does not specify a `to` prop, return an empty anchor tag.
	      if (to == null) {
	        return _react2.default.createElement('a', props);
	      }
	
	      var location = createLocationDescriptor(to, { query: query, hash: hash, state: state });
	      props.href = router.createHref(location);
	
	      if (activeClassName || activeStyle != null && !isEmptyObject(activeStyle)) {
	        if (router.isActive(location, onlyActiveOnIndex)) {
	          if (activeClassName) {
	            if (props.className) {
	              props.className += ' ' + activeClassName;
	            } else {
	              props.className = activeClassName;
	            }
	          }
	
	          if (activeStyle) props.style = _extends({}, props.style, activeStyle);
	        }
	      }
	    }
	
	    return _react2.default.createElement('a', _extends({}, props, { onClick: this.handleClick }));
	  }
	});
	
	exports.default = Link;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Link = __webpack_require__(206);
	
	var _Link2 = _interopRequireDefault(_Link);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	/**
	 * An <IndexLink> is used to link to an <IndexRoute>.
	 */
	var IndexLink = _react2.default.createClass({
	  displayName: 'IndexLink',
	  render: function render() {
	    return _react2.default.createElement(_Link2.default, _extends({}, this.props, { onlyActiveOnIndex: true }));
	  }
	});
	
	exports.default = IndexLink;
	module.exports = exports['default'];

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports.default = withRouter;
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _hoistNonReactStatics = __webpack_require__(209);
	
	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);
	
	var _PropTypes = __webpack_require__(168);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function getDisplayName(WrappedComponent) {
	  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
	}
	
	function withRouter(WrappedComponent, options) {
	  var withRef = options && options.withRef;
	
	  var WithRouter = _react2.default.createClass({
	    displayName: 'WithRouter',
	
	    contextTypes: { router: _PropTypes.routerShape },
	    propTypes: { router: _PropTypes.routerShape },
	
	    getWrappedInstance: function getWrappedInstance() {
	      !withRef ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'To access the wrapped instance, you need to specify ' + '`{ withRef: true }` as the second argument of the withRouter() call.') : (0, _invariant2.default)(false) : void 0;
	
	      return this.wrappedInstance;
	    },
	    render: function render() {
	      var _this = this;
	
	      var router = this.props.router || this.context.router;
	      var props = _extends({}, this.props, { router: router });
	
	      if (withRef) {
	        props.ref = function (c) {
	          _this.wrappedInstance = c;
	        };
	      }
	
	      return _react2.default.createElement(WrappedComponent, props);
	    }
	  });
	
	  WithRouter.displayName = 'withRouter(' + getDisplayName(WrappedComponent) + ')';
	  WithRouter.WrappedComponent = WrappedComponent;
	
	  return (0, _hoistNonReactStatics2.default)(WithRouter, WrappedComponent);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 209 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
	'use strict';
	
	var REACT_STATICS = {
	    childContextTypes: true,
	    contextTypes: true,
	    defaultProps: true,
	    displayName: true,
	    getDefaultProps: true,
	    mixins: true,
	    propTypes: true,
	    type: true
	};
	
	var KNOWN_STATICS = {
	    name: true,
	    length: true,
	    prototype: true,
	    caller: true,
	    arguments: true,
	    arity: true
	};
	
	var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';
	
	module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
	    if (typeof sourceComponent !== 'string') {
	        // don't hoist over string (html) components
	        var keys = Object.getOwnPropertyNames(sourceComponent);
	
	        /* istanbul ignore else */
	        if (isGetOwnPropertySymbolsAvailable) {
	            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
	        }
	
	        for (var i = 0; i < keys.length; ++i) {
	            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
	                try {
	                    targetComponent[keys[i]] = sourceComponent[keys[i]];
	                } catch (error) {}
	            }
	        }
	    }
	
	    return targetComponent;
	};

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Redirect = __webpack_require__(211);
	
	var _Redirect2 = _interopRequireDefault(_Redirect);
	
	var _InternalPropTypes = __webpack_require__(172);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var _React$PropTypes = _react2.default.PropTypes;
	var string = _React$PropTypes.string;
	var object = _React$PropTypes.object;
	
	/**
	 * An <IndexRedirect> is used to redirect from an indexRoute.
	 */
	
	var IndexRedirect = _react2.default.createClass({
	  displayName: 'IndexRedirect',
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
	      /* istanbul ignore else: sanity check */
	      if (parentRoute) {
	        parentRoute.indexRoute = _Redirect2.default.createRouteFromReactElement(element);
	      } else {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'An <IndexRedirect> does not make sense at the root of your route config') : void 0;
	      }
	    }
	  },
	
	  propTypes: {
	    to: string.isRequired,
	    query: object,
	    state: object,
	    onEnter: _InternalPropTypes.falsy,
	    children: _InternalPropTypes.falsy
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<IndexRedirect> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = IndexRedirect;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(167);
	
	var _PatternUtils = __webpack_require__(173);
	
	var _InternalPropTypes = __webpack_require__(172);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var _React$PropTypes = _react2.default.PropTypes;
	var string = _React$PropTypes.string;
	var object = _React$PropTypes.object;
	
	/**
	 * A <Redirect> is used to declare another URL path a client should
	 * be sent to when they request a given URL.
	 *
	 * Redirects are placed alongside routes in the route configuration
	 * and are traversed in the same manner.
	 */
	
	var Redirect = _react2.default.createClass({
	  displayName: 'Redirect',
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element) {
	      var route = (0, _RouteUtils.createRouteFromReactElement)(element);
	
	      if (route.from) route.path = route.from;
	
	      route.onEnter = function (nextState, replace) {
	        var location = nextState.location;
	        var params = nextState.params;
	
	        var pathname = void 0;
	        if (route.to.charAt(0) === '/') {
	          pathname = (0, _PatternUtils.formatPattern)(route.to, params);
	        } else if (!route.to) {
	          pathname = location.pathname;
	        } else {
	          var routeIndex = nextState.routes.indexOf(route);
	          var parentPattern = Redirect.getRoutePattern(nextState.routes, routeIndex - 1);
	          var pattern = parentPattern.replace(/\/*$/, '/') + route.to;
	          pathname = (0, _PatternUtils.formatPattern)(pattern, params);
	        }
	
	        replace({
	          pathname: pathname,
	          query: route.query || location.query,
	          state: route.state || location.state
	        });
	      };
	
	      return route;
	    },
	    getRoutePattern: function getRoutePattern(routes, routeIndex) {
	      var parentPattern = '';
	
	      for (var i = routeIndex; i >= 0; i--) {
	        var route = routes[i];
	        var pattern = route.path || '';
	
	        parentPattern = pattern.replace(/\/*$/, '/') + parentPattern;
	
	        if (pattern.indexOf('/') === 0) break;
	      }
	
	      return '/' + parentPattern;
	    }
	  },
	
	  propTypes: {
	    path: string,
	    from: string, // Alias for path
	    to: string.isRequired,
	    query: object,
	    state: object,
	    onEnter: _InternalPropTypes.falsy,
	    children: _InternalPropTypes.falsy
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Redirect> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = Redirect;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(167);
	
	var _InternalPropTypes = __webpack_require__(172);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var func = _react2.default.PropTypes.func;
	
	/**
	 * An <IndexRoute> is used to specify its parent's <Route indexRoute> in
	 * a JSX route config.
	 */
	
	var IndexRoute = _react2.default.createClass({
	  displayName: 'IndexRoute',
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
	      /* istanbul ignore else: sanity check */
	      if (parentRoute) {
	        parentRoute.indexRoute = (0, _RouteUtils.createRouteFromReactElement)(element);
	      } else {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'An <IndexRoute> does not make sense at the root of your route config') : void 0;
	      }
	    }
	  },
	
	  propTypes: {
	    path: _InternalPropTypes.falsy,
	    component: _InternalPropTypes.component,
	    components: _InternalPropTypes.components,
	    getComponent: func,
	    getComponents: func
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<IndexRoute> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = IndexRoute;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(167);
	
	var _InternalPropTypes = __webpack_require__(172);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var _React$PropTypes = _react2.default.PropTypes;
	var string = _React$PropTypes.string;
	var func = _React$PropTypes.func;
	
	/**
	 * A <Route> is used to declare which components are rendered to the
	 * page when the URL matches a given pattern.
	 *
	 * Routes are arranged in a nested tree structure. When a new URL is
	 * requested, the tree is searched depth-first to find a route whose
	 * path matches the URL.  When one is found, all routes in the tree
	 * that lead to it are considered "active" and their components are
	 * rendered into the DOM, nested in the same order as in the tree.
	 */
	
	var Route = _react2.default.createClass({
	  displayName: 'Route',
	
	  statics: {
	    createRouteFromReactElement: _RouteUtils.createRouteFromReactElement
	  },
	
	  propTypes: {
	    path: string,
	    component: _InternalPropTypes.component,
	    components: _InternalPropTypes.components,
	    getComponent: func,
	    getComponents: func
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Route> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = Route;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _InternalPropTypes = __webpack_require__(172);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	/**
	 * A mixin that adds the "history" instance variable to components.
	 */
	var History = {
	
	  contextTypes: {
	    history: _InternalPropTypes.history
	  },
	
	  componentWillMount: function componentWillMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'the `History` mixin is deprecated, please access `context.router` with your own `contextTypes`. http://tiny.cc/router-historymixin') : void 0;
	    this.history = this.context.history;
	  }
	};
	
	exports.default = History;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var object = _react2.default.PropTypes.object;
	
	/**
	 * The Lifecycle mixin adds the routerWillLeave lifecycle method to a
	 * component that may be used to cancel a transition or prompt the user
	 * for confirmation.
	 *
	 * On standard transitions, routerWillLeave receives a single argument: the
	 * location we're transitioning to. To cancel the transition, return false.
	 * To prompt the user for confirmation, return a prompt message (string).
	 *
	 * During the beforeunload event (assuming you're using the useBeforeUnload
	 * history enhancer), routerWillLeave does not receive a location object
	 * because it isn't possible for us to know the location we're transitioning
	 * to. In this case routerWillLeave must return a prompt message to prevent
	 * the user from closing the window/tab.
	 */
	
	var Lifecycle = {
	
	  contextTypes: {
	    history: object.isRequired,
	    // Nested children receive the route as context, either
	    // set by the route component using the RouteContext mixin
	    // or by some other ancestor.
	    route: object
	  },
	
	  propTypes: {
	    // Route components receive the route object as a prop.
	    route: object
	  },
	
	  componentDidMount: function componentDidMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'the `Lifecycle` mixin is deprecated, please use `context.router.setRouteLeaveHook(route, hook)`. http://tiny.cc/router-lifecyclemixin') : void 0;
	    !this.routerWillLeave ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'The Lifecycle mixin requires you to define a routerWillLeave method') : (0, _invariant2.default)(false) : void 0;
	
	    var route = this.props.route || this.context.route;
	
	    !route ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'The Lifecycle mixin must be used on either a) a <Route component> or ' + 'b) a descendant of a <Route component> that uses the RouteContext mixin') : (0, _invariant2.default)(false) : void 0;
	
	    this._unlistenBeforeLeavingRoute = this.context.history.listenBeforeLeavingRoute(route, this.routerWillLeave);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    if (this._unlistenBeforeLeavingRoute) this._unlistenBeforeLeavingRoute();
	  }
	};
	
	exports.default = Lifecycle;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var object = _react2.default.PropTypes.object;
	
	/**
	 * The RouteContext mixin provides a convenient way for route
	 * components to set the route in context. This is needed for
	 * routes that render elements that want to use the Lifecycle
	 * mixin to prevent transitions.
	 */
	
	var RouteContext = {
	
	  propTypes: {
	    route: object.isRequired
	  },
	
	  childContextTypes: {
	    route: object.isRequired
	  },
	
	  getChildContext: function getChildContext() {
	    return {
	      route: this.props.route
	    };
	  },
	  componentWillMount: function componentWillMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'The `RouteContext` mixin is deprecated. You can provide `this.props.route` on context with your own `contextTypes`. http://tiny.cc/router-routecontextmixin') : void 0;
	  }
	};
	
	exports.default = RouteContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _useQueries = __webpack_require__(192);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _createTransitionManager = __webpack_require__(195);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	  var target = {};for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	  }return target;
	}
	
	/**
	 * Returns a new createHistory function that may be used to create
	 * history objects that know about routing.
	 *
	 * Enhances history objects with the following methods:
	 *
	 * - listen((error, nextState) => {})
	 * - listenBeforeLeavingRoute(route, (nextLocation) => {})
	 * - match(location, (error, redirectLocation, nextState) => {})
	 * - isActive(pathname, query, indexOnly=false)
	 */
	function useRoutes(createHistory) {
	  process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`useRoutes` is deprecated. Please use `createTransitionManager` instead.') : void 0;
	
	  return function () {
	    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var routes = _ref.routes;
	
	    var options = _objectWithoutProperties(_ref, ['routes']);
	
	    var history = (0, _useQueries2.default)(createHistory)(options);
	    var transitionManager = (0, _createTransitionManager2.default)(history, routes);
	    return _extends({}, history, transitionManager);
	  };
	}
	
	exports.default = useRoutes;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _RouterContext = __webpack_require__(203);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var RoutingContext = _react2.default.createClass({
	  displayName: 'RoutingContext',
	  componentWillMount: function componentWillMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`RoutingContext` has been renamed to `RouterContext`. Please use `import { RouterContext } from \'react-router\'`. http://tiny.cc/router-routercontext') : void 0;
	  },
	  render: function render() {
	    return _react2.default.createElement(_RouterContext2.default, this.props);
	  }
	});
	
	exports.default = RoutingContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _Actions = __webpack_require__(178);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _createMemoryHistory = __webpack_require__(220);
	
	var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);
	
	var _createTransitionManager = __webpack_require__(195);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _RouteUtils = __webpack_require__(167);
	
	var _RouterUtils = __webpack_require__(205);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	  var target = {};for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	  }return target;
	}
	
	/**
	 * A high-level API to be used for server-side rendering.
	 *
	 * This function matches a location to a set of routes and calls
	 * callback(error, redirectLocation, renderProps) when finished.
	 *
	 * Note: You probably don't want to use this in a browser unless you're using
	 * server-side rendering with async routes.
	 */
	function match(_ref, callback) {
	  var history = _ref.history;
	  var routes = _ref.routes;
	  var location = _ref.location;
	
	  var options = _objectWithoutProperties(_ref, ['history', 'routes', 'location']);
	
	  !(history || location) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'match needs a history or a location') : (0, _invariant2.default)(false) : void 0;
	
	  history = history ? history : (0, _createMemoryHistory2.default)(options);
	  var transitionManager = (0, _createTransitionManager2.default)(history, (0, _RouteUtils.createRoutes)(routes));
	
	  var unlisten = void 0;
	
	  if (location) {
	    // Allow match({ location: '/the/path', ... })
	    location = history.createLocation(location);
	  } else {
	    // Pick up the location from the history via synchronous history.listen
	    // call if needed.
	    unlisten = history.listen(function (historyLocation) {
	      location = historyLocation;
	    });
	  }
	
	  var router = (0, _RouterUtils.createRouterObject)(history, transitionManager);
	  history = (0, _RouterUtils.createRoutingHistory)(history, transitionManager);
	
	  transitionManager.match(location, function (error, redirectLocation, nextState) {
	    callback(error, redirectLocation && router.createLocation(redirectLocation, _Actions.REPLACE), nextState && _extends({}, nextState, {
	      history: history,
	      router: router,
	      matchContext: { history: history, transitionManager: transitionManager, router: router }
	    }));
	
	    // Defer removing the listener to here to prevent DOM histories from having
	    // to unwind DOM event listeners unnecessarily, in case callback renders a
	    // <Router> and attaches another history listener.
	    if (unlisten) {
	      unlisten();
	    }
	  });
	}
	
	exports.default = match;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = createMemoryHistory;
	
	var _useQueries = __webpack_require__(192);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _useBasename = __webpack_require__(221);
	
	var _useBasename2 = _interopRequireDefault(_useBasename);
	
	var _createMemoryHistory = __webpack_require__(222);
	
	var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function createMemoryHistory(options) {
	  // signatures and type checking differ between `useRoutes` and
	  // `createMemoryHistory`, have to create `memoryHistory` first because
	  // `useQueries` doesn't understand the signature
	  var memoryHistory = (0, _createMemoryHistory2.default)(options);
	  var createHistory = function createHistory() {
	    return memoryHistory;
	  };
	  var history = (0, _useQueries2.default)((0, _useBasename2.default)(createHistory))(options);
	  history.__v2_compatible__ = true;
	  return history;
	}
	module.exports = exports['default'];

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _ExecutionEnvironment = __webpack_require__(180);
	
	var _PathUtils = __webpack_require__(179);
	
	var _runTransitionHook = __webpack_require__(190);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _deprecate = __webpack_require__(191);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	function useBasename(createHistory) {
	  return function () {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var history = createHistory(options);
	
	    var basename = options.basename;
	
	    var checkedBaseHref = false;
	
	    function checkBaseHref() {
	      if (checkedBaseHref) {
	        return;
	      }
	
	      // Automatically use the value of <base href> in HTML
	      // documents as basename if it's not explicitly given.
	      if (basename == null && _ExecutionEnvironment.canUseDOM) {
	        var base = document.getElementsByTagName('base')[0];
	        var baseHref = base && base.getAttribute('href');
	
	        if (baseHref != null) {
	          basename = baseHref;
	
	          process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'Automatically setting basename using <base href> is deprecated and will ' + 'be removed in the next major release. The semantics of <base href> are ' + 'subtly different from basename. Please pass the basename explicitly in ' + 'the options to createHistory') : undefined;
	        }
	      }
	
	      checkedBaseHref = true;
	    }
	
	    function addBasename(location) {
	      checkBaseHref();
	
	      if (basename && location.basename == null) {
	        if (location.pathname.indexOf(basename) === 0) {
	          location.pathname = location.pathname.substring(basename.length);
	          location.basename = basename;
	
	          if (location.pathname === '') location.pathname = '/';
	        } else {
	          location.basename = '';
	        }
	      }
	
	      return location;
	    }
	
	    function prependBasename(location) {
	      checkBaseHref();
	
	      if (!basename) return location;
	
	      if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	      var pname = location.pathname;
	      var normalizedBasename = basename.slice(-1) === '/' ? basename : basename + '/';
	      var normalizedPathname = pname.charAt(0) === '/' ? pname.slice(1) : pname;
	      var pathname = normalizedBasename + normalizedPathname;
	
	      return _extends({}, location, {
	        pathname: pathname
	      });
	    }
	
	    // Override all read methods with basename-aware versions.
	    function listenBefore(hook) {
	      return history.listenBefore(function (location, callback) {
	        _runTransitionHook2['default'](hook, addBasename(location), callback);
	      });
	    }
	
	    function listen(listener) {
	      return history.listen(function (location) {
	        listener(addBasename(location));
	      });
	    }
	
	    // Override all write methods with basename-aware versions.
	    function push(location) {
	      history.push(prependBasename(location));
	    }
	
	    function replace(location) {
	      history.replace(prependBasename(location));
	    }
	
	    function createPath(location) {
	      return history.createPath(prependBasename(location));
	    }
	
	    function createHref(location) {
	      return history.createHref(prependBasename(location));
	    }
	
	    function createLocation(location) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      return addBasename(history.createLocation.apply(history, [prependBasename(location)].concat(args)));
	    }
	
	    // deprecated
	    function pushState(state, path) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      push(_extends({ state: state }, path));
	    }
	
	    // deprecated
	    function replaceState(state, path) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      replace(_extends({ state: state }, path));
	    }
	
	    return _extends({}, history, {
	      listenBefore: listenBefore,
	      listen: listen,
	      push: push,
	      replace: replace,
	      createPath: createPath,
	      createHref: createHref,
	      createLocation: createLocation,
	
	      pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
	      replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
	    });
	  };
	}
	
	exports['default'] = useBasename;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _PathUtils = __webpack_require__(179);
	
	var _Actions = __webpack_require__(178);
	
	var _createHistory = __webpack_require__(184);
	
	var _createHistory2 = _interopRequireDefault(_createHistory);
	
	function createStateStorage(entries) {
	  return entries.filter(function (entry) {
	    return entry.state;
	  }).reduce(function (memo, entry) {
	    memo[entry.key] = entry.state;
	    return memo;
	  }, {});
	}
	
	function createMemoryHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  if (Array.isArray(options)) {
	    options = { entries: options };
	  } else if (typeof options === 'string') {
	    options = { entries: [options] };
	  }
	
	  var history = _createHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: saveState,
	    go: go
	  }));
	
	  var _options = options;
	  var entries = _options.entries;
	  var current = _options.current;
	
	  if (typeof entries === 'string') {
	    entries = [entries];
	  } else if (!Array.isArray(entries)) {
	    entries = ['/'];
	  }
	
	  entries = entries.map(function (entry) {
	    var key = history.createKey();
	
	    if (typeof entry === 'string') return { pathname: entry, key: key };
	
	    if ((typeof entry === 'undefined' ? 'undefined' : _typeof(entry)) === 'object' && entry) return _extends({}, entry, { key: key });
	
	     true ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Unable to create history entry from %s', entry) : _invariant2['default'](false) : undefined;
	  });
	
	  if (current == null) {
	    current = entries.length - 1;
	  } else {
	    !(current >= 0 && current < entries.length) ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Current index must be >= 0 and < %s, was %s', entries.length, current) : _invariant2['default'](false) : undefined;
	  }
	
	  var storage = createStateStorage(entries);
	
	  function saveState(key, state) {
	    storage[key] = state;
	  }
	
	  function readState(key) {
	    return storage[key];
	  }
	
	  function getCurrentLocation() {
	    var entry = entries[current];
	    var basename = entry.basename;
	    var pathname = entry.pathname;
	    var search = entry.search;
	
	    var path = (basename || '') + pathname + (search || '');
	
	    var key = undefined,
	        state = undefined;
	    if (entry.key) {
	      key = entry.key;
	      state = readState(key);
	    } else {
	      key = history.createKey();
	      state = null;
	      entry.key = key;
	    }
	
	    var location = _PathUtils.parsePath(path);
	
	    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
	  }
	
	  function canGo(n) {
	    var index = current + n;
	    return index >= 0 && index < entries.length;
	  }
	
	  function go(n) {
	    if (n) {
	      if (!canGo(n)) {
	        process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'Cannot go(%s) there is not enough history', n) : undefined;
	        return;
	      }
	
	      current += n;
	
	      var currentLocation = getCurrentLocation();
	
	      // change action to POP
	      history.transitionTo(_extends({}, currentLocation, { action: _Actions.POP }));
	    }
	  }
	
	  function finishTransition(location) {
	    switch (location.action) {
	      case _Actions.PUSH:
	        current += 1;
	
	        // if we are not on the top of stack
	        // remove rest and push new
	        if (current < entries.length) entries.splice(current);
	
	        entries.push(location);
	        saveState(location.key, location.state);
	        break;
	      case _Actions.REPLACE:
	        entries[current] = location;
	        saveState(location.key, location.state);
	        break;
	    }
	  }
	
	  return history;
	}
	
	exports['default'] = createMemoryHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = useRouterHistory;
	
	var _useQueries = __webpack_require__(192);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _useBasename = __webpack_require__(221);
	
	var _useBasename2 = _interopRequireDefault(_useBasename);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function useRouterHistory(createHistory) {
	  return function (options) {
	    var history = (0, _useQueries2.default)((0, _useBasename2.default)(createHistory))(options);
	    history.__v2_compatible__ = true;
	    return history;
	  };
	}
	module.exports = exports['default'];

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _RouterContext = __webpack_require__(203);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	exports.default = function () {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    middlewares.forEach(function (middleware, index) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(middleware.renderRouterContext || middleware.renderRouteComponent, 'The middleware specified at index ' + index + ' does not appear to be ' + 'a valid React Router middleware.') : void 0;
	    });
	  }
	
	  var withContext = middlewares.map(function (middleware) {
	    return middleware.renderRouterContext;
	  }).filter(Boolean);
	  var withComponent = middlewares.map(function (middleware) {
	    return middleware.renderRouteComponent;
	  }).filter(Boolean);
	
	  var makeCreateElement = function makeCreateElement() {
	    var baseCreateElement = arguments.length <= 0 || arguments[0] === undefined ? _react.createElement : arguments[0];
	    return function (Component, props) {
	      return withComponent.reduceRight(function (previous, renderRouteComponent) {
	        return renderRouteComponent(previous, props);
	      }, baseCreateElement(Component, props));
	    };
	  };
	
	  return function (renderProps) {
	    return withContext.reduceRight(function (previous, renderRouterContext) {
	      return renderRouterContext(previous, renderProps);
	    }, _react2.default.createElement(_RouterContext2.default, _extends({}, renderProps, {
	      createElement: makeCreateElement(renderProps.createElement)
	    })));
	  };
	};
	
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _createBrowserHistory = __webpack_require__(226);
	
	var _createBrowserHistory2 = _interopRequireDefault(_createBrowserHistory);
	
	var _createRouterHistory = __webpack_require__(227);
	
	var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	exports.default = (0, _createRouterHistory2.default)(_createBrowserHistory2.default);
	module.exports = exports['default'];

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Actions = __webpack_require__(178);
	
	var _PathUtils = __webpack_require__(179);
	
	var _ExecutionEnvironment = __webpack_require__(180);
	
	var _DOMUtils = __webpack_require__(181);
	
	var _DOMStateStorage = __webpack_require__(182);
	
	var _createDOMHistory = __webpack_require__(183);
	
	var _createDOMHistory2 = _interopRequireDefault(_createDOMHistory);
	
	/**
	 * Creates and returns a history object that uses HTML5's history API
	 * (pushState, replaceState, and the popstate event) to manage history.
	 * This is the recommended method of managing history in browsers because
	 * it provides the cleanest URLs.
	 *
	 * Note: In browsers that do not support the HTML5 history API full
	 * page reloads will be used to preserve URLs.
	 */
	function createBrowserHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Browser history needs a DOM') : _invariant2['default'](false) : undefined;
	
	  var forceRefresh = options.forceRefresh;
	
	  var isSupported = _DOMUtils.supportsHistory();
	  var useRefresh = !isSupported || forceRefresh;
	
	  function getCurrentLocation(historyState) {
	    try {
	      historyState = historyState || window.history.state || {};
	    } catch (e) {
	      historyState = {};
	    }
	
	    var path = _DOMUtils.getWindowPath();
	    var _historyState = historyState;
	    var key = _historyState.key;
	
	    var state = undefined;
	    if (key) {
	      state = _DOMStateStorage.readState(key);
	    } else {
	      state = null;
	      key = history.createKey();
	
	      if (isSupported) window.history.replaceState(_extends({}, historyState, { key: key }), null);
	    }
	
	    var location = _PathUtils.parsePath(path);
	
	    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
	  }
	
	  function startPopStateListener(_ref) {
	    var transitionTo = _ref.transitionTo;
	
	    function popStateListener(event) {
	      if (event.state === undefined) return; // Ignore extraneous popstate events in WebKit.
	
	      transitionTo(getCurrentLocation(event.state));
	    }
	
	    _DOMUtils.addEventListener(window, 'popstate', popStateListener);
	
	    return function () {
	      _DOMUtils.removeEventListener(window, 'popstate', popStateListener);
	    };
	  }
	
	  function finishTransition(location) {
	    var basename = location.basename;
	    var pathname = location.pathname;
	    var search = location.search;
	    var hash = location.hash;
	    var state = location.state;
	    var action = location.action;
	    var key = location.key;
	
	    if (action === _Actions.POP) return; // Nothing to do.
	
	    _DOMStateStorage.saveState(key, state);
	
	    var path = (basename || '') + pathname + search + hash;
	    var historyState = {
	      key: key
	    };
	
	    if (action === _Actions.PUSH) {
	      if (useRefresh) {
	        window.location.href = path;
	        return false; // Prevent location update.
	      } else {
	        window.history.pushState(historyState, null, path);
	      }
	    } else {
	      // REPLACE
	      if (useRefresh) {
	        window.location.replace(path);
	        return false; // Prevent location update.
	      } else {
	        window.history.replaceState(historyState, null, path);
	      }
	    }
	  }
	
	  var history = _createDOMHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: _DOMStateStorage.saveState
	  }));
	
	  var listenerCount = 0,
	      stopPopStateListener = undefined;
	
	  function listenBefore(listener) {
	    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);
	
	    var unlisten = history.listenBefore(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopPopStateListener();
	    };
	  }
	
	  function listen(listener) {
	    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);
	
	    var unlisten = history.listen(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopPopStateListener();
	    };
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);
	
	    history.registerTransitionHook(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    history.unregisterTransitionHook(hook);
	
	    if (--listenerCount === 0) stopPopStateListener();
	  }
	
	  return _extends({}, history, {
	    listenBefore: listenBefore,
	    listen: listen,
	    registerTransitionHook: registerTransitionHook,
	    unregisterTransitionHook: unregisterTransitionHook
	  });
	}
	
	exports['default'] = createBrowserHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	exports.default = function (createHistory) {
	  var history = void 0;
	  if (canUseDOM) history = (0, _useRouterHistory2.default)(createHistory)();
	  return history;
	};
	
	var _useRouterHistory = __webpack_require__(223);
	
	var _useRouterHistory2 = _interopRequireDefault(_useRouterHistory);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	module.exports = exports['default'];

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _createHashHistory = __webpack_require__(176);
	
	var _createHashHistory2 = _interopRequireDefault(_createHashHistory);
	
	var _createRouterHistory = __webpack_require__(227);
	
	var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	exports.default = (0, _createRouterHistory2.default)(_createHashHistory2.default);
	module.exports = exports['default'];

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	var React = __webpack_require__(8);
	var uuid = __webpack_require__(234);
	
	var TodoList = __webpack_require__(257);
	var AddTodo = __webpack_require__(259);
	var TodoSearch = __webpack_require__(260);
	var TodoAPI = __webpack_require__(261);
	
	var TodoApp = React.createClass({
	  displayName: 'TodoApp',
	
	  getInitialState: function getInitialState() {
	    return {
	      showCompleted: false,
	      searchText: "",
	      todos: TodoAPI.getTodos()
	    };
	  },
	  componentDidUpdate: function componentDidUpdate() {
	    TodoAPI.setTodos(this.state.todos);
	  },
	  handleToggle: function handleToggle(id) {
	    var updatedTodos = this.state.todos.map(function (todo) {
	      if (todo.id === id) {
	        todo.completed = !todo.completed;
	      }
	      return todo;
	    });
	
	    this.setState({ todos: updatedTodos });
	  },
	  handleSearch: function handleSearch(showCompleted, searchText) {
	    this.setState({
	      showCompleted: showCompleted,
	      searchText: searchText.toLowerCase()
	    });
	  },
	  handleAddTodo: function handleAddTodo(text) {
	    this.setState({
	      todos: [].concat(_toConsumableArray(this.state.todos), [{
	        id: uuid(),
	        text: text
	      }])
	    });
	  },
	  render: function render() {
	    var todos = this.state.todos;
	
	    return React.createElement(
	      'div',
	      null,
	      React.createElement(TodoSearch, { onSearch: this.handleSearch }),
	      React.createElement(TodoList, { todos: todos, onToggle: this.handleToggle }),
	      React.createElement(AddTodo, { onAddTodo: this.handleAddTodo })
	    );
	  }
	});
	
	module.exports = TodoApp;

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(231);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(233)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./app.scss", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./app.scss");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(232)();
	// imports
	
	
	// module
	exports.push([module.id, "@charset \"UTF-8\";\n/**\n * Foundation for Sites by ZURB\n * Version 6.2.3\n * foundation.zurb.com\n * Licensed under MIT Open Source\n */\n/*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */\n/**\n   * 1. Set default font family to sans-serif.\n   * 2. Prevent iOS and IE text size adjust after device orientation change,\n   *    without disabling user zoom.\n   */\nhtml {\n  font-family: sans-serif;\n  /* 1 */\n  -ms-text-size-adjust: 100%;\n  /* 2 */\n  -webkit-text-size-adjust: 100%;\n  /* 2 */ }\n\n/**\n   * Remove default margin.\n   */\nbody {\n  margin: 0; }\n\n/* HTML5 display definitions\n     ========================================================================== */\n/**\n   * Correct `block` display not defined for any HTML5 element in IE 8/9.\n   * Correct `block` display not defined for `details` or `summary` in IE 10/11\n   * and Firefox.\n   * Correct `block` display not defined for `main` in IE 11.\n   */\narticle,\naside,\ndetails,\nfigcaption,\nfigure,\nfooter,\nheader,\nhgroup,\nmain,\nmenu,\nnav,\nsection,\nsummary {\n  display: block; }\n\n/**\n   * 1. Correct `inline-block` display not defined in IE 8/9.\n   * 2. Normalize vertical alignment of `progress` in Chrome, Firefox, and Opera.\n   */\naudio,\ncanvas,\nprogress,\nvideo {\n  display: inline-block;\n  /* 1 */\n  vertical-align: baseline;\n  /* 2 */ }\n\n/**\n   * Prevent modern browsers from displaying `audio` without controls.\n   * Remove excess height in iOS 5 devices.\n   */\naudio:not([controls]) {\n  display: none;\n  height: 0; }\n\n/**\n   * Address `[hidden]` styling not present in IE 8/9/10.\n   * Hide the `template` element in IE 8/9/10/11, Safari, and Firefox < 22.\n   */\n[hidden],\ntemplate {\n  display: none; }\n\n/* Links\n     ========================================================================== */\n/**\n   * Remove the gray background color from active links in IE 10.\n   */\na {\n  background-color: transparent; }\n\n/**\n   * Improve readability of focused elements when they are also in an\n   * active/hover state.\n   */\na:active,\na:hover {\n  outline: 0; }\n\n/* Text-level semantics\n     ========================================================================== */\n/**\n   * Address styling not present in IE 8/9/10/11, Safari, and Chrome.\n   */\nabbr[title] {\n  border-bottom: 1px dotted; }\n\n/**\n   * Address style set to `bolder` in Firefox 4+, Safari, and Chrome.\n   */\nb,\nstrong {\n  font-weight: bold; }\n\n/**\n   * Address styling not present in Safari and Chrome.\n   */\ndfn {\n  font-style: italic; }\n\n/**\n   * Address variable `h1` font-size and margin within `section` and `article`\n   * contexts in Firefox 4+, Safari, and Chrome.\n   */\nh1 {\n  font-size: 2em;\n  margin: 0.67em 0; }\n\n/**\n   * Address styling not present in IE 8/9.\n   */\nmark {\n  background: #ff0;\n  color: #000; }\n\n/**\n   * Address inconsistent and variable font size in all browsers.\n   */\nsmall {\n  font-size: 80%; }\n\n/**\n   * Prevent `sub` and `sup` affecting `line-height` in all browsers.\n   */\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline; }\n\nsup {\n  top: -0.5em; }\n\nsub {\n  bottom: -0.25em; }\n\n/* Embedded content\n     ========================================================================== */\n/**\n   * Remove border when inside `a` element in IE 8/9/10.\n   */\nimg {\n  border: 0; }\n\n/**\n   * Correct overflow not hidden in IE 9/10/11.\n   */\nsvg:not(:root) {\n  overflow: hidden; }\n\n/* Grouping content\n     ========================================================================== */\n/**\n   * Address margin not present in IE 8/9 and Safari.\n   */\nfigure {\n  margin: 1em 40px; }\n\n/**\n   * Address differences between Firefox and other browsers.\n   */\nhr {\n  box-sizing: content-box;\n  height: 0; }\n\n/**\n   * Contain overflow in all browsers.\n   */\npre {\n  overflow: auto; }\n\n/**\n   * Address odd `em`-unit font size rendering in all browsers.\n   */\ncode,\nkbd,\npre,\nsamp {\n  font-family: monospace, monospace;\n  font-size: 1em; }\n\n/* Forms\n     ========================================================================== */\n/**\n   * Known limitation: by default, Chrome and Safari on OS X allow very limited\n   * styling of `select`, unless a `border` property is set.\n   */\n/**\n   * 1. Correct color not being inherited.\n   *    Known issue: affects color of disabled elements.\n   * 2. Correct font properties not being inherited.\n   * 3. Address margins set differently in Firefox 4+, Safari, and Chrome.\n   */\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  color: inherit;\n  /* 1 */\n  font: inherit;\n  /* 2 */\n  margin: 0;\n  /* 3 */ }\n\n/**\n   * Address `overflow` set to `hidden` in IE 8/9/10/11.\n   */\nbutton {\n  overflow: visible; }\n\n/**\n   * Address inconsistent `text-transform` inheritance for `button` and `select`.\n   * All other form control elements do not inherit `text-transform` values.\n   * Correct `button` style inheritance in Firefox, IE 8/9/10/11, and Opera.\n   * Correct `select` style inheritance in Firefox.\n   */\nbutton,\nselect {\n  text-transform: none; }\n\n/**\n   * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`\n   *    and `video` controls.\n   * 2. Correct inability to style clickable `input` types in iOS.\n   * 3. Improve usability and consistency of cursor style between image-type\n   *    `input` and others.\n   */\nbutton,\nhtml input[type=\"button\"],\ninput[type=\"reset\"],\ninput[type=\"submit\"] {\n  -webkit-appearance: button;\n  /* 2 */\n  cursor: pointer;\n  /* 3 */ }\n\n/**\n   * Re-set default cursor for disabled elements.\n   */\nbutton[disabled],\nhtml input[disabled] {\n  cursor: not-allowed; }\n\n/**\n   * Remove inner padding and border in Firefox 4+.\n   */\nbutton::-moz-focus-inner,\ninput::-moz-focus-inner {\n  border: 0;\n  padding: 0; }\n\n/**\n   * Address Firefox 4+ setting `line-height` on `input` using `!important` in\n   * the UA stylesheet.\n   */\ninput {\n  line-height: normal; }\n\n/**\n   * It's recommended that you don't attempt to style these elements.\n   * Firefox's implementation doesn't respect box-sizing, padding, or width.\n   *\n   * 1. Address box sizing set to `content-box` in IE 8/9/10.\n   * 2. Remove excess padding in IE 8/9/10.\n   */\ninput[type=\"checkbox\"],\ninput[type=\"radio\"] {\n  box-sizing: border-box;\n  /* 1 */\n  padding: 0;\n  /* 2 */ }\n\n/**\n   * Fix the cursor style for Chrome's increment/decrement buttons. For certain\n   * `font-size` values of the `input`, it causes the cursor style of the\n   * decrement button to change from `default` to `text`.\n   */\ninput[type=\"number\"]::-webkit-inner-spin-button,\ninput[type=\"number\"]::-webkit-outer-spin-button {\n  height: auto; }\n\n/**\n   * 1. Address `appearance` set to `searchfield` in Safari and Chrome.\n   * 2. Address `box-sizing` set to `border-box` in Safari and Chrome.\n   */\ninput[type=\"search\"] {\n  -webkit-appearance: textfield;\n  /* 1 */\n  box-sizing: content-box;\n  /* 2 */ }\n\n/**\n   * Remove inner padding and search cancel button in Safari and Chrome on OS X.\n   * Safari (but not Chrome) clips the cancel button when the search input has\n   * padding (and `textfield` appearance).\n   */\ninput[type=\"search\"]::-webkit-search-cancel-button,\ninput[type=\"search\"]::-webkit-search-decoration {\n  -webkit-appearance: none; }\n\n/**\n   * Define consistent border, margin, and padding.\n   * [NOTE] We don't enable this ruleset in Foundation, because we want the <fieldset> element to have plain styling.\n   */\n/* fieldset {\n    border: 1px solid #c0c0c0;\n    margin: 0 2px;\n    padding: 0.35em 0.625em 0.75em;\n  } */\n/**\n   * 1. Correct `color` not being inherited in IE 8/9/10/11.\n   * 2. Remove padding so people aren't caught out if they zero out fieldsets.\n   */\nlegend {\n  border: 0;\n  /* 1 */\n  padding: 0;\n  /* 2 */ }\n\n/**\n   * Remove default vertical scrollbar in IE 8/9/10/11.\n   */\ntextarea {\n  overflow: auto; }\n\n/**\n   * Don't inherit the `font-weight` (applied by a rule above).\n   * NOTE: the default cannot safely be changed in Chrome and Safari on OS X.\n   */\noptgroup {\n  font-weight: bold; }\n\n/* Tables\n     ========================================================================== */\n/**\n   * Remove most spacing between table cells.\n   */\ntable {\n  border-collapse: collapse;\n  border-spacing: 0; }\n\ntd,\nth {\n  padding: 0; }\n\n.foundation-mq {\n  font-family: \"small=0em&medium=40em&large=64em&xlarge=75em&xxlarge=90em\"; }\n\nhtml {\n  font-size: 100%;\n  box-sizing: border-box; }\n\n*,\n*::before,\n*::after {\n  box-sizing: inherit; }\n\nbody {\n  padding: 0;\n  margin: 0;\n  font-family: \"Helvetica Neue\", Helvetica, Roboto, Arial, sans-serif;\n  font-weight: normal;\n  line-height: 1.5;\n  color: #0a0a0a;\n  background: #fefefe;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale; }\n\nimg {\n  max-width: 100%;\n  height: auto;\n  -ms-interpolation-mode: bicubic;\n  display: inline-block;\n  vertical-align: middle; }\n\ntextarea {\n  height: auto;\n  min-height: 50px;\n  border-radius: 0; }\n\nselect {\n  width: 100%;\n  border-radius: 0; }\n\n#map_canvas img,\n#map_canvas embed,\n#map_canvas object,\n.map_canvas img,\n.map_canvas embed,\n.map_canvas object,\n.mqa-display img,\n.mqa-display embed,\n.mqa-display object {\n  max-width: none !important; }\n\nbutton {\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  background: transparent;\n  padding: 0;\n  border: 0;\n  border-radius: 0;\n  line-height: 1; }\n  [data-whatinput='mouse'] button {\n    outline: 0; }\n\n.is-visible {\n  display: block !important; }\n\n.is-hidden {\n  display: none !important; }\n\n.row {\n  max-width: 75rem;\n  margin-left: auto;\n  margin-right: auto; }\n  .row::before, .row::after {\n    content: ' ';\n    display: table; }\n  .row::after {\n    clear: both; }\n  .row.collapse > .column, .row.collapse > .columns {\n    padding-left: 0;\n    padding-right: 0; }\n  .row .row {\n    max-width: none;\n    margin-left: -0.625rem;\n    margin-right: -0.625rem; }\n    @media screen and (min-width: 40em) {\n      .row .row {\n        margin-left: -0.9375rem;\n        margin-right: -0.9375rem; } }\n    .row .row.collapse {\n      margin-left: 0;\n      margin-right: 0; }\n  .row.expanded {\n    max-width: none; }\n    .row.expanded .row {\n      margin-left: auto;\n      margin-right: auto; }\n\n.column, .columns {\n  width: 100%;\n  float: left;\n  padding-left: 0.625rem;\n  padding-right: 0.625rem; }\n  @media screen and (min-width: 40em) {\n    .column, .columns {\n      padding-left: 0.9375rem;\n      padding-right: 0.9375rem; } }\n  .column:last-child:not(:first-child), .columns:last-child:not(:first-child) {\n    float: right; }\n  .column.end:last-child:last-child, .end.columns:last-child:last-child {\n    float: left; }\n\n.column.row.row, .row.row.columns {\n  float: none; }\n  .row .column.row.row, .row .row.row.columns {\n    padding-left: 0;\n    padding-right: 0;\n    margin-left: 0;\n    margin-right: 0; }\n\n.small-1 {\n  width: 8.33333%; }\n\n.small-push-1 {\n  position: relative;\n  left: 8.33333%; }\n\n.small-pull-1 {\n  position: relative;\n  left: -8.33333%; }\n\n.small-offset-0 {\n  margin-left: 0%; }\n\n.small-2 {\n  width: 16.66667%; }\n\n.small-push-2 {\n  position: relative;\n  left: 16.66667%; }\n\n.small-pull-2 {\n  position: relative;\n  left: -16.66667%; }\n\n.small-offset-1 {\n  margin-left: 8.33333%; }\n\n.small-3 {\n  width: 25%; }\n\n.small-push-3 {\n  position: relative;\n  left: 25%; }\n\n.small-pull-3 {\n  position: relative;\n  left: -25%; }\n\n.small-offset-2 {\n  margin-left: 16.66667%; }\n\n.small-4 {\n  width: 33.33333%; }\n\n.small-push-4 {\n  position: relative;\n  left: 33.33333%; }\n\n.small-pull-4 {\n  position: relative;\n  left: -33.33333%; }\n\n.small-offset-3 {\n  margin-left: 25%; }\n\n.small-5 {\n  width: 41.66667%; }\n\n.small-push-5 {\n  position: relative;\n  left: 41.66667%; }\n\n.small-pull-5 {\n  position: relative;\n  left: -41.66667%; }\n\n.small-offset-4 {\n  margin-left: 33.33333%; }\n\n.small-6 {\n  width: 50%; }\n\n.small-push-6 {\n  position: relative;\n  left: 50%; }\n\n.small-pull-6 {\n  position: relative;\n  left: -50%; }\n\n.small-offset-5 {\n  margin-left: 41.66667%; }\n\n.small-7 {\n  width: 58.33333%; }\n\n.small-push-7 {\n  position: relative;\n  left: 58.33333%; }\n\n.small-pull-7 {\n  position: relative;\n  left: -58.33333%; }\n\n.small-offset-6 {\n  margin-left: 50%; }\n\n.small-8 {\n  width: 66.66667%; }\n\n.small-push-8 {\n  position: relative;\n  left: 66.66667%; }\n\n.small-pull-8 {\n  position: relative;\n  left: -66.66667%; }\n\n.small-offset-7 {\n  margin-left: 58.33333%; }\n\n.small-9 {\n  width: 75%; }\n\n.small-push-9 {\n  position: relative;\n  left: 75%; }\n\n.small-pull-9 {\n  position: relative;\n  left: -75%; }\n\n.small-offset-8 {\n  margin-left: 66.66667%; }\n\n.small-10 {\n  width: 83.33333%; }\n\n.small-push-10 {\n  position: relative;\n  left: 83.33333%; }\n\n.small-pull-10 {\n  position: relative;\n  left: -83.33333%; }\n\n.small-offset-9 {\n  margin-left: 75%; }\n\n.small-11 {\n  width: 91.66667%; }\n\n.small-push-11 {\n  position: relative;\n  left: 91.66667%; }\n\n.small-pull-11 {\n  position: relative;\n  left: -91.66667%; }\n\n.small-offset-10 {\n  margin-left: 83.33333%; }\n\n.small-12 {\n  width: 100%; }\n\n.small-offset-11 {\n  margin-left: 91.66667%; }\n\n.small-up-1 > .column, .small-up-1 > .columns {\n  width: 100%;\n  float: left; }\n  .small-up-1 > .column:nth-of-type(1n), .small-up-1 > .columns:nth-of-type(1n) {\n    clear: none; }\n  .small-up-1 > .column:nth-of-type(1n+1), .small-up-1 > .columns:nth-of-type(1n+1) {\n    clear: both; }\n  .small-up-1 > .column:last-child, .small-up-1 > .columns:last-child {\n    float: left; }\n\n.small-up-2 > .column, .small-up-2 > .columns {\n  width: 50%;\n  float: left; }\n  .small-up-2 > .column:nth-of-type(1n), .small-up-2 > .columns:nth-of-type(1n) {\n    clear: none; }\n  .small-up-2 > .column:nth-of-type(2n+1), .small-up-2 > .columns:nth-of-type(2n+1) {\n    clear: both; }\n  .small-up-2 > .column:last-child, .small-up-2 > .columns:last-child {\n    float: left; }\n\n.small-up-3 > .column, .small-up-3 > .columns {\n  width: 33.33333%;\n  float: left; }\n  .small-up-3 > .column:nth-of-type(1n), .small-up-3 > .columns:nth-of-type(1n) {\n    clear: none; }\n  .small-up-3 > .column:nth-of-type(3n+1), .small-up-3 > .columns:nth-of-type(3n+1) {\n    clear: both; }\n  .small-up-3 > .column:last-child, .small-up-3 > .columns:last-child {\n    float: left; }\n\n.small-up-4 > .column, .small-up-4 > .columns {\n  width: 25%;\n  float: left; }\n  .small-up-4 > .column:nth-of-type(1n), .small-up-4 > .columns:nth-of-type(1n) {\n    clear: none; }\n  .small-up-4 > .column:nth-of-type(4n+1), .small-up-4 > .columns:nth-of-type(4n+1) {\n    clear: both; }\n  .small-up-4 > .column:last-child, .small-up-4 > .columns:last-child {\n    float: left; }\n\n.small-up-5 > .column, .small-up-5 > .columns {\n  width: 20%;\n  float: left; }\n  .small-up-5 > .column:nth-of-type(1n), .small-up-5 > .columns:nth-of-type(1n) {\n    clear: none; }\n  .small-up-5 > .column:nth-of-type(5n+1), .small-up-5 > .columns:nth-of-type(5n+1) {\n    clear: both; }\n  .small-up-5 > .column:last-child, .small-up-5 > .columns:last-child {\n    float: left; }\n\n.small-up-6 > .column, .small-up-6 > .columns {\n  width: 16.66667%;\n  float: left; }\n  .small-up-6 > .column:nth-of-type(1n), .small-up-6 > .columns:nth-of-type(1n) {\n    clear: none; }\n  .small-up-6 > .column:nth-of-type(6n+1), .small-up-6 > .columns:nth-of-type(6n+1) {\n    clear: both; }\n  .small-up-6 > .column:last-child, .small-up-6 > .columns:last-child {\n    float: left; }\n\n.small-up-7 > .column, .small-up-7 > .columns {\n  width: 14.28571%;\n  float: left; }\n  .small-up-7 > .column:nth-of-type(1n), .small-up-7 > .columns:nth-of-type(1n) {\n    clear: none; }\n  .small-up-7 > .column:nth-of-type(7n+1), .small-up-7 > .columns:nth-of-type(7n+1) {\n    clear: both; }\n  .small-up-7 > .column:last-child, .small-up-7 > .columns:last-child {\n    float: left; }\n\n.small-up-8 > .column, .small-up-8 > .columns {\n  width: 12.5%;\n  float: left; }\n  .small-up-8 > .column:nth-of-type(1n), .small-up-8 > .columns:nth-of-type(1n) {\n    clear: none; }\n  .small-up-8 > .column:nth-of-type(8n+1), .small-up-8 > .columns:nth-of-type(8n+1) {\n    clear: both; }\n  .small-up-8 > .column:last-child, .small-up-8 > .columns:last-child {\n    float: left; }\n\n.small-collapse > .column, .small-collapse > .columns {\n  padding-left: 0;\n  padding-right: 0; }\n\n.small-collapse .row,\n.expanded.row .small-collapse.row {\n  margin-left: 0;\n  margin-right: 0; }\n\n.small-uncollapse > .column, .small-uncollapse > .columns {\n  padding-left: 0.625rem;\n  padding-right: 0.625rem; }\n\n.small-centered {\n  float: none;\n  margin-left: auto;\n  margin-right: auto; }\n\n.small-uncentered,\n.small-push-0,\n.small-pull-0 {\n  position: static;\n  margin-left: 0;\n  margin-right: 0;\n  float: left; }\n\n@media screen and (min-width: 40em) {\n  .medium-1 {\n    width: 8.33333%; }\n  .medium-push-1 {\n    position: relative;\n    left: 8.33333%; }\n  .medium-pull-1 {\n    position: relative;\n    left: -8.33333%; }\n  .medium-offset-0 {\n    margin-left: 0%; }\n  .medium-2 {\n    width: 16.66667%; }\n  .medium-push-2 {\n    position: relative;\n    left: 16.66667%; }\n  .medium-pull-2 {\n    position: relative;\n    left: -16.66667%; }\n  .medium-offset-1 {\n    margin-left: 8.33333%; }\n  .medium-3 {\n    width: 25%; }\n  .medium-push-3 {\n    position: relative;\n    left: 25%; }\n  .medium-pull-3 {\n    position: relative;\n    left: -25%; }\n  .medium-offset-2 {\n    margin-left: 16.66667%; }\n  .medium-4 {\n    width: 33.33333%; }\n  .medium-push-4 {\n    position: relative;\n    left: 33.33333%; }\n  .medium-pull-4 {\n    position: relative;\n    left: -33.33333%; }\n  .medium-offset-3 {\n    margin-left: 25%; }\n  .medium-5 {\n    width: 41.66667%; }\n  .medium-push-5 {\n    position: relative;\n    left: 41.66667%; }\n  .medium-pull-5 {\n    position: relative;\n    left: -41.66667%; }\n  .medium-offset-4 {\n    margin-left: 33.33333%; }\n  .medium-6 {\n    width: 50%; }\n  .medium-push-6 {\n    position: relative;\n    left: 50%; }\n  .medium-pull-6 {\n    position: relative;\n    left: -50%; }\n  .medium-offset-5 {\n    margin-left: 41.66667%; }\n  .medium-7 {\n    width: 58.33333%; }\n  .medium-push-7 {\n    position: relative;\n    left: 58.33333%; }\n  .medium-pull-7 {\n    position: relative;\n    left: -58.33333%; }\n  .medium-offset-6 {\n    margin-left: 50%; }\n  .medium-8 {\n    width: 66.66667%; }\n  .medium-push-8 {\n    position: relative;\n    left: 66.66667%; }\n  .medium-pull-8 {\n    position: relative;\n    left: -66.66667%; }\n  .medium-offset-7 {\n    margin-left: 58.33333%; }\n  .medium-9 {\n    width: 75%; }\n  .medium-push-9 {\n    position: relative;\n    left: 75%; }\n  .medium-pull-9 {\n    position: relative;\n    left: -75%; }\n  .medium-offset-8 {\n    margin-left: 66.66667%; }\n  .medium-10 {\n    width: 83.33333%; }\n  .medium-push-10 {\n    position: relative;\n    left: 83.33333%; }\n  .medium-pull-10 {\n    position: relative;\n    left: -83.33333%; }\n  .medium-offset-9 {\n    margin-left: 75%; }\n  .medium-11 {\n    width: 91.66667%; }\n  .medium-push-11 {\n    position: relative;\n    left: 91.66667%; }\n  .medium-pull-11 {\n    position: relative;\n    left: -91.66667%; }\n  .medium-offset-10 {\n    margin-left: 83.33333%; }\n  .medium-12 {\n    width: 100%; }\n  .medium-offset-11 {\n    margin-left: 91.66667%; }\n  .medium-up-1 > .column, .medium-up-1 > .columns {\n    width: 100%;\n    float: left; }\n    .medium-up-1 > .column:nth-of-type(1n), .medium-up-1 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .medium-up-1 > .column:nth-of-type(1n+1), .medium-up-1 > .columns:nth-of-type(1n+1) {\n      clear: both; }\n    .medium-up-1 > .column:last-child, .medium-up-1 > .columns:last-child {\n      float: left; }\n  .medium-up-2 > .column, .medium-up-2 > .columns {\n    width: 50%;\n    float: left; }\n    .medium-up-2 > .column:nth-of-type(1n), .medium-up-2 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .medium-up-2 > .column:nth-of-type(2n+1), .medium-up-2 > .columns:nth-of-type(2n+1) {\n      clear: both; }\n    .medium-up-2 > .column:last-child, .medium-up-2 > .columns:last-child {\n      float: left; }\n  .medium-up-3 > .column, .medium-up-3 > .columns {\n    width: 33.33333%;\n    float: left; }\n    .medium-up-3 > .column:nth-of-type(1n), .medium-up-3 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .medium-up-3 > .column:nth-of-type(3n+1), .medium-up-3 > .columns:nth-of-type(3n+1) {\n      clear: both; }\n    .medium-up-3 > .column:last-child, .medium-up-3 > .columns:last-child {\n      float: left; }\n  .medium-up-4 > .column, .medium-up-4 > .columns {\n    width: 25%;\n    float: left; }\n    .medium-up-4 > .column:nth-of-type(1n), .medium-up-4 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .medium-up-4 > .column:nth-of-type(4n+1), .medium-up-4 > .columns:nth-of-type(4n+1) {\n      clear: both; }\n    .medium-up-4 > .column:last-child, .medium-up-4 > .columns:last-child {\n      float: left; }\n  .medium-up-5 > .column, .medium-up-5 > .columns {\n    width: 20%;\n    float: left; }\n    .medium-up-5 > .column:nth-of-type(1n), .medium-up-5 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .medium-up-5 > .column:nth-of-type(5n+1), .medium-up-5 > .columns:nth-of-type(5n+1) {\n      clear: both; }\n    .medium-up-5 > .column:last-child, .medium-up-5 > .columns:last-child {\n      float: left; }\n  .medium-up-6 > .column, .medium-up-6 > .columns {\n    width: 16.66667%;\n    float: left; }\n    .medium-up-6 > .column:nth-of-type(1n), .medium-up-6 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .medium-up-6 > .column:nth-of-type(6n+1), .medium-up-6 > .columns:nth-of-type(6n+1) {\n      clear: both; }\n    .medium-up-6 > .column:last-child, .medium-up-6 > .columns:last-child {\n      float: left; }\n  .medium-up-7 > .column, .medium-up-7 > .columns {\n    width: 14.28571%;\n    float: left; }\n    .medium-up-7 > .column:nth-of-type(1n), .medium-up-7 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .medium-up-7 > .column:nth-of-type(7n+1), .medium-up-7 > .columns:nth-of-type(7n+1) {\n      clear: both; }\n    .medium-up-7 > .column:last-child, .medium-up-7 > .columns:last-child {\n      float: left; }\n  .medium-up-8 > .column, .medium-up-8 > .columns {\n    width: 12.5%;\n    float: left; }\n    .medium-up-8 > .column:nth-of-type(1n), .medium-up-8 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .medium-up-8 > .column:nth-of-type(8n+1), .medium-up-8 > .columns:nth-of-type(8n+1) {\n      clear: both; }\n    .medium-up-8 > .column:last-child, .medium-up-8 > .columns:last-child {\n      float: left; }\n  .medium-collapse > .column, .medium-collapse > .columns {\n    padding-left: 0;\n    padding-right: 0; }\n  .medium-collapse .row,\n  .expanded.row .medium-collapse.row {\n    margin-left: 0;\n    margin-right: 0; }\n  .medium-uncollapse > .column, .medium-uncollapse > .columns {\n    padding-left: 0.9375rem;\n    padding-right: 0.9375rem; }\n  .medium-centered {\n    float: none;\n    margin-left: auto;\n    margin-right: auto; }\n  .medium-uncentered,\n  .medium-push-0,\n  .medium-pull-0 {\n    position: static;\n    margin-left: 0;\n    margin-right: 0;\n    float: left; } }\n\n@media screen and (min-width: 64em) {\n  .large-1 {\n    width: 8.33333%; }\n  .large-push-1 {\n    position: relative;\n    left: 8.33333%; }\n  .large-pull-1 {\n    position: relative;\n    left: -8.33333%; }\n  .large-offset-0 {\n    margin-left: 0%; }\n  .large-2 {\n    width: 16.66667%; }\n  .large-push-2 {\n    position: relative;\n    left: 16.66667%; }\n  .large-pull-2 {\n    position: relative;\n    left: -16.66667%; }\n  .large-offset-1 {\n    margin-left: 8.33333%; }\n  .large-3 {\n    width: 25%; }\n  .large-push-3 {\n    position: relative;\n    left: 25%; }\n  .large-pull-3 {\n    position: relative;\n    left: -25%; }\n  .large-offset-2 {\n    margin-left: 16.66667%; }\n  .large-4 {\n    width: 33.33333%; }\n  .large-push-4 {\n    position: relative;\n    left: 33.33333%; }\n  .large-pull-4 {\n    position: relative;\n    left: -33.33333%; }\n  .large-offset-3 {\n    margin-left: 25%; }\n  .large-5 {\n    width: 41.66667%; }\n  .large-push-5 {\n    position: relative;\n    left: 41.66667%; }\n  .large-pull-5 {\n    position: relative;\n    left: -41.66667%; }\n  .large-offset-4 {\n    margin-left: 33.33333%; }\n  .large-6 {\n    width: 50%; }\n  .large-push-6 {\n    position: relative;\n    left: 50%; }\n  .large-pull-6 {\n    position: relative;\n    left: -50%; }\n  .large-offset-5 {\n    margin-left: 41.66667%; }\n  .large-7 {\n    width: 58.33333%; }\n  .large-push-7 {\n    position: relative;\n    left: 58.33333%; }\n  .large-pull-7 {\n    position: relative;\n    left: -58.33333%; }\n  .large-offset-6 {\n    margin-left: 50%; }\n  .large-8 {\n    width: 66.66667%; }\n  .large-push-8 {\n    position: relative;\n    left: 66.66667%; }\n  .large-pull-8 {\n    position: relative;\n    left: -66.66667%; }\n  .large-offset-7 {\n    margin-left: 58.33333%; }\n  .large-9 {\n    width: 75%; }\n  .large-push-9 {\n    position: relative;\n    left: 75%; }\n  .large-pull-9 {\n    position: relative;\n    left: -75%; }\n  .large-offset-8 {\n    margin-left: 66.66667%; }\n  .large-10 {\n    width: 83.33333%; }\n  .large-push-10 {\n    position: relative;\n    left: 83.33333%; }\n  .large-pull-10 {\n    position: relative;\n    left: -83.33333%; }\n  .large-offset-9 {\n    margin-left: 75%; }\n  .large-11 {\n    width: 91.66667%; }\n  .large-push-11 {\n    position: relative;\n    left: 91.66667%; }\n  .large-pull-11 {\n    position: relative;\n    left: -91.66667%; }\n  .large-offset-10 {\n    margin-left: 83.33333%; }\n  .large-12 {\n    width: 100%; }\n  .large-offset-11 {\n    margin-left: 91.66667%; }\n  .large-up-1 > .column, .large-up-1 > .columns {\n    width: 100%;\n    float: left; }\n    .large-up-1 > .column:nth-of-type(1n), .large-up-1 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .large-up-1 > .column:nth-of-type(1n+1), .large-up-1 > .columns:nth-of-type(1n+1) {\n      clear: both; }\n    .large-up-1 > .column:last-child, .large-up-1 > .columns:last-child {\n      float: left; }\n  .large-up-2 > .column, .large-up-2 > .columns {\n    width: 50%;\n    float: left; }\n    .large-up-2 > .column:nth-of-type(1n), .large-up-2 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .large-up-2 > .column:nth-of-type(2n+1), .large-up-2 > .columns:nth-of-type(2n+1) {\n      clear: both; }\n    .large-up-2 > .column:last-child, .large-up-2 > .columns:last-child {\n      float: left; }\n  .large-up-3 > .column, .large-up-3 > .columns {\n    width: 33.33333%;\n    float: left; }\n    .large-up-3 > .column:nth-of-type(1n), .large-up-3 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .large-up-3 > .column:nth-of-type(3n+1), .large-up-3 > .columns:nth-of-type(3n+1) {\n      clear: both; }\n    .large-up-3 > .column:last-child, .large-up-3 > .columns:last-child {\n      float: left; }\n  .large-up-4 > .column, .large-up-4 > .columns {\n    width: 25%;\n    float: left; }\n    .large-up-4 > .column:nth-of-type(1n), .large-up-4 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .large-up-4 > .column:nth-of-type(4n+1), .large-up-4 > .columns:nth-of-type(4n+1) {\n      clear: both; }\n    .large-up-4 > .column:last-child, .large-up-4 > .columns:last-child {\n      float: left; }\n  .large-up-5 > .column, .large-up-5 > .columns {\n    width: 20%;\n    float: left; }\n    .large-up-5 > .column:nth-of-type(1n), .large-up-5 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .large-up-5 > .column:nth-of-type(5n+1), .large-up-5 > .columns:nth-of-type(5n+1) {\n      clear: both; }\n    .large-up-5 > .column:last-child, .large-up-5 > .columns:last-child {\n      float: left; }\n  .large-up-6 > .column, .large-up-6 > .columns {\n    width: 16.66667%;\n    float: left; }\n    .large-up-6 > .column:nth-of-type(1n), .large-up-6 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .large-up-6 > .column:nth-of-type(6n+1), .large-up-6 > .columns:nth-of-type(6n+1) {\n      clear: both; }\n    .large-up-6 > .column:last-child, .large-up-6 > .columns:last-child {\n      float: left; }\n  .large-up-7 > .column, .large-up-7 > .columns {\n    width: 14.28571%;\n    float: left; }\n    .large-up-7 > .column:nth-of-type(1n), .large-up-7 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .large-up-7 > .column:nth-of-type(7n+1), .large-up-7 > .columns:nth-of-type(7n+1) {\n      clear: both; }\n    .large-up-7 > .column:last-child, .large-up-7 > .columns:last-child {\n      float: left; }\n  .large-up-8 > .column, .large-up-8 > .columns {\n    width: 12.5%;\n    float: left; }\n    .large-up-8 > .column:nth-of-type(1n), .large-up-8 > .columns:nth-of-type(1n) {\n      clear: none; }\n    .large-up-8 > .column:nth-of-type(8n+1), .large-up-8 > .columns:nth-of-type(8n+1) {\n      clear: both; }\n    .large-up-8 > .column:last-child, .large-up-8 > .columns:last-child {\n      float: left; }\n  .large-collapse > .column, .large-collapse > .columns {\n    padding-left: 0;\n    padding-right: 0; }\n  .large-collapse .row,\n  .expanded.row .large-collapse.row {\n    margin-left: 0;\n    margin-right: 0; }\n  .large-uncollapse > .column, .large-uncollapse > .columns {\n    padding-left: 0.9375rem;\n    padding-right: 0.9375rem; }\n  .large-centered {\n    float: none;\n    margin-left: auto;\n    margin-right: auto; }\n  .large-uncentered,\n  .large-push-0,\n  .large-pull-0 {\n    position: static;\n    margin-left: 0;\n    margin-right: 0;\n    float: left; } }\n\ndiv,\ndl,\ndt,\ndd,\nul,\nol,\nli,\nh1,\nh2,\nh3,\nh4,\nh5,\nh6,\npre,\nform,\np,\nblockquote,\nth,\ntd {\n  margin: 0;\n  padding: 0; }\n\np {\n  font-size: inherit;\n  line-height: 1.6;\n  margin-bottom: 1rem;\n  text-rendering: optimizeLegibility; }\n\nem,\ni {\n  font-style: italic;\n  line-height: inherit; }\n\nstrong,\nb {\n  font-weight: bold;\n  line-height: inherit; }\n\nsmall {\n  font-size: 80%;\n  line-height: inherit; }\n\nh1,\nh2,\nh3,\nh4,\nh5,\nh6 {\n  font-family: \"Helvetica Neue\", Helvetica, Roboto, Arial, sans-serif;\n  font-weight: normal;\n  font-style: normal;\n  color: inherit;\n  text-rendering: optimizeLegibility;\n  margin-top: 0;\n  margin-bottom: 0.5rem;\n  line-height: 1.4; }\n  h1 small,\n  h2 small,\n  h3 small,\n  h4 small,\n  h5 small,\n  h6 small {\n    color: #cacaca;\n    line-height: 0; }\n\nh1 {\n  font-size: 1.5rem; }\n\nh2 {\n  font-size: 1.25rem; }\n\nh3 {\n  font-size: 1.1875rem; }\n\nh4 {\n  font-size: 1.125rem; }\n\nh5 {\n  font-size: 1.0625rem; }\n\nh6 {\n  font-size: 1rem; }\n\n@media screen and (min-width: 40em) {\n  h1 {\n    font-size: 3rem; }\n  h2 {\n    font-size: 2.5rem; }\n  h3 {\n    font-size: 1.9375rem; }\n  h4 {\n    font-size: 1.5625rem; }\n  h5 {\n    font-size: 1.25rem; }\n  h6 {\n    font-size: 1rem; } }\n\na {\n  color: #2199e8;\n  text-decoration: none;\n  line-height: inherit;\n  cursor: pointer; }\n  a:hover, a:focus {\n    color: #1585cf; }\n  a img {\n    border: 0; }\n\nhr {\n  max-width: 75rem;\n  height: 0;\n  border-right: 0;\n  border-top: 0;\n  border-bottom: 1px solid #cacaca;\n  border-left: 0;\n  margin: 1.25rem auto;\n  clear: both; }\n\nul,\nol,\ndl {\n  line-height: 1.6;\n  margin-bottom: 1rem;\n  list-style-position: outside; }\n\nli {\n  font-size: inherit; }\n\nul {\n  list-style-type: disc;\n  margin-left: 1.25rem; }\n\nol {\n  margin-left: 1.25rem; }\n\nul ul, ol ul, ul ol, ol ol {\n  margin-left: 1.25rem;\n  margin-bottom: 0; }\n\ndl {\n  margin-bottom: 1rem; }\n  dl dt {\n    margin-bottom: 0.3rem;\n    font-weight: bold; }\n\nblockquote {\n  margin: 0 0 1rem;\n  padding: 0.5625rem 1.25rem 0 1.1875rem;\n  border-left: 1px solid #cacaca; }\n  blockquote, blockquote p {\n    line-height: 1.6;\n    color: #8a8a8a; }\n\ncite {\n  display: block;\n  font-size: 0.8125rem;\n  color: #8a8a8a; }\n  cite:before {\n    content: '\\2014    '; }\n\nabbr {\n  color: #0a0a0a;\n  cursor: help;\n  border-bottom: 1px dotted #0a0a0a; }\n\ncode {\n  font-family: Consolas, \"Liberation Mono\", Courier, monospace;\n  font-weight: normal;\n  color: #0a0a0a;\n  background-color: #e6e6e6;\n  border: 1px solid #cacaca;\n  padding: 0.125rem 0.3125rem 0.0625rem; }\n\nkbd {\n  padding: 0.125rem 0.25rem 0;\n  margin: 0;\n  background-color: #e6e6e6;\n  color: #0a0a0a;\n  font-family: Consolas, \"Liberation Mono\", Courier, monospace; }\n\n.subheader {\n  margin-top: 0.2rem;\n  margin-bottom: 0.5rem;\n  font-weight: normal;\n  line-height: 1.4;\n  color: #8a8a8a; }\n\n.lead {\n  font-size: 125%;\n  line-height: 1.6; }\n\n.stat {\n  font-size: 2.5rem;\n  line-height: 1; }\n  p + .stat {\n    margin-top: -1rem; }\n\n.no-bullet {\n  margin-left: 0;\n  list-style: none; }\n\n.text-left {\n  text-align: left; }\n\n.text-right {\n  text-align: right; }\n\n.text-center {\n  text-align: center; }\n\n.text-justify {\n  text-align: justify; }\n\n@media screen and (min-width: 40em) {\n  .medium-text-left {\n    text-align: left; }\n  .medium-text-right {\n    text-align: right; }\n  .medium-text-center {\n    text-align: center; }\n  .medium-text-justify {\n    text-align: justify; } }\n\n@media screen and (min-width: 64em) {\n  .large-text-left {\n    text-align: left; }\n  .large-text-right {\n    text-align: right; }\n  .large-text-center {\n    text-align: center; }\n  .large-text-justify {\n    text-align: justify; } }\n\n.show-for-print {\n  display: none !important; }\n\n@media print {\n  * {\n    background: transparent !important;\n    color: black !important;\n    box-shadow: none !important;\n    text-shadow: none !important; }\n  .show-for-print {\n    display: block !important; }\n  .hide-for-print {\n    display: none !important; }\n  table.show-for-print {\n    display: table !important; }\n  thead.show-for-print {\n    display: table-header-group !important; }\n  tbody.show-for-print {\n    display: table-row-group !important; }\n  tr.show-for-print {\n    display: table-row !important; }\n  td.show-for-print {\n    display: table-cell !important; }\n  th.show-for-print {\n    display: table-cell !important; }\n  a,\n  a:visited {\n    text-decoration: underline; }\n  a[href]:after {\n    content: \" (\" attr(href) \")\"; }\n  .ir a:after,\n  a[href^='javascript:']:after,\n  a[href^='#']:after {\n    content: ''; }\n  abbr[title]:after {\n    content: \" (\" attr(title) \")\"; }\n  pre,\n  blockquote {\n    border: 1px solid #8a8a8a;\n    page-break-inside: avoid; }\n  thead {\n    display: table-header-group; }\n  tr,\n  img {\n    page-break-inside: avoid; }\n  img {\n    max-width: 100% !important; }\n  @page {\n    margin: 0.5cm; }\n  p,\n  h2,\n  h3 {\n    orphans: 3;\n    widows: 3; }\n  h2,\n  h3 {\n    page-break-after: avoid; } }\n\n[type='text'], [type='password'], [type='date'], [type='datetime'], [type='datetime-local'], [type='month'], [type='week'], [type='email'], [type='number'], [type='search'], [type='tel'], [type='time'], [type='url'], [type='color'],\ntextarea {\n  display: block;\n  box-sizing: border-box;\n  width: 100%;\n  height: 2.4375rem;\n  padding: 0.5rem;\n  border: 1px solid #cacaca;\n  margin: 0 0 1rem;\n  font-family: inherit;\n  font-size: 1rem;\n  color: #0a0a0a;\n  background-color: #fefefe;\n  box-shadow: inset 0 1px 2px rgba(10, 10, 10, 0.1);\n  border-radius: 0;\n  transition: box-shadow 0.5s, border-color 0.25s ease-in-out;\n  -webkit-appearance: none;\n  -moz-appearance: none; }\n  [type='text']:focus, [type='password']:focus, [type='date']:focus, [type='datetime']:focus, [type='datetime-local']:focus, [type='month']:focus, [type='week']:focus, [type='email']:focus, [type='number']:focus, [type='search']:focus, [type='tel']:focus, [type='time']:focus, [type='url']:focus, [type='color']:focus,\n  textarea:focus {\n    border: 1px solid #8a8a8a;\n    background-color: #fefefe;\n    outline: none;\n    box-shadow: 0 0 5px #cacaca;\n    transition: box-shadow 0.5s, border-color 0.25s ease-in-out; }\n\ntextarea {\n  max-width: 100%; }\n  textarea[rows] {\n    height: auto; }\n\ninput::placeholder,\ntextarea::placeholder {\n  color: #cacaca; }\n\ninput:disabled, input[readonly],\ntextarea:disabled,\ntextarea[readonly] {\n  background-color: #e6e6e6;\n  cursor: not-allowed; }\n\n[type='submit'],\n[type='button'] {\n  border-radius: 0;\n  -webkit-appearance: none;\n  -moz-appearance: none; }\n\ninput[type='search'] {\n  box-sizing: border-box; }\n\n[type='file'],\n[type='checkbox'],\n[type='radio'] {\n  margin: 0 0 1rem; }\n\n[type='checkbox'] + label,\n[type='radio'] + label {\n  display: inline-block;\n  margin-left: 0.5rem;\n  margin-right: 1rem;\n  margin-bottom: 0;\n  vertical-align: baseline; }\n  [type='checkbox'] + label[for],\n  [type='radio'] + label[for] {\n    cursor: pointer; }\n\nlabel > [type='checkbox'],\nlabel > [type='radio'] {\n  margin-right: 0.5rem; }\n\n[type='file'] {\n  width: 100%; }\n\nlabel {\n  display: block;\n  margin: 0;\n  font-size: 0.875rem;\n  font-weight: normal;\n  line-height: 1.8;\n  color: #0a0a0a; }\n  label.middle {\n    margin: 0 0 1rem;\n    padding: 0.5625rem 0; }\n\n.help-text {\n  margin-top: -0.5rem;\n  font-size: 0.8125rem;\n  font-style: italic;\n  color: #0a0a0a; }\n\n.input-group {\n  display: table;\n  width: 100%;\n  margin-bottom: 1rem; }\n  .input-group > :first-child {\n    border-radius: 0 0 0 0; }\n  .input-group > :last-child > * {\n    border-radius: 0 0 0 0; }\n\n.input-group-label, .input-group-field, .input-group-button {\n  margin: 0;\n  white-space: nowrap;\n  display: table-cell;\n  vertical-align: middle; }\n\n.input-group-label {\n  text-align: center;\n  padding: 0 1rem;\n  background: #e6e6e6;\n  color: #0a0a0a;\n  border: 1px solid #cacaca;\n  white-space: nowrap;\n  width: 1%;\n  height: 100%; }\n  .input-group-label:first-child {\n    border-right: 0; }\n  .input-group-label:last-child {\n    border-left: 0; }\n\n.input-group-field {\n  border-radius: 0;\n  height: 2.5rem; }\n\n.input-group-button {\n  padding-top: 0;\n  padding-bottom: 0;\n  text-align: center;\n  height: 100%;\n  width: 1%; }\n  .input-group-button a,\n  .input-group-button input,\n  .input-group-button button {\n    margin: 0; }\n\n.input-group .input-group-button {\n  display: table-cell; }\n\nfieldset {\n  border: 0;\n  padding: 0;\n  margin: 0; }\n\nlegend {\n  margin-bottom: 0.5rem;\n  max-width: 100%; }\n\n.fieldset {\n  border: 1px solid #cacaca;\n  padding: 1.25rem;\n  margin: 1.125rem 0; }\n  .fieldset legend {\n    background: #fefefe;\n    padding: 0 0.1875rem;\n    margin: 0;\n    margin-left: -0.1875rem; }\n\nselect {\n  height: 2.4375rem;\n  padding: 0.5rem;\n  border: 1px solid #cacaca;\n  margin: 0 0 1rem;\n  font-size: 1rem;\n  font-family: inherit;\n  line-height: normal;\n  color: #0a0a0a;\n  background-color: #fefefe;\n  border-radius: 0;\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  background-image: url(\"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' width='32' height='24' viewBox='0 0 32 24'><polygon points='0,0 32,0 16,24' style='fill: rgb%28138, 138, 138%29'></polygon></svg>\");\n  background-size: 9px 6px;\n  background-position: right -1rem center;\n  background-origin: content-box;\n  background-repeat: no-repeat;\n  padding-right: 1.5rem; }\n  @media screen and (min-width: 0\\0) {\n    select {\n      background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAYCAYAAACbU/80AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAIpJREFUeNrEkckNgDAMBBfRkEt0ObRBBdsGXUDgmQfK4XhH2m8czQAAy27R3tsw4Qfe2x8uOO6oYLb6GlOor3GF+swURAOmUJ+RwtEJs9WvTGEYxBXqI1MQAZhCfUQKRzDMVj+TwrAIV6jvSUEkYAr1LSkcyTBb/V+KYfX7xAeusq3sLDtGH3kEGACPWIflNZfhRQAAAABJRU5ErkJggg==\"); } }\n  select:disabled {\n    background-color: #e6e6e6;\n    cursor: not-allowed; }\n  select::-ms-expand {\n    display: none; }\n  select[multiple] {\n    height: auto;\n    background-image: none; }\n\n.is-invalid-input:not(:focus) {\n  background-color: rgba(236, 88, 64, 0.1);\n  border-color: #ec5840; }\n\n.is-invalid-label {\n  color: #ec5840; }\n\n.form-error {\n  display: none;\n  margin-top: -0.5rem;\n  margin-bottom: 1rem;\n  font-size: 0.75rem;\n  font-weight: bold;\n  color: #ec5840; }\n  .form-error.is-visible {\n    display: block; }\n\n.button {\n  display: inline-block;\n  text-align: center;\n  line-height: 1;\n  cursor: pointer;\n  -webkit-appearance: none;\n  transition: background-color 0.25s ease-out, color 0.25s ease-out;\n  vertical-align: middle;\n  border: 1px solid transparent;\n  border-radius: 0;\n  padding: 0.85em 1em;\n  margin: 0 0 1rem 0;\n  font-size: 0.9rem;\n  background-color: #2199e8;\n  color: #fefefe; }\n  [data-whatinput='mouse'] .button {\n    outline: 0; }\n  .button:hover, .button:focus {\n    background-color: #1583cc;\n    color: #fefefe; }\n  .button.tiny {\n    font-size: 0.6rem; }\n  .button.small {\n    font-size: 0.75rem; }\n  .button.large {\n    font-size: 1.25rem; }\n  .button.expanded {\n    display: block;\n    width: 100%;\n    margin-left: 0;\n    margin-right: 0; }\n  .button.primary {\n    background-color: #2199e8;\n    color: #fefefe; }\n    .button.primary:hover, .button.primary:focus {\n      background-color: #147cc0;\n      color: #fefefe; }\n  .button.secondary {\n    background-color: #777;\n    color: #fefefe; }\n    .button.secondary:hover, .button.secondary:focus {\n      background-color: #5f5f5f;\n      color: #fefefe; }\n  .button.success {\n    background-color: #3adb76;\n    color: #fefefe; }\n    .button.success:hover, .button.success:focus {\n      background-color: #22bb5b;\n      color: #fefefe; }\n  .button.warning {\n    background-color: #ffae00;\n    color: #fefefe; }\n    .button.warning:hover, .button.warning:focus {\n      background-color: #cc8b00;\n      color: #fefefe; }\n  .button.alert {\n    background-color: #ec5840;\n    color: #fefefe; }\n    .button.alert:hover, .button.alert:focus {\n      background-color: #da3116;\n      color: #fefefe; }\n  .button.hollow {\n    border: 1px solid #2199e8;\n    color: #2199e8; }\n    .button.hollow, .button.hollow:hover, .button.hollow:focus {\n      background-color: transparent; }\n    .button.hollow:hover, .button.hollow:focus {\n      border-color: #0c4d78;\n      color: #0c4d78; }\n    .button.hollow.primary {\n      border: 1px solid #2199e8;\n      color: #2199e8; }\n      .button.hollow.primary:hover, .button.hollow.primary:focus {\n        border-color: #0c4d78;\n        color: #0c4d78; }\n    .button.hollow.secondary {\n      border: 1px solid #777;\n      color: #777; }\n      .button.hollow.secondary:hover, .button.hollow.secondary:focus {\n        border-color: #3c3c3c;\n        color: #3c3c3c; }\n    .button.hollow.success {\n      border: 1px solid #3adb76;\n      color: #3adb76; }\n      .button.hollow.success:hover, .button.hollow.success:focus {\n        border-color: #157539;\n        color: #157539; }\n    .button.hollow.warning {\n      border: 1px solid #ffae00;\n      color: #ffae00; }\n      .button.hollow.warning:hover, .button.hollow.warning:focus {\n        border-color: #805700;\n        color: #805700; }\n    .button.hollow.alert {\n      border: 1px solid #ec5840;\n      color: #ec5840; }\n      .button.hollow.alert:hover, .button.hollow.alert:focus {\n        border-color: #881f0e;\n        color: #881f0e; }\n  .button.disabled, .button[disabled] {\n    opacity: 0.25;\n    cursor: not-allowed; }\n    .button.disabled:hover, .button.disabled:focus, .button[disabled]:hover, .button[disabled]:focus {\n      background-color: #2199e8;\n      color: #fefefe; }\n  .button.dropdown::after {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 0.4em;\n    border-color: #fefefe transparent transparent;\n    border-top-style: solid;\n    border-bottom-width: 0;\n    position: relative;\n    top: 0.4em;\n    float: right;\n    margin-left: 1em;\n    display: inline-block; }\n  .button.arrow-only::after {\n    margin-left: 0;\n    float: none;\n    top: -0.1em; }\n\n.accordion {\n  list-style-type: none;\n  background: #fefefe;\n  margin-left: 0; }\n\n.accordion-item:first-child > :first-child {\n  border-radius: 0 0 0 0; }\n\n.accordion-item:last-child > :last-child {\n  border-radius: 0 0 0 0; }\n\n.accordion-title {\n  display: block;\n  padding: 1.25rem 1rem;\n  line-height: 1;\n  font-size: 0.75rem;\n  color: #2199e8;\n  position: relative;\n  border: 1px solid #e6e6e6;\n  border-bottom: 0; }\n  :last-child:not(.is-active) > .accordion-title {\n    border-radius: 0 0 0 0;\n    border-bottom: 1px solid #e6e6e6; }\n  .accordion-title:hover, .accordion-title:focus {\n    background-color: #e6e6e6; }\n  .accordion-title::before {\n    content: '+';\n    position: absolute;\n    right: 1rem;\n    top: 50%;\n    margin-top: -0.5rem; }\n  .is-active > .accordion-title::before {\n    content: '\\2013'; }\n\n.accordion-content {\n  padding: 1rem;\n  display: none;\n  border: 1px solid #e6e6e6;\n  border-bottom: 0;\n  background-color: #fefefe;\n  color: #0a0a0a; }\n  :last-child > .accordion-content:last-child {\n    border-bottom: 1px solid #e6e6e6; }\n\n.is-accordion-submenu-parent > a {\n  position: relative; }\n  .is-accordion-submenu-parent > a::after {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 6px;\n    border-color: #2199e8 transparent transparent;\n    border-top-style: solid;\n    border-bottom-width: 0;\n    position: absolute;\n    top: 50%;\n    margin-top: -4px;\n    right: 1rem; }\n\n.is-accordion-submenu-parent[aria-expanded='true'] > a::after {\n  transform-origin: 50% 50%;\n  transform: scaleY(-1); }\n\n.badge {\n  display: inline-block;\n  padding: 0.3em;\n  min-width: 2.1em;\n  font-size: 0.6rem;\n  text-align: center;\n  border-radius: 50%;\n  background: #2199e8;\n  color: #fefefe; }\n  .badge.secondary {\n    background: #777;\n    color: #fefefe; }\n  .badge.success {\n    background: #3adb76;\n    color: #fefefe; }\n  .badge.warning {\n    background: #ffae00;\n    color: #fefefe; }\n  .badge.alert {\n    background: #ec5840;\n    color: #fefefe; }\n\n.breadcrumbs {\n  list-style: none;\n  margin: 0 0 1rem 0; }\n  .breadcrumbs::before, .breadcrumbs::after {\n    content: ' ';\n    display: table; }\n  .breadcrumbs::after {\n    clear: both; }\n  .breadcrumbs li {\n    float: left;\n    color: #0a0a0a;\n    font-size: 0.6875rem;\n    cursor: default;\n    text-transform: uppercase; }\n    .breadcrumbs li:not(:last-child)::after {\n      color: #cacaca;\n      content: \"/\";\n      margin: 0 0.75rem;\n      position: relative;\n      top: 1px;\n      opacity: 1; }\n  .breadcrumbs a {\n    color: #2199e8; }\n    .breadcrumbs a:hover {\n      text-decoration: underline; }\n  .breadcrumbs .disabled {\n    color: #cacaca;\n    cursor: not-allowed; }\n\n.button-group {\n  margin-bottom: 1rem;\n  font-size: 0; }\n  .button-group::before, .button-group::after {\n    content: ' ';\n    display: table; }\n  .button-group::after {\n    clear: both; }\n  .button-group .button {\n    margin: 0;\n    margin-right: 1px;\n    margin-bottom: 1px;\n    font-size: 0.9rem; }\n    .button-group .button:last-child {\n      margin-right: 0; }\n  .button-group.tiny .button {\n    font-size: 0.6rem; }\n  .button-group.small .button {\n    font-size: 0.75rem; }\n  .button-group.large .button {\n    font-size: 1.25rem; }\n  .button-group.expanded {\n    margin-right: -1px; }\n    .button-group.expanded::before, .button-group.expanded::after {\n      display: none; }\n    .button-group.expanded .button:first-child:nth-last-child(2), .button-group.expanded .button:first-child:nth-last-child(2):first-child:nth-last-child(2) ~ .button {\n      display: inline-block;\n      width: calc(50% - 1px);\n      margin-right: 1px; }\n      .button-group.expanded .button:first-child:nth-last-child(2):last-child, .button-group.expanded .button:first-child:nth-last-child(2):first-child:nth-last-child(2) ~ .button:last-child {\n        margin-right: -6px; }\n    .button-group.expanded .button:first-child:nth-last-child(3), .button-group.expanded .button:first-child:nth-last-child(3):first-child:nth-last-child(3) ~ .button {\n      display: inline-block;\n      width: calc(33.33333% - 1px);\n      margin-right: 1px; }\n      .button-group.expanded .button:first-child:nth-last-child(3):last-child, .button-group.expanded .button:first-child:nth-last-child(3):first-child:nth-last-child(3) ~ .button:last-child {\n        margin-right: -6px; }\n    .button-group.expanded .button:first-child:nth-last-child(4), .button-group.expanded .button:first-child:nth-last-child(4):first-child:nth-last-child(4) ~ .button {\n      display: inline-block;\n      width: calc(25% - 1px);\n      margin-right: 1px; }\n      .button-group.expanded .button:first-child:nth-last-child(4):last-child, .button-group.expanded .button:first-child:nth-last-child(4):first-child:nth-last-child(4) ~ .button:last-child {\n        margin-right: -6px; }\n    .button-group.expanded .button:first-child:nth-last-child(5), .button-group.expanded .button:first-child:nth-last-child(5):first-child:nth-last-child(5) ~ .button {\n      display: inline-block;\n      width: calc(20% - 1px);\n      margin-right: 1px; }\n      .button-group.expanded .button:first-child:nth-last-child(5):last-child, .button-group.expanded .button:first-child:nth-last-child(5):first-child:nth-last-child(5) ~ .button:last-child {\n        margin-right: -6px; }\n    .button-group.expanded .button:first-child:nth-last-child(6), .button-group.expanded .button:first-child:nth-last-child(6):first-child:nth-last-child(6) ~ .button {\n      display: inline-block;\n      width: calc(16.66667% - 1px);\n      margin-right: 1px; }\n      .button-group.expanded .button:first-child:nth-last-child(6):last-child, .button-group.expanded .button:first-child:nth-last-child(6):first-child:nth-last-child(6) ~ .button:last-child {\n        margin-right: -6px; }\n  .button-group.primary .button {\n    background-color: #2199e8;\n    color: #fefefe; }\n    .button-group.primary .button:hover, .button-group.primary .button:focus {\n      background-color: #147cc0;\n      color: #fefefe; }\n  .button-group.secondary .button {\n    background-color: #777;\n    color: #fefefe; }\n    .button-group.secondary .button:hover, .button-group.secondary .button:focus {\n      background-color: #5f5f5f;\n      color: #fefefe; }\n  .button-group.success .button {\n    background-color: #3adb76;\n    color: #fefefe; }\n    .button-group.success .button:hover, .button-group.success .button:focus {\n      background-color: #22bb5b;\n      color: #fefefe; }\n  .button-group.warning .button {\n    background-color: #ffae00;\n    color: #fefefe; }\n    .button-group.warning .button:hover, .button-group.warning .button:focus {\n      background-color: #cc8b00;\n      color: #fefefe; }\n  .button-group.alert .button {\n    background-color: #ec5840;\n    color: #fefefe; }\n    .button-group.alert .button:hover, .button-group.alert .button:focus {\n      background-color: #da3116;\n      color: #fefefe; }\n  .button-group.stacked .button, .button-group.stacked-for-small .button, .button-group.stacked-for-medium .button {\n    width: 100%; }\n    .button-group.stacked .button:last-child, .button-group.stacked-for-small .button:last-child, .button-group.stacked-for-medium .button:last-child {\n      margin-bottom: 0; }\n  @media screen and (min-width: 40em) {\n    .button-group.stacked-for-small .button {\n      width: auto;\n      margin-bottom: 0; } }\n  @media screen and (min-width: 64em) {\n    .button-group.stacked-for-medium .button {\n      width: auto;\n      margin-bottom: 0; } }\n  @media screen and (max-width: 39.9375em) {\n    .button-group.stacked-for-small.expanded {\n      display: block; }\n      .button-group.stacked-for-small.expanded .button {\n        display: block;\n        margin-right: 0; } }\n\n.callout {\n  margin: 0 0 1rem 0;\n  padding: 1rem;\n  border: 1px solid rgba(10, 10, 10, 0.25);\n  border-radius: 0;\n  position: relative;\n  color: #0a0a0a;\n  background-color: white; }\n  .callout > :first-child {\n    margin-top: 0; }\n  .callout > :last-child {\n    margin-bottom: 0; }\n  .callout.primary {\n    background-color: #def0fc; }\n  .callout.secondary {\n    background-color: #ebebeb; }\n  .callout.success {\n    background-color: #e1faea; }\n  .callout.warning {\n    background-color: #fff3d9; }\n  .callout.alert {\n    background-color: #fce6e2; }\n  .callout.small {\n    padding-top: 0.5rem;\n    padding-right: 0.5rem;\n    padding-bottom: 0.5rem;\n    padding-left: 0.5rem; }\n  .callout.large {\n    padding-top: 3rem;\n    padding-right: 3rem;\n    padding-bottom: 3rem;\n    padding-left: 3rem; }\n\n.close-button {\n  position: absolute;\n  color: #8a8a8a;\n  right: 1rem;\n  top: 0.5rem;\n  font-size: 2em;\n  line-height: 1;\n  cursor: pointer; }\n  [data-whatinput='mouse'] .close-button {\n    outline: 0; }\n  .close-button:hover, .close-button:focus {\n    color: #0a0a0a; }\n\n.menu {\n  margin: 0;\n  list-style-type: none; }\n  .menu > li {\n    display: table-cell;\n    vertical-align: middle; }\n    [data-whatinput='mouse'] .menu > li {\n      outline: 0; }\n  .menu > li > a {\n    display: block;\n    padding: 0.7rem 1rem;\n    line-height: 1; }\n  .menu input,\n  .menu a,\n  .menu button {\n    margin-bottom: 0; }\n  .menu > li > a img,\n  .menu > li > a i,\n  .menu > li > a svg {\n    vertical-align: middle; }\n    .menu > li > a img + span,\n    .menu > li > a i + span,\n    .menu > li > a svg + span {\n      vertical-align: middle; }\n  .menu > li > a img,\n  .menu > li > a i,\n  .menu > li > a svg {\n    margin-right: 0.25rem;\n    display: inline-block; }\n  .menu > li {\n    display: table-cell; }\n  .menu.vertical > li {\n    display: block; }\n  @media screen and (min-width: 40em) {\n    .menu.medium-horizontal > li {\n      display: table-cell; }\n    .menu.medium-vertical > li {\n      display: block; } }\n  @media screen and (min-width: 64em) {\n    .menu.large-horizontal > li {\n      display: table-cell; }\n    .menu.large-vertical > li {\n      display: block; } }\n  .menu.simple li {\n    line-height: 1;\n    display: inline-block;\n    margin-right: 1rem; }\n  .menu.simple a {\n    padding: 0; }\n  .menu.align-right::before, .menu.align-right::after {\n    content: ' ';\n    display: table; }\n  .menu.align-right::after {\n    clear: both; }\n  .menu.align-right > li {\n    float: right; }\n  .menu.expanded {\n    width: 100%;\n    display: table;\n    table-layout: fixed; }\n    .menu.expanded > li:first-child:last-child {\n      width: 100%; }\n  .menu.icon-top > li > a {\n    text-align: center; }\n    .menu.icon-top > li > a img,\n    .menu.icon-top > li > a i,\n    .menu.icon-top > li > a svg {\n      display: block;\n      margin: 0 auto 0.25rem; }\n  .menu.nested {\n    margin-left: 1rem; }\n  .menu .active > a {\n    color: #fefefe;\n    background: #2199e8; }\n\n.menu-text {\n  font-weight: bold;\n  color: inherit;\n  line-height: 1;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding: 0.7rem 1rem; }\n\n.menu-centered {\n  text-align: center; }\n  .menu-centered > .menu {\n    display: inline-block; }\n\n.no-js [data-responsive-menu] ul {\n  display: none; }\n\n.menu-icon {\n  position: relative;\n  display: inline-block;\n  vertical-align: middle;\n  cursor: pointer;\n  width: 20px;\n  height: 16px; }\n  .menu-icon::after {\n    content: '';\n    position: absolute;\n    display: block;\n    width: 100%;\n    height: 2px;\n    background: #fefefe;\n    top: 0;\n    left: 0;\n    box-shadow: 0 7px 0 #fefefe, 0 14px 0 #fefefe; }\n  .menu-icon:hover::after {\n    background: #cacaca;\n    box-shadow: 0 7px 0 #cacaca, 0 14px 0 #cacaca; }\n\n.menu-icon.dark {\n  position: relative;\n  display: inline-block;\n  vertical-align: middle;\n  cursor: pointer;\n  width: 20px;\n  height: 16px; }\n  .menu-icon.dark::after {\n    content: '';\n    position: absolute;\n    display: block;\n    width: 100%;\n    height: 2px;\n    background: #0a0a0a;\n    top: 0;\n    left: 0;\n    box-shadow: 0 7px 0 #0a0a0a, 0 14px 0 #0a0a0a; }\n  .menu-icon.dark:hover::after {\n    background: #8a8a8a;\n    box-shadow: 0 7px 0 #8a8a8a, 0 14px 0 #8a8a8a; }\n\n.is-drilldown {\n  position: relative;\n  overflow: hidden; }\n  .is-drilldown li {\n    display: block !important; }\n\n.is-drilldown-submenu {\n  position: absolute;\n  top: 0;\n  left: 100%;\n  z-index: -1;\n  height: 100%;\n  width: 100%;\n  background: #fefefe;\n  transition: transform 0.15s linear; }\n  .is-drilldown-submenu.is-active {\n    z-index: 1;\n    display: block;\n    transform: translateX(-100%); }\n  .is-drilldown-submenu.is-closing {\n    transform: translateX(100%); }\n\n.is-drilldown-submenu-parent > a {\n  position: relative; }\n  .is-drilldown-submenu-parent > a::after {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 6px;\n    border-color: transparent transparent transparent #2199e8;\n    border-left-style: solid;\n    border-right-width: 0;\n    position: absolute;\n    top: 50%;\n    margin-top: -6px;\n    right: 1rem; }\n\n.js-drilldown-back > a::before {\n  content: '';\n  display: block;\n  width: 0;\n  height: 0;\n  border: inset 6px;\n  border-color: transparent #2199e8 transparent transparent;\n  border-right-style: solid;\n  border-left-width: 0;\n  border-left-width: 0;\n  display: inline-block;\n  vertical-align: middle;\n  margin-right: 0.75rem; }\n\n.dropdown-pane {\n  background-color: #fefefe;\n  border: 1px solid #cacaca;\n  border-radius: 0;\n  display: block;\n  font-size: 1rem;\n  padding: 1rem;\n  position: absolute;\n  visibility: hidden;\n  width: 300px;\n  z-index: 10; }\n  .dropdown-pane.is-open {\n    visibility: visible; }\n\n.dropdown-pane.tiny {\n  width: 100px; }\n\n.dropdown-pane.small {\n  width: 200px; }\n\n.dropdown-pane.large {\n  width: 400px; }\n\n.dropdown.menu > li.opens-left > .is-dropdown-submenu {\n  left: auto;\n  right: 0;\n  top: 100%; }\n\n.dropdown.menu > li.opens-right > .is-dropdown-submenu {\n  right: auto;\n  left: 0;\n  top: 100%; }\n\n.dropdown.menu > li.is-dropdown-submenu-parent > a {\n  padding-right: 1.5rem;\n  position: relative; }\n\n.dropdown.menu > li.is-dropdown-submenu-parent > a::after {\n  content: '';\n  display: block;\n  width: 0;\n  height: 0;\n  border: inset 5px;\n  border-color: #2199e8 transparent transparent;\n  border-top-style: solid;\n  border-bottom-width: 0;\n  right: 5px;\n  margin-top: -2px; }\n\n[data-whatinput='mouse'] .dropdown.menu a {\n  outline: 0; }\n\n.no-js .dropdown.menu ul {\n  display: none; }\n\n.dropdown.menu.vertical > li .is-dropdown-submenu {\n  top: 0; }\n\n.dropdown.menu.vertical > li.opens-left > .is-dropdown-submenu {\n  left: auto;\n  right: 100%; }\n\n.dropdown.menu.vertical > li.opens-right > .is-dropdown-submenu {\n  right: auto;\n  left: 100%; }\n\n.dropdown.menu.vertical > li > a::after {\n  right: 14px;\n  margin-top: -3px; }\n\n.dropdown.menu.vertical > li.opens-left > a::after {\n  content: '';\n  display: block;\n  width: 0;\n  height: 0;\n  border: inset 5px;\n  border-color: transparent #2199e8 transparent transparent;\n  border-right-style: solid;\n  border-left-width: 0; }\n\n.dropdown.menu.vertical > li.opens-right > a::after {\n  content: '';\n  display: block;\n  width: 0;\n  height: 0;\n  border: inset 5px;\n  border-color: transparent transparent transparent #2199e8;\n  border-left-style: solid;\n  border-right-width: 0; }\n\n@media screen and (min-width: 40em) {\n  .dropdown.menu.medium-horizontal > li.opens-left > .is-dropdown-submenu {\n    left: auto;\n    right: 0;\n    top: 100%; }\n  .dropdown.menu.medium-horizontal > li.opens-right > .is-dropdown-submenu {\n    right: auto;\n    left: 0;\n    top: 100%; }\n  .dropdown.menu.medium-horizontal > li.is-dropdown-submenu-parent > a {\n    padding-right: 1.5rem;\n    position: relative; }\n  .dropdown.menu.medium-horizontal > li.is-dropdown-submenu-parent > a::after {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 5px;\n    border-color: #2199e8 transparent transparent;\n    border-top-style: solid;\n    border-bottom-width: 0;\n    right: 5px;\n    margin-top: -2px; }\n  .dropdown.menu.medium-vertical > li .is-dropdown-submenu {\n    top: 0; }\n  .dropdown.menu.medium-vertical > li.opens-left > .is-dropdown-submenu {\n    left: auto;\n    right: 100%; }\n  .dropdown.menu.medium-vertical > li.opens-right > .is-dropdown-submenu {\n    right: auto;\n    left: 100%; }\n  .dropdown.menu.medium-vertical > li > a::after {\n    right: 14px;\n    margin-top: -3px; }\n  .dropdown.menu.medium-vertical > li.opens-left > a::after {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 5px;\n    border-color: transparent #2199e8 transparent transparent;\n    border-right-style: solid;\n    border-left-width: 0; }\n  .dropdown.menu.medium-vertical > li.opens-right > a::after {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 5px;\n    border-color: transparent transparent transparent #2199e8;\n    border-left-style: solid;\n    border-right-width: 0; } }\n\n@media screen and (min-width: 64em) {\n  .dropdown.menu.large-horizontal > li.opens-left > .is-dropdown-submenu {\n    left: auto;\n    right: 0;\n    top: 100%; }\n  .dropdown.menu.large-horizontal > li.opens-right > .is-dropdown-submenu {\n    right: auto;\n    left: 0;\n    top: 100%; }\n  .dropdown.menu.large-horizontal > li.is-dropdown-submenu-parent > a {\n    padding-right: 1.5rem;\n    position: relative; }\n  .dropdown.menu.large-horizontal > li.is-dropdown-submenu-parent > a::after {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 5px;\n    border-color: #2199e8 transparent transparent;\n    border-top-style: solid;\n    border-bottom-width: 0;\n    right: 5px;\n    margin-top: -2px; }\n  .dropdown.menu.large-vertical > li .is-dropdown-submenu {\n    top: 0; }\n  .dropdown.menu.large-vertical > li.opens-left > .is-dropdown-submenu {\n    left: auto;\n    right: 100%; }\n  .dropdown.menu.large-vertical > li.opens-right > .is-dropdown-submenu {\n    right: auto;\n    left: 100%; }\n  .dropdown.menu.large-vertical > li > a::after {\n    right: 14px;\n    margin-top: -3px; }\n  .dropdown.menu.large-vertical > li.opens-left > a::after {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 5px;\n    border-color: transparent #2199e8 transparent transparent;\n    border-right-style: solid;\n    border-left-width: 0; }\n  .dropdown.menu.large-vertical > li.opens-right > a::after {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 5px;\n    border-color: transparent transparent transparent #2199e8;\n    border-left-style: solid;\n    border-right-width: 0; } }\n\n.dropdown.menu.align-right .is-dropdown-submenu.first-sub {\n  top: 100%;\n  left: auto;\n  right: 0; }\n\n.is-dropdown-menu.vertical {\n  width: 100px; }\n  .is-dropdown-menu.vertical.align-right {\n    float: right; }\n\n.is-dropdown-submenu-parent {\n  position: relative; }\n  .is-dropdown-submenu-parent a::after {\n    position: absolute;\n    top: 50%;\n    right: 5px;\n    margin-top: -2px; }\n  .is-dropdown-submenu-parent.opens-inner > .is-dropdown-submenu {\n    top: 100%;\n    left: auto; }\n  .is-dropdown-submenu-parent.opens-left > .is-dropdown-submenu {\n    left: auto;\n    right: 100%; }\n  .is-dropdown-submenu-parent.opens-right > .is-dropdown-submenu {\n    right: auto;\n    left: 100%; }\n\n.is-dropdown-submenu {\n  display: none;\n  position: absolute;\n  top: 0;\n  left: 100%;\n  min-width: 200px;\n  z-index: 1;\n  background: #fefefe;\n  border: 1px solid #cacaca; }\n  .is-dropdown-submenu .is-dropdown-submenu-parent > a::after {\n    right: 14px;\n    margin-top: -3px; }\n  .is-dropdown-submenu .is-dropdown-submenu-parent.opens-left > a::after {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 5px;\n    border-color: transparent #2199e8 transparent transparent;\n    border-right-style: solid;\n    border-left-width: 0; }\n  .is-dropdown-submenu .is-dropdown-submenu-parent.opens-right > a::after {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 5px;\n    border-color: transparent transparent transparent #2199e8;\n    border-left-style: solid;\n    border-right-width: 0; }\n  .is-dropdown-submenu .is-dropdown-submenu {\n    margin-top: -1px; }\n  .is-dropdown-submenu > li {\n    width: 100%; }\n  .is-dropdown-submenu.js-dropdown-active {\n    display: block; }\n\n.flex-video {\n  position: relative;\n  height: 0;\n  padding-bottom: 75%;\n  margin-bottom: 1rem;\n  overflow: hidden; }\n  .flex-video iframe,\n  .flex-video object,\n  .flex-video embed,\n  .flex-video video {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%; }\n  .flex-video.widescreen {\n    padding-bottom: 56.25%; }\n  .flex-video.vimeo {\n    padding-top: 0; }\n\n.label {\n  display: inline-block;\n  padding: 0.33333rem 0.5rem;\n  font-size: 0.8rem;\n  line-height: 1;\n  white-space: nowrap;\n  cursor: default;\n  border-radius: 0;\n  background: #2199e8;\n  color: #fefefe; }\n  .label.secondary {\n    background: #777;\n    color: #fefefe; }\n  .label.success {\n    background: #3adb76;\n    color: #fefefe; }\n  .label.warning {\n    background: #ffae00;\n    color: #fefefe; }\n  .label.alert {\n    background: #ec5840;\n    color: #fefefe; }\n\n.media-object {\n  margin-bottom: 1rem;\n  display: block; }\n  .media-object img {\n    max-width: none; }\n  @media screen and (max-width: 39.9375em) {\n    .media-object.stack-for-small .media-object-section {\n      padding: 0;\n      padding-bottom: 1rem;\n      display: block; }\n      .media-object.stack-for-small .media-object-section img {\n        width: 100%; } }\n\n.media-object-section {\n  display: table-cell;\n  vertical-align: top; }\n  .media-object-section:first-child {\n    padding-right: 1rem; }\n  .media-object-section:last-child:not(:nth-child(2)) {\n    padding-left: 1rem; }\n  .media-object-section > :last-child {\n    margin-bottom: 0; }\n  .media-object-section.middle {\n    vertical-align: middle; }\n  .media-object-section.bottom {\n    vertical-align: bottom; }\n\nhtml,\nbody {\n  height: 100%; }\n\n.off-canvas-wrapper {\n  width: 100%;\n  overflow-x: hidden;\n  position: relative;\n  backface-visibility: hidden;\n  -webkit-overflow-scrolling: auto; }\n\n.off-canvas-wrapper-inner {\n  position: relative;\n  width: 100%;\n  transition: transform 0.5s ease; }\n  .off-canvas-wrapper-inner::before, .off-canvas-wrapper-inner::after {\n    content: ' ';\n    display: table; }\n  .off-canvas-wrapper-inner::after {\n    clear: both; }\n\n.off-canvas-content,\n.off-canvas-content {\n  min-height: 100%;\n  background: #fefefe;\n  transition: transform 0.5s ease;\n  backface-visibility: hidden;\n  z-index: 1;\n  padding-bottom: 0.1px;\n  box-shadow: 0 0 10px rgba(10, 10, 10, 0.5); }\n\n.js-off-canvas-exit {\n  display: none;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: rgba(254, 254, 254, 0.25);\n  cursor: pointer;\n  transition: background 0.5s ease; }\n\n.off-canvas {\n  position: absolute;\n  background: #e6e6e6;\n  z-index: -1;\n  max-height: 100%;\n  overflow-y: auto;\n  transform: translateX(0); }\n  [data-whatinput='mouse'] .off-canvas {\n    outline: 0; }\n  .off-canvas.position-left {\n    left: -250px;\n    top: 0;\n    width: 250px; }\n    .is-open-left {\n      transform: translateX(250px); }\n  .off-canvas.position-right {\n    right: -250px;\n    top: 0;\n    width: 250px; }\n    .is-open-right {\n      transform: translateX(-250px); }\n\n@media screen and (min-width: 40em) {\n  .position-left.reveal-for-medium {\n    left: 0;\n    z-index: auto;\n    position: fixed; }\n    .position-left.reveal-for-medium ~ .off-canvas-content {\n      margin-left: 250px; }\n  .position-right.reveal-for-medium {\n    right: 0;\n    z-index: auto;\n    position: fixed; }\n    .position-right.reveal-for-medium ~ .off-canvas-content {\n      margin-right: 250px; } }\n\n@media screen and (min-width: 64em) {\n  .position-left.reveal-for-large {\n    left: 0;\n    z-index: auto;\n    position: fixed; }\n    .position-left.reveal-for-large ~ .off-canvas-content {\n      margin-left: 250px; }\n  .position-right.reveal-for-large {\n    right: 0;\n    z-index: auto;\n    position: fixed; }\n    .position-right.reveal-for-large ~ .off-canvas-content {\n      margin-right: 250px; } }\n\n.orbit {\n  position: relative; }\n\n.orbit-container {\n  position: relative;\n  margin: 0;\n  overflow: hidden;\n  list-style: none; }\n\n.orbit-slide {\n  width: 100%;\n  max-height: 100%; }\n  .orbit-slide.no-motionui.is-active {\n    top: 0;\n    left: 0; }\n\n.orbit-figure {\n  margin: 0; }\n\n.orbit-image {\n  margin: 0;\n  width: 100%;\n  max-width: 100%; }\n\n.orbit-caption {\n  position: absolute;\n  bottom: 0;\n  width: 100%;\n  padding: 1rem;\n  margin-bottom: 0;\n  color: #fefefe;\n  background-color: rgba(10, 10, 10, 0.5); }\n\n.orbit-previous, .orbit-next {\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n  z-index: 10;\n  padding: 1rem;\n  color: #fefefe; }\n  [data-whatinput='mouse'] .orbit-previous, [data-whatinput='mouse'] .orbit-next {\n    outline: 0; }\n  .orbit-previous:hover, .orbit-next:hover, .orbit-previous:active, .orbit-next:active, .orbit-previous:focus, .orbit-next:focus {\n    background-color: rgba(10, 10, 10, 0.5); }\n\n.orbit-previous {\n  left: 0; }\n\n.orbit-next {\n  left: auto;\n  right: 0; }\n\n.orbit-bullets {\n  position: relative;\n  margin-top: 0.8rem;\n  margin-bottom: 0.8rem;\n  text-align: center; }\n  [data-whatinput='mouse'] .orbit-bullets {\n    outline: 0; }\n  .orbit-bullets button {\n    width: 1.2rem;\n    height: 1.2rem;\n    margin: 0.1rem;\n    background-color: #cacaca;\n    border-radius: 50%; }\n    .orbit-bullets button:hover {\n      background-color: #8a8a8a; }\n    .orbit-bullets button.is-active {\n      background-color: #8a8a8a; }\n\n.pagination {\n  margin-left: 0;\n  margin-bottom: 1rem; }\n  .pagination::before, .pagination::after {\n    content: ' ';\n    display: table; }\n  .pagination::after {\n    clear: both; }\n  .pagination li {\n    font-size: 0.875rem;\n    margin-right: 0.0625rem;\n    border-radius: 0;\n    display: none; }\n    .pagination li:last-child, .pagination li:first-child {\n      display: inline-block; }\n    @media screen and (min-width: 40em) {\n      .pagination li {\n        display: inline-block; } }\n  .pagination a,\n  .pagination button {\n    color: #0a0a0a;\n    display: block;\n    padding: 0.1875rem 0.625rem;\n    border-radius: 0; }\n    .pagination a:hover,\n    .pagination button:hover {\n      background: #e6e6e6; }\n  .pagination .current {\n    padding: 0.1875rem 0.625rem;\n    background: #2199e8;\n    color: #fefefe;\n    cursor: default; }\n  .pagination .disabled {\n    padding: 0.1875rem 0.625rem;\n    color: #cacaca;\n    cursor: not-allowed; }\n    .pagination .disabled:hover {\n      background: transparent; }\n  .pagination .ellipsis::after {\n    content: '\\2026';\n    padding: 0.1875rem 0.625rem;\n    color: #0a0a0a; }\n\n.pagination-previous a::before,\n.pagination-previous.disabled::before {\n  content: '\\AB';\n  display: inline-block;\n  margin-right: 0.5rem; }\n\n.pagination-next a::after,\n.pagination-next.disabled::after {\n  content: '\\BB';\n  display: inline-block;\n  margin-left: 0.5rem; }\n\n.progress {\n  background-color: #cacaca;\n  height: 1rem;\n  margin-bottom: 1rem;\n  border-radius: 0; }\n  .progress.primary .progress-meter {\n    background-color: #2199e8; }\n  .progress.secondary .progress-meter {\n    background-color: #777; }\n  .progress.success .progress-meter {\n    background-color: #3adb76; }\n  .progress.warning .progress-meter {\n    background-color: #ffae00; }\n  .progress.alert .progress-meter {\n    background-color: #ec5840; }\n\n.progress-meter {\n  position: relative;\n  display: block;\n  width: 0%;\n  height: 100%;\n  background-color: #2199e8; }\n\n.progress-meter-text {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  position: absolute;\n  margin: 0;\n  font-size: 0.75rem;\n  font-weight: bold;\n  color: #fefefe;\n  white-space: nowrap; }\n\n.slider {\n  position: relative;\n  height: 0.5rem;\n  margin-top: 1.25rem;\n  margin-bottom: 2.25rem;\n  background-color: #e6e6e6;\n  cursor: pointer;\n  user-select: none;\n  touch-action: none; }\n\n.slider-fill {\n  position: absolute;\n  top: 0;\n  left: 0;\n  display: inline-block;\n  max-width: 100%;\n  height: 0.5rem;\n  background-color: #cacaca;\n  transition: all 0.2s ease-in-out; }\n  .slider-fill.is-dragging {\n    transition: all 0s linear; }\n\n.slider-handle {\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n  position: absolute;\n  left: 0;\n  z-index: 1;\n  display: inline-block;\n  width: 1.4rem;\n  height: 1.4rem;\n  background-color: #2199e8;\n  transition: all 0.2s ease-in-out;\n  touch-action: manipulation;\n  border-radius: 0; }\n  [data-whatinput='mouse'] .slider-handle {\n    outline: 0; }\n  .slider-handle:hover {\n    background-color: #1583cc; }\n  .slider-handle.is-dragging {\n    transition: all 0s linear; }\n\n.slider.disabled,\n.slider[disabled] {\n  opacity: 0.25;\n  cursor: not-allowed; }\n\n.slider.vertical {\n  display: inline-block;\n  width: 0.5rem;\n  height: 12.5rem;\n  margin: 0 1.25rem;\n  transform: scale(1, -1); }\n  .slider.vertical .slider-fill {\n    top: 0;\n    width: 0.5rem;\n    max-height: 100%; }\n  .slider.vertical .slider-handle {\n    position: absolute;\n    top: 0;\n    left: 50%;\n    width: 1.4rem;\n    height: 1.4rem;\n    transform: translateX(-50%); }\n\n.sticky-container {\n  position: relative; }\n\n.sticky {\n  position: absolute;\n  z-index: 0;\n  transform: translate3d(0, 0, 0); }\n\n.sticky.is-stuck {\n  position: fixed;\n  z-index: 5; }\n  .sticky.is-stuck.is-at-top {\n    top: 0; }\n  .sticky.is-stuck.is-at-bottom {\n    bottom: 0; }\n\n.sticky.is-anchored {\n  position: absolute;\n  left: auto;\n  right: auto; }\n  .sticky.is-anchored.is-at-bottom {\n    bottom: 0; }\n\nbody.is-reveal-open {\n  overflow: hidden; }\n\nhtml.is-reveal-open,\nhtml.is-reveal-open body {\n  height: 100%;\n  overflow: hidden;\n  user-select: none; }\n\n.reveal-overlay {\n  display: none;\n  position: fixed;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  z-index: 1005;\n  background-color: rgba(10, 10, 10, 0.45);\n  overflow-y: scroll; }\n\n.reveal {\n  display: none;\n  z-index: 1006;\n  padding: 1rem;\n  border: 1px solid #cacaca;\n  background-color: #fefefe;\n  border-radius: 0;\n  position: relative;\n  top: 100px;\n  margin-left: auto;\n  margin-right: auto;\n  overflow-y: auto; }\n  [data-whatinput='mouse'] .reveal {\n    outline: 0; }\n  @media screen and (min-width: 40em) {\n    .reveal {\n      min-height: 0; } }\n  .reveal .column, .reveal .columns,\n  .reveal .columns {\n    min-width: 0; }\n  .reveal > :last-child {\n    margin-bottom: 0; }\n  @media screen and (min-width: 40em) {\n    .reveal {\n      width: 600px;\n      max-width: 75rem; } }\n  @media screen and (min-width: 40em) {\n    .reveal .reveal {\n      left: auto;\n      right: auto;\n      margin: 0 auto; } }\n  .reveal.collapse {\n    padding: 0; }\n  @media screen and (min-width: 40em) {\n    .reveal.tiny {\n      width: 30%;\n      max-width: 75rem; } }\n  @media screen and (min-width: 40em) {\n    .reveal.small {\n      width: 50%;\n      max-width: 75rem; } }\n  @media screen and (min-width: 40em) {\n    .reveal.large {\n      width: 90%;\n      max-width: 75rem; } }\n  .reveal.full {\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    height: 100vh;\n    min-height: 100vh;\n    max-width: none;\n    margin-left: 0;\n    border: 0;\n    border-radius: 0; }\n  @media screen and (max-width: 39.9375em) {\n    .reveal {\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      height: 100vh;\n      min-height: 100vh;\n      max-width: none;\n      margin-left: 0;\n      border: 0;\n      border-radius: 0; } }\n  .reveal.without-overlay {\n    position: fixed; }\n\n.switch {\n  margin-bottom: 1rem;\n  outline: 0;\n  position: relative;\n  user-select: none;\n  color: #fefefe;\n  font-weight: bold;\n  font-size: 0.875rem; }\n\n.switch-input {\n  opacity: 0;\n  position: absolute; }\n\n.switch-paddle {\n  background: #cacaca;\n  cursor: pointer;\n  display: block;\n  position: relative;\n  width: 4rem;\n  height: 2rem;\n  transition: all 0.25s ease-out;\n  border-radius: 0;\n  color: inherit;\n  font-weight: inherit; }\n  input + .switch-paddle {\n    margin: 0; }\n  .switch-paddle::after {\n    background: #fefefe;\n    content: '';\n    display: block;\n    position: absolute;\n    height: 1.5rem;\n    left: 0.25rem;\n    top: 0.25rem;\n    width: 1.5rem;\n    transition: all 0.25s ease-out;\n    transform: translate3d(0, 0, 0);\n    border-radius: 0; }\n  input:checked ~ .switch-paddle {\n    background: #2199e8; }\n    input:checked ~ .switch-paddle::after {\n      left: 2.25rem; }\n  [data-whatinput='mouse'] input:focus ~ .switch-paddle {\n    outline: 0; }\n\n.switch-active, .switch-inactive {\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%); }\n\n.switch-active {\n  left: 8%;\n  display: none; }\n  input:checked + label > .switch-active {\n    display: block; }\n\n.switch-inactive {\n  right: 15%; }\n  input:checked + label > .switch-inactive {\n    display: none; }\n\n.switch.tiny .switch-paddle {\n  width: 3rem;\n  height: 1.5rem;\n  font-size: 0.625rem; }\n\n.switch.tiny .switch-paddle::after {\n  width: 1rem;\n  height: 1rem; }\n\n.switch.tiny input:checked ~ .switch-paddle::after {\n  left: 1.75rem; }\n\n.switch.small .switch-paddle {\n  width: 3.5rem;\n  height: 1.75rem;\n  font-size: 0.75rem; }\n\n.switch.small .switch-paddle::after {\n  width: 1.25rem;\n  height: 1.25rem; }\n\n.switch.small input:checked ~ .switch-paddle::after {\n  left: 2rem; }\n\n.switch.large .switch-paddle {\n  width: 5rem;\n  height: 2.5rem;\n  font-size: 1rem; }\n\n.switch.large .switch-paddle::after {\n  width: 2rem;\n  height: 2rem; }\n\n.switch.large input:checked ~ .switch-paddle::after {\n  left: 2.75rem; }\n\ntable {\n  width: 100%;\n  margin-bottom: 1rem;\n  border-radius: 0; }\n  table thead,\n  table tbody,\n  table tfoot {\n    border: 1px solid #f1f1f1;\n    background-color: #fefefe; }\n  table caption {\n    font-weight: bold;\n    padding: 0.5rem 0.625rem 0.625rem; }\n  table thead,\n  table tfoot {\n    background: #f8f8f8;\n    color: #0a0a0a; }\n    table thead tr,\n    table tfoot tr {\n      background: transparent; }\n    table thead th,\n    table thead td,\n    table tfoot th,\n    table tfoot td {\n      padding: 0.5rem 0.625rem 0.625rem;\n      font-weight: bold;\n      text-align: left; }\n  table tbody tr:nth-child(even) {\n    background-color: #f1f1f1; }\n  table tbody th,\n  table tbody td {\n    padding: 0.5rem 0.625rem 0.625rem; }\n\n@media screen and (max-width: 63.9375em) {\n  table.stack thead {\n    display: none; }\n  table.stack tfoot {\n    display: none; }\n  table.stack tr,\n  table.stack th,\n  table.stack td {\n    display: block; }\n  table.stack td {\n    border-top: 0; } }\n\ntable.scroll {\n  display: block;\n  width: 100%;\n  overflow-x: auto; }\n\ntable.hover tr:hover {\n  background-color: #f9f9f9; }\n\ntable.hover tr:nth-of-type(even):hover {\n  background-color: #ececec; }\n\n.table-scroll {\n  overflow-x: auto; }\n  .table-scroll table {\n    width: auto; }\n\n.tabs {\n  margin: 0;\n  list-style-type: none;\n  background: #fefefe;\n  border: 1px solid #e6e6e6; }\n  .tabs::before, .tabs::after {\n    content: ' ';\n    display: table; }\n  .tabs::after {\n    clear: both; }\n\n.tabs.vertical > li {\n  width: auto;\n  float: none;\n  display: block; }\n\n.tabs.simple > li > a {\n  padding: 0; }\n  .tabs.simple > li > a:hover {\n    background: transparent; }\n\n.tabs.primary {\n  background: #2199e8; }\n  .tabs.primary > li > a {\n    color: #fefefe; }\n    .tabs.primary > li > a:hover, .tabs.primary > li > a:focus {\n      background: #1893e4; }\n\n.tabs-title {\n  float: left; }\n  .tabs-title > a {\n    display: block;\n    padding: 1.25rem 1.5rem;\n    line-height: 1;\n    font-size: 0.75rem; }\n    .tabs-title > a:hover {\n      background: #fefefe; }\n    .tabs-title > a:focus, .tabs-title > a[aria-selected='true'] {\n      background: #e6e6e6; }\n\n.tabs-content {\n  background: #fefefe;\n  transition: all 0.5s ease;\n  border: 1px solid #e6e6e6;\n  border-top: 0; }\n\n.tabs-content.vertical {\n  border: 1px solid #e6e6e6;\n  border-left: 0; }\n\n.tabs-panel {\n  display: none;\n  padding: 1rem; }\n  .tabs-panel.is-active {\n    display: block; }\n\n.thumbnail {\n  border: solid 4px #fefefe;\n  box-shadow: 0 0 0 1px rgba(10, 10, 10, 0.2);\n  display: inline-block;\n  line-height: 0;\n  max-width: 100%;\n  transition: box-shadow 200ms ease-out;\n  border-radius: 0;\n  margin-bottom: 1rem; }\n  .thumbnail:hover, .thumbnail:focus {\n    box-shadow: 0 0 6px 1px rgba(33, 153, 232, 0.5); }\n\n.title-bar {\n  background: #0a0a0a;\n  color: #fefefe;\n  padding: 0.5rem; }\n  .title-bar::before, .title-bar::after {\n    content: ' ';\n    display: table; }\n  .title-bar::after {\n    clear: both; }\n  .title-bar .menu-icon {\n    margin-left: 0.25rem;\n    margin-right: 0.25rem; }\n\n.title-bar-left {\n  float: left; }\n\n.title-bar-right {\n  float: right;\n  text-align: right; }\n\n.title-bar-title {\n  font-weight: bold;\n  vertical-align: middle;\n  display: inline-block; }\n\n.menu-icon.dark {\n  position: relative;\n  display: inline-block;\n  vertical-align: middle;\n  cursor: pointer;\n  width: 20px;\n  height: 16px; }\n  .menu-icon.dark::after {\n    content: '';\n    position: absolute;\n    display: block;\n    width: 100%;\n    height: 2px;\n    background: #0a0a0a;\n    top: 0;\n    left: 0;\n    box-shadow: 0 7px 0 #0a0a0a, 0 14px 0 #0a0a0a; }\n  .menu-icon.dark:hover::after {\n    background: #8a8a8a;\n    box-shadow: 0 7px 0 #8a8a8a, 0 14px 0 #8a8a8a; }\n\n.has-tip {\n  border-bottom: dotted 1px #8a8a8a;\n  font-weight: bold;\n  position: relative;\n  display: inline-block;\n  cursor: help; }\n\n.tooltip {\n  background-color: #0a0a0a;\n  color: #fefefe;\n  font-size: 80%;\n  padding: 0.75rem;\n  position: absolute;\n  z-index: 10;\n  top: calc(100% + 0.6495rem);\n  max-width: 10rem !important;\n  border-radius: 0; }\n  .tooltip::before {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 0.75rem;\n    border-color: transparent transparent #0a0a0a;\n    border-bottom-style: solid;\n    border-top-width: 0;\n    bottom: 100%;\n    position: absolute;\n    left: 50%;\n    transform: translateX(-50%); }\n  .tooltip.top::before {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 0.75rem;\n    border-color: #0a0a0a transparent transparent;\n    border-top-style: solid;\n    border-bottom-width: 0;\n    top: 100%;\n    bottom: auto; }\n  .tooltip.left::before {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 0.75rem;\n    border-color: transparent transparent transparent #0a0a0a;\n    border-left-style: solid;\n    border-right-width: 0;\n    bottom: auto;\n    left: 100%;\n    top: 50%;\n    transform: translateY(-50%); }\n  .tooltip.right::before {\n    content: '';\n    display: block;\n    width: 0;\n    height: 0;\n    border: inset 0.75rem;\n    border-color: transparent #0a0a0a transparent transparent;\n    border-right-style: solid;\n    border-left-width: 0;\n    bottom: auto;\n    left: auto;\n    right: 100%;\n    top: 50%;\n    transform: translateY(-50%); }\n\n.top-bar {\n  padding: 0.5rem; }\n  .top-bar::before, .top-bar::after {\n    content: ' ';\n    display: table; }\n  .top-bar::after {\n    clear: both; }\n  .top-bar,\n  .top-bar ul {\n    background-color: #e6e6e6; }\n  .top-bar input {\n    max-width: 200px;\n    margin-right: 1rem; }\n  .top-bar .input-group-field {\n    width: 100%;\n    margin-right: 0; }\n  .top-bar input.button {\n    width: auto; }\n  .top-bar .top-bar-left,\n  .top-bar .top-bar-right {\n    width: 100%; }\n  @media screen and (min-width: 40em) {\n    .top-bar .top-bar-left,\n    .top-bar .top-bar-right {\n      width: auto; } }\n  @media screen and (max-width: 63.9375em) {\n    .top-bar.stacked-for-medium .top-bar-left,\n    .top-bar.stacked-for-medium .top-bar-right {\n      width: 100%; } }\n  @media screen and (max-width: 74.9375em) {\n    .top-bar.stacked-for-large .top-bar-left,\n    .top-bar.stacked-for-large .top-bar-right {\n      width: 100%; } }\n\n.top-bar-title {\n  float: left;\n  margin-right: 1rem; }\n\n.top-bar-left {\n  float: left; }\n\n.top-bar-right {\n  float: right; }\n\n.hide {\n  display: none !important; }\n\n.invisible {\n  visibility: hidden; }\n\n@media screen and (max-width: 39.9375em) {\n  .hide-for-small-only {\n    display: none !important; } }\n\n@media screen and (max-width: 0em), screen and (min-width: 40em) {\n  .show-for-small-only {\n    display: none !important; } }\n\n@media screen and (min-width: 40em) {\n  .hide-for-medium {\n    display: none !important; } }\n\n@media screen and (max-width: 39.9375em) {\n  .show-for-medium {\n    display: none !important; } }\n\n@media screen and (min-width: 40em) and (max-width: 63.9375em) {\n  .hide-for-medium-only {\n    display: none !important; } }\n\n@media screen and (max-width: 39.9375em), screen and (min-width: 64em) {\n  .show-for-medium-only {\n    display: none !important; } }\n\n@media screen and (min-width: 64em) {\n  .hide-for-large {\n    display: none !important; } }\n\n@media screen and (max-width: 63.9375em) {\n  .show-for-large {\n    display: none !important; } }\n\n@media screen and (min-width: 64em) and (max-width: 74.9375em) {\n  .hide-for-large-only {\n    display: none !important; } }\n\n@media screen and (max-width: 63.9375em), screen and (min-width: 75em) {\n  .show-for-large-only {\n    display: none !important; } }\n\n.show-for-sr,\n.show-on-focus {\n  position: absolute !important;\n  width: 1px;\n  height: 1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0); }\n\n.show-on-focus:active, .show-on-focus:focus {\n  position: static !important;\n  height: auto;\n  width: auto;\n  overflow: visible;\n  clip: auto; }\n\n.show-for-landscape,\n.hide-for-portrait {\n  display: block !important; }\n  @media screen and (orientation: landscape) {\n    .show-for-landscape,\n    .hide-for-portrait {\n      display: block !important; } }\n  @media screen and (orientation: portrait) {\n    .show-for-landscape,\n    .hide-for-portrait {\n      display: none !important; } }\n\n.hide-for-landscape,\n.show-for-portrait {\n  display: none !important; }\n  @media screen and (orientation: landscape) {\n    .hide-for-landscape,\n    .show-for-portrait {\n      display: none !important; } }\n  @media screen and (orientation: portrait) {\n    .hide-for-landscape,\n    .show-for-portrait {\n      display: block !important; } }\n\n.float-left {\n  float: left !important; }\n\n.float-right {\n  float: right !important; }\n\n.float-center {\n  display: block;\n  margin-left: auto;\n  margin-right: auto; }\n\n.clearfix::before, .clearfix::after {\n  content: ' ';\n  display: table; }\n\n.clearfix::after {\n  clear: both; }\n", ""]);
	
	// exports


/***/ },
/* 232 */
/***/ function(module, exports) {

	"use strict";
	
	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function () {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for (var i = 0; i < this.length; i++) {
				var item = this[i];
				if (item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function (modules, mediaQuery) {
			if (typeof modules === "string") modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for (var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if (typeof id === "number") alreadyImportedModules[id] = true;
			}
			for (i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if (mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if (mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';
	
	//     uuid.js
	//
	//     Copyright (c) 2010-2012 Robert Kieffer
	//     MIT License - http://opensource.org/licenses/mit-license.php
	
	/*global window, require, define */
	(function (_window) {
	  'use strict';
	
	  // Unique ID creation requires a high quality random # generator.  We feature
	  // detect to determine the best RNG source, normalizing to a function that
	  // returns 128-bits of randomness, since that's what's usually required
	
	  var _rng, _mathRNG, _nodeRNG, _whatwgRNG, _previousRoot;
	
	  function setupBrowser() {
	    // Allow for MSIE11 msCrypto
	    var _crypto = _window.crypto || _window.msCrypto;
	
	    if (!_rng && _crypto && _crypto.getRandomValues) {
	      // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
	      //
	      // Moderately fast, high quality
	      try {
	        var _rnds8 = new Uint8Array(16);
	        _whatwgRNG = _rng = function whatwgRNG() {
	          _crypto.getRandomValues(_rnds8);
	          return _rnds8;
	        };
	        _rng();
	      } catch (e) {}
	    }
	
	    if (!_rng) {
	      // Math.random()-based (RNG)
	      //
	      // If all else fails, use Math.random().  It's fast, but is of unspecified
	      // quality.
	      var _rnds = new Array(16);
	      _mathRNG = _rng = function _rng() {
	        for (var i = 0, r; i < 16; i++) {
	          if ((i & 0x03) === 0) {
	            r = Math.random() * 0x100000000;
	          }
	          _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
	        }
	
	        return _rnds;
	      };
	      if ('undefined' !== typeof console && console.warn) {
	        console.warn("[SECURITY] node-uuid: crypto not usable, falling back to insecure Math.random()");
	      }
	    }
	  }
	
	  function setupNode() {
	    // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
	    //
	    // Moderately fast, high quality
	    if (true) {
	      try {
	        var _rb = __webpack_require__(239).randomBytes;
	        _nodeRNG = _rng = _rb && function () {
	          return _rb(16);
	        };
	        _rng();
	      } catch (e) {}
	    }
	  }
	
	  if (_window) {
	    setupBrowser();
	  } else {
	    setupNode();
	  }
	
	  // Buffer class to use
	  var BufferClass = 'function' === typeof Buffer ? Buffer : Array;
	
	  // Maps for number <-> hex string conversion
	  var _byteToHex = [];
	  var _hexToByte = {};
	  for (var i = 0; i < 256; i++) {
	    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
	    _hexToByte[_byteToHex[i]] = i;
	  }
	
	  // **`parse()` - Parse a UUID into it's component bytes**
	  function parse(s, buf, offset) {
	    var i = buf && offset || 0,
	        ii = 0;
	
	    buf = buf || [];
	    s.toLowerCase().replace(/[0-9a-f]{2}/g, function (oct) {
	      if (ii < 16) {
	        // Don't overflow!
	        buf[i + ii++] = _hexToByte[oct];
	      }
	    });
	
	    // Zero out remaining bytes if string was short
	    while (ii < 16) {
	      buf[i + ii++] = 0;
	    }
	
	    return buf;
	  }
	
	  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
	  function unparse(buf, offset) {
	    var i = offset || 0,
	        bth = _byteToHex;
	    return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];
	  }
	
	  // **`v1()` - Generate time-based UUID**
	  //
	  // Inspired by https://github.com/LiosK/UUID.js
	  // and http://docs.python.org/library/uuid.html
	
	  // random #'s we need to init node and clockseq
	  var _seedBytes = _rng();
	
	  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
	  var _nodeId = [_seedBytes[0] | 0x01, _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]];
	
	  // Per 4.2.2, randomize (14 bit) clockseq
	  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;
	
	  // Previous uuid creation time
	  var _lastMSecs = 0,
	      _lastNSecs = 0;
	
	  // See https://github.com/broofa/node-uuid for API details
	  function v1(options, buf, offset) {
	    var i = buf && offset || 0;
	    var b = buf || [];
	
	    options = options || {};
	
	    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;
	
	    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
	    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
	    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
	    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
	    var msecs = options.msecs != null ? options.msecs : new Date().getTime();
	
	    // Per 4.2.1.2, use count of uuid's generated during the current clock
	    // cycle to simulate higher resolution clock
	    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;
	
	    // Time since last uuid creation (in msecs)
	    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;
	
	    // Per 4.2.1.2, Bump clockseq on clock regression
	    if (dt < 0 && options.clockseq == null) {
	      clockseq = clockseq + 1 & 0x3fff;
	    }
	
	    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
	    // time interval
	    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
	      nsecs = 0;
	    }
	
	    // Per 4.2.1.2 Throw error if too many uuids are requested
	    if (nsecs >= 10000) {
	      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
	    }
	
	    _lastMSecs = msecs;
	    _lastNSecs = nsecs;
	    _clockseq = clockseq;
	
	    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
	    msecs += 12219292800000;
	
	    // `time_low`
	    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
	    b[i++] = tl >>> 24 & 0xff;
	    b[i++] = tl >>> 16 & 0xff;
	    b[i++] = tl >>> 8 & 0xff;
	    b[i++] = tl & 0xff;
	
	    // `time_mid`
	    var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
	    b[i++] = tmh >>> 8 & 0xff;
	    b[i++] = tmh & 0xff;
	
	    // `time_high_and_version`
	    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
	    b[i++] = tmh >>> 16 & 0xff;
	
	    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
	    b[i++] = clockseq >>> 8 | 0x80;
	
	    // `clock_seq_low`
	    b[i++] = clockseq & 0xff;
	
	    // `node`
	    var node = options.node || _nodeId;
	    for (var n = 0; n < 6; n++) {
	      b[i + n] = node[n];
	    }
	
	    return buf ? buf : unparse(b);
	  }
	
	  // **`v4()` - Generate random UUID**
	
	  // See https://github.com/broofa/node-uuid for API details
	  function v4(options, buf, offset) {
	    // Deprecated - 'format' argument, as supported in v1.2
	    var i = buf && offset || 0;
	
	    if (typeof options === 'string') {
	      buf = options === 'binary' ? new BufferClass(16) : null;
	      options = null;
	    }
	    options = options || {};
	
	    var rnds = options.random || (options.rng || _rng)();
	
	    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
	    rnds[6] = rnds[6] & 0x0f | 0x40;
	    rnds[8] = rnds[8] & 0x3f | 0x80;
	
	    // Copy bytes to buffer, if provided
	    if (buf) {
	      for (var ii = 0; ii < 16; ii++) {
	        buf[i + ii] = rnds[ii];
	      }
	    }
	
	    return buf || unparse(rnds);
	  }
	
	  // Export public API
	  var uuid = v4;
	  uuid.v1 = v1;
	  uuid.v4 = v4;
	  uuid.parse = parse;
	  uuid.unparse = unparse;
	  uuid.BufferClass = BufferClass;
	  uuid._rng = _rng;
	  uuid._mathRNG = _mathRNG;
	  uuid._nodeRNG = _nodeRNG;
	  uuid._whatwgRNG = _whatwgRNG;
	
	  if ('undefined' !== typeof module && module.exports) {
	    // Publish as node.js module
	    module.exports = uuid;
	  } else if (true) {
	    // Publish as AMD module
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return uuid;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else {
	    // Publish as global (in browsers)
	    _previousRoot = _window.uuid;
	
	    // **`noConflict()` - (browser only) to reset global 'uuid' var**
	    uuid.noConflict = function () {
	      _window.uuid = _previousRoot;
	      return uuid;
	    };
	
	    _window.uuid = uuid;
	  }
	})('undefined' !== typeof window ? window : null);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(235).Buffer))

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict';
	
	var base64 = __webpack_require__(236);
	var ieee754 = __webpack_require__(237);
	var isArray = __webpack_require__(238);
	
	exports.Buffer = Buffer;
	exports.SlowBuffer = SlowBuffer;
	exports.INSPECT_MAX_BYTES = 50;
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
	
	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	exports.kMaxLength = kMaxLength();
	
	function typedArraySupport() {
	  try {
	    var arr = new Uint8Array(1);
	    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {
	        return 42;
	      } };
	    return arr.foo() === 42 && // typed array instances can be augmented
	    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
	  } catch (e) {
	    return false;
	  }
	}
	
	function kMaxLength() {
	  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
	}
	
	function createBuffer(that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length');
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length);
	    that.__proto__ = Buffer.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length);
	    }
	    that.length = length;
	  }
	
	  return that;
	}
	
	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */
	
	function Buffer(arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length);
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error('If encoding is specified then the first argument must be a string');
	    }
	    return allocUnsafe(this, arg);
	  }
	  return from(this, arg, encodingOrOffset, length);
	}
	
	Buffer.poolSize = 8192; // not used by this implementation
	
	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype;
	  return arr;
	};
	
	function from(that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number');
	  }
	
	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length);
	  }
	
	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset);
	  }
	
	  return fromObject(that, value);
	}
	
	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length);
	};
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype;
	  Buffer.__proto__ = Uint8Array;
	  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
	    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true
	    });
	  }
	}
	
	function assertSize(size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number');
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative');
	  }
	}
	
	function alloc(that, size, fill, encoding) {
	  assertSize(size);
	  if (size <= 0) {
	    return createBuffer(that, size);
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
	  }
	  return createBuffer(that, size);
	}
	
	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding);
	};
	
	function allocUnsafe(that, size) {
	  assertSize(size);
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0;
	    }
	  }
	  return that;
	}
	
	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size);
	};
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size);
	};
	
	function fromString(that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8';
	  }
	
	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding');
	  }
	
	  var length = byteLength(string, encoding) | 0;
	  that = createBuffer(that, length);
	
	  var actual = that.write(string, encoding);
	
	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual);
	  }
	
	  return that;
	}
	
	function fromArrayLike(that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0;
	  that = createBuffer(that, length);
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255;
	  }
	  return that;
	}
	
	function fromArrayBuffer(that, array, byteOffset, length) {
	  array.byteLength; // this throws if `array` is not a valid ArrayBuffer
	
	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds');
	  }
	
	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds');
	  }
	
	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array);
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset);
	  } else {
	    array = new Uint8Array(array, byteOffset, length);
	  }
	
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array;
	    that.__proto__ = Buffer.prototype;
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array);
	  }
	  return that;
	}
	
	function fromObject(that, obj) {
	  if (Buffer.isBuffer(obj)) {
	    var len = checked(obj.length) | 0;
	    that = createBuffer(that, len);
	
	    if (that.length === 0) {
	      return that;
	    }
	
	    obj.copy(that, 0, 0, len);
	    return that;
	  }
	
	  if (obj) {
	    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0);
	      }
	      return fromArrayLike(that, obj);
	    }
	
	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data);
	    }
	  }
	
	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
	}
	
	function checked(length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
	  }
	  return length | 0;
	}
	
	function SlowBuffer(length) {
	  if (+length != length) {
	    // eslint-disable-line eqeqeq
	    length = 0;
	  }
	  return Buffer.alloc(+length);
	}
	
	Buffer.isBuffer = function isBuffer(b) {
	  return !!(b != null && b._isBuffer);
	};
	
	Buffer.compare = function compare(a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers');
	  }
	
	  if (a === b) return 0;
	
	  var x = a.length;
	  var y = b.length;
	
	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break;
	    }
	  }
	
	  if (x < y) return -1;
	  if (y < x) return 1;
	  return 0;
	};
	
	Buffer.isEncoding = function isEncoding(encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true;
	    default:
	      return false;
	  }
	};
	
	Buffer.concat = function concat(list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers');
	  }
	
	  if (list.length === 0) {
	    return Buffer.alloc(0);
	  }
	
	  var i;
	  if (length === undefined) {
	    length = 0;
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length;
	    }
	  }
	
	  var buffer = Buffer.allocUnsafe(length);
	  var pos = 0;
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i];
	    if (!Buffer.isBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers');
	    }
	    buf.copy(buffer, pos);
	    pos += buf.length;
	  }
	  return buffer;
	};
	
	function byteLength(string, encoding) {
	  if (Buffer.isBuffer(string)) {
	    return string.length;
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength;
	  }
	  if (typeof string !== 'string') {
	    string = '' + string;
	  }
	
	  var len = string.length;
	  if (len === 0) return 0;
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len;
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length;
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2;
	      case 'hex':
	        return len >>> 1;
	      case 'base64':
	        return base64ToBytes(string).length;
	      default:
	        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	}
	Buffer.byteLength = byteLength;
	
	function slowToString(encoding, start, end) {
	  var loweredCase = false;
	
	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.
	
	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0;
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return '';
	  }
	
	  if (end === undefined || end > this.length) {
	    end = this.length;
	  }
	
	  if (end <= 0) {
	    return '';
	  }
	
	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0;
	  start >>>= 0;
	
	  if (end <= start) {
	    return '';
	  }
	
	  if (!encoding) encoding = 'utf8';
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end);
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end);
	
	      case 'ascii':
	        return asciiSlice(this, start, end);
	
	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end);
	
	      case 'base64':
	        return base64Slice(this, start, end);
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end);
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
	        encoding = (encoding + '').toLowerCase();
	        loweredCase = true;
	    }
	  }
	}
	
	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true;
	
	function swap(b, n, m) {
	  var i = b[n];
	  b[n] = b[m];
	  b[m] = i;
	}
	
	Buffer.prototype.swap16 = function swap16() {
	  var len = this.length;
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits');
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1);
	  }
	  return this;
	};
	
	Buffer.prototype.swap32 = function swap32() {
	  var len = this.length;
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits');
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3);
	    swap(this, i + 1, i + 2);
	  }
	  return this;
	};
	
	Buffer.prototype.swap64 = function swap64() {
	  var len = this.length;
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits');
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7);
	    swap(this, i + 1, i + 6);
	    swap(this, i + 2, i + 5);
	    swap(this, i + 3, i + 4);
	  }
	  return this;
	};
	
	Buffer.prototype.toString = function toString() {
	  var length = this.length | 0;
	  if (length === 0) return '';
	  if (arguments.length === 0) return utf8Slice(this, 0, length);
	  return slowToString.apply(this, arguments);
	};
	
	Buffer.prototype.equals = function equals(b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
	  if (this === b) return true;
	  return Buffer.compare(this, b) === 0;
	};
	
	Buffer.prototype.inspect = function inspect() {
	  var str = '';
	  var max = exports.INSPECT_MAX_BYTES;
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
	    if (this.length > max) str += ' ... ';
	  }
	  return '<Buffer ' + str + '>';
	};
	
	Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
	  if (!Buffer.isBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer');
	  }
	
	  if (start === undefined) {
	    start = 0;
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0;
	  }
	  if (thisStart === undefined) {
	    thisStart = 0;
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length;
	  }
	
	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index');
	  }
	
	  if (thisStart >= thisEnd && start >= end) {
	    return 0;
	  }
	  if (thisStart >= thisEnd) {
	    return -1;
	  }
	  if (start >= end) {
	    return 1;
	  }
	
	  start >>>= 0;
	  end >>>= 0;
	  thisStart >>>= 0;
	  thisEnd >>>= 0;
	
	  if (this === target) return 0;
	
	  var x = thisEnd - thisStart;
	  var y = end - start;
	  var len = Math.min(x, y);
	
	  var thisCopy = this.slice(thisStart, thisEnd);
	  var targetCopy = target.slice(start, end);
	
	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i];
	      y = targetCopy[i];
	      break;
	    }
	  }
	
	  if (x < y) return -1;
	  if (y < x) return 1;
	  return 0;
	};
	
	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1;
	
	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset;
	    byteOffset = 0;
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff;
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000;
	  }
	  byteOffset = +byteOffset; // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : buffer.length - 1;
	  }
	
	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1;else byteOffset = buffer.length - 1;
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0;else return -1;
	  }
	
	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding);
	  }
	
	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (Buffer.isBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1;
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
	  } else if (typeof val === 'number') {
	    val = val & 0xFF; // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
	      }
	    }
	    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
	  }
	
	  throw new TypeError('val must be string, number or Buffer');
	}
	
	function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1;
	  var arrLength = arr.length;
	  var valLength = val.length;
	
	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase();
	    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1;
	      }
	      indexSize = 2;
	      arrLength /= 2;
	      valLength /= 2;
	      byteOffset /= 2;
	    }
	  }
	
	  function read(buf, i) {
	    if (indexSize === 1) {
	      return buf[i];
	    } else {
	      return buf.readUInt16BE(i * indexSize);
	    }
	  }
	
	  var i;
	  if (dir) {
	    var foundIndex = -1;
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i;
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex;
	        foundIndex = -1;
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true;
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false;
	          break;
	        }
	      }
	      if (found) return i;
	    }
	  }
	
	  return -1;
	}
	
	Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1;
	};
	
	Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
	};
	
	Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
	};
	
	function hexWrite(buf, string, offset, length) {
	  offset = Number(offset) || 0;
	  var remaining = buf.length - offset;
	  if (!length) {
	    length = remaining;
	  } else {
	    length = Number(length);
	    if (length > remaining) {
	      length = remaining;
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length;
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');
	
	  if (length > strLen / 2) {
	    length = strLen / 2;
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16);
	    if (isNaN(parsed)) return i;
	    buf[offset + i] = parsed;
	  }
	  return i;
	}
	
	function utf8Write(buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
	}
	
	function asciiWrite(buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length);
	}
	
	function latin1Write(buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length);
	}
	
	function base64Write(buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length);
	}
	
	function ucs2Write(buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
	}
	
	Buffer.prototype.write = function write(string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8';
	    length = this.length;
	    offset = 0;
	    // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset;
	    length = this.length;
	    offset = 0;
	    // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0;
	    if (isFinite(length)) {
	      length = length | 0;
	      if (encoding === undefined) encoding = 'utf8';
	    } else {
	      encoding = length;
	      length = undefined;
	    }
	    // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
	  }
	
	  var remaining = this.length - offset;
	  if (length === undefined || length > remaining) length = remaining;
	
	  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds');
	  }
	
	  if (!encoding) encoding = 'utf8';
	
	  var loweredCase = false;
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length);
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length);
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length);
	
	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length);
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length);
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length);
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
	        encoding = ('' + encoding).toLowerCase();
	        loweredCase = true;
	    }
	  }
	};
	
	Buffer.prototype.toJSON = function toJSON() {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  };
	};
	
	function base64Slice(buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf);
	  } else {
	    return base64.fromByteArray(buf.slice(start, end));
	  }
	}
	
	function utf8Slice(buf, start, end) {
	  end = Math.min(buf.length, end);
	  var res = [];
	
	  var i = start;
	  while (i < end) {
	    var firstByte = buf[i];
	    var codePoint = null;
	    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint;
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte;
	          }
	          break;
	        case 2:
	          secondByte = buf[i + 1];
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break;
	        case 3:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint;
	            }
	          }
	          break;
	        case 4:
	          secondByte = buf[i + 1];
	          thirdByte = buf[i + 2];
	          fourthByte = buf[i + 3];
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint;
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD;
	      bytesPerSequence = 1;
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000;
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
	      codePoint = 0xDC00 | codePoint & 0x3FF;
	    }
	
	    res.push(codePoint);
	    i += bytesPerSequence;
	  }
	
	  return decodeCodePointsArray(res);
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000;
	
	function decodeCodePointsArray(codePoints) {
	  var len = codePoints.length;
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = '';
	  var i = 0;
	  while (i < len) {
	    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
	  }
	  return res;
	}
	
	function asciiSlice(buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F);
	  }
	  return ret;
	}
	
	function latin1Slice(buf, start, end) {
	  var ret = '';
	  end = Math.min(buf.length, end);
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i]);
	  }
	  return ret;
	}
	
	function hexSlice(buf, start, end) {
	  var len = buf.length;
	
	  if (!start || start < 0) start = 0;
	  if (!end || end < 0 || end > len) end = len;
	
	  var out = '';
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i]);
	  }
	  return out;
	}
	
	function utf16leSlice(buf, start, end) {
	  var bytes = buf.slice(start, end);
	  var res = '';
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
	  }
	  return res;
	}
	
	Buffer.prototype.slice = function slice(start, end) {
	  var len = this.length;
	  start = ~~start;
	  end = end === undefined ? len : ~~end;
	
	  if (start < 0) {
	    start += len;
	    if (start < 0) start = 0;
	  } else if (start > len) {
	    start = len;
	  }
	
	  if (end < 0) {
	    end += len;
	    if (end < 0) end = 0;
	  } else if (end > len) {
	    end = len;
	  }
	
	  if (end < start) end = start;
	
	  var newBuf;
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end);
	    newBuf.__proto__ = Buffer.prototype;
	  } else {
	    var sliceLen = end - start;
	    newBuf = new Buffer(sliceLen, undefined);
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start];
	    }
	  }
	
	  return newBuf;
	};
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset(offset, ext, length) {
	  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);
	
	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }
	
	  return val;
	};
	
	Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length);
	  }
	
	  var val = this[offset + --byteLength];
	  var mul = 1;
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul;
	  }
	
	  return val;
	};
	
	Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  return this[offset];
	};
	
	Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return this[offset] | this[offset + 1] << 8;
	};
	
	Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  return this[offset] << 8 | this[offset + 1];
	};
	
	Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	
	  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
	};
	
	Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	
	  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
	};
	
	Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);
	
	  var val = this[offset];
	  var mul = 1;
	  var i = 0;
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul;
	  }
	  mul *= 0x80;
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
	
	  return val;
	};
	
	Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) checkOffset(offset, byteLength, this.length);
	
	  var i = byteLength;
	  var mul = 1;
	  var val = this[offset + --i];
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul;
	  }
	  mul *= 0x80;
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
	
	  return val;
	};
	
	Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length);
	  if (!(this[offset] & 0x80)) return this[offset];
	  return (0xff - this[offset] + 1) * -1;
	};
	
	Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset] | this[offset + 1] << 8;
	  return val & 0x8000 ? val | 0xFFFF0000 : val;
	};
	
	Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length);
	  var val = this[offset + 1] | this[offset] << 8;
	  return val & 0x8000 ? val | 0xFFFF0000 : val;
	};
	
	Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	
	  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
	};
	
	Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	
	  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
	};
	
	Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return ieee754.read(this, offset, true, 23, 4);
	};
	
	Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length);
	  return ieee754.read(this, offset, false, 23, 4);
	};
	
	Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return ieee754.read(this, offset, true, 52, 8);
	};
	
	Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length);
	  return ieee754.read(this, offset, false, 52, 8);
	};
	
	function checkInt(buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
	  if (offset + ext > buf.length) throw new RangeError('Index out of range');
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt(this, value, offset, byteLength, maxBytes, 0);
	  }
	
	  var mul = 1;
	  var i = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = value / mul & 0xFF;
	  }
	
	  return offset + byteLength;
	};
	
	Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  byteLength = byteLength | 0;
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
	    checkInt(this, value, offset, byteLength, maxBytes, 0);
	  }
	
	  var i = byteLength - 1;
	  var mul = 1;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = value / mul & 0xFF;
	  }
	
	  return offset + byteLength;
	};
	
	Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  this[offset] = value & 0xff;
	  return offset + 1;
	};
	
	function objectWriteUInt16(buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value & 0xff;
	    this[offset + 1] = value >>> 8;
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2;
	};
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value >>> 8;
	    this[offset + 1] = value & 0xff;
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2;
	};
	
	function objectWriteUInt32(buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1;
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = value >>> 24;
	    this[offset + 2] = value >>> 16;
	    this[offset + 1] = value >>> 8;
	    this[offset] = value & 0xff;
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4;
	};
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value >>> 24;
	    this[offset + 1] = value >>> 16;
	    this[offset + 2] = value >>> 8;
	    this[offset + 3] = value & 0xff;
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4;
	};
	
	Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }
	
	  var i = 0;
	  var mul = 1;
	  var sub = 0;
	  this[offset] = value & 0xFF;
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
	  }
	
	  return offset + byteLength;
	};
	
	Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1);
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit);
	  }
	
	  var i = byteLength - 1;
	  var mul = 1;
	  var sub = 0;
	  this[offset + i] = value & 0xFF;
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1;
	    }
	    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
	  }
	
	  return offset + byteLength;
	};
	
	Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
	  if (value < 0) value = 0xff + value + 1;
	  this[offset] = value & 0xff;
	  return offset + 1;
	};
	
	Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value & 0xff;
	    this[offset + 1] = value >>> 8;
	  } else {
	    objectWriteUInt16(this, value, offset, true);
	  }
	  return offset + 2;
	};
	
	Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value >>> 8;
	    this[offset + 1] = value & 0xff;
	  } else {
	    objectWriteUInt16(this, value, offset, false);
	  }
	  return offset + 2;
	};
	
	Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value & 0xff;
	    this[offset + 1] = value >>> 8;
	    this[offset + 2] = value >>> 16;
	    this[offset + 3] = value >>> 24;
	  } else {
	    objectWriteUInt32(this, value, offset, true);
	  }
	  return offset + 4;
	};
	
	Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
	  value = +value;
	  offset = offset | 0;
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
	  if (value < 0) value = 0xffffffff + value + 1;
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value >>> 24;
	    this[offset + 1] = value >>> 16;
	    this[offset + 2] = value >>> 8;
	    this[offset + 3] = value & 0xff;
	  } else {
	    objectWriteUInt32(this, value, offset, false);
	  }
	  return offset + 4;
	};
	
	function checkIEEE754(buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range');
	  if (offset < 0) throw new RangeError('Index out of range');
	}
	
	function writeFloat(buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4);
	  return offset + 4;
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert);
	};
	
	Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert);
	};
	
	function writeDouble(buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8);
	  return offset + 8;
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert);
	};
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert);
	};
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy(target, targetStart, start, end) {
	  if (!start) start = 0;
	  if (!end && end !== 0) end = this.length;
	  if (targetStart >= target.length) targetStart = target.length;
	  if (!targetStart) targetStart = 0;
	  if (end > 0 && end < start) end = start;
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0;
	  if (target.length === 0 || this.length === 0) return 0;
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds');
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
	  if (end < 0) throw new RangeError('sourceEnd out of bounds');
	
	  // Are we oob?
	  if (end > this.length) end = this.length;
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start;
	  }
	
	  var len = end - start;
	  var i;
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start];
	    }
	  } else {
	    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
	  }
	
	  return len;
	};
	
	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill(val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start;
	      start = 0;
	      end = this.length;
	    } else if (typeof end === 'string') {
	      encoding = end;
	      end = this.length;
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0);
	      if (code < 256) {
	        val = code;
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string');
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding);
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255;
	  }
	
	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index');
	  }
	
	  if (end <= start) {
	    return this;
	  }
	
	  start = start >>> 0;
	  end = end === undefined ? this.length : end >>> 0;
	
	  if (!val) val = 0;
	
	  var i;
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val;
	    }
	  } else {
	    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
	    var len = bytes.length;
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len];
	    }
	  }
	
	  return this;
	};
	
	// HELPER FUNCTIONS
	// ================
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
	
	function base64clean(str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return '';
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '=';
	  }
	  return str;
	}
	
	function stringtrim(str) {
	  if (str.trim) return str.trim();
	  return str.replace(/^\s+|\s+$/g, '');
	}
	
	function toHex(n) {
	  if (n < 16) return '0' + n.toString(16);
	  return n.toString(16);
	}
	
	function utf8ToBytes(string, units) {
	  units = units || Infinity;
	  var codePoint;
	  var length = string.length;
	  var leadSurrogate = null;
	  var bytes = [];
	
	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i);
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue;
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	          continue;
	        }
	
	        // valid lead
	        leadSurrogate = codePoint;
	
	        continue;
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	        leadSurrogate = codePoint;
	        continue;
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
	    }
	
	    leadSurrogate = null;
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break;
	      bytes.push(codePoint);
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break;
	      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break;
	      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break;
	      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
	    } else {
	      throw new Error('Invalid code point');
	    }
	  }
	
	  return bytes;
	}
	
	function asciiToBytes(str) {
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF);
	  }
	  return byteArray;
	}
	
	function utf16leToBytes(str, units) {
	  var c, hi, lo;
	  var byteArray = [];
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break;
	
	    c = str.charCodeAt(i);
	    hi = c >> 8;
	    lo = c % 256;
	    byteArray.push(lo);
	    byteArray.push(hi);
	  }
	
	  return byteArray;
	}
	
	function base64ToBytes(str) {
	  return base64.toByteArray(base64clean(str));
	}
	
	function blitBuffer(src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if (i + offset >= dst.length || i >= src.length) break;
	    dst[i + offset] = src[i];
	  }
	  return i;
	}
	
	function isnan(val) {
	  return val !== val; // eslint-disable-line no-self-compare
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(235).Buffer, (function() { return this; }())))

/***/ },
/* 236 */
/***/ function(module, exports) {

	'use strict';
	
	exports.byteLength = byteLength;
	exports.toByteArray = toByteArray;
	exports.fromByteArray = fromByteArray;
	
	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
	
	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i];
	  revLookup[code.charCodeAt(i)] = i;
	}
	
	revLookup['-'.charCodeAt(0)] = 62;
	revLookup['_'.charCodeAt(0)] = 63;
	
	function placeHoldersCount(b64) {
	  var len = b64.length;
	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4');
	  }
	
	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
	}
	
	function byteLength(b64) {
	  // base64 is 4/3 + up to two characters of the original data
	  return b64.length * 3 / 4 - placeHoldersCount(b64);
	}
	
	function toByteArray(b64) {
	  var i, j, l, tmp, placeHolders, arr;
	  var len = b64.length;
	  placeHolders = placeHoldersCount(b64);
	
	  arr = new Arr(len * 3 / 4 - placeHolders);
	
	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len;
	
	  var L = 0;
	
	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
	    arr[L++] = tmp >> 16 & 0xFF;
	    arr[L++] = tmp >> 8 & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }
	
	  if (placeHolders === 2) {
	    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
	    arr[L++] = tmp & 0xFF;
	  } else if (placeHolders === 1) {
	    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
	    arr[L++] = tmp >> 8 & 0xFF;
	    arr[L++] = tmp & 0xFF;
	  }
	
	  return arr;
	}
	
	function tripletToBase64(num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
	}
	
	function encodeChunk(uint8, start, end) {
	  var tmp;
	  var output = [];
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
	    output.push(tripletToBase64(tmp));
	  }
	  return output.join('');
	}
	
	function fromByteArray(uint8) {
	  var tmp;
	  var len = uint8.length;
	  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
	  var output = '';
	  var parts = [];
	  var maxChunkLength = 16383; // must be multiple of 3
	
	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
	  }
	
	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1];
	    output += lookup[tmp >> 2];
	    output += lookup[tmp << 4 & 0x3F];
	    output += '==';
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
	    output += lookup[tmp >> 10];
	    output += lookup[tmp >> 4 & 0x3F];
	    output += lookup[tmp << 2 & 0x3F];
	    output += '=';
	  }
	
	  parts.push(output);
	
	  return parts.join('');
	}

/***/ },
/* 237 */
/***/ function(module, exports) {

	"use strict";
	
	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var nBits = -7;
	  var i = isLE ? nBytes - 1 : 0;
	  var d = isLE ? -1 : 1;
	  var s = buffer[offset + i];
	
	  i += d;
	
	  e = s & (1 << -nBits) - 1;
	  s >>= -nBits;
	  nBits += eLen;
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & (1 << -nBits) - 1;
	  e >>= -nBits;
	  nBits += mLen;
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias;
	  } else if (e === eMax) {
	    return m ? NaN : (s ? -1 : 1) * Infinity;
	  } else {
	    m = m + Math.pow(2, mLen);
	    e = e - eBias;
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
	};
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c;
	  var eLen = nBytes * 8 - mLen - 1;
	  var eMax = (1 << eLen) - 1;
	  var eBias = eMax >> 1;
	  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
	  var i = isLE ? 0 : nBytes - 1;
	  var d = isLE ? 1 : -1;
	  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
	
	  value = Math.abs(value);
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0;
	    e = eMax;
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2);
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--;
	      c *= 2;
	    }
	    if (e + eBias >= 1) {
	      value += rt / c;
	    } else {
	      value += rt * Math.pow(2, 1 - eBias);
	    }
	    if (value * c >= 2) {
	      e++;
	      c /= 2;
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0;
	      e = eMax;
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
	      e = 0;
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = e << mLen | m;
	  eLen += mLen;
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128;
	};

/***/ },
/* 238 */
/***/ function(module, exports) {

	'use strict';
	
	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';
	
	var rng = __webpack_require__(240);
	
	function error() {
	  var m = [].slice.call(arguments).join(' ');
	  throw new Error([m, 'we accept pull requests', 'http://github.com/dominictarr/crypto-browserify'].join('\n'));
	}
	
	exports.createHash = __webpack_require__(242);
	
	exports.createHmac = __webpack_require__(254);
	
	exports.randomBytes = function (size, callback) {
	  if (callback && callback.call) {
	    try {
	      callback.call(this, undefined, new Buffer(rng(size)));
	    } catch (err) {
	      callback(err);
	    }
	  } else {
	    return new Buffer(rng(size));
	  }
	};
	
	function each(a, f) {
	  for (var i in a) {
	    f(a[i], i);
	  }
	}
	
	exports.getHashes = function () {
	  return ['sha1', 'sha256', 'sha512', 'md5', 'rmd160'];
	};
	
	var p = __webpack_require__(255)(exports);
	exports.pbkdf2 = p.pbkdf2;
	exports.pbkdf2Sync = p.pbkdf2Sync;
	
	// the least I can do is make error messages for the rest of the node.js/crypto api.
	each(['createCredentials', 'createCipher', 'createCipheriv', 'createDecipher', 'createDecipheriv', 'createSign', 'createVerify', 'createDiffieHellman'], function (name) {
	  exports[name] = function () {
	    error('sorry,', name, 'is not implemented yet');
	  };
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(235).Buffer))

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, Buffer) {'use strict';
	
	(function () {
	  var g = ('undefined' === typeof window ? global : window) || {};
	  _crypto = g.crypto || g.msCrypto || __webpack_require__(241);
	  module.exports = function (size) {
	    // Modern Browsers
	    if (_crypto.getRandomValues) {
	      var bytes = new Buffer(size); //in browserify, this is an extended Uint8Array
	      /* This will not work in older browsers.
	       * See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
	       */
	
	      _crypto.getRandomValues(bytes);
	      return bytes;
	    } else if (_crypto.randomBytes) {
	      return _crypto.randomBytes(size);
	    } else throw new Error('secure random number generation not supported by this browser\n' + 'use chrome, FireFox or Internet Explorer 11');
	  };
	})();
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(235).Buffer))

/***/ },
/* 241 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';
	
	var createHash = __webpack_require__(243);
	
	var md5 = toConstructor(__webpack_require__(251));
	var rmd160 = toConstructor(__webpack_require__(253));
	
	function toConstructor(fn) {
	  return function () {
	    var buffers = [];
	    var m = {
	      update: function update(data, enc) {
	        if (!Buffer.isBuffer(data)) data = new Buffer(data, enc);
	        buffers.push(data);
	        return this;
	      },
	      digest: function digest(enc) {
	        var buf = Buffer.concat(buffers);
	        var r = fn(buf);
	        buffers = null;
	        return enc ? r.toString(enc) : r;
	      }
	    };
	    return m;
	  };
	}
	
	module.exports = function (alg) {
	  if ('md5' === alg) return new md5();
	  if ('rmd160' === alg) return new rmd160();
	  return createHash(alg);
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(235).Buffer))

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _exports = module.exports = function (alg) {
	  var Alg = _exports[alg];
	  if (!Alg) throw new Error(alg + ' is not supported (we accept pull requests)');
	  return new Alg();
	};
	
	var Buffer = __webpack_require__(235).Buffer;
	var Hash = __webpack_require__(244)(Buffer);
	
	_exports.sha1 = __webpack_require__(245)(Buffer, Hash);
	_exports.sha256 = __webpack_require__(249)(Buffer, Hash);
	_exports.sha512 = __webpack_require__(250)(Buffer, Hash);

/***/ },
/* 244 */
/***/ function(module, exports) {

	"use strict";
	
	module.exports = function (Buffer) {
	
	  //prototype class for hash functions
	  function Hash(blockSize, finalSize) {
	    this._block = new Buffer(blockSize); //new Uint32Array(blockSize/4)
	    this._finalSize = finalSize;
	    this._blockSize = blockSize;
	    this._len = 0;
	    this._s = 0;
	  }
	
	  Hash.prototype.init = function () {
	    this._s = 0;
	    this._len = 0;
	  };
	
	  Hash.prototype.update = function (data, enc) {
	    if ("string" === typeof data) {
	      enc = enc || "utf8";
	      data = new Buffer(data, enc);
	    }
	
	    var l = this._len += data.length;
	    var s = this._s = this._s || 0;
	    var f = 0;
	    var buffer = this._block;
	
	    while (s < l) {
	      var t = Math.min(data.length, f + this._blockSize - s % this._blockSize);
	      var ch = t - f;
	
	      for (var i = 0; i < ch; i++) {
	        buffer[s % this._blockSize + i] = data[i + f];
	      }
	
	      s += ch;
	      f += ch;
	
	      if (s % this._blockSize === 0) {
	        this._update(buffer);
	      }
	    }
	    this._s = s;
	
	    return this;
	  };
	
	  Hash.prototype.digest = function (enc) {
	    // Suppose the length of the message M, in bits, is l
	    var l = this._len * 8;
	
	    // Append the bit 1 to the end of the message
	    this._block[this._len % this._blockSize] = 0x80;
	
	    // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
	    this._block.fill(0, this._len % this._blockSize + 1);
	
	    if (l % (this._blockSize * 8) >= this._finalSize * 8) {
	      this._update(this._block);
	      this._block.fill(0);
	    }
	
	    // to this append the block which is equal to the number l written in binary
	    // TODO: handle case where l is > Math.pow(2, 29)
	    this._block.writeInt32BE(l, this._blockSize - 4);
	
	    var hash = this._update(this._block) || this._hash();
	
	    return enc ? hash.toString(enc) : hash;
	  };
	
	  Hash.prototype._update = function () {
	    throw new Error('_update must be implemented by subclass');
	  };
	
	  return Hash;
	};

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
	 * in FIPS PUB 180-1
	 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 */
	
	var inherits = __webpack_require__(246).inherits;
	
	module.exports = function (Buffer, Hash) {
	
	  var A = 0 | 0;
	  var B = 4 | 0;
	  var C = 8 | 0;
	  var D = 12 | 0;
	  var E = 16 | 0;
	
	  var W = new (typeof Int32Array === 'undefined' ? Array : Int32Array)(80);
	
	  var POOL = [];
	
	  function Sha1() {
	    if (POOL.length) return POOL.pop().init();
	
	    if (!(this instanceof Sha1)) return new Sha1();
	    this._w = W;
	    Hash.call(this, 16 * 4, 14 * 4);
	
	    this._h = null;
	    this.init();
	  }
	
	  inherits(Sha1, Hash);
	
	  Sha1.prototype.init = function () {
	    this._a = 0x67452301;
	    this._b = 0xefcdab89;
	    this._c = 0x98badcfe;
	    this._d = 0x10325476;
	    this._e = 0xc3d2e1f0;
	
	    Hash.prototype.init.call(this);
	    return this;
	  };
	
	  Sha1.prototype._POOL = POOL;
	  Sha1.prototype._update = function (X) {
	
	    var a, b, c, d, e, _a, _b, _c, _d, _e;
	
	    a = _a = this._a;
	    b = _b = this._b;
	    c = _c = this._c;
	    d = _d = this._d;
	    e = _e = this._e;
	
	    var w = this._w;
	
	    for (var j = 0; j < 80; j++) {
	      var W = w[j] = j < 16 ? X.readInt32BE(j * 4) : rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
	
	      var t = add(add(rol(a, 5), sha1_ft(j, b, c, d)), add(add(e, W), sha1_kt(j)));
	
	      e = d;
	      d = c;
	      c = rol(b, 30);
	      b = a;
	      a = t;
	    }
	
	    this._a = add(a, _a);
	    this._b = add(b, _b);
	    this._c = add(c, _c);
	    this._d = add(d, _d);
	    this._e = add(e, _e);
	  };
	
	  Sha1.prototype._hash = function () {
	    if (POOL.length < 100) POOL.push(this);
	    var H = new Buffer(20);
	    //console.log(this._a|0, this._b|0, this._c|0, this._d|0, this._e|0)
	    H.writeInt32BE(this._a | 0, A);
	    H.writeInt32BE(this._b | 0, B);
	    H.writeInt32BE(this._c | 0, C);
	    H.writeInt32BE(this._d | 0, D);
	    H.writeInt32BE(this._e | 0, E);
	    return H;
	  };
	
	  /*
	   * Perform the appropriate triplet combination function for the current
	   * iteration
	   */
	  function sha1_ft(t, b, c, d) {
	    if (t < 20) return b & c | ~b & d;
	    if (t < 40) return b ^ c ^ d;
	    if (t < 60) return b & c | b & d | c & d;
	    return b ^ c ^ d;
	  }
	
	  /*
	   * Determine the appropriate additive constant for the current iteration
	   */
	  function sha1_kt(t) {
	    return t < 20 ? 1518500249 : t < 40 ? 1859775393 : t < 60 ? -1894007588 : -899497514;
	  }
	
	  /*
	   * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	   * to work around bugs in some JS interpreters.
	   * //dominictarr: this is 10 years old, so maybe this can be dropped?)
	   *
	   */
	  function add(x, y) {
	    return x + y | 0;
	    //lets see how this goes on testling.
	    //  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	    //  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	    //  return (msw << 16) | (lsw & 0xFFFF);
	  }
	
	  /*
	   * Bitwise rotate a 32-bit number to the left.
	   */
	  function rol(num, cnt) {
	    return num << cnt | num >>> 32 - cnt;
	  }
	
	  return Sha1;
	};

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var formatRegExp = /%[sdj%]/g;
	exports.format = function (f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }
	
	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function (x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s':
	        return String(args[i++]);
	      case '%d':
	        return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};
	
	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function (fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function () {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }
	
	  if (process.noDeprecation === true) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	};
	
	var debugs = {};
	var debugEnviron;
	exports.debuglog = function (set) {
	  if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function () {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function () {};
	    }
	  }
	  return debugs[set];
	};
	
	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;
	
	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold': [1, 22],
	  'italic': [3, 23],
	  'underline': [4, 24],
	  'inverse': [7, 27],
	  'white': [37, 39],
	  'grey': [90, 39],
	  'black': [30, 39],
	  'blue': [34, 39],
	  'cyan': [36, 39],
	  'green': [32, 39],
	  'magenta': [35, 39],
	  'red': [31, 39],
	  'yellow': [33, 39]
	};
	
	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};
	
	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];
	
	  if (style) {
	    return '\x1B[' + inspect.colors[style][0] + 'm' + str + '\x1B[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}
	
	function stylizeNoColor(str, styleType) {
	  return str;
	}
	
	function arrayToHash(array) {
	  var hash = {};
	
	  array.forEach(function (val, idx) {
	    hash[val] = true;
	  });
	
	  return hash;
	}
	
	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect && value && isFunction(value.inspect) &&
	  // Filter out the util module, it's inspect function is special
	  value.inspect !== exports.inspect &&
	  // Also filter out any prototype objects using the circular check.
	  !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }
	
	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }
	
	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);
	
	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }
	
	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }
	
	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }
	
	  var base = '',
	      array = false,
	      braces = ['{', '}'];
	
	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }
	
	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }
	
	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }
	
	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }
	
	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }
	
	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }
	
	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }
	
	  ctx.seen.push(value);
	
	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function (key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }
	
	  ctx.seen.pop();
	
	  return reduceToSingleString(output, base, braces);
	}
	
	function formatPrimitive(ctx, value) {
	  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value)) return ctx.stylize('' + value, 'number');
	  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value)) return ctx.stylize('null', 'null');
	}
	
	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}
	
	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function (key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
	    }
	  });
	  return output;
	}
	
	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function (line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function (line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }
	
	  return name + ': ' + str;
	}
	
	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function (prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);
	
	  if (length > 60) {
	    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
	  }
	
	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol' || // ES6 symbol
	  typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = __webpack_require__(247);
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}
	
	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
	
	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}
	
	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function () {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};
	
	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(248);
	
	exports._extend = function (origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;
	
	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};
	
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(11)))

/***/ },
/* 247 */
/***/ function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	module.exports = function isBuffer(arg) {
	  return arg && (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
	};

/***/ },
/* 248 */
/***/ function(module, exports) {

	'use strict';
	
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor;
	    var TempCtor = function TempCtor() {};
	    TempCtor.prototype = superCtor.prototype;
	    ctor.prototype = new TempCtor();
	    ctor.prototype.constructor = ctor;
	  };
	}

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 *
	 */
	
	var inherits = __webpack_require__(246).inherits;
	
	module.exports = function (Buffer, Hash) {
	
	  var K = [0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5, 0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174, 0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA, 0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967, 0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85, 0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070, 0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3, 0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2];
	
	  var W = new Array(64);
	
	  function Sha256() {
	    this.init();
	
	    this._w = W; //new Array(64)
	
	    Hash.call(this, 16 * 4, 14 * 4);
	  }
	
	  inherits(Sha256, Hash);
	
	  Sha256.prototype.init = function () {
	
	    this._a = 0x6a09e667 | 0;
	    this._b = 0xbb67ae85 | 0;
	    this._c = 0x3c6ef372 | 0;
	    this._d = 0xa54ff53a | 0;
	    this._e = 0x510e527f | 0;
	    this._f = 0x9b05688c | 0;
	    this._g = 0x1f83d9ab | 0;
	    this._h = 0x5be0cd19 | 0;
	
	    this._len = this._s = 0;
	
	    return this;
	  };
	
	  function S(X, n) {
	    return X >>> n | X << 32 - n;
	  }
	
	  function R(X, n) {
	    return X >>> n;
	  }
	
	  function Ch(x, y, z) {
	    return x & y ^ ~x & z;
	  }
	
	  function Maj(x, y, z) {
	    return x & y ^ x & z ^ y & z;
	  }
	
	  function Sigma0256(x) {
	    return S(x, 2) ^ S(x, 13) ^ S(x, 22);
	  }
	
	  function Sigma1256(x) {
	    return S(x, 6) ^ S(x, 11) ^ S(x, 25);
	  }
	
	  function Gamma0256(x) {
	    return S(x, 7) ^ S(x, 18) ^ R(x, 3);
	  }
	
	  function Gamma1256(x) {
	    return S(x, 17) ^ S(x, 19) ^ R(x, 10);
	  }
	
	  Sha256.prototype._update = function (M) {
	
	    var W = this._w;
	    var a, b, c, d, e, f, g, h;
	    var T1, T2;
	
	    a = this._a | 0;
	    b = this._b | 0;
	    c = this._c | 0;
	    d = this._d | 0;
	    e = this._e | 0;
	    f = this._f | 0;
	    g = this._g | 0;
	    h = this._h | 0;
	
	    for (var j = 0; j < 64; j++) {
	      var w = W[j] = j < 16 ? M.readInt32BE(j * 4) : Gamma1256(W[j - 2]) + W[j - 7] + Gamma0256(W[j - 15]) + W[j - 16];
	
	      T1 = h + Sigma1256(e) + Ch(e, f, g) + K[j] + w;
	
	      T2 = Sigma0256(a) + Maj(a, b, c);
	      h = g;g = f;f = e;e = d + T1;d = c;c = b;b = a;a = T1 + T2;
	    }
	
	    this._a = a + this._a | 0;
	    this._b = b + this._b | 0;
	    this._c = c + this._c | 0;
	    this._d = d + this._d | 0;
	    this._e = e + this._e | 0;
	    this._f = f + this._f | 0;
	    this._g = g + this._g | 0;
	    this._h = h + this._h | 0;
	  };
	
	  Sha256.prototype._hash = function () {
	    var H = new Buffer(32);
	
	    H.writeInt32BE(this._a, 0);
	    H.writeInt32BE(this._b, 4);
	    H.writeInt32BE(this._c, 8);
	    H.writeInt32BE(this._d, 12);
	    H.writeInt32BE(this._e, 16);
	    H.writeInt32BE(this._f, 20);
	    H.writeInt32BE(this._g, 24);
	    H.writeInt32BE(this._h, 28);
	
	    return H;
	  };
	
	  return Sha256;
	};

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var inherits = __webpack_require__(246).inherits;
	
	module.exports = function (Buffer, Hash) {
	  var K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];
	
	  var W = new Array(160);
	
	  function Sha512() {
	    this.init();
	    this._w = W;
	
	    Hash.call(this, 128, 112);
	  }
	
	  inherits(Sha512, Hash);
	
	  Sha512.prototype.init = function () {
	
	    this._a = 0x6a09e667 | 0;
	    this._b = 0xbb67ae85 | 0;
	    this._c = 0x3c6ef372 | 0;
	    this._d = 0xa54ff53a | 0;
	    this._e = 0x510e527f | 0;
	    this._f = 0x9b05688c | 0;
	    this._g = 0x1f83d9ab | 0;
	    this._h = 0x5be0cd19 | 0;
	
	    this._al = 0xf3bcc908 | 0;
	    this._bl = 0x84caa73b | 0;
	    this._cl = 0xfe94f82b | 0;
	    this._dl = 0x5f1d36f1 | 0;
	    this._el = 0xade682d1 | 0;
	    this._fl = 0x2b3e6c1f | 0;
	    this._gl = 0xfb41bd6b | 0;
	    this._hl = 0x137e2179 | 0;
	
	    this._len = this._s = 0;
	
	    return this;
	  };
	
	  function S(X, Xl, n) {
	    return X >>> n | Xl << 32 - n;
	  }
	
	  function Ch(x, y, z) {
	    return x & y ^ ~x & z;
	  }
	
	  function Maj(x, y, z) {
	    return x & y ^ x & z ^ y & z;
	  }
	
	  Sha512.prototype._update = function (M) {
	
	    var W = this._w;
	    var a, b, c, d, e, f, g, h;
	    var al, bl, cl, dl, el, fl, gl, hl;
	
	    a = this._a | 0;
	    b = this._b | 0;
	    c = this._c | 0;
	    d = this._d | 0;
	    e = this._e | 0;
	    f = this._f | 0;
	    g = this._g | 0;
	    h = this._h | 0;
	
	    al = this._al | 0;
	    bl = this._bl | 0;
	    cl = this._cl | 0;
	    dl = this._dl | 0;
	    el = this._el | 0;
	    fl = this._fl | 0;
	    gl = this._gl | 0;
	    hl = this._hl | 0;
	
	    for (var i = 0; i < 80; i++) {
	      var j = i * 2;
	
	      var Wi, Wil;
	
	      if (i < 16) {
	        Wi = W[j] = M.readInt32BE(j * 4);
	        Wil = W[j + 1] = M.readInt32BE(j * 4 + 4);
	      } else {
	        var x = W[j - 15 * 2];
	        var xl = W[j - 15 * 2 + 1];
	        var gamma0 = S(x, xl, 1) ^ S(x, xl, 8) ^ x >>> 7;
	        var gamma0l = S(xl, x, 1) ^ S(xl, x, 8) ^ S(xl, x, 7);
	
	        x = W[j - 2 * 2];
	        xl = W[j - 2 * 2 + 1];
	        var gamma1 = S(x, xl, 19) ^ S(xl, x, 29) ^ x >>> 6;
	        var gamma1l = S(xl, x, 19) ^ S(x, xl, 29) ^ S(xl, x, 6);
	
	        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	        var Wi7 = W[j - 7 * 2];
	        var Wi7l = W[j - 7 * 2 + 1];
	
	        var Wi16 = W[j - 16 * 2];
	        var Wi16l = W[j - 16 * 2 + 1];
	
	        Wil = gamma0l + Wi7l;
	        Wi = gamma0 + Wi7 + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
	        Wil = Wil + gamma1l;
	        Wi = Wi + gamma1 + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
	        Wil = Wil + Wi16l;
	        Wi = Wi + Wi16 + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
	
	        W[j] = Wi;
	        W[j + 1] = Wil;
	      }
	
	      var maj = Maj(a, b, c);
	      var majl = Maj(al, bl, cl);
	
	      var sigma0h = S(a, al, 28) ^ S(al, a, 2) ^ S(al, a, 7);
	      var sigma0l = S(al, a, 28) ^ S(a, al, 2) ^ S(a, al, 7);
	      var sigma1h = S(e, el, 14) ^ S(e, el, 18) ^ S(el, e, 9);
	      var sigma1l = S(el, e, 14) ^ S(el, e, 18) ^ S(e, el, 9);
	
	      // t1 = h + sigma1 + ch + K[i] + W[i]
	      var Ki = K[j];
	      var Kil = K[j + 1];
	
	      var ch = Ch(e, f, g);
	      var chl = Ch(el, fl, gl);
	
	      var t1l = hl + sigma1l;
	      var t1 = h + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
	      t1l = t1l + chl;
	      t1 = t1 + ch + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
	      t1l = t1l + Kil;
	      t1 = t1 + Ki + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
	      t1l = t1l + Wil;
	      t1 = t1 + Wi + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
	
	      // t2 = sigma0 + maj
	      var t2l = sigma0l + majl;
	      var t2 = sigma0h + maj + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
	
	      h = g;
	      hl = gl;
	      g = f;
	      gl = fl;
	      f = e;
	      fl = el;
	      el = dl + t1l | 0;
	      e = d + t1 + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
	      d = c;
	      dl = cl;
	      c = b;
	      cl = bl;
	      b = a;
	      bl = al;
	      al = t1l + t2l | 0;
	      a = t1 + t2 + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
	    }
	
	    this._al = this._al + al | 0;
	    this._bl = this._bl + bl | 0;
	    this._cl = this._cl + cl | 0;
	    this._dl = this._dl + dl | 0;
	    this._el = this._el + el | 0;
	    this._fl = this._fl + fl | 0;
	    this._gl = this._gl + gl | 0;
	    this._hl = this._hl + hl | 0;
	
	    this._a = this._a + a + (this._al >>> 0 < al >>> 0 ? 1 : 0) | 0;
	    this._b = this._b + b + (this._bl >>> 0 < bl >>> 0 ? 1 : 0) | 0;
	    this._c = this._c + c + (this._cl >>> 0 < cl >>> 0 ? 1 : 0) | 0;
	    this._d = this._d + d + (this._dl >>> 0 < dl >>> 0 ? 1 : 0) | 0;
	    this._e = this._e + e + (this._el >>> 0 < el >>> 0 ? 1 : 0) | 0;
	    this._f = this._f + f + (this._fl >>> 0 < fl >>> 0 ? 1 : 0) | 0;
	    this._g = this._g + g + (this._gl >>> 0 < gl >>> 0 ? 1 : 0) | 0;
	    this._h = this._h + h + (this._hl >>> 0 < hl >>> 0 ? 1 : 0) | 0;
	  };
	
	  Sha512.prototype._hash = function () {
	    var H = new Buffer(64);
	
	    function writeInt64BE(h, l, offset) {
	      H.writeInt32BE(h, offset);
	      H.writeInt32BE(l, offset + 4);
	    }
	
	    writeInt64BE(this._a, this._al, 0);
	    writeInt64BE(this._b, this._bl, 8);
	    writeInt64BE(this._c, this._cl, 16);
	    writeInt64BE(this._d, this._dl, 24);
	    writeInt64BE(this._e, this._el, 32);
	    writeInt64BE(this._f, this._fl, 40);
	    writeInt64BE(this._g, this._gl, 48);
	    writeInt64BE(this._h, this._hl, 56);
	
	    return H;
	  };
	
	  return Sha512;
	};

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/*
	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
	 * Digest Algorithm, as defined in RFC 1321.
	 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for more info.
	 */
	
	var helpers = __webpack_require__(252);
	
	/*
	 * Calculate the MD5 of an array of little-endian words, and a bit length
	 */
	function core_md5(x, len) {
	  /* append padding */
	  x[len >> 5] |= 0x80 << len % 32;
	  x[(len + 64 >>> 9 << 4) + 14] = len;
	
	  var a = 1732584193;
	  var b = -271733879;
	  var c = -1732584194;
	  var d = 271733878;
	
	  for (var i = 0; i < x.length; i += 16) {
	    var olda = a;
	    var oldb = b;
	    var oldc = c;
	    var oldd = d;
	
	    a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
	    d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
	    c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
	    b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
	    a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
	    d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
	    c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
	    b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
	    a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
	    d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
	    c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
	    b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
	    a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
	    d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
	    c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
	    b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);
	
	    a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
	    d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
	    c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
	    b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
	    a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
	    d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
	    c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
	    b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
	    a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
	    d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
	    c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
	    b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
	    a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
	    d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
	    c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
	    b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);
	
	    a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
	    d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
	    c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
	    b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
	    a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
	    d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
	    c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
	    b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
	    a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
	    d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
	    c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
	    b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
	    a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
	    d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
	    c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
	    b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);
	
	    a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
	    d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
	    c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
	    b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
	    a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
	    d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
	    c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
	    b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
	    a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
	    d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
	    c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
	    b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
	    a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
	    d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
	    c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
	    b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);
	
	    a = safe_add(a, olda);
	    b = safe_add(b, oldb);
	    c = safe_add(c, oldc);
	    d = safe_add(d, oldd);
	  }
	  return Array(a, b, c, d);
	}
	
	/*
	 * These functions implement the four basic operations the algorithm uses.
	 */
	function md5_cmn(q, a, b, x, s, t) {
	  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
	}
	function md5_ff(a, b, c, d, x, s, t) {
	  return md5_cmn(b & c | ~b & d, a, b, x, s, t);
	}
	function md5_gg(a, b, c, d, x, s, t) {
	  return md5_cmn(b & d | c & ~d, a, b, x, s, t);
	}
	function md5_hh(a, b, c, d, x, s, t) {
	  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
	}
	function md5_ii(a, b, c, d, x, s, t) {
	  return md5_cmn(c ^ (b | ~d), a, b, x, s, t);
	}
	
	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 */
	function safe_add(x, y) {
	  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  return msw << 16 | lsw & 0xFFFF;
	}
	
	/*
	 * Bitwise rotate a 32-bit number to the left.
	 */
	function bit_rol(num, cnt) {
	  return num << cnt | num >>> 32 - cnt;
	}
	
	module.exports = function md5(buf) {
	  return helpers.hash(buf, core_md5, 16);
	};

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {"use strict";
	
	var intSize = 4;
	var zeroBuffer = new Buffer(intSize);zeroBuffer.fill(0);
	var chrsz = 8;
	
	function toArray(buf, bigEndian) {
	  if (buf.length % intSize !== 0) {
	    var len = buf.length + (intSize - buf.length % intSize);
	    buf = Buffer.concat([buf, zeroBuffer], len);
	  }
	
	  var arr = [];
	  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
	  for (var i = 0; i < buf.length; i += intSize) {
	    arr.push(fn.call(buf, i));
	  }
	  return arr;
	}
	
	function toBuffer(arr, size, bigEndian) {
	  var buf = new Buffer(size);
	  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
	  for (var i = 0; i < arr.length; i++) {
	    fn.call(buf, arr[i], i * 4, true);
	  }
	  return buf;
	}
	
	function hash(buf, fn, hashSize, bigEndian) {
	  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
	  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
	  return toBuffer(arr, hashSize, bigEndian);
	}
	
	module.exports = { hash: hash };
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(235).Buffer))

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';
	
	module.exports = ripemd160;
	
	/*
	CryptoJS v3.1.2
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	/** @preserve
	(c) 2012 by Cédric Mesnil. All rights reserved.
	
	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
	
	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
	
	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	// Constants table
	var zl = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
	var zr = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
	var sl = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
	var sr = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
	
	var hl = [0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E];
	var hr = [0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000];
	
	var bytesToWords = function bytesToWords(bytes) {
	  var words = [];
	  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
	    words[b >>> 5] |= bytes[i] << 24 - b % 32;
	  }
	  return words;
	};
	
	var wordsToBytes = function wordsToBytes(words) {
	  var bytes = [];
	  for (var b = 0; b < words.length * 32; b += 8) {
	    bytes.push(words[b >>> 5] >>> 24 - b % 32 & 0xFF);
	  }
	  return bytes;
	};
	
	var processBlock = function processBlock(H, M, offset) {
	
	  // Swap endian
	  for (var i = 0; i < 16; i++) {
	    var offset_i = offset + i;
	    var M_offset_i = M[offset_i];
	
	    // Swap
	    M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 0x00ff00ff | (M_offset_i << 24 | M_offset_i >>> 8) & 0xff00ff00;
	  }
	
	  // Working variables
	  var al, bl, cl, dl, el;
	  var ar, br, cr, dr, er;
	
	  ar = al = H[0];
	  br = bl = H[1];
	  cr = cl = H[2];
	  dr = dl = H[3];
	  er = el = H[4];
	  // Computation
	  var t;
	  for (var i = 0; i < 80; i += 1) {
	    t = al + M[offset + zl[i]] | 0;
	    if (i < 16) {
	      t += f1(bl, cl, dl) + hl[0];
	    } else if (i < 32) {
	      t += f2(bl, cl, dl) + hl[1];
	    } else if (i < 48) {
	      t += f3(bl, cl, dl) + hl[2];
	    } else if (i < 64) {
	      t += f4(bl, cl, dl) + hl[3];
	    } else {
	      // if (i<80) {
	      t += f5(bl, cl, dl) + hl[4];
	    }
	    t = t | 0;
	    t = rotl(t, sl[i]);
	    t = t + el | 0;
	    al = el;
	    el = dl;
	    dl = rotl(cl, 10);
	    cl = bl;
	    bl = t;
	
	    t = ar + M[offset + zr[i]] | 0;
	    if (i < 16) {
	      t += f5(br, cr, dr) + hr[0];
	    } else if (i < 32) {
	      t += f4(br, cr, dr) + hr[1];
	    } else if (i < 48) {
	      t += f3(br, cr, dr) + hr[2];
	    } else if (i < 64) {
	      t += f2(br, cr, dr) + hr[3];
	    } else {
	      // if (i<80) {
	      t += f1(br, cr, dr) + hr[4];
	    }
	    t = t | 0;
	    t = rotl(t, sr[i]);
	    t = t + er | 0;
	    ar = er;
	    er = dr;
	    dr = rotl(cr, 10);
	    cr = br;
	    br = t;
	  }
	  // Intermediate hash value
	  t = H[1] + cl + dr | 0;
	  H[1] = H[2] + dl + er | 0;
	  H[2] = H[3] + el + ar | 0;
	  H[3] = H[4] + al + br | 0;
	  H[4] = H[0] + bl + cr | 0;
	  H[0] = t;
	};
	
	function f1(x, y, z) {
	  return x ^ y ^ z;
	}
	
	function f2(x, y, z) {
	  return x & y | ~x & z;
	}
	
	function f3(x, y, z) {
	  return (x | ~y) ^ z;
	}
	
	function f4(x, y, z) {
	  return x & z | y & ~z;
	}
	
	function f5(x, y, z) {
	  return x ^ (y | ~z);
	}
	
	function rotl(x, n) {
	  return x << n | x >>> 32 - n;
	}
	
	function ripemd160(message) {
	  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
	
	  if (typeof message == 'string') message = new Buffer(message, 'utf8');
	
	  var m = bytesToWords(message);
	
	  var nBitsLeft = message.length * 8;
	  var nBitsTotal = message.length * 8;
	
	  // Add padding
	  m[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
	  m[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 0x00ff00ff | (nBitsTotal << 24 | nBitsTotal >>> 8) & 0xff00ff00;
	
	  for (var i = 0; i < m.length; i += 16) {
	    processBlock(H, m, i);
	  }
	
	  // Swap endian
	  for (var i = 0; i < 5; i++) {
	    // Shortcut
	    var H_i = H[i];
	
	    // Swap
	    H[i] = (H_i << 8 | H_i >>> 24) & 0x00ff00ff | (H_i << 24 | H_i >>> 8) & 0xff00ff00;
	  }
	
	  var digestbytes = wordsToBytes(H);
	  return new Buffer(digestbytes);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(235).Buffer))

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';
	
	var createHash = __webpack_require__(242);
	
	var zeroBuffer = new Buffer(128);
	zeroBuffer.fill(0);
	
	module.exports = Hmac;
	
	function Hmac(alg, key) {
	  if (!(this instanceof Hmac)) return new Hmac(alg, key);
	  this._opad = opad;
	  this._alg = alg;
	
	  var blocksize = alg === 'sha512' ? 128 : 64;
	
	  key = this._key = !Buffer.isBuffer(key) ? new Buffer(key) : key;
	
	  if (key.length > blocksize) {
	    key = createHash(alg).update(key).digest();
	  } else if (key.length < blocksize) {
	    key = Buffer.concat([key, zeroBuffer], blocksize);
	  }
	
	  var ipad = this._ipad = new Buffer(blocksize);
	  var opad = this._opad = new Buffer(blocksize);
	
	  for (var i = 0; i < blocksize; i++) {
	    ipad[i] = key[i] ^ 0x36;
	    opad[i] = key[i] ^ 0x5C;
	  }
	
	  this._hash = createHash(alg).update(ipad);
	}
	
	Hmac.prototype.update = function (data, enc) {
	  this._hash.update(data, enc);
	  return this;
	};
	
	Hmac.prototype.digest = function (enc) {
	  var h = this._hash.digest();
	  return createHash(this._alg).update(this._opad).update(h).digest(enc);
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(235).Buffer))

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var pbkdf2Export = __webpack_require__(256);
	
	module.exports = function (crypto, exports) {
	  exports = exports || {};
	
	  var exported = pbkdf2Export(crypto);
	
	  exports.pbkdf2 = exported.pbkdf2;
	  exports.pbkdf2Sync = exported.pbkdf2Sync;
	
	  return exports;
	};

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';
	
	module.exports = function (crypto) {
	  function pbkdf2(password, salt, iterations, keylen, digest, callback) {
	    if ('function' === typeof digest) {
	      callback = digest;
	      digest = undefined;
	    }
	
	    if ('function' !== typeof callback) throw new Error('No callback provided to pbkdf2');
	
	    setTimeout(function () {
	      var result;
	
	      try {
	        result = pbkdf2Sync(password, salt, iterations, keylen, digest);
	      } catch (e) {
	        return callback(e);
	      }
	
	      callback(undefined, result);
	    });
	  }
	
	  function pbkdf2Sync(password, salt, iterations, keylen, digest) {
	    if ('number' !== typeof iterations) throw new TypeError('Iterations not a number');
	
	    if (iterations < 0) throw new TypeError('Bad iterations');
	
	    if ('number' !== typeof keylen) throw new TypeError('Key length not a number');
	
	    if (keylen < 0) throw new TypeError('Bad key length');
	
	    digest = digest || 'sha1';
	
	    if (!Buffer.isBuffer(password)) password = new Buffer(password);
	    if (!Buffer.isBuffer(salt)) salt = new Buffer(salt);
	
	    var hLen,
	        l = 1,
	        r,
	        T;
	    var DK = new Buffer(keylen);
	    var block1 = new Buffer(salt.length + 4);
	    salt.copy(block1, 0, 0, salt.length);
	
	    for (var i = 1; i <= l; i++) {
	      block1.writeUInt32BE(i, salt.length);
	
	      var U = crypto.createHmac(digest, password).update(block1).digest();
	
	      if (!hLen) {
	        hLen = U.length;
	        T = new Buffer(hLen);
	        l = Math.ceil(keylen / hLen);
	        r = keylen - (l - 1) * hLen;
	
	        if (keylen > (Math.pow(2, 32) - 1) * hLen) throw new TypeError('keylen exceeds maximum length');
	      }
	
	      U.copy(T, 0, 0, hLen);
	
	      for (var j = 1; j < iterations; j++) {
	        U = crypto.createHmac(digest, password).update(U).digest();
	
	        for (var k = 0; k < hLen; k++) {
	          T[k] ^= U[k];
	        }
	      }
	
	      var destPos = (i - 1) * hLen;
	      var len = i == l ? r : hLen;
	      T.copy(DK, destPos, 0, len);
	    }
	
	    return DK;
	  }
	
	  return {
	    pbkdf2: pbkdf2,
	    pbkdf2Sync: pbkdf2Sync
	  };
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(235).Buffer))

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var React = __webpack_require__(8);
	var Todo = __webpack_require__(258);
	
	var ToDoList = React.createClass({
	  displayName: 'ToDoList',
	
	  render: function render() {
	    var _this = this;
	
	    var todos = this.props.todos;
	
	    var renderTodos = function renderTodos() {
	      return todos.map(function (todo) {
	        return React.createElement(Todo, _extends({ key: todo.id }, todo, { onToggle: _this.props.onToggle }));
	      });
	    };
	    return React.createElement(
	      'div',
	      null,
	      renderTodos()
	    );
	  }
	});
	
	module.exports = ToDoList;

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var React = __webpack_require__(8);
	
	var ToDo = React.createClass({
	  displayName: "ToDo",
	
	  render: function render() {
	    var _this = this;
	
	    var _props = this.props;
	    var id = _props.id;
	    var text = _props.text;
	    var completed = _props.completed;
	
	    return React.createElement(
	      "div",
	      { onClick: function onClick() {
	          _this.props.onToggle(id);
	        } },
	      React.createElement("input", { type: "checkbox", checked: completed }),
	      text
	    );
	  }
	});
	
	module.exports = ToDo;

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var React = __webpack_require__(8);
	
	var AddTodo = React.createClass({
	  displayName: "AddTodo",
	
	  handleSubmit: function handleSubmit(e) {
	    e.preventDefault();
	    var todoText = this.refs.todoText.value;
	    if (todoText.length > 0) {
	      this.refs.todoText.value = "";
	      this.props.onAddTodo(todoText);
	    } else {
	      this.refs.todoText.focus();
	    }
	  },
	  render: function render() {
	    return React.createElement(
	      "div",
	      null,
	      React.createElement(
	        "form",
	        { onSubmit: this.handleSubmit },
	        React.createElement("input", { type: "text", ref: "todoText", placeholder: "What do you need to do?" }),
	        React.createElement(
	          "button",
	          { className: "button expanded" },
	          "Add todo"
	        )
	      )
	    );
	  }
	});
	
	module.exports = AddTodo;

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var React = __webpack_require__(8);
	
	var TodoSearch = React.createClass({
	  displayName: "TodoSearch",
	
	  handleSearch: function handleSearch() {
	    var showCompleted = this.refs.showCompleted.checked;
	    var searchText = this.refs.searchText.value;
	
	    this.props.onSearch(showCompleted, searchText);
	  },
	  render: function render() {
	    return React.createElement(
	      "div",
	      null,
	      React.createElement(
	        "div",
	        null,
	        React.createElement("input", { type: "search", ref: "searchText", placeholder: "Search todos", onChange: this.handleSearch })
	      ),
	      React.createElement(
	        "div",
	        null,
	        React.createElement(
	          "label",
	          null,
	          React.createElement("input", { type: "checkbox", ref: "showCompleted", onChange: this.handleSearch }),
	          "Show completed todos"
	        )
	      )
	    );
	  }
	});
	
	module.exports = TodoSearch;

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var $ = __webpack_require__(7);
	
	module.exports = {
	  setTodos: function setTodos(todos) {
	    if ($.isArray(todos)) {
	      localStorage.setItem('todos', JSON.stringify(todos));
	      return todos;
	    }
	  },
	  getTodos: function getTodos() {
	    var stringTodos = localStorage.getItem('todos');
	    var todos = [];
	
	    try {
	      todos = JSON.parse(stringTodos);
	    } catch (e) {}
	
	    return $.isArray(todos) ? todos : [];
	  }
	};

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMDhkZTI1MTVmODhkNmJiMDQ4YjQiLCJ3ZWJwYWNrOi8vLy4vfi9qcXVlcnkvZGlzdC9qcXVlcnkubWluLmpzPzZlZjYiLCJ3ZWJwYWNrOi8vLy4vfi9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2pxdWVyeS9kaXN0L2pxdWVyeS5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9mb3VuZGF0aW9uLXNpdGVzL2Rpc3QvZm91bmRhdGlvbi5taW4uanM/YjYxYiIsIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9mb3VuZGF0aW9uLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvYXBwLmpzeCIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJqUXVlcnlcIiIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L3JlYWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NLmpzIiwid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NVGV4dENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9ET01DaGlsZHJlbk9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRGFuZ2VyLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9jcmVhdGVOb2Rlc0Zyb21NYXJrdXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9jcmVhdGVBcnJheUZyb21NaXhlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL3RvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9pbnZhcmlhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9nZXRNYXJrdXBXcmFwLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2tleU1pcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFBlcmYuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvc2V0SW5uZXJIVE1MLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL3NldFRleHRDb250ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRE9NUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi93YXJuaW5nLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NSURPcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0TW91bnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0V2ZW50Q29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0V2ZW50UGx1Z2luSHViLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0V2ZW50UGx1Z2luUmVnaXN0cnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRXZlbnRQbHVnaW5VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEVycm9yVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvYWNjdW11bGF0ZUludG8uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZm9yRWFjaEFjY3VtdWxhdGVkLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RXZlbnRFbWl0dGVyTWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvVmlld3BvcnRNZXRyaWNzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL09iamVjdC5hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvaXNFdmVudFN1cHBvcnRlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUZlYXR1cmVGbGFncy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvY2FuRGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SW5zdGFuY2VIYW5kbGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Um9vdEluZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SW5zdGFuY2VNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RNYXJrdXBDaGVja3N1bS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9hZGxlcjMyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UmVjb25jaWxlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFJlZi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdE93bmVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0VXBkYXRlUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RVcGRhdGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0NhbGxiYWNrUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUG9vbGVkQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvVHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2NvbnRhaW5zTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2lzVGV4dE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9pc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RFbXB0eUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdE5hdGl2ZUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi92YWxpZGF0ZURPTU5lc3RpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3REZWZhdWx0SW5qZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRXZlbnRQcm9wYWdhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9GYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZ2V0VGV4dENvbnRlbnRBY2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0V2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0lucHV0RXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9rZXlPZi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9DaGFuZ2VFdmVudFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRFdmVudFRhcmdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9pc1RleHRJbnB1dEVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvQ2xpZW50UmVhY3RSb290SW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY01vdXNlRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljVUlFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRFdmVudE1vZGlmaWVyU3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvSFRNTERPTVByb3BlcnR5Q29uZmlnLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2ZpbmRET01Ob2RlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01Db21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvQXV0b0ZvY3VzVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9mb2N1c05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvQ1NTUHJvcGVydHlPcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0NTU1Byb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9jYW1lbGl6ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9kYW5nZXJvdXNTdHlsZVZhbHVlLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvaHlwaGVuYXRlLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvbWVtb2l6ZVN0cmluZ09ubHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01CdXR0b24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01JbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9MaW5rZWRWYWx1ZVV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldEl0ZXJhdG9yRm4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01PcHRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi90cmF2ZXJzZUFsbENoaWxkcmVuLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NU2VsZWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NVGV4dGFyZWEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RNdWx0aUNoaWxkLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q2hpbGRSZWNvbmNpbGVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2ZsYXR0ZW5DaGlsZHJlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL3NoYWxsb3dFcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEV2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9FdmVudExpc3RlbmVyLmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RJbmplY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdE5vb3BVcGRhdGVRdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SW5wdXRTZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01TZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU2VsZWN0RXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU2VydmVyUmVhY3RSb290SW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU2ltcGxlRXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljQ2xpcGJvYXJkRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljRm9jdXNFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNLZXlib2FyZEV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldEV2ZW50Q2hhckNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZ2V0RXZlbnRLZXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljRHJhZ0V2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY1RvdWNoRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljV2hlZWxFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TVkdET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERlZmF1bHRQZXJmLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2ZianMvbGliL3BlcmZvcm1hbmNlTm93LmpzIiwid2VicGFjazovLy8uL34vZmJqcy9saWIvcGVyZm9ybWFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RWZXJzaW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NU2VydmVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0U2VydmVyUmVuZGVyaW5nLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0SXNvbW9ycGhpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUZhY3Rvcmllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRWYWxpZGF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9mYmpzL2xpYi9tYXBPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvb25seUNoaWxkLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2RlcHJlY2F0ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZVV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Qcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL3JvdXRlcldhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi93YXJuaW5nL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL0ludGVybmFsUHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9QYXR0ZXJuVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9pbnZhcmlhbnQvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGVyLmpzIiwid2VicGFjazovLy8uL34vaGlzdG9yeS9saWIvY3JlYXRlSGFzaEhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L34vd2FybmluZy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vaGlzdG9yeS9saWIvQWN0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL1BhdGhVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL34vaGlzdG9yeS9saWIvRE9NVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9ET01TdGF0ZVN0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9jcmVhdGVET01IaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vaGlzdG9yeS9saWIvY3JlYXRlSGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2RlZXAtZXF1YWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9kZWVwLWVxdWFsL2xpYi9rZXlzLmpzIiwid2VicGFjazovLy8uL34vZGVlcC1lcXVhbC9saWIvaXNfYXJndW1lbnRzLmpzIiwid2VicGFjazovLy8uL34vaGlzdG9yeS9saWIvQXN5bmNVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL2NyZWF0ZUxvY2F0aW9uLmpzIiwid2VicGFjazovLy8uL34vaGlzdG9yeS9saWIvcnVuVHJhbnNpdGlvbkhvb2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9kZXByZWNhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi91c2VRdWVyaWVzLmpzIiwid2VicGFjazovLy8uL34vcXVlcnktc3RyaW5nL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vc3RyaWN0LXVyaS1lbmNvZGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9jb21wdXRlQ2hhbmdlZFJvdXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvVHJhbnNpdGlvblV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Bc3luY1V0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9pc0FjdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvZ2V0Q29tcG9uZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvbWFrZVN0YXRlV2l0aExvY2F0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9tYXRjaFJvdXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGVyQ29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvZ2V0Um91dGVQYXJhbXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlclV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9MaW5rLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9JbmRleExpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL3dpdGhSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvSW5kZXhSZWRpcmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUmVkaXJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL0luZGV4Um91dGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9IaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9MaWZlY3ljbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlQ29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvdXNlUm91dGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0aW5nQ29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvbWF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi91c2VCYXNlbmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2hpc3RvcnkvbGliL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL3VzZVJvdXRlckhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2FwcGx5Um91dGVyTWlkZGxld2FyZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvYnJvd3Nlckhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9oaXN0b3J5L2xpYi9jcmVhdGVCcm93c2VySGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvY3JlYXRlUm91dGVySGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvaGFzaEhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vYXBwL2NvbXBvbmVudHMvVG9kb0FwcC5qc3giLCJ3ZWJwYWNrOi8vLy4vYXBwL3N0eWxlcy9hcHAuc2Nzcz9iMjlmIiwid2VicGFjazovLy8uL2FwcC9zdHlsZXMvYXBwLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9ub2RlLXV1aWQvdXVpZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vY3J5cHRvLWJyb3dzZXJpZnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jcnlwdG8tYnJvd3NlcmlmeS9ybmcuanMiLCJ3ZWJwYWNrOi8vL2NyeXB0byAoaWdub3JlZCkiLCJ3ZWJwYWNrOi8vLy4vfi9jcnlwdG8tYnJvd3NlcmlmeS9jcmVhdGUtaGFzaC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NoYS5qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3NoYS5qcy9oYXNoLmpzIiwid2VicGFjazovLy8uL34vc2hhLmpzL3NoYTEuanMiLCJ3ZWJwYWNrOi8vLy4vfi91dGlsL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwid2VicGFjazovLy8uL34vaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3NoYS5qcy9zaGEyNTYuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zaGEuanMvc2hhNTEyLmpzIiwid2VicGFjazovLy8uL34vY3J5cHRvLWJyb3dzZXJpZnkvbWQ1LmpzIiwid2VicGFjazovLy8uL34vY3J5cHRvLWJyb3dzZXJpZnkvaGVscGVycy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JpcGVtZDE2MC9saWIvcmlwZW1kMTYwLmpzIiwid2VicGFjazovLy8uL34vY3J5cHRvLWJyb3dzZXJpZnkvY3JlYXRlLWhtYWMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jcnlwdG8tYnJvd3NlcmlmeS9wYmtkZjIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wYmtkZjItY29tcGF0L3Bia2RmMi5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvY29tcG9uZW50cy9Ub2RvTGlzdC5qc3giLCJ3ZWJwYWNrOi8vLy4vYXBwL2NvbXBvbmVudHMvVG9kby5qc3giLCJ3ZWJwYWNrOi8vLy4vYXBwL2NvbXBvbmVudHMvQWRkVG9kby5qc3giLCJ3ZWJwYWNrOi8vLy4vYXBwL2NvbXBvbmVudHMvVG9kb1NlYXJjaC5qc3giLCJ3ZWJwYWNrOi8vLy4vYXBwL0FQSS9Ub2RvQVBJLmpzeCJdLCJuYW1lcyI6WyJSZWFjdCIsInJlcXVpcmUiLCJSZWFjdERPTSIsIlJvdXRlIiwiUm91dGVyIiwiSW5kZXhSb3V0ZSIsImhhc2hIaXN0b3J5IiwiVG9kb0FwcCIsIiQiLCJkb2N1bWVudCIsImZvdW5kYXRpb24iLCJyZW5kZXIiLCJnZXRFbGVtZW50QnlJZCIsIm1vZHVsZSIsImV4cG9ydHMiLCJSZWFjdERPTVNlcnZlciIsIlJlYWN0SXNvbW9ycGhpYyIsImFzc2lnbiIsImRlcHJlY2F0ZWQiLCJmaW5kRE9NTm9kZSIsInVubW91bnRDb21wb25lbnRBdE5vZGUiLCJyZW5kZXJUb1N0cmluZyIsInJlbmRlclRvU3RhdGljTWFya3VwIiwiX19TRUNSRVRfRE9NX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJfX1NFQ1JFVF9ET01fU0VSVkVSX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJSZWFjdEN1cnJlbnRPd25lciIsIlJlYWN0RE9NVGV4dENvbXBvbmVudCIsIlJlYWN0RGVmYXVsdEluamVjdGlvbiIsIlJlYWN0SW5zdGFuY2VIYW5kbGVzIiwiUmVhY3RNb3VudCIsIlJlYWN0UGVyZiIsIlJlYWN0UmVjb25jaWxlciIsIlJlYWN0VXBkYXRlcyIsIlJlYWN0VmVyc2lvbiIsInJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyIiwid2FybmluZyIsImluamVjdCIsIm1lYXN1cmUiLCJ2ZXJzaW9uIiwidW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMiLCJiYXRjaGVkVXBkYXRlcyIsInVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyIiwiX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiQ3VycmVudE93bmVyIiwiSW5zdGFuY2VIYW5kbGVzIiwiTW91bnQiLCJSZWNvbmNpbGVyIiwiVGV4dENvbXBvbmVudCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIkV4ZWN1dGlvbkVudmlyb25tZW50IiwiY2FuVXNlRE9NIiwid2luZG93IiwidG9wIiwic2VsZiIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImluZGV4T2YiLCJjb25zb2xlIiwiZGVidWciLCJpZUNvbXBhdGliaWxpdHlNb2RlIiwiZG9jdW1lbnRNb2RlIiwidW5kZWZpbmVkIiwiZXhwZWN0ZWRGZWF0dXJlcyIsIkFycmF5IiwiaXNBcnJheSIsInByb3RvdHlwZSIsImV2ZXJ5IiwiZm9yRWFjaCIsIm1hcCIsIkRhdGUiLCJub3ciLCJGdW5jdGlvbiIsImJpbmQiLCJPYmplY3QiLCJrZXlzIiwiU3RyaW5nIiwic3BsaXQiLCJ0cmltIiwiY3JlYXRlIiwiZnJlZXplIiwiaSIsImxlbmd0aCIsImVycm9yIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZSIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJjYWxsIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwicXVldWUiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJjb25jYXQiLCJkcmFpblF1ZXVlIiwidGltZW91dCIsImxlbiIsInJ1biIsIm5leHRUaWNrIiwiYXJncyIsImFyZ3VtZW50cyIsInB1c2giLCJJdGVtIiwiYXJyYXkiLCJhcHBseSIsInRpdGxlIiwiYnJvd3NlciIsImFyZ3YiLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsImJpbmRpbmciLCJuYW1lIiwiY3dkIiwiY2hkaXIiLCJkaXIiLCJ1bWFzayIsImN1cnJlbnQiLCJET01DaGlsZHJlbk9wZXJhdGlvbnMiLCJET01Qcm9wZXJ0eU9wZXJhdGlvbnMiLCJSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCIsImVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciIsInNldFRleHRDb250ZW50IiwidmFsaWRhdGVET01OZXN0aW5nIiwicHJvcHMiLCJjb25zdHJ1Y3QiLCJ0ZXh0IiwiX2N1cnJlbnRFbGVtZW50IiwiX3N0cmluZ1RleHQiLCJfcm9vdE5vZGVJRCIsIl9tb3VudEluZGV4IiwibW91bnRDb21wb25lbnQiLCJyb290SUQiLCJ0cmFuc2FjdGlvbiIsImNvbnRleHQiLCJhbmNlc3RvckluZm9Db250ZXh0S2V5IiwidXNlQ3JlYXRlRWxlbWVudCIsIm93bmVyRG9jdW1lbnQiLCJvd25lckRvY3VtZW50Q29udGV4dEtleSIsImVsIiwiY3JlYXRlRWxlbWVudCIsInNldEF0dHJpYnV0ZUZvcklEIiwiZ2V0SUQiLCJlc2NhcGVkVGV4dCIsImNyZWF0ZU1hcmt1cEZvcklEIiwicmVjZWl2ZUNvbXBvbmVudCIsIm5leHRUZXh0IiwibmV4dFN0cmluZ1RleHQiLCJub2RlIiwiZ2V0Tm9kZSIsInVwZGF0ZVRleHRDb250ZW50IiwidW5tb3VudENvbXBvbmVudCIsInVubW91bnRJREZyb21FbnZpcm9ubWVudCIsIkRhbmdlciIsIlJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzIiwic2V0SW5uZXJIVE1MIiwiaW52YXJpYW50IiwiaW5zZXJ0Q2hpbGRBdCIsInBhcmVudE5vZGUiLCJjaGlsZE5vZGUiLCJpbmRleCIsImJlZm9yZUNoaWxkIiwiY2hpbGROb2RlcyIsIml0ZW0iLCJpbnNlcnRCZWZvcmUiLCJkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCIsInByb2Nlc3NVcGRhdGVzIiwidXBkYXRlcyIsIm1hcmt1cExpc3QiLCJ1cGRhdGUiLCJpbml0aWFsQ2hpbGRyZW4iLCJ1cGRhdGVkQ2hpbGRyZW4iLCJ0eXBlIiwiTU9WRV9FWElTVElORyIsIlJFTU9WRV9OT0RFIiwidXBkYXRlZEluZGV4IiwiZnJvbUluZGV4IiwidXBkYXRlZENoaWxkIiwicGFyZW50SUQiLCJyZW5kZXJlZE1hcmt1cCIsImRhbmdlcm91c2x5UmVuZGVyTWFya3VwIiwiaiIsInJlbW92ZUNoaWxkIiwiayIsIklOU0VSVF9NQVJLVVAiLCJtYXJrdXBJbmRleCIsInRvSW5kZXgiLCJTRVRfTUFSS1VQIiwiY29udGVudCIsIlRFWFRfQ09OVEVOVCIsIm1lYXN1cmVNZXRob2RzIiwiY3JlYXRlTm9kZXNGcm9tTWFya3VwIiwiZW1wdHlGdW5jdGlvbiIsImdldE1hcmt1cFdyYXAiLCJPUEVOX1RBR19OQU1FX0VYUCIsIlJFU1VMVF9JTkRFWF9BVFRSIiwiZ2V0Tm9kZU5hbWUiLCJtYXJrdXAiLCJzdWJzdHJpbmciLCJub2RlTmFtZSIsIm1hcmt1cEJ5Tm9kZU5hbWUiLCJyZXN1bHRMaXN0IiwicmVzdWx0TGlzdEFzc2lnbm1lbnRDb3VudCIsImhhc093blByb3BlcnR5IiwibWFya3VwTGlzdEJ5Tm9kZU5hbWUiLCJyZXN1bHRJbmRleCIsInJlcGxhY2UiLCJyZW5kZXJOb2RlcyIsImpvaW4iLCJyZW5kZXJOb2RlIiwiaGFzQXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwib2xkQ2hpbGQiLCJ0YWdOYW1lIiwidG9Mb3dlckNhc2UiLCJuZXdDaGlsZCIsInJlcGxhY2VDaGlsZCIsImNhblVzZVdvcmtlcnMiLCJXb3JrZXIiLCJjYW5Vc2VFdmVudExpc3RlbmVycyIsImFkZEV2ZW50TGlzdGVuZXIiLCJhdHRhY2hFdmVudCIsImNhblVzZVZpZXdwb3J0Iiwic2NyZWVuIiwiaXNJbldvcmtlciIsImNyZWF0ZUFycmF5RnJvbU1peGVkIiwiZHVtbXlOb2RlIiwibm9kZU5hbWVQYXR0ZXJuIiwibm9kZU5hbWVNYXRjaCIsIm1hdGNoIiwiaGFuZGxlU2NyaXB0Iiwid3JhcCIsImlubmVySFRNTCIsIndyYXBEZXB0aCIsImxhc3RDaGlsZCIsInNjcmlwdHMiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsIm5vZGVzIiwidG9BcnJheSIsImhhc0FycmF5TmF0dXJlIiwib2JqIiwibm9kZVR5cGUiLCJzbGljZSIsInJldCIsImlpIiwiY29uZGl0aW9uIiwiZm9ybWF0IiwiYSIsImIiLCJjIiwiZCIsImYiLCJhcmdJbmRleCIsImZyYW1lc1RvUG9wIiwic2hvdWxkV3JhcCIsInNlbGVjdFdyYXAiLCJ0YWJsZVdyYXAiLCJ0cldyYXAiLCJzdmdXcmFwIiwibWFya3VwV3JhcCIsInN2Z0VsZW1lbnRzIiwiZmlyc3RDaGlsZCIsIm1ha2VFbXB0eUZ1bmN0aW9uIiwiYXJnIiwidGhhdFJldHVybnMiLCJ0aGF0UmV0dXJuc0ZhbHNlIiwidGhhdFJldHVybnNUcnVlIiwidGhhdFJldHVybnNOdWxsIiwidGhhdFJldHVybnNUaGlzIiwidGhhdFJldHVybnNBcmd1bWVudCIsImtleU1pcnJvciIsImtleSIsImVuYWJsZU1lYXN1cmUiLCJzdG9yZWRNZWFzdXJlIiwiX25vTWVhc3VyZSIsIm9iamVjdCIsIm9iamVjdE5hbWUiLCJtZXRob2ROYW1lcyIsIm9iak5hbWUiLCJmbk5hbWUiLCJmdW5jIiwibWVhc3VyZWRGdW5jIiwid3JhcHBlciIsImRpc3BsYXlOYW1lIiwiaW5qZWN0aW9uIiwiaW5qZWN0TWVhc3VyZSIsIldISVRFU1BBQ0VfVEVTVCIsIk5PTlZJU0lCTEVfVEVTVCIsImh0bWwiLCJNU0FwcCIsImV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uIiwidGVzdEVsZW1lbnQiLCJ0ZXN0IiwiZnJvbUNoYXJDb2RlIiwidGV4dE5vZGUiLCJkYXRhIiwiZGVsZXRlRGF0YSIsInRleHRDb250ZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiRVNDQVBFX0xPT0tVUCIsIkVTQ0FQRV9SRUdFWCIsImVzY2FwZXIiLCJET01Qcm9wZXJ0eSIsInF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyIiwiVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgiLCJpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlIiwidmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlIiwiaXNBdHRyaWJ1dGVOYW1lU2FmZSIsImF0dHJpYnV0ZU5hbWUiLCJzaG91bGRJZ25vcmVWYWx1ZSIsInByb3BlcnR5SW5mbyIsInZhbHVlIiwiaGFzQm9vbGVhblZhbHVlIiwiaGFzTnVtZXJpY1ZhbHVlIiwiaXNOYU4iLCJoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSIsImhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUiLCJyZWFjdFByb3BzIiwiY2hpbGRyZW4iLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsInJlZiIsIndhcm5lZFByb3BlcnRpZXMiLCJ3YXJuVW5rbm93blByb3BlcnR5IiwibG93ZXJDYXNlZE5hbWUiLCJzdGFuZGFyZE5hbWUiLCJpc0N1c3RvbUF0dHJpYnV0ZSIsImdldFBvc3NpYmxlU3RhbmRhcmROYW1lIiwiaWQiLCJJRF9BVFRSSUJVVEVfTkFNRSIsInNldEF0dHJpYnV0ZSIsImNyZWF0ZU1hcmt1cEZvclByb3BlcnR5IiwicHJvcGVydGllcyIsImNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZSIsInNldFZhbHVlRm9yUHJvcGVydHkiLCJtdXRhdGlvbk1ldGhvZCIsImRlbGV0ZVZhbHVlRm9yUHJvcGVydHkiLCJtdXN0VXNlQXR0cmlidXRlIiwibmFtZXNwYWNlIiwiYXR0cmlidXRlTmFtZXNwYWNlIiwic2V0QXR0cmlidXRlTlMiLCJwcm9wTmFtZSIsInByb3BlcnR5TmFtZSIsImhhc1NpZGVFZmZlY3RzIiwic2V0VmFsdWVGb3JBdHRyaWJ1dGUiLCJkZWZhdWx0VmFsdWUiLCJnZXREZWZhdWx0VmFsdWVGb3JQcm9wZXJ0eSIsImNoZWNrTWFzayIsImJpdG1hc2siLCJET01Qcm9wZXJ0eUluamVjdGlvbiIsIk1VU1RfVVNFX0FUVFJJQlVURSIsIk1VU1RfVVNFX1BST1BFUlRZIiwiSEFTX1NJREVfRUZGRUNUUyIsIkhBU19CT09MRUFOX1ZBTFVFIiwiSEFTX05VTUVSSUNfVkFMVUUiLCJIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSIsIkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUiLCJpbmplY3RET01Qcm9wZXJ0eUNvbmZpZyIsImRvbVByb3BlcnR5Q29uZmlnIiwiSW5qZWN0aW9uIiwiUHJvcGVydGllcyIsIkRPTUF0dHJpYnV0ZU5hbWVzcGFjZXMiLCJET01BdHRyaWJ1dGVOYW1lcyIsIkRPTVByb3BlcnR5TmFtZXMiLCJET01NdXRhdGlvbk1ldGhvZHMiLCJfaXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMiLCJsb3dlckNhc2VkIiwicHJvcENvbmZpZyIsIm11c3RVc2VQcm9wZXJ0eSIsImRlZmF1bHRWYWx1ZUNhY2hlIiwiaXNDdXN0b21BdHRyaWJ1dGVGbiIsInByb3AiLCJub2RlRGVmYXVsdHMiLCJfbGVuIiwiX2tleSIsIm1lc3NhZ2UiLCJ4IiwiUmVhY3RET01JRE9wZXJhdGlvbnMiLCJwcm9jZXNzQ2hpbGRyZW5VcGRhdGVzIiwiZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzIiwicmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRCIsImRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRCIsInJvb3ROb2RlSUQiLCJwdXJnZUlEIiwiSU5WQUxJRF9QUk9QRVJUWV9FUlJPUlMiLCJzdHlsZSIsInVwZGF0ZVByb3BlcnR5QnlJRCIsIlJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciIsIlJlYWN0RE9NRmVhdHVyZUZsYWdzIiwiUmVhY3RFbGVtZW50IiwiUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5IiwiUmVhY3RJbnN0YW5jZU1hcCIsIlJlYWN0TWFya3VwQ2hlY2tzdW0iLCJSZWFjdFVwZGF0ZVF1ZXVlIiwiZW1wdHlPYmplY3QiLCJjb250YWluc05vZGUiLCJpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50Iiwic2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQiLCJBVFRSX05BTUUiLCJub2RlQ2FjaGUiLCJFTEVNRU5UX05PREVfVFlQRSIsIkRPQ19OT0RFX1RZUEUiLCJET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJpbnN0YW5jZXNCeVJlYWN0Um9vdElEIiwiY29udGFpbmVyc0J5UmVhY3RSb290SUQiLCJyb290RWxlbWVudHNCeVJlYWN0Um9vdElEIiwiZmluZENvbXBvbmVudFJvb3RSZXVzYWJsZUFycmF5IiwiZmlyc3REaWZmZXJlbmNlSW5kZXgiLCJzdHJpbmcxIiwic3RyaW5nMiIsIm1pbkxlbiIsIm1pbiIsImNoYXJBdCIsImdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lciIsImNvbnRhaW5lciIsImdldFJlYWN0Um9vdElEIiwicm9vdEVsZW1lbnQiLCJpbnRlcm5hbEdldElEIiwiY2FjaGVkIiwiaXNWYWxpZCIsInNldElEIiwib2xkSUQiLCJmaW5kUmVhY3ROb2RlQnlJRCIsImdldE5vZGVGcm9tSW5zdGFuY2UiLCJpbnN0YW5jZSIsImdldCIsImlzTnVsbENvbXBvbmVudElEIiwiZmluZFJlYWN0Q29udGFpbmVyRm9ySUQiLCJkZWVwZXN0Tm9kZVNvRmFyIiwiZmluZERlZXBlc3RDYWNoZWRBbmNlc3RvckltcGwiLCJhbmNlc3RvcklEIiwiYW5jZXN0b3IiLCJmaW5kRGVlcGVzdENhY2hlZEFuY2VzdG9yIiwidGFyZ2V0SUQiLCJ0cmF2ZXJzZUFuY2VzdG9ycyIsImZvdW5kTm9kZSIsIm1vdW50Q29tcG9uZW50SW50b05vZGUiLCJjb21wb25lbnRJbnN0YW5jZSIsInNob3VsZFJldXNlTWFya3VwIiwidGFnIiwidXBkYXRlZEFuY2VzdG9ySW5mbyIsIl9yZW5kZXJlZENvbXBvbmVudCIsIl90b3BMZXZlbFdyYXBwZXIiLCJfbW91bnRJbWFnZUludG9Ob2RlIiwiYmF0Y2hlZE1vdW50Q29tcG9uZW50SW50b05vZGUiLCJSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uIiwiZ2V0UG9vbGVkIiwicGVyZm9ybSIsInJlbGVhc2UiLCJ1bm1vdW50Q29tcG9uZW50RnJvbU5vZGUiLCJoYXNOb25Sb290UmVhY3RDaGlsZCIsInJlYWN0Um9vdElEIiwiZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEIiwiZmluZEZpcnN0UmVhY3RET01JbXBsIiwibm9kZUlEIiwibGFzdElEIiwiVG9wTGV2ZWxXcmFwcGVyIiwiaXNSZWFjdENvbXBvbmVudCIsIl9pbnN0YW5jZXNCeVJlYWN0Um9vdElEIiwic2Nyb2xsTW9uaXRvciIsInJlbmRlckNhbGxiYWNrIiwiX3VwZGF0ZVJvb3RDb21wb25lbnQiLCJwcmV2Q29tcG9uZW50IiwibmV4dEVsZW1lbnQiLCJjYWxsYmFjayIsImVucXVldWVFbGVtZW50SW50ZXJuYWwiLCJlbnF1ZXVlQ2FsbGJhY2tJbnRlcm5hbCIsIl9yZWdpc3RlckNvbXBvbmVudCIsIm5leHRDb21wb25lbnQiLCJlbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3JpbmciLCJyZWdpc3RlckNvbnRhaW5lciIsIl9yZW5kZXJOZXdSb290Q29tcG9uZW50IiwiZ2V0TmFtZSIsInBhcmVudENvbXBvbmVudCIsIl9yZWFjdEludGVybmFsSW5zdGFuY2UiLCJfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJpc1ZhbGlkRWxlbWVudCIsInRvVXBwZXJDYXNlIiwibmV4dFdyYXBwZWRFbGVtZW50IiwicHJldldyYXBwZWRFbGVtZW50IiwicHJldkVsZW1lbnQiLCJwdWJsaWNJbnN0IiwiZ2V0UHVibGljSW5zdGFuY2UiLCJ1cGRhdGVkQ2FsbGJhY2siLCJyZWFjdFJvb3RFbGVtZW50IiwiY29udGFpbmVySGFzUmVhY3RNYXJrdXAiLCJjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCIsIm5leHRTaWJsaW5nIiwicm9vdEVsZW1lbnRTaWJsaW5nIiwiY29tcG9uZW50IiwiX3Byb2Nlc3NDaGlsZENvbnRleHQiLCJfY29udGV4dCIsImNyZWF0ZVJlYWN0Um9vdElEIiwiY29udGFpbmVySUQiLCJpc0NvbnRhaW5lclJlYWN0Um9vdCIsImNvbnRhaW5lckNoaWxkIiwicmVhY3RSb290IiwiZmluZENvbXBvbmVudFJvb3QiLCJnZXRGaXJzdFJlYWN0RE9NIiwiYW5jZXN0b3JOb2RlIiwiZmlyc3RDaGlsZHJlbiIsImNoaWxkSW5kZXgiLCJkZWVwZXN0QW5jZXN0b3IiLCJjaGlsZCIsInRhcmdldENoaWxkIiwiY2hpbGRJRCIsImlzQW5jZXN0b3JJRE9mIiwiY2FuUmV1c2VNYXJrdXAiLCJjaGVja3N1bSIsIkNIRUNLU1VNX0FUVFJfTkFNRSIsInJvb3RNYXJrdXAiLCJvdXRlckhUTUwiLCJub3JtYWxpemVkTWFya3VwIiwibm9ybWFsaXplciIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImNvbnRlbnREb2N1bWVudCIsIndyaXRlIiwiZGlmZkluZGV4IiwiZGlmZmVyZW5jZSIsIkV2ZW50Q29uc3RhbnRzIiwiRXZlbnRQbHVnaW5IdWIiLCJFdmVudFBsdWdpblJlZ2lzdHJ5IiwiUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiIsIlZpZXdwb3J0TWV0cmljcyIsImlzRXZlbnRTdXBwb3J0ZWQiLCJhbHJlYWR5TGlzdGVuaW5nVG8iLCJpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSIsInJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciIsInRvcEV2ZW50TWFwcGluZyIsInRvcEFib3J0IiwidG9wQmx1ciIsInRvcENhblBsYXkiLCJ0b3BDYW5QbGF5VGhyb3VnaCIsInRvcENoYW5nZSIsInRvcENsaWNrIiwidG9wQ29tcG9zaXRpb25FbmQiLCJ0b3BDb21wb3NpdGlvblN0YXJ0IiwidG9wQ29tcG9zaXRpb25VcGRhdGUiLCJ0b3BDb250ZXh0TWVudSIsInRvcENvcHkiLCJ0b3BDdXQiLCJ0b3BEb3VibGVDbGljayIsInRvcERyYWciLCJ0b3BEcmFnRW5kIiwidG9wRHJhZ0VudGVyIiwidG9wRHJhZ0V4aXQiLCJ0b3BEcmFnTGVhdmUiLCJ0b3BEcmFnT3ZlciIsInRvcERyYWdTdGFydCIsInRvcERyb3AiLCJ0b3BEdXJhdGlvbkNoYW5nZSIsInRvcEVtcHRpZWQiLCJ0b3BFbmNyeXB0ZWQiLCJ0b3BFbmRlZCIsInRvcEVycm9yIiwidG9wRm9jdXMiLCJ0b3BJbnB1dCIsInRvcEtleURvd24iLCJ0b3BLZXlQcmVzcyIsInRvcEtleVVwIiwidG9wTG9hZGVkRGF0YSIsInRvcExvYWRlZE1ldGFkYXRhIiwidG9wTG9hZFN0YXJ0IiwidG9wTW91c2VEb3duIiwidG9wTW91c2VNb3ZlIiwidG9wTW91c2VPdXQiLCJ0b3BNb3VzZU92ZXIiLCJ0b3BNb3VzZVVwIiwidG9wUGFzdGUiLCJ0b3BQYXVzZSIsInRvcFBsYXkiLCJ0b3BQbGF5aW5nIiwidG9wUHJvZ3Jlc3MiLCJ0b3BSYXRlQ2hhbmdlIiwidG9wU2Nyb2xsIiwidG9wU2Vla2VkIiwidG9wU2Vla2luZyIsInRvcFNlbGVjdGlvbkNoYW5nZSIsInRvcFN0YWxsZWQiLCJ0b3BTdXNwZW5kIiwidG9wVGV4dElucHV0IiwidG9wVGltZVVwZGF0ZSIsInRvcFRvdWNoQ2FuY2VsIiwidG9wVG91Y2hFbmQiLCJ0b3BUb3VjaE1vdmUiLCJ0b3BUb3VjaFN0YXJ0IiwidG9wVm9sdW1lQ2hhbmdlIiwidG9wV2FpdGluZyIsInRvcFdoZWVsIiwidG9wTGlzdGVuZXJzSURLZXkiLCJnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudCIsIm1vdW50QXQiLCJSZWFjdEV2ZW50TGlzdGVuZXIiLCJpbmplY3RSZWFjdEV2ZW50TGlzdGVuZXIiLCJzZXRIYW5kbGVUb3BMZXZlbCIsImhhbmRsZVRvcExldmVsIiwic2V0RW5hYmxlZCIsImVuYWJsZWQiLCJpc0VuYWJsZWQiLCJsaXN0ZW5UbyIsInJlZ2lzdHJhdGlvbk5hbWUiLCJjb250ZW50RG9jdW1lbnRIYW5kbGUiLCJpc0xpc3RlbmluZyIsImRlcGVuZGVuY2llcyIsInJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMiLCJ0b3BMZXZlbFR5cGVzIiwiZGVwZW5kZW5jeSIsInRyYXBCdWJibGVkRXZlbnQiLCJ0cmFwQ2FwdHVyZWRFdmVudCIsIldJTkRPV19IQU5ETEUiLCJ0b3BMZXZlbFR5cGUiLCJoYW5kbGVyQmFzZU5hbWUiLCJoYW5kbGUiLCJyZWZyZXNoIiwicmVmcmVzaFNjcm9sbFZhbHVlcyIsIm1vbml0b3JTY3JvbGxWYWx1ZSIsImV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyIsInJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzIiwicHV0TGlzdGVuZXIiLCJnZXRMaXN0ZW5lciIsImRlbGV0ZUxpc3RlbmVyIiwiZGVsZXRlQWxsTGlzdGVuZXJzIiwiUHJvcGFnYXRpb25QaGFzZXMiLCJidWJibGVkIiwiY2FwdHVyZWQiLCJ0b3BMb2FkIiwidG9wUmVzZXQiLCJ0b3BTdWJtaXQiLCJFdmVudFBsdWdpblV0aWxzIiwiUmVhY3RFcnJvclV0aWxzIiwiYWNjdW11bGF0ZUludG8iLCJmb3JFYWNoQWNjdW11bGF0ZWQiLCJsaXN0ZW5lckJhbmsiLCJldmVudFF1ZXVlIiwiZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlIiwiZXZlbnQiLCJzaW11bGF0ZWQiLCJleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIiLCJpc1BlcnNpc3RlbnQiLCJjb25zdHJ1Y3RvciIsImV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCIsImV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsIiwiSW5zdGFuY2VIYW5kbGUiLCJ2YWxpZGF0ZUluc3RhbmNlSGFuZGxlIiwidmFsaWQiLCJ0cmF2ZXJzZVR3b1BoYXNlIiwidHJhdmVyc2VFbnRlckxlYXZlIiwiaW5qZWN0TW91bnQiLCJpbmplY3RJbnN0YW5jZUhhbmRsZSIsIkluamVjdGVkSW5zdGFuY2VIYW5kbGUiLCJnZXRJbnN0YW5jZUhhbmRsZSIsImluamVjdEV2ZW50UGx1Z2luT3JkZXIiLCJpbmplY3RFdmVudFBsdWdpbnNCeU5hbWUiLCJsaXN0ZW5lciIsImJhbmtGb3JSZWdpc3RyYXRpb25OYW1lIiwiUGx1Z2luTW9kdWxlIiwiZGlkUHV0TGlzdGVuZXIiLCJ3aWxsRGVsZXRlTGlzdGVuZXIiLCJleHRyYWN0RXZlbnRzIiwidG9wTGV2ZWxUYXJnZXQiLCJ0b3BMZXZlbFRhcmdldElEIiwibmF0aXZlRXZlbnQiLCJuYXRpdmVFdmVudFRhcmdldCIsImV2ZW50cyIsInBsdWdpbnMiLCJwb3NzaWJsZVBsdWdpbiIsImV4dHJhY3RlZEV2ZW50cyIsImVucXVldWVFdmVudHMiLCJwcm9jZXNzRXZlbnRRdWV1ZSIsInByb2Nlc3NpbmdFdmVudFF1ZXVlIiwicmV0aHJvd0NhdWdodEVycm9yIiwiX19wdXJnZSIsIl9fZ2V0TGlzdGVuZXJCYW5rIiwiRXZlbnRQbHVnaW5PcmRlciIsIm5hbWVzVG9QbHVnaW5zIiwicmVjb21wdXRlUGx1Z2luT3JkZXJpbmciLCJwbHVnaW5OYW1lIiwicGx1Z2luSW5kZXgiLCJwdWJsaXNoZWRFdmVudHMiLCJldmVudFR5cGVzIiwiZXZlbnROYW1lIiwicHVibGlzaEV2ZW50Rm9yUGx1Z2luIiwiZGlzcGF0Y2hDb25maWciLCJwaGFzZWRSZWdpc3RyYXRpb25OYW1lcyIsInBoYXNlTmFtZSIsInBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUiLCJwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZSIsIkluamVjdGVkRXZlbnRQbHVnaW5PcmRlciIsImluamVjdGVkTmFtZXNUb1BsdWdpbnMiLCJpc09yZGVyaW5nRGlydHkiLCJnZXRQbHVnaW5Nb2R1bGVGb3JFdmVudCIsInBoYXNlIiwiX3Jlc2V0RXZlbnRQbHVnaW5zIiwiSW5qZWN0ZWRNb3VudCIsImlzRW5kaXNoIiwiaXNNb3ZlaXNoIiwiaXNTdGFydGlzaCIsInZhbGlkYXRlRXZlbnREaXNwYXRjaGVzIiwiZGlzcGF0Y2hMaXN0ZW5lcnMiLCJfZGlzcGF0Y2hMaXN0ZW5lcnMiLCJkaXNwYXRjaElEcyIsIl9kaXNwYXRjaElEcyIsImxpc3RlbmVyc0lzQXJyIiwiaWRzSXNBcnIiLCJJRHNMZW4iLCJsaXN0ZW5lcnNMZW4iLCJleGVjdXRlRGlzcGF0Y2giLCJkb21JRCIsImN1cnJlbnRUYXJnZXQiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tXaXRoQ2F0Y2giLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2siLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsImV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsIiwiZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZSIsImV4ZWN1dGVEaXJlY3REaXNwYXRjaCIsImRpc3BhdGNoTGlzdGVuZXIiLCJkaXNwYXRjaElEIiwicmVzIiwiaGFzRGlzcGF0Y2hlcyIsImNhdWdodEVycm9yIiwiZGlzcGF0Y2hFdmVudCIsImNyZWF0ZUV2ZW50IiwiZmFrZU5vZGUiLCJib3VuZEZ1bmMiLCJldnRUeXBlIiwiZXZ0IiwiaW5pdEV2ZW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm5leHQiLCJjdXJyZW50SXNBcnJheSIsIm5leHRJc0FycmF5IiwiYXJyIiwiY2IiLCJzY29wZSIsInJ1bkV2ZW50UXVldWVJbkJhdGNoIiwiY3VycmVudFNjcm9sbExlZnQiLCJjdXJyZW50U2Nyb2xsVG9wIiwic2Nyb2xsUG9zaXRpb24iLCJ5IiwidGFyZ2V0Iiwic291cmNlcyIsIlR5cGVFcnJvciIsInRvIiwibmV4dEluZGV4IiwibmV4dFNvdXJjZSIsImZyb20iLCJ1c2VIYXNGZWF0dXJlIiwiaW1wbGVtZW50YXRpb24iLCJoYXNGZWF0dXJlIiwiZXZlbnROYW1lU3VmZml4IiwiY2FwdHVyZSIsImlzU3VwcG9ydGVkIiwiZWxlbWVudCIsImNhbkRlZmluZVByb3BlcnR5IiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiU3ltYm9sIiwiUkVTRVJWRURfUFJPUFMiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNvdXJjZSIsIm93bmVyIiwiJCR0eXBlb2YiLCJfb3duZXIiLCJfc3RvcmUiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsInZhbGlkYXRlZCIsIl9zZWxmIiwiX3NvdXJjZSIsImNvbmZpZyIsImNoaWxkcmVuTGVuZ3RoIiwiY2hpbGRBcnJheSIsImRlZmF1bHRQcm9wcyIsImNyZWF0ZUZhY3RvcnkiLCJmYWN0b3J5IiwiY2xvbmVBbmRSZXBsYWNlS2V5Iiwib2xkRWxlbWVudCIsIm5ld0tleSIsIm5ld0VsZW1lbnQiLCJjbG9uZUFuZFJlcGxhY2VQcm9wcyIsIm5ld1Byb3BzIiwiY2xvbmVFbGVtZW50IiwibnVsbENvbXBvbmVudElEc1JlZ2lzdHJ5IiwicmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQiLCJkZXJlZ2lzdGVyTnVsbENvbXBvbmVudElEIiwiUmVhY3RSb290SW5kZXgiLCJTRVBBUkFUT1IiLCJTRVBBUkFUT1JfTEVOR1RIIiwiTUFYX1RSRUVfREVQVEgiLCJnZXRSZWFjdFJvb3RJRFN0cmluZyIsImlzQm91bmRhcnkiLCJpc1ZhbGlkSUQiLCJkZXNjZW5kYW50SUQiLCJnZXRQYXJlbnRJRCIsInN1YnN0ciIsImxhc3RJbmRleE9mIiwiZ2V0TmV4dERlc2NlbmRhbnRJRCIsImRlc3RpbmF0aW9uSUQiLCJzdGFydCIsImdldEZpcnN0Q29tbW9uQW5jZXN0b3JJRCIsIm9uZUlEIiwidHdvSUQiLCJtaW5MZW5ndGgiLCJsYXN0Q29tbW9uTWFya2VySW5kZXgiLCJsb25nZXN0Q29tbW9uSUQiLCJ0cmF2ZXJzZVBhcmVudFBhdGgiLCJzdG9wIiwic2tpcEZpcnN0Iiwic2tpcExhc3QiLCJ0cmF2ZXJzZVVwIiwiZGVwdGgiLCJ0cmF2ZXJzZSIsImNyZWF0ZVJlYWN0Um9vdEluZGV4IiwiY3JlYXRlUmVhY3RJRCIsImxlYXZlSUQiLCJlbnRlcklEIiwidXBBcmciLCJkb3duQXJnIiwidHJhdmVyc2VUd29QaGFzZVNraXBUYXJnZXQiLCJfZ2V0TmV4dERlc2NlbmRhbnRJRCIsIlJlYWN0Um9vdEluZGV4SW5qZWN0aW9uIiwiaW5qZWN0Q3JlYXRlUmVhY3RSb290SW5kZXgiLCJfY3JlYXRlUmVhY3RSb290SW5kZXgiLCJyZW1vdmUiLCJoYXMiLCJzZXQiLCJhZGxlcjMyIiwiVEFHX0VORCIsImFkZENoZWNrc3VtVG9NYXJrdXAiLCJleGlzdGluZ0NoZWNrc3VtIiwicGFyc2VJbnQiLCJtYXJrdXBDaGVja3N1bSIsIk1PRCIsImwiLCJtIiwiY2hhckNvZGVBdCIsIlJlYWN0UmVmIiwiYXR0YWNoUmVmcyIsImludGVybmFsSW5zdGFuY2UiLCJnZXRSZWFjdE1vdW50UmVhZHkiLCJlbnF1ZXVlIiwiZGV0YWNoUmVmcyIsInJlZnNDaGFuZ2VkIiwic2hvdWxkVXBkYXRlUmVmcyIsInBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSIsIlJlYWN0T3duZXIiLCJhdHRhY2hSZWYiLCJhZGRDb21wb25lbnRBc1JlZlRvIiwiZGV0YWNoUmVmIiwicmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tIiwicHJldkVtcHR5IiwibmV4dEVtcHR5IiwiaXNWYWxpZE93bmVyIiwicmVmcyIsImVucXVldWVVcGRhdGUiLCJnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUiLCJwdWJsaWNJbnN0YW5jZSIsImNhbGxlck5hbWUiLCJpc01vdW50ZWQiLCJfd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIiLCJlbnF1ZXVlQ2FsbGJhY2siLCJfcGVuZGluZ0NhbGxiYWNrcyIsImVucXVldWVGb3JjZVVwZGF0ZSIsIl9wZW5kaW5nRm9yY2VVcGRhdGUiLCJlbnF1ZXVlUmVwbGFjZVN0YXRlIiwiY29tcGxldGVTdGF0ZSIsIl9wZW5kaW5nU3RhdGVRdWV1ZSIsIl9wZW5kaW5nUmVwbGFjZVN0YXRlIiwiZW5xdWV1ZVNldFN0YXRlIiwicGFydGlhbFN0YXRlIiwiZW5xdWV1ZVNldFByb3BzIiwicGFydGlhbFByb3BzIiwiZW5xdWV1ZVNldFByb3BzSW50ZXJuYWwiLCJ0b3BMZXZlbFdyYXBwZXIiLCJ3cmFwRWxlbWVudCIsIl9wZW5kaW5nRWxlbWVudCIsImVucXVldWVSZXBsYWNlUHJvcHMiLCJlbnF1ZXVlUmVwbGFjZVByb3BzSW50ZXJuYWwiLCJDYWxsYmFja1F1ZXVlIiwiUG9vbGVkQ2xhc3MiLCJUcmFuc2FjdGlvbiIsImRpcnR5Q29tcG9uZW50cyIsImFzYXBDYWxsYmFja1F1ZXVlIiwiYXNhcEVucXVldWVkIiwiYmF0Y2hpbmdTdHJhdGVneSIsImVuc3VyZUluamVjdGVkIiwiTkVTVEVEX1VQREFURVMiLCJpbml0aWFsaXplIiwiZGlydHlDb21wb25lbnRzTGVuZ3RoIiwiY2xvc2UiLCJzcGxpY2UiLCJmbHVzaEJhdGNoZWRVcGRhdGVzIiwiVVBEQVRFX1FVRVVFSU5HIiwiY2FsbGJhY2tRdWV1ZSIsInJlc2V0Iiwibm90aWZ5QWxsIiwiVFJBTlNBQ1RJT05fV1JBUFBFUlMiLCJSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uIiwicmVpbml0aWFsaXplVHJhbnNhY3Rpb24iLCJyZWNvbmNpbGVUcmFuc2FjdGlvbiIsIk1peGluIiwiZ2V0VHJhbnNhY3Rpb25XcmFwcGVycyIsImRlc3RydWN0b3IiLCJtZXRob2QiLCJhZGRQb29saW5nVG8iLCJtb3VudE9yZGVyQ29tcGFyYXRvciIsImMxIiwiYzIiLCJfbW91bnRPcmRlciIsInJ1bkJhdGNoZWRVcGRhdGVzIiwic29ydCIsImNhbGxiYWNrcyIsImlzQmF0Y2hpbmdVcGRhdGVzIiwiYXNhcCIsIlJlYWN0VXBkYXRlc0luamVjdGlvbiIsImluamVjdFJlY29uY2lsZVRyYW5zYWN0aW9uIiwiUmVjb25jaWxlVHJhbnNhY3Rpb24iLCJpbmplY3RCYXRjaGluZ1N0cmF0ZWd5IiwiX2JhdGNoaW5nU3RyYXRlZ3kiLCJfY2FsbGJhY2tzIiwiX2NvbnRleHRzIiwiY29udGV4dHMiLCJvbmVBcmd1bWVudFBvb2xlciIsImNvcHlGaWVsZHNGcm9tIiwiS2xhc3MiLCJpbnN0YW5jZVBvb2wiLCJwb3AiLCJ0d29Bcmd1bWVudFBvb2xlciIsImExIiwiYTIiLCJ0aHJlZUFyZ3VtZW50UG9vbGVyIiwiYTMiLCJmb3VyQXJndW1lbnRQb29sZXIiLCJhNCIsImZpdmVBcmd1bWVudFBvb2xlciIsImE1Iiwic3RhbmRhcmRSZWxlYXNlciIsInBvb2xTaXplIiwiREVGQVVMVF9QT09MX1NJWkUiLCJERUZBVUxUX1BPT0xFUiIsIkNvcHlDb25zdHJ1Y3RvciIsInBvb2xlciIsIk5ld0tsYXNzIiwidHJhbnNhY3Rpb25XcmFwcGVycyIsIndyYXBwZXJJbml0RGF0YSIsIl9pc0luVHJhbnNhY3Rpb24iLCJpc0luVHJhbnNhY3Rpb24iLCJlcnJvclRocm93biIsImluaXRpYWxpemVBbGwiLCJjbG9zZUFsbCIsImVyciIsInN0YXJ0SW5kZXgiLCJPQlNFUlZFRF9FUlJPUiIsImluaXREYXRhIiwiaXNUZXh0Tm9kZSIsIl94IiwiX3gyIiwiX2FnYWluIiwiX2Z1bmN0aW9uIiwib3V0ZXJOb2RlIiwiaW5uZXJOb2RlIiwiY29udGFpbnMiLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsImlzTm9kZSIsIk5vZGUiLCJSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCIsIlJlYWN0RW1wdHlDb21wb25lbnQiLCJSZWFjdE5hdGl2ZUNvbXBvbmVudCIsIlJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlciIsIl9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiaXNJbnRlcm5hbENvbXBvbmVudFR5cGUiLCJjcmVhdGVJbnRlcm5hbENvbXBvbmVudCIsImNyZWF0ZUluc3RhbmNlRm9yVGV4dCIsIl9tb3VudEltYWdlIiwiX2lzT3duZXJOZWNlc3NhcnkiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsIlJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQiLCJSZWFjdFByb3BUeXBlTG9jYXRpb25zIiwiUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMiLCJTdGF0ZWxlc3NDb21wb25lbnQiLCJDb21wb25lbnQiLCJ1cGRhdGVyIiwibmV4dE1vdW50SUQiLCJSZWFjdENvbXBvc2l0ZUNvbXBvbmVudE1peGluIiwiX2luc3RhbmNlIiwicHVibGljUHJvcHMiLCJfcHJvY2Vzc1Byb3BzIiwicHVibGljQ29udGV4dCIsIl9wcm9jZXNzQ29udGV4dCIsImluc3QiLCJyZW5kZXJlZEVsZW1lbnQiLCJjYW5JbnN0YW50aWF0ZSIsImdldEluaXRpYWxTdGF0ZSIsImlzUmVhY3RDbGFzc0FwcHJvdmVkIiwiZ2V0RGVmYXVsdFByb3BzIiwicHJvcFR5cGVzIiwiY29udGV4dFR5cGVzIiwiY29tcG9uZW50U2hvdWxkVXBkYXRlIiwiY29tcG9uZW50RGlkVW5tb3VudCIsImNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJpbml0aWFsU3RhdGUiLCJzdGF0ZSIsImNvbXBvbmVudFdpbGxNb3VudCIsIl9wcm9jZXNzUGVuZGluZ1N0YXRlIiwiX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCIsImNvbXBvbmVudERpZE1vdW50IiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJfbWFza0NvbnRleHQiLCJtYXNrZWRDb250ZXh0IiwiY29udGV4dE5hbWUiLCJfY2hlY2tQcm9wVHlwZXMiLCJjdXJyZW50Q29udGV4dCIsImNoaWxkQ29udGV4dCIsImdldENoaWxkQ29udGV4dCIsImNoaWxkQ29udGV4dFR5cGVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiZXgiLCJhZGRlbmR1bSIsIm5leHRDb250ZXh0IiwicHJldkNvbnRleHQiLCJ1cGRhdGVDb21wb25lbnQiLCJwcmV2UGFyZW50RWxlbWVudCIsIm5leHRQYXJlbnRFbGVtZW50IiwicHJldlVubWFza2VkQ29udGV4dCIsIm5leHRVbm1hc2tlZENvbnRleHQiLCJuZXh0UHJvcHMiLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwibmV4dFN0YXRlIiwic2hvdWxkVXBkYXRlIiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwiX3BlcmZvcm1Db21wb25lbnRVcGRhdGUiLCJwYXJ0aWFsIiwidW5tYXNrZWRDb250ZXh0IiwiaGFzQ29tcG9uZW50RGlkVXBkYXRlIiwiQm9vbGVhbiIsImNvbXBvbmVudERpZFVwZGF0ZSIsInByZXZQcm9wcyIsInByZXZTdGF0ZSIsImNvbXBvbmVudFdpbGxVcGRhdGUiLCJfdXBkYXRlUmVuZGVyZWRDb21wb25lbnQiLCJwcmV2Q29tcG9uZW50SW5zdGFuY2UiLCJwcmV2UmVuZGVyZWRFbGVtZW50IiwibmV4dFJlbmRlcmVkRWxlbWVudCIsInRoaXNJRCIsInByZXZDb21wb25lbnRJRCIsIm5leHRNYXJrdXAiLCJfcmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRCIsIl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnRXaXRob3V0T3duZXJPckNvbnRleHQiLCJyZW5kZXJlZENvbXBvbmVudCIsIl9pc01vY2tGdW5jdGlvbiIsInB1YmxpY0NvbXBvbmVudEluc3RhbmNlIiwiaW5qZWN0ZWQiLCJpbmplY3RFbnZpcm9ubWVudCIsImVudmlyb25tZW50IiwicHJldlR5cGUiLCJuZXh0VHlwZSIsInBsYWNlaG9sZGVyRWxlbWVudCIsIlJlYWN0RW1wdHlDb21wb25lbnRJbmplY3Rpb24iLCJpbmplY3RFbXB0eUNvbXBvbmVudCIsImluc3RhbnRpYXRlIiwiYXV0b0dlbmVyYXRlV3JhcHBlckNsYXNzIiwiZ2VuZXJpY0NvbXBvbmVudENsYXNzIiwidGFnVG9Db21wb25lbnRDbGFzcyIsInRleHRDb21wb25lbnRDbGFzcyIsIlJlYWN0TmF0aXZlQ29tcG9uZW50SW5qZWN0aW9uIiwiaW5qZWN0R2VuZXJpY0NvbXBvbmVudENsYXNzIiwiY29tcG9uZW50Q2xhc3MiLCJpbmplY3RUZXh0Q29tcG9uZW50Q2xhc3MiLCJpbmplY3RDb21wb25lbnRDbGFzc2VzIiwiY29tcG9uZW50Q2xhc3NlcyIsImdldENvbXBvbmVudENsYXNzRm9yRWxlbWVudCIsImlzVGV4dENvbXBvbmVudCIsInNwZWNpYWxUYWdzIiwiaW5TY29wZVRhZ3MiLCJidXR0b25TY29wZVRhZ3MiLCJpbXBsaWVkRW5kVGFncyIsImVtcHR5QW5jZXN0b3JJbmZvIiwicGFyZW50VGFnIiwiZm9ybVRhZyIsImFUYWdJblNjb3BlIiwiYnV0dG9uVGFnSW5TY29wZSIsIm5vYnJUYWdJblNjb3BlIiwicFRhZ0luQnV0dG9uU2NvcGUiLCJsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nIiwiZGxJdGVtVGFnQXV0b2Nsb3NpbmciLCJvbGRJbmZvIiwiYW5jZXN0b3JJbmZvIiwiaW5mbyIsImlzVGFnVmFsaWRXaXRoUGFyZW50IiwiZmluZEludmFsaWRBbmNlc3RvckZvclRhZyIsImZpbmRPd25lclN0YWNrIiwic3RhY2siLCJyZXZlcnNlIiwiZGlkV2FybiIsImNoaWxkVGFnIiwiY2hpbGRJbnN0YW5jZSIsInBhcmVudEluZm8iLCJpbnZhbGlkUGFyZW50IiwiaW52YWxpZEFuY2VzdG9yIiwicHJvYmxlbWF0aWMiLCJhbmNlc3RvclRhZyIsImFuY2VzdG9ySW5zdGFuY2UiLCJjaGlsZE93bmVyIiwiYW5jZXN0b3JPd25lciIsImNoaWxkT3duZXJzIiwiYW5jZXN0b3JPd25lcnMiLCJtaW5TdGFja0xlbiIsImRlZXBlc3RDb21tb24iLCJVTktOT1dOIiwiY2hpbGRPd25lck5hbWVzIiwiYW5jZXN0b3JPd25lck5hbWVzIiwib3duZXJJbmZvIiwid2FybktleSIsImlzVGFnVmFsaWRJbkNvbnRleHQiLCJCZWZvcmVJbnB1dEV2ZW50UGx1Z2luIiwiQ2hhbmdlRXZlbnRQbHVnaW4iLCJDbGllbnRSZWFjdFJvb3RJbmRleCIsIkRlZmF1bHRFdmVudFBsdWdpbk9yZGVyIiwiRW50ZXJMZWF2ZUV2ZW50UGx1Z2luIiwiSFRNTERPTVByb3BlcnR5Q29uZmlnIiwiUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4iLCJSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5IiwiUmVhY3RET01Db21wb25lbnQiLCJSZWFjdEluamVjdGlvbiIsIlNlbGVjdEV2ZW50UGx1Z2luIiwiU2VydmVyUmVhY3RSb290SW5kZXgiLCJTaW1wbGVFdmVudFBsdWdpbiIsIlNWR0RPTVByb3BlcnR5Q29uZmlnIiwiYWxyZWFkeUluamVjdGVkIiwiRXZlbnRFbWl0dGVyIiwiTmF0aXZlQ29tcG9uZW50IiwiQ2xhc3MiLCJpbmplY3RNaXhpbiIsIkVtcHR5Q29tcG9uZW50IiwiVXBkYXRlcyIsIlJvb3RJbmRleCIsInVybCIsImhyZWYiLCJSZWFjdERlZmF1bHRQZXJmIiwiRXZlbnRQcm9wYWdhdG9ycyIsIkZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSIsIlN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQiLCJTeW50aGV0aWNJbnB1dEV2ZW50Iiwia2V5T2YiLCJFTkRfS0VZQ09ERVMiLCJTVEFSVF9LRVlDT0RFIiwiY2FuVXNlQ29tcG9zaXRpb25FdmVudCIsImNhblVzZVRleHRJbnB1dEV2ZW50IiwiaXNQcmVzdG8iLCJ1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSIsIm9wZXJhIiwiU1BBQ0VCQVJfQ09ERSIsIlNQQUNFQkFSX0NIQVIiLCJiZWZvcmVJbnB1dCIsIm9uQmVmb3JlSW5wdXQiLCJvbkJlZm9yZUlucHV0Q2FwdHVyZSIsImNvbXBvc2l0aW9uRW5kIiwib25Db21wb3NpdGlvbkVuZCIsIm9uQ29tcG9zaXRpb25FbmRDYXB0dXJlIiwiY29tcG9zaXRpb25TdGFydCIsIm9uQ29tcG9zaXRpb25TdGFydCIsIm9uQ29tcG9zaXRpb25TdGFydENhcHR1cmUiLCJjb21wb3NpdGlvblVwZGF0ZSIsIm9uQ29tcG9zaXRpb25VcGRhdGUiLCJvbkNvbXBvc2l0aW9uVXBkYXRlQ2FwdHVyZSIsImhhc1NwYWNlS2V5cHJlc3MiLCJpc0tleXByZXNzQ29tbWFuZCIsImN0cmxLZXkiLCJhbHRLZXkiLCJtZXRhS2V5IiwiZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUiLCJpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCIsImtleUNvZGUiLCJpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQiLCJnZXREYXRhRnJvbUN1c3RvbUV2ZW50IiwiZGV0YWlsIiwiY3VycmVudENvbXBvc2l0aW9uIiwiZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQiLCJldmVudFR5cGUiLCJmYWxsYmFja0RhdGEiLCJnZXREYXRhIiwiY3VzdG9tRGF0YSIsImFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMiLCJnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzIiwid2hpY2giLCJjaGFycyIsImdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyIsImV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50IiwibGlzdGVuZXJBdFBoYXNlIiwicHJvcGFnYXRpb25QaGFzZSIsImFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMiLCJ1cHdhcmRzIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSIsImRpc3BhdGNoTWFya2VyIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQiLCJhY2N1bXVsYXRlRGlzcGF0Y2hlcyIsImlnbm9yZWREaXJlY3Rpb24iLCJhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSIsImFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0IiwiYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzIiwibGVhdmUiLCJlbnRlciIsImZyb21JRCIsInRvSUQiLCJhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyIsImdldFRleHRDb250ZW50QWNjZXNzb3IiLCJyb290IiwiX3Jvb3QiLCJfc3RhcnRUZXh0IiwiZ2V0VGV4dCIsIl9mYWxsYmFja1RleHQiLCJzdGFydFZhbHVlIiwic3RhcnRMZW5ndGgiLCJlbmQiLCJlbmRWYWx1ZSIsImVuZExlbmd0aCIsIm1pbkVuZCIsInNsaWNlVGFpbCIsImNvbnRlbnRLZXkiLCJTeW50aGV0aWNFdmVudCIsIkNvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UiLCJhdWdtZW50Q2xhc3MiLCJFdmVudEludGVyZmFjZSIsImV2ZW50UGhhc2UiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsInRpbWVTdGFtcCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJpc1RydXN0ZWQiLCJJbnRlcmZhY2UiLCJub3JtYWxpemUiLCJyZXR1cm5WYWx1ZSIsImlzRGVmYXVsdFByZXZlbnRlZCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiY2FuY2VsQnViYmxlIiwicGVyc2lzdCIsIlN1cGVyIiwiSW5wdXRFdmVudEludGVyZmFjZSIsIm9uZUtleU9iaiIsImdldEV2ZW50VGFyZ2V0IiwiaXNUZXh0SW5wdXRFbGVtZW50IiwiY2hhbmdlIiwib25DaGFuZ2UiLCJvbkNoYW5nZUNhcHR1cmUiLCJhY3RpdmVFbGVtZW50IiwiYWN0aXZlRWxlbWVudElEIiwiYWN0aXZlRWxlbWVudFZhbHVlIiwiYWN0aXZlRWxlbWVudFZhbHVlUHJvcCIsInNob3VsZFVzZUNoYW5nZUV2ZW50IiwiZWxlbSIsImRvZXNDaGFuZ2VFdmVudEJ1YmJsZSIsIm1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQiLCJydW5FdmVudEluQmF0Y2giLCJzdGFydFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgiLCJzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCIsImRldGFjaEV2ZW50IiwiZ2V0VGFyZ2V0SURGb3JDaGFuZ2VFdmVudCIsImhhbmRsZUV2ZW50c0ZvckNoYW5nZUV2ZW50SUU4IiwiaXNJbnB1dEV2ZW50U3VwcG9ydGVkIiwibmV3VmFsdWVQcm9wIiwidmFsIiwic3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiaGFuZGxlUHJvcGVydHlDaGFuZ2UiLCJzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSIsInNyY0VsZW1lbnQiLCJnZXRUYXJnZXRJREZvcklucHV0RXZlbnQiLCJoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50SUUiLCJnZXRUYXJnZXRJREZvcklucHV0RXZlbnRJRSIsInNob3VsZFVzZUNsaWNrRXZlbnQiLCJnZXRUYXJnZXRJREZvckNsaWNrRXZlbnQiLCJnZXRUYXJnZXRJREZ1bmMiLCJoYW5kbGVFdmVudEZ1bmMiLCJzdXBwb3J0ZWRJbnB1dFR5cGVzIiwibmV4dFJlYWN0Um9vdEluZGV4IiwiUmVzcG9uZGVyRXZlbnRQbHVnaW4iLCJUYXBFdmVudFBsdWdpbiIsIlN5bnRoZXRpY01vdXNlRXZlbnQiLCJtb3VzZUVudGVyIiwib25Nb3VzZUVudGVyIiwibW91c2VMZWF2ZSIsIm9uTW91c2VMZWF2ZSIsInJlbGF0ZWRUYXJnZXQiLCJmcm9tRWxlbWVudCIsIndpbiIsImRvYyIsImRlZmF1bHRWaWV3IiwicGFyZW50V2luZG93IiwidG9FbGVtZW50IiwiU3ludGhldGljVUlFdmVudCIsImdldEV2ZW50TW9kaWZpZXJTdGF0ZSIsIk1vdXNlRXZlbnRJbnRlcmZhY2UiLCJzY3JlZW5YIiwic2NyZWVuWSIsImNsaWVudFgiLCJjbGllbnRZIiwic2hpZnRLZXkiLCJnZXRNb2RpZmllclN0YXRlIiwiYnV0dG9uIiwiYnV0dG9ucyIsInBhZ2VYIiwicGFnZVkiLCJVSUV2ZW50SW50ZXJmYWNlIiwidmlldyIsIm1vZGlmaWVyS2V5VG9Qcm9wIiwibW9kaWZpZXJTdGF0ZUdldHRlciIsImtleUFyZyIsInN5bnRoZXRpY0V2ZW50Iiwia2V5UHJvcCIsImhhc1NWRyIsIlJlZ0V4cCIsImFjY2VwdCIsImFjY2VwdENoYXJzZXQiLCJhY2Nlc3NLZXkiLCJhY3Rpb24iLCJhbGxvd0Z1bGxTY3JlZW4iLCJhbGxvd1RyYW5zcGFyZW5jeSIsImFsdCIsImFzeW5jIiwiYXV0b0NvbXBsZXRlIiwiYXV0b1BsYXkiLCJjZWxsUGFkZGluZyIsImNlbGxTcGFjaW5nIiwiY2hhclNldCIsImNoYWxsZW5nZSIsImNoZWNrZWQiLCJjbGFzc0lEIiwiY2xhc3NOYW1lIiwiY29scyIsImNvbFNwYW4iLCJjb250ZW50RWRpdGFibGUiLCJjb250ZXh0TWVudSIsImNvbnRyb2xzIiwiY29vcmRzIiwiY3Jvc3NPcmlnaW4iLCJkYXRlVGltZSIsImRlZmVyIiwiZGlzYWJsZWQiLCJkb3dubG9hZCIsImRyYWdnYWJsZSIsImVuY1R5cGUiLCJmb3JtIiwiZm9ybUFjdGlvbiIsImZvcm1FbmNUeXBlIiwiZm9ybU1ldGhvZCIsImZvcm1Ob1ZhbGlkYXRlIiwiZm9ybVRhcmdldCIsImZyYW1lQm9yZGVyIiwiaGVhZGVycyIsImhlaWdodCIsImhpZGRlbiIsImhpZ2giLCJocmVmTGFuZyIsImh0bWxGb3IiLCJodHRwRXF1aXYiLCJpY29uIiwiaW5wdXRNb2RlIiwiaW50ZWdyaXR5IiwiaXMiLCJrZXlQYXJhbXMiLCJrZXlUeXBlIiwia2luZCIsImxhYmVsIiwibGFuZyIsImxpc3QiLCJsb29wIiwibG93IiwibWFuaWZlc3QiLCJtYXJnaW5IZWlnaHQiLCJtYXJnaW5XaWR0aCIsIm1heCIsIm1heExlbmd0aCIsIm1lZGlhIiwibWVkaWFHcm91cCIsIm11bHRpcGxlIiwibXV0ZWQiLCJub25jZSIsIm5vVmFsaWRhdGUiLCJvcGVuIiwib3B0aW11bSIsInBhdHRlcm4iLCJwbGFjZWhvbGRlciIsInBvc3RlciIsInByZWxvYWQiLCJyYWRpb0dyb3VwIiwicmVhZE9ubHkiLCJyZWwiLCJyZXF1aXJlZCIsInJldmVyc2VkIiwicm9sZSIsInJvd3MiLCJyb3dTcGFuIiwic2FuZGJveCIsInNjb3BlZCIsInNjcm9sbGluZyIsInNlYW1sZXNzIiwic2VsZWN0ZWQiLCJzaGFwZSIsInNpemUiLCJzaXplcyIsInNwYW4iLCJzcGVsbENoZWNrIiwic3JjIiwic3JjRG9jIiwic3JjTGFuZyIsInNyY1NldCIsInN0ZXAiLCJzdW1tYXJ5IiwidGFiSW5kZXgiLCJ1c2VNYXAiLCJ3aWR0aCIsIndtb2RlIiwiYWJvdXQiLCJkYXRhdHlwZSIsImlubGlzdCIsInByZWZpeCIsInByb3BlcnR5IiwicmVzb3VyY2UiLCJ2b2NhYiIsImF1dG9DYXBpdGFsaXplIiwiYXV0b0NvcnJlY3QiLCJhdXRvU2F2ZSIsImNvbG9yIiwiaXRlbVByb3AiLCJpdGVtU2NvcGUiLCJpdGVtVHlwZSIsIml0ZW1JRCIsIml0ZW1SZWYiLCJyZXN1bHRzIiwic2VjdXJpdHkiLCJ1bnNlbGVjdGFibGUiLCJhdXRvRm9jdXMiLCJkaWRXYXJuS2V5IiwiZ2V0RE9NTm9kZSIsImNvbXBvbmVudE9yRWxlbWVudCIsIlJFU0VUX0JBVENIRURfVVBEQVRFUyIsIkZMVVNIX0JBVENIRURfVVBEQVRFUyIsIlJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbiIsImFscmVhZHlCYXRjaGluZ1VwZGF0ZXMiLCJBdXRvRm9jdXNVdGlscyIsIkNTU1Byb3BlcnR5T3BlcmF0aW9ucyIsIlJlYWN0RE9NQnV0dG9uIiwiUmVhY3RET01JbnB1dCIsIlJlYWN0RE9NT3B0aW9uIiwiUmVhY3RET01TZWxlY3QiLCJSZWFjdERPTVRleHRhcmVhIiwiUmVhY3RNdWx0aUNoaWxkIiwic2hhbGxvd0VxdWFsIiwiQ09OVEVOVF9UWVBFUyIsIkNISUxEUkVOIiwiU1RZTEUiLCJIVE1MIiwiX19odG1sIiwibGVnYWN5UHJvcHNEZXNjcmlwdG9yIiwiX3JlYWN0SW50ZXJuYWxDb21wb25lbnQiLCJsZWdhY3lHZXRET01Ob2RlIiwibGVnYWN5SXNNb3VudGVkIiwibGVnYWN5U2V0U3RhdGVFdGMiLCJsZWdhY3lTZXRQcm9wcyIsImxlZ2FjeVJlcGxhY2VQcm9wcyIsImZyaWVuZGx5U3RyaW5naWZ5IiwicGFpcnMiLCJrZXlFc2NhcGVkIiwiSlNPTiIsInN0cmluZ2lmeSIsInN0eWxlTXV0YXRpb25XYXJuaW5nIiwiY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFN0eWxlIiwic3R5bGUxIiwic3R5bGUyIiwiX3RhZyIsIm93bmVyTmFtZSIsImhhc2giLCJhc3NlcnRWYWxpZFByb3BzIiwidm9pZEVsZW1lbnRUYWdzIiwiZW5xdWV1ZVB1dExpc3RlbmVyIiwibGlzdGVuZXJUb1B1dCIsIm1lZGlhRXZlbnRzIiwidHJhcEJ1YmJsZWRFdmVudHNMb2NhbCIsIl93cmFwcGVyU3RhdGUiLCJsaXN0ZW5lcnMiLCJtb3VudFJlYWR5SW5wdXRXcmFwcGVyIiwibW91bnRSZWFkeVdyYXBwZXIiLCJwb3N0VXBkYXRlU2VsZWN0V3JhcHBlciIsInBvc3RVcGRhdGVXcmFwcGVyIiwib21pdHRlZENsb3NlVGFncyIsIm5ld2xpbmVFYXRpbmdUYWdzIiwiVkFMSURfVEFHX1JFR0VYIiwidmFsaWRhdGVkVGFnQ2FjaGUiLCJ2YWxpZGF0ZURhbmdlcm91c1RhZyIsInByb2Nlc3NDaGlsZENvbnRleHREZXYiLCJpc0N1c3RvbUNvbXBvbmVudCIsIl9yZW5kZXJlZENoaWxkcmVuIiwiX3ByZXZpb3VzU3R5bGUiLCJfcHJldmlvdXNTdHlsZUNvcHkiLCJfbm9kZVdpdGhMZWdhY3lQcm9wZXJ0aWVzIiwiX3VucHJvY2Vzc2VkQ29udGV4dERldiIsIl9wcm9jZXNzZWRDb250ZXh0RGV2IiwiZ2V0TmF0aXZlUHJvcHMiLCJtb3VudFdyYXBwZXIiLCJwcm9jZXNzQ2hpbGRDb250ZXh0IiwibW91bnRJbWFnZSIsIl91cGRhdGVET01Qcm9wZXJ0aWVzIiwiX2NyZWF0ZUluaXRpYWxDaGlsZHJlbiIsInRhZ09wZW4iLCJfY3JlYXRlT3BlblRhZ01hcmt1cEFuZFB1dExpc3RlbmVycyIsInRhZ0NvbnRlbnQiLCJfY3JlYXRlQ29udGVudE1hcmt1cCIsImZvY3VzRE9NQ29tcG9uZW50IiwicHJvcEtleSIsInByb3BWYWx1ZSIsImNyZWF0ZU1hcmt1cEZvclN0eWxlcyIsIm1hcmt1cEZvcklEIiwiY29udGVudFRvVXNlIiwiY2hpbGRyZW5Ub1VzZSIsIm1vdW50SW1hZ2VzIiwibW91bnRDaGlsZHJlbiIsImxhc3RQcm9wcyIsInVwZGF0ZVdyYXBwZXIiLCJfdXBkYXRlRE9NQ2hpbGRyZW4iLCJzdHlsZU5hbWUiLCJzdHlsZVVwZGF0ZXMiLCJsYXN0U3R5bGUiLCJuZXh0UHJvcCIsImxhc3RQcm9wIiwic2V0VmFsdWVGb3JTdHlsZXMiLCJsYXN0Q29udGVudCIsIm5leHRDb250ZW50IiwibGFzdEh0bWwiLCJuZXh0SHRtbCIsImxhc3RDaGlsZHJlbiIsIm5leHRDaGlsZHJlbiIsImxhc3RIYXNDb250ZW50T3JIdG1sIiwibmV4dEhhc0NvbnRlbnRPckh0bWwiLCJ1cGRhdGVDaGlsZHJlbiIsInVwZGF0ZU1hcmt1cCIsInVubW91bnRXcmFwcGVyIiwidW5tb3VudENoaWxkcmVuIiwic2V0U3RhdGUiLCJyZXBsYWNlU3RhdGUiLCJmb3JjZVVwZGF0ZSIsInNldFByb3BzIiwicmVwbGFjZVByb3BzIiwiZGVmaW5lUHJvcGVydGllcyIsImZvY3VzTm9kZSIsImZvY3VzIiwiQ1NTUHJvcGVydHkiLCJjYW1lbGl6ZVN0eWxlTmFtZSIsImRhbmdlcm91c1N0eWxlVmFsdWUiLCJoeXBoZW5hdGVTdHlsZU5hbWUiLCJtZW1vaXplU3RyaW5nT25seSIsInByb2Nlc3NTdHlsZU5hbWUiLCJoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyIsInN0eWxlRmxvYXRBY2Nlc3NvciIsInRlbXBTdHlsZSIsImZvbnQiLCJjc3NGbG9hdCIsImJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiIsImJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiIsIndhcm5lZFN0eWxlTmFtZXMiLCJ3YXJuZWRTdHlsZVZhbHVlcyIsIndhcm5IeXBoZW5hdGVkU3R5bGVOYW1lIiwid2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lIiwid2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uIiwid2FyblZhbGlkU3R5bGUiLCJzdHlsZXMiLCJzZXJpYWxpemVkIiwic3R5bGVWYWx1ZSIsImV4cGFuc2lvbiIsInNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9ucyIsImluZGl2aWR1YWxTdHlsZU5hbWUiLCJpc1VuaXRsZXNzTnVtYmVyIiwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQiLCJib3hGbGV4IiwiYm94RmxleEdyb3VwIiwiYm94T3JkaW5hbEdyb3VwIiwiY29sdW1uQ291bnQiLCJmbGV4IiwiZmxleEdyb3ciLCJmbGV4UG9zaXRpdmUiLCJmbGV4U2hyaW5rIiwiZmxleE5lZ2F0aXZlIiwiZmxleE9yZGVyIiwiZm9udFdlaWdodCIsImxpbmVDbGFtcCIsImxpbmVIZWlnaHQiLCJvcGFjaXR5Iiwib3JkZXIiLCJvcnBoYW5zIiwidGFiU2l6ZSIsIndpZG93cyIsInpJbmRleCIsInpvb20iLCJmaWxsT3BhY2l0eSIsInN0b3BPcGFjaXR5Iiwic3Ryb2tlRGFzaG9mZnNldCIsInN0cm9rZU9wYWNpdHkiLCJzdHJva2VXaWR0aCIsInByZWZpeEtleSIsInByZWZpeGVzIiwiYmFja2dyb3VuZCIsImJhY2tncm91bmRBdHRhY2htZW50IiwiYmFja2dyb3VuZENvbG9yIiwiYmFja2dyb3VuZEltYWdlIiwiYmFja2dyb3VuZFBvc2l0aW9uWCIsImJhY2tncm91bmRQb3NpdGlvblkiLCJiYWNrZ3JvdW5kUmVwZWF0IiwiYmFja2dyb3VuZFBvc2l0aW9uIiwiYm9yZGVyIiwiYm9yZGVyV2lkdGgiLCJib3JkZXJTdHlsZSIsImJvcmRlckNvbG9yIiwiYm9yZGVyQm90dG9tIiwiYm9yZGVyQm90dG9tV2lkdGgiLCJib3JkZXJCb3R0b21TdHlsZSIsImJvcmRlckJvdHRvbUNvbG9yIiwiYm9yZGVyTGVmdCIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlckxlZnRTdHlsZSIsImJvcmRlckxlZnRDb2xvciIsImJvcmRlclJpZ2h0IiwiYm9yZGVyUmlnaHRXaWR0aCIsImJvcmRlclJpZ2h0U3R5bGUiLCJib3JkZXJSaWdodENvbG9yIiwiYm9yZGVyVG9wIiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJUb3BTdHlsZSIsImJvcmRlclRvcENvbG9yIiwiZm9udFN0eWxlIiwiZm9udFZhcmlhbnQiLCJmb250U2l6ZSIsImZvbnRGYW1pbHkiLCJvdXRsaW5lIiwib3V0bGluZVdpZHRoIiwib3V0bGluZVN0eWxlIiwib3V0bGluZUNvbG9yIiwiY2FtZWxpemUiLCJtc1BhdHRlcm4iLCJzdHJpbmciLCJfaHlwaGVuUGF0dGVybiIsIl8iLCJjaGFyYWN0ZXIiLCJpc0VtcHR5IiwiaXNOb25OdW1lcmljIiwiaHlwaGVuYXRlIiwiX3VwcGVyY2FzZVBhdHRlcm4iLCJjYWNoZSIsIm1vdXNlTGlzdGVuZXJOYW1lcyIsIm9uQ2xpY2siLCJvbkRvdWJsZUNsaWNrIiwib25Nb3VzZURvd24iLCJvbk1vdXNlTW92ZSIsIm9uTW91c2VVcCIsIm9uQ2xpY2tDYXB0dXJlIiwib25Eb3VibGVDbGlja0NhcHR1cmUiLCJvbk1vdXNlRG93bkNhcHR1cmUiLCJvbk1vdXNlTW92ZUNhcHR1cmUiLCJvbk1vdXNlVXBDYXB0dXJlIiwibmF0aXZlUHJvcHMiLCJMaW5rZWRWYWx1ZVV0aWxzIiwiaW5zdGFuY2VzQnlSZWFjdElEIiwiZm9yY2VVcGRhdGVJZk1vdW50ZWQiLCJnZXRWYWx1ZSIsImdldENoZWNrZWQiLCJkZWZhdWx0Q2hlY2tlZCIsImluaXRpYWxWYWx1ZSIsImluaXRpYWxDaGVja2VkIiwiY2hlY2tQcm9wVHlwZXMiLCJfaGFuZGxlQ2hhbmdlIiwiZXhlY3V0ZU9uQ2hhbmdlIiwicm9vdE5vZGUiLCJxdWVyeVJvb3QiLCJncm91cCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJvdGhlck5vZGUiLCJvdGhlcklEIiwib3RoZXJJbnN0YW5jZSIsIlJlYWN0UHJvcFR5cGVzIiwiaGFzUmVhZE9ubHlWYWx1ZSIsIl9hc3NlcnRTaW5nbGVMaW5rIiwiaW5wdXRQcm9wcyIsImNoZWNrZWRMaW5rIiwidmFsdWVMaW5rIiwiX2Fzc2VydFZhbHVlTGluayIsIl9hc3NlcnRDaGVja2VkTGluayIsImxvZ2dlZFR5cGVGYWlsdXJlcyIsInJlcXVlc3RDaGFuZ2UiLCJnZXRJdGVyYXRvckZuIiwiQU5PTllNT1VTIiwiY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIiLCJib29sIiwibnVtYmVyIiwiYW55IiwiY3JlYXRlQW55VHlwZUNoZWNrZXIiLCJhcnJheU9mIiwiY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyIiwiY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyIiwiaW5zdGFuY2VPZiIsImNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIiLCJjcmVhdGVOb2RlQ2hlY2tlciIsIm9iamVjdE9mIiwiY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlciIsIm9uZU9mIiwiY3JlYXRlRW51bVR5cGVDaGVja2VyIiwib25lT2ZUeXBlIiwiY3JlYXRlVW5pb25UeXBlQ2hlY2tlciIsImNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIiLCJjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlciIsInZhbGlkYXRlIiwiY2hlY2tUeXBlIiwiaXNSZXF1aXJlZCIsInByb3BGdWxsTmFtZSIsImxvY2F0aW9uTmFtZSIsImNoYWluZWRDaGVja1R5cGUiLCJleHBlY3RlZFR5cGUiLCJwcm9wVHlwZSIsImdldFByb3BUeXBlIiwicHJlY2lzZVR5cGUiLCJnZXRQcmVjaXNlVHlwZSIsInR5cGVDaGVja2VyIiwiZXhwZWN0ZWRDbGFzcyIsImV4cGVjdGVkQ2xhc3NOYW1lIiwiYWN0dWFsQ2xhc3NOYW1lIiwiZ2V0Q2xhc3NOYW1lIiwiZXhwZWN0ZWRWYWx1ZXMiLCJ2YWx1ZXNTdHJpbmciLCJhcnJheU9mVHlwZUNoZWNrZXJzIiwiY2hlY2tlciIsInNoYXBlVHlwZXMiLCJpdGVyYXRvckZuIiwiaXRlcmF0b3IiLCJlbnRyaWVzIiwiZG9uZSIsImVudHJ5IiwiSVRFUkFUT1JfU1lNQk9MIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJtYXliZUl0ZXJhYmxlIiwiUmVhY3RDaGlsZHJlbiIsInZhbHVlQ29udGV4dEtleSIsInNlbGVjdFZhbHVlIiwidHJhdmVyc2VBbGxDaGlsZHJlbiIsInVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4IiwiZXNjYXBlVXNlclByb3ZpZGVkS2V5IiwiRm9yRWFjaEJvb2tLZWVwaW5nIiwiZm9yRWFjaEZ1bmN0aW9uIiwiZm9yRWFjaENvbnRleHQiLCJjb3VudCIsImZvckVhY2hTaW5nbGVDaGlsZCIsImJvb2tLZWVwaW5nIiwiZm9yRWFjaENoaWxkcmVuIiwiZm9yRWFjaEZ1bmMiLCJ0cmF2ZXJzZUNvbnRleHQiLCJNYXBCb29rS2VlcGluZyIsIm1hcFJlc3VsdCIsImtleVByZWZpeCIsIm1hcEZ1bmN0aW9uIiwibWFwQ29udGV4dCIsInJlc3VsdCIsIm1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQiLCJjaGlsZEtleSIsIm1hcHBlZENoaWxkIiwibWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbCIsImVzY2FwZWRQcmVmaXgiLCJtYXBDaGlsZHJlbiIsImZvckVhY2hTaW5nbGVDaGlsZER1bW15IiwiY291bnRDaGlsZHJlbiIsIlNVQlNFUEFSQVRPUiIsInVzZXJQcm92aWRlZEtleUVzY2FwZXJMb29rdXAiLCJkaWRXYXJuQWJvdXRNYXBzIiwidXNlclByb3ZpZGVkS2V5RXNjYXBlciIsImdldENvbXBvbmVudEtleSIsIndyYXBVc2VyUHJvdmlkZWRLZXkiLCJ0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbCIsIm5hbWVTb0ZhciIsIm5leHROYW1lIiwic3VidHJlZUNvdW50IiwibmV4dE5hbWVQcmVmaXgiLCJfaXNSZWFjdEVsZW1lbnQiLCJjaGlsZHJlblN0cmluZyIsInVwZGF0ZU9wdGlvbnNJZlBlbmRpbmdVcGRhdGVBbmRNb3VudGVkIiwicGVuZGluZ1VwZGF0ZSIsInVwZGF0ZU9wdGlvbnMiLCJ2YWx1ZVByb3BOYW1lcyIsImNoZWNrU2VsZWN0UHJvcFR5cGVzIiwic2VsZWN0ZWRWYWx1ZSIsIm9wdGlvbnMiLCJ3YXNNdWx0aXBsZSIsIlJlYWN0Q2hpbGRSZWNvbmNpbGVyIiwiZmxhdHRlbkNoaWxkcmVuIiwidXBkYXRlRGVwdGgiLCJ1cGRhdGVRdWV1ZSIsIm1hcmt1cFF1ZXVlIiwiZW5xdWV1ZUluc2VydE1hcmt1cCIsImVucXVldWVNb3ZlIiwiZW5xdWV1ZVJlbW92ZSIsImVucXVldWVTZXRNYXJrdXAiLCJlbnF1ZXVlVGV4dENvbnRlbnQiLCJwcm9jZXNzUXVldWUiLCJjbGVhclF1ZXVlIiwiX3JlY29uY2lsZXJJbnN0YW50aWF0ZUNoaWxkcmVuIiwibmVzdGVkQ2hpbGRyZW4iLCJpbnN0YW50aWF0ZUNoaWxkcmVuIiwiX3JlY29uY2lsZXJVcGRhdGVDaGlsZHJlbiIsInByZXZDaGlsZHJlbiIsIm5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzIiwiX3VubW91bnRDaGlsZCIsIl91bm1vdW50Q2hpbGRCeU5hbWUiLCJzZXRNYXJrdXAiLCJfdXBkYXRlQ2hpbGRyZW4iLCJsYXN0SW5kZXgiLCJwcmV2Q2hpbGQiLCJuZXh0Q2hpbGQiLCJtb3ZlQ2hpbGQiLCJfbW91bnRDaGlsZEJ5TmFtZUF0SW5kZXgiLCJyZW5kZXJlZENoaWxkcmVuIiwiY3JlYXRlQ2hpbGQiLCJpbnN0YW50aWF0ZUNoaWxkIiwiY2hpbGRJbnN0YW5jZXMiLCJrZXlVbmlxdWUiLCJuZXN0ZWRDaGlsZE5vZGVzIiwibmV4dENoaWxkSW5zdGFuY2UiLCJyZW5kZXJlZENoaWxkIiwiZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQiLCJvYmpBIiwib2JqQiIsImtleXNBIiwia2V5c0IiLCJiSGFzT3duUHJvcGVydHkiLCJFdmVudExpc3RlbmVyIiwiZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24iLCJmaW5kUGFyZW50IiwicGFyZW50IiwiVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nIiwiYW5jZXN0b3JzIiwiaGFuZGxlVG9wTGV2ZWxJbXBsIiwiaGFuZGxlVG9wTGV2ZWxXaXRoUGF0aCIsImhhbmRsZVRvcExldmVsV2l0aG91dFBhdGgiLCJfaGFuZGxlVG9wTGV2ZWwiLCJwYXRoIiwiY3VycmVudE5hdGl2ZVRhcmdldCIsImV2ZW50c0ZpcmVkIiwiY3VycmVudFBhdGhFbGVtZW50IiwicmVhY3RQYXJlbnQiLCJjdXJyZW50UGF0aEVsZW1lbnRJRCIsIm5ld1Jvb3RJRCIsInNjcm9sbFZhbHVlTW9uaXRvciIsIl9lbmFibGVkIiwibGlzdGVuIiwicmVnaXN0ZXJEZWZhdWx0Iiwic2Nyb2xsYWJsZSIsInBhZ2VYT2Zmc2V0Iiwic2Nyb2xsTGVmdCIsInBhZ2VZT2Zmc2V0Iiwic2Nyb2xsVG9wIiwiUmVhY3RDbGFzcyIsIlBlcmYiLCJSZWFjdENvbXBvbmVudCIsIlJlYWN0Tm9vcFVwZGF0ZVF1ZXVlIiwiTUlYSU5TX0tFWSIsIm1peGlucyIsIlNwZWNQb2xpY3kiLCJERUZJTkVfT05DRSIsIkRFRklORV9NQU5ZIiwiT1ZFUlJJREVfQkFTRSIsIkRFRklORV9NQU5ZX01FUkdFRCIsImluamVjdGVkTWl4aW5zIiwid2FybmVkU2V0UHJvcHMiLCJ3YXJuU2V0UHJvcHMiLCJSZWFjdENsYXNzSW50ZXJmYWNlIiwic3RhdGljcyIsIlJFU0VSVkVEX1NQRUNfS0VZUyIsIkNvbnN0cnVjdG9yIiwibWl4U3BlY0ludG9Db21wb25lbnQiLCJ2YWxpZGF0ZVR5cGVEZWYiLCJjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbiIsIm1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50IiwiYXV0b2JpbmQiLCJ0eXBlRGVmIiwidmFsaWRhdGVNZXRob2RPdmVycmlkZSIsInByb3RvIiwic3BlY1BvbGljeSIsIlJlYWN0Q2xhc3NNaXhpbiIsInNwZWMiLCJpc1JlYWN0Q2xhc3NNZXRob2QiLCJpc0FscmVhZHlEZWZpbmVkIiwiaXNGdW5jdGlvbiIsInNob3VsZEF1dG9CaW5kIiwiX19yZWFjdEF1dG9CaW5kTWFwIiwiY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uIiwiaXNSZXNlcnZlZCIsImlzSW5oZXJpdGVkIiwibWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyIsIm9uZSIsInR3byIsIm1lcmdlZFJlc3VsdCIsImNoYWluZWRGdW5jdGlvbiIsImJpbmRBdXRvQmluZE1ldGhvZCIsImJvdW5kTWV0aG9kIiwiX19yZWFjdEJvdW5kQ29udGV4dCIsIl9fcmVhY3RCb3VuZE1ldGhvZCIsIl9fcmVhY3RCb3VuZEFyZ3VtZW50cyIsIl9iaW5kIiwibmV3VGhpcyIsInJlYm91bmRNZXRob2QiLCJiaW5kQXV0b0JpbmRNZXRob2RzIiwiYXV0b0JpbmRLZXkiLCJuZXdTdGF0ZSIsIlJlYWN0Q2xhc3NDb21wb25lbnQiLCJjcmVhdGVDbGFzcyIsIm1ldGhvZE5hbWUiLCJtaXhpbiIsImRlcHJlY2F0ZWRBUElzIiwiZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nIiwid2FyblREWiIsIlJlYWN0SW5wdXRTZWxlY3Rpb24iLCJTRUxFQ1RJT05fUkVTVE9SQVRJT04iLCJnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbiIsInJlc3RvcmVTZWxlY3Rpb24iLCJFVkVOVF9TVVBQUkVTU0lPTiIsImN1cnJlbnRseUVuYWJsZWQiLCJwcmV2aW91c2x5RW5hYmxlZCIsIk9OX0RPTV9SRUFEWV9RVUVVRUlORyIsInJlYWN0TW91bnRSZWFkeSIsImZvcmNlSFRNTCIsIlJlYWN0RE9NU2VsZWN0aW9uIiwiZ2V0QWN0aXZlRWxlbWVudCIsImlzSW5Eb2N1bWVudCIsImhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyIsImZvY3VzZWRFbGVtIiwic2VsZWN0aW9uUmFuZ2UiLCJnZXRTZWxlY3Rpb24iLCJwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uIiwiY3VyRm9jdXNlZEVsZW0iLCJwcmlvckZvY3VzZWRFbGVtIiwicHJpb3JTZWxlY3Rpb25SYW5nZSIsInNldFNlbGVjdGlvbiIsImlucHV0Iiwic2VsZWN0aW9uIiwic2VsZWN0aW9uU3RhcnQiLCJzZWxlY3Rpb25FbmQiLCJyYW5nZSIsImNyZWF0ZVJhbmdlIiwicGFyZW50RWxlbWVudCIsIm1vdmVTdGFydCIsIm1vdmVFbmQiLCJnZXRPZmZzZXRzIiwib2Zmc2V0cyIsImNyZWF0ZVRleHRSYW5nZSIsImNvbGxhcHNlIiwic2VsZWN0Iiwic2V0T2Zmc2V0cyIsImdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQiLCJpc0NvbGxhcHNlZCIsImFuY2hvck5vZGUiLCJhbmNob3JPZmZzZXQiLCJmb2N1c09mZnNldCIsImdldElFT2Zmc2V0cyIsInNlbGVjdGVkUmFuZ2UiLCJzZWxlY3RlZExlbmd0aCIsImZyb21TdGFydCIsImR1cGxpY2F0ZSIsIm1vdmVUb0VsZW1lbnRUZXh0Iiwic2V0RW5kUG9pbnQiLCJzdGFydE9mZnNldCIsImVuZE9mZnNldCIsImdldE1vZGVybk9mZnNldHMiLCJyYW5nZUNvdW50IiwiY3VycmVudFJhbmdlIiwiZ2V0UmFuZ2VBdCIsInN0YXJ0Q29udGFpbmVyIiwiZW5kQ29udGFpbmVyIiwiaXNTZWxlY3Rpb25Db2xsYXBzZWQiLCJyYW5nZUxlbmd0aCIsInRlbXBSYW5nZSIsImNsb25lUmFuZ2UiLCJzZWxlY3ROb2RlQ29udGVudHMiLCJzZXRFbmQiLCJpc1RlbXBSYW5nZUNvbGxhcHNlZCIsImRldGVjdGlvblJhbmdlIiwic2V0U3RhcnQiLCJpc0JhY2t3YXJkIiwiY29sbGFwc2VkIiwic2V0SUVPZmZzZXRzIiwic2V0TW9kZXJuT2Zmc2V0cyIsImV4dGVuZCIsInRlbXAiLCJzdGFydE1hcmtlciIsImVuZE1hcmtlciIsIm9mZnNldCIsInJlbW92ZUFsbFJhbmdlcyIsImFkZFJhbmdlIiwidXNlSUVPZmZzZXRzIiwiZ2V0TGVhZk5vZGUiLCJnZXRTaWJsaW5nTm9kZSIsIm5vZGVTdGFydCIsIm5vZGVFbmQiLCJza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQiLCJvblNlbGVjdCIsIm9uU2VsZWN0Q2FwdHVyZSIsImxhc3RTZWxlY3Rpb24iLCJtb3VzZURvd24iLCJoYXNMaXN0ZW5lciIsIk9OX1NFTEVDVF9LRVkiLCJib3VuZGluZ1RvcCIsImxlZnQiLCJib3VuZGluZ0xlZnQiLCJjb25zdHJ1Y3RTZWxlY3RFdmVudCIsImN1cnJlbnRTZWxlY3Rpb24iLCJHTE9CQUxfTU9VTlRfUE9JTlRfTUFYIiwicG93IiwiY2VpbCIsIlN5bnRoZXRpY0NsaXBib2FyZEV2ZW50IiwiU3ludGhldGljRm9jdXNFdmVudCIsIlN5bnRoZXRpY0tleWJvYXJkRXZlbnQiLCJTeW50aGV0aWNEcmFnRXZlbnQiLCJTeW50aGV0aWNUb3VjaEV2ZW50IiwiU3ludGhldGljV2hlZWxFdmVudCIsImdldEV2ZW50Q2hhckNvZGUiLCJhYm9ydCIsIm9uQWJvcnQiLCJvbkFib3J0Q2FwdHVyZSIsImJsdXIiLCJvbkJsdXIiLCJvbkJsdXJDYXB0dXJlIiwiY2FuUGxheSIsIm9uQ2FuUGxheSIsIm9uQ2FuUGxheUNhcHR1cmUiLCJjYW5QbGF5VGhyb3VnaCIsIm9uQ2FuUGxheVRocm91Z2giLCJvbkNhblBsYXlUaHJvdWdoQ2FwdHVyZSIsImNsaWNrIiwib25Db250ZXh0TWVudSIsIm9uQ29udGV4dE1lbnVDYXB0dXJlIiwiY29weSIsIm9uQ29weSIsIm9uQ29weUNhcHR1cmUiLCJjdXQiLCJvbkN1dCIsIm9uQ3V0Q2FwdHVyZSIsImRvdWJsZUNsaWNrIiwiZHJhZyIsIm9uRHJhZyIsIm9uRHJhZ0NhcHR1cmUiLCJkcmFnRW5kIiwib25EcmFnRW5kIiwib25EcmFnRW5kQ2FwdHVyZSIsImRyYWdFbnRlciIsIm9uRHJhZ0VudGVyIiwib25EcmFnRW50ZXJDYXB0dXJlIiwiZHJhZ0V4aXQiLCJvbkRyYWdFeGl0Iiwib25EcmFnRXhpdENhcHR1cmUiLCJkcmFnTGVhdmUiLCJvbkRyYWdMZWF2ZSIsIm9uRHJhZ0xlYXZlQ2FwdHVyZSIsImRyYWdPdmVyIiwib25EcmFnT3ZlciIsIm9uRHJhZ092ZXJDYXB0dXJlIiwiZHJhZ1N0YXJ0Iiwib25EcmFnU3RhcnQiLCJvbkRyYWdTdGFydENhcHR1cmUiLCJkcm9wIiwib25Ecm9wIiwib25Ecm9wQ2FwdHVyZSIsImR1cmF0aW9uQ2hhbmdlIiwib25EdXJhdGlvbkNoYW5nZSIsIm9uRHVyYXRpb25DaGFuZ2VDYXB0dXJlIiwiZW1wdGllZCIsIm9uRW1wdGllZCIsIm9uRW1wdGllZENhcHR1cmUiLCJlbmNyeXB0ZWQiLCJvbkVuY3J5cHRlZCIsIm9uRW5jcnlwdGVkQ2FwdHVyZSIsImVuZGVkIiwib25FbmRlZCIsIm9uRW5kZWRDYXB0dXJlIiwib25FcnJvciIsIm9uRXJyb3JDYXB0dXJlIiwib25Gb2N1cyIsIm9uRm9jdXNDYXB0dXJlIiwib25JbnB1dCIsIm9uSW5wdXRDYXB0dXJlIiwia2V5RG93biIsIm9uS2V5RG93biIsIm9uS2V5RG93bkNhcHR1cmUiLCJrZXlQcmVzcyIsIm9uS2V5UHJlc3MiLCJvbktleVByZXNzQ2FwdHVyZSIsImtleVVwIiwib25LZXlVcCIsIm9uS2V5VXBDYXB0dXJlIiwibG9hZCIsIm9uTG9hZCIsIm9uTG9hZENhcHR1cmUiLCJsb2FkZWREYXRhIiwib25Mb2FkZWREYXRhIiwib25Mb2FkZWREYXRhQ2FwdHVyZSIsImxvYWRlZE1ldGFkYXRhIiwib25Mb2FkZWRNZXRhZGF0YSIsIm9uTG9hZGVkTWV0YWRhdGFDYXB0dXJlIiwibG9hZFN0YXJ0Iiwib25Mb2FkU3RhcnQiLCJvbkxvYWRTdGFydENhcHR1cmUiLCJtb3VzZU1vdmUiLCJtb3VzZU91dCIsIm9uTW91c2VPdXQiLCJvbk1vdXNlT3V0Q2FwdHVyZSIsIm1vdXNlT3ZlciIsIm9uTW91c2VPdmVyIiwib25Nb3VzZU92ZXJDYXB0dXJlIiwibW91c2VVcCIsInBhc3RlIiwib25QYXN0ZSIsIm9uUGFzdGVDYXB0dXJlIiwicGF1c2UiLCJvblBhdXNlIiwib25QYXVzZUNhcHR1cmUiLCJwbGF5Iiwib25QbGF5Iiwib25QbGF5Q2FwdHVyZSIsInBsYXlpbmciLCJvblBsYXlpbmciLCJvblBsYXlpbmdDYXB0dXJlIiwicHJvZ3Jlc3MiLCJvblByb2dyZXNzIiwib25Qcm9ncmVzc0NhcHR1cmUiLCJyYXRlQ2hhbmdlIiwib25SYXRlQ2hhbmdlIiwib25SYXRlQ2hhbmdlQ2FwdHVyZSIsIm9uUmVzZXQiLCJvblJlc2V0Q2FwdHVyZSIsInNjcm9sbCIsIm9uU2Nyb2xsIiwib25TY3JvbGxDYXB0dXJlIiwic2Vla2VkIiwib25TZWVrZWQiLCJvblNlZWtlZENhcHR1cmUiLCJzZWVraW5nIiwib25TZWVraW5nIiwib25TZWVraW5nQ2FwdHVyZSIsInN0YWxsZWQiLCJvblN0YWxsZWQiLCJvblN0YWxsZWRDYXB0dXJlIiwic3VibWl0Iiwib25TdWJtaXQiLCJvblN1Ym1pdENhcHR1cmUiLCJzdXNwZW5kIiwib25TdXNwZW5kIiwib25TdXNwZW5kQ2FwdHVyZSIsInRpbWVVcGRhdGUiLCJvblRpbWVVcGRhdGUiLCJvblRpbWVVcGRhdGVDYXB0dXJlIiwidG91Y2hDYW5jZWwiLCJvblRvdWNoQ2FuY2VsIiwib25Ub3VjaENhbmNlbENhcHR1cmUiLCJ0b3VjaEVuZCIsIm9uVG91Y2hFbmQiLCJvblRvdWNoRW5kQ2FwdHVyZSIsInRvdWNoTW92ZSIsIm9uVG91Y2hNb3ZlIiwib25Ub3VjaE1vdmVDYXB0dXJlIiwidG91Y2hTdGFydCIsIm9uVG91Y2hTdGFydCIsIm9uVG91Y2hTdGFydENhcHR1cmUiLCJ2b2x1bWVDaGFuZ2UiLCJvblZvbHVtZUNoYW5nZSIsIm9uVm9sdW1lQ2hhbmdlQ2FwdHVyZSIsIndhaXRpbmciLCJvbldhaXRpbmciLCJvbldhaXRpbmdDYXB0dXJlIiwid2hlZWwiLCJvbldoZWVsIiwib25XaGVlbENhcHR1cmUiLCJ0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWciLCJPTl9DTElDS19LRVkiLCJvbkNsaWNrTGlzdGVuZXJzIiwiRXZlbnRDb25zdHJ1Y3RvciIsIkNsaXBib2FyZEV2ZW50SW50ZXJmYWNlIiwiY2xpcGJvYXJkRGF0YSIsIkZvY3VzRXZlbnRJbnRlcmZhY2UiLCJnZXRFdmVudEtleSIsIktleWJvYXJkRXZlbnRJbnRlcmZhY2UiLCJyZXBlYXQiLCJsb2NhbGUiLCJjaGFyQ29kZSIsIm5vcm1hbGl6ZUtleSIsInRyYW5zbGF0ZVRvS2V5IiwiRHJhZ0V2ZW50SW50ZXJmYWNlIiwiZGF0YVRyYW5zZmVyIiwiVG91Y2hFdmVudEludGVyZmFjZSIsInRvdWNoZXMiLCJ0YXJnZXRUb3VjaGVzIiwiY2hhbmdlZFRvdWNoZXMiLCJXaGVlbEV2ZW50SW50ZXJmYWNlIiwiZGVsdGFYIiwid2hlZWxEZWx0YVgiLCJkZWx0YVkiLCJ3aGVlbERlbHRhWSIsIndoZWVsRGVsdGEiLCJkZWx0YVoiLCJkZWx0YU1vZGUiLCJOUyIsInhsaW5rIiwieG1sIiwiY2xpcFBhdGgiLCJjeCIsImN5IiwiZHgiLCJkeSIsImZpbGwiLCJmeCIsImZ5IiwiZ3JhZGllbnRUcmFuc2Zvcm0iLCJncmFkaWVudFVuaXRzIiwibWFya2VyRW5kIiwibWFya2VyTWlkIiwibWFya2VyU3RhcnQiLCJwYXR0ZXJuQ29udGVudFVuaXRzIiwicGF0dGVyblVuaXRzIiwicG9pbnRzIiwicHJlc2VydmVBc3BlY3RSYXRpbyIsInIiLCJyeCIsInJ5Iiwic3ByZWFkTWV0aG9kIiwic3RvcENvbG9yIiwic3Ryb2tlIiwic3Ryb2tlRGFzaGFycmF5Iiwic3Ryb2tlTGluZWNhcCIsInRleHRBbmNob3IiLCJ0cmFuc2Zvcm0iLCJ2aWV3Qm94IiwieDEiLCJ4MiIsInhsaW5rQWN0dWF0ZSIsInhsaW5rQXJjcm9sZSIsInhsaW5rSHJlZiIsInhsaW5rUm9sZSIsInhsaW5rU2hvdyIsInhsaW5rVGl0bGUiLCJ4bGlua1R5cGUiLCJ4bWxCYXNlIiwieG1sTGFuZyIsInhtbFNwYWNlIiwieTEiLCJ5MiIsIlJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcyIsInBlcmZvcm1hbmNlTm93Iiwicm91bmRGbG9hdCIsImZsb29yIiwiYWRkVmFsdWUiLCJfYWxsTWVhc3VyZW1lbnRzIiwiX21vdW50U3RhY2siLCJfaW5qZWN0ZWQiLCJnZXRMYXN0TWVhc3VyZW1lbnRzIiwicHJpbnRFeGNsdXNpdmUiLCJtZWFzdXJlbWVudHMiLCJnZXRFeGNsdXNpdmVTdW1tYXJ5IiwidGFibGUiLCJpbmNsdXNpdmUiLCJleGNsdXNpdmUiLCJwcmludEluY2x1c2l2ZSIsImdldEluY2x1c2l2ZVN1bW1hcnkiLCJ0aW1lIiwibG9nIiwiZ2V0VG90YWxUaW1lIiwidG9GaXhlZCIsImdldE1lYXN1cmVtZW50c1N1bW1hcnlNYXAiLCJwcmludFdhc3RlZCIsInByaW50RE9NIiwiZ2V0RE9NU3VtbWFyeSIsIl9yZWNvcmRXcml0ZSIsInRvdGFsVGltZSIsIndyaXRlcyIsIm1vZHVsZU5hbWUiLCJydiIsImNvdW50cyIsImRpc3BsYXlOYW1lcyIsImNyZWF0ZWQiLCJtb3VudElEIiwid3JpdGVBcmdzIiwiaXNSZW5kZXIiLCJpc01vdW50IiwibW91bnRTdGFjayIsInN1Yk1vdW50VGltZSIsIkRPTlRfQ0FSRV9USFJFU0hPTEQiLCJET01fT1BFUkFUSU9OX1RZUEVTIiwibWVhc3VyZW1lbnQiLCJpdGVtcyIsImNhbmRpZGF0ZXMiLCJhbGxJRHMiLCJvbmx5Q2xlYW4iLCJpbmNsdXNpdmVLZXkiLCJjbGVhbkNvbXBvbmVudHMiLCJnZXRVbmNoYW5nZWRDb21wb25lbnRzIiwiZGlydHlMZWFmSURzIiwiaXNEaXJ0eSIsInBlcmZvcm1hbmNlIiwibXNQZXJmb3JtYW5jZSIsIndlYmtpdFBlcmZvcm1hbmNlIiwiUmVhY3RTZXJ2ZXJSZW5kZXJpbmciLCJSZWFjdFNlcnZlckJhdGNoaW5nU3RyYXRlZ3kiLCJSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uIiwiUmVhY3RET01GYWN0b3JpZXMiLCJSZWFjdEVsZW1lbnRWYWxpZGF0b3IiLCJvbmx5Q2hpbGQiLCJDaGlsZHJlbiIsIm9ubHkiLCJQcm9wVHlwZXMiLCJjcmVhdGVNaXhpbiIsIkRPTSIsIl9fc3ByZWFkIiwibWFwT2JqZWN0IiwiY3JlYXRlRE9NRmFjdG9yeSIsImFiYnIiLCJhZGRyZXNzIiwiYXJlYSIsImFydGljbGUiLCJhc2lkZSIsImF1ZGlvIiwiYmFzZSIsImJkaSIsImJkbyIsImJpZyIsImJsb2NrcXVvdGUiLCJiciIsImNhbnZhcyIsImNhcHRpb24iLCJjaXRlIiwiY29kZSIsImNvbCIsImNvbGdyb3VwIiwiZGF0YWxpc3QiLCJkZCIsImRlbCIsImRldGFpbHMiLCJkZm4iLCJkaWFsb2ciLCJkaXYiLCJkbCIsImR0IiwiZW0iLCJlbWJlZCIsImZpZWxkc2V0IiwiZmlnY2FwdGlvbiIsImZpZ3VyZSIsImZvb3RlciIsImgxIiwiaDIiLCJoMyIsImg0IiwiaDUiLCJoNiIsImhlYWQiLCJoZWFkZXIiLCJoZ3JvdXAiLCJociIsImlmcmFtZSIsImltZyIsImlucyIsImtiZCIsImtleWdlbiIsImxlZ2VuZCIsImxpIiwibGluayIsIm1haW4iLCJtYXJrIiwibWVudSIsIm1lbnVpdGVtIiwibWV0YSIsIm1ldGVyIiwibmF2Iiwibm9zY3JpcHQiLCJvbCIsIm9wdGdyb3VwIiwib3B0aW9uIiwib3V0cHV0IiwicCIsInBhcmFtIiwicGljdHVyZSIsInByZSIsInEiLCJycCIsInJ0IiwicnVieSIsInMiLCJzYW1wIiwic2NyaXB0Iiwic2VjdGlvbiIsInNtYWxsIiwic3Ryb25nIiwic3ViIiwic3VwIiwidGJvZHkiLCJ0ZCIsInRleHRhcmVhIiwidGZvb3QiLCJ0aCIsInRoZWFkIiwidHIiLCJ0cmFjayIsInUiLCJ1bCIsInZpZGVvIiwid2JyIiwiY2lyY2xlIiwiZGVmcyIsImVsbGlwc2UiLCJnIiwiaW1hZ2UiLCJsaW5lIiwibGluZWFyR3JhZGllbnQiLCJtYXNrIiwicG9seWdvbiIsInBvbHlsaW5lIiwicmFkaWFsR3JhZGllbnQiLCJyZWN0Iiwic3ZnIiwidHNwYW4iLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwicGFyZW50VHlwZSIsImFkZGVuZGEiLCJnZXRBZGRlbmRhRm9yS2V5VXNlIiwicGFyZW50T3JPd25lciIsIm1lc3NhZ2VUeXBlIiwicGFyZW50TmFtZSIsIm1lbW9pemVyIiwidmFsaWRhdGVDaGlsZEtleXMiLCJ2YWxpZGF0ZVByb3BUeXBlcyIsInZhbGlkVHlwZSIsInZhbGlkYXRlZEZhY3RvcnkiLCJuZXdNb2R1bGUiLCJuZXdQYWNrYWdlIiwiY3R4IiwiZm4iLCJ3YXJuZWQiLCJuZXdGbiIsIl9fZXNNb2R1bGUiLCJjcmVhdGVNZW1vcnlIaXN0b3J5IiwiYnJvd3Nlckhpc3RvcnkiLCJhcHBseVJvdXRlck1pZGRsZXdhcmUiLCJmb3JtYXRQYXR0ZXJuIiwidXNlUm91dGVySGlzdG9yeSIsInJvdXRlclNoYXBlIiwibG9jYXRpb25TaGFwZSIsIlJvdXRpbmdDb250ZXh0IiwiUm91dGVyQ29udGV4dCIsImNyZWF0ZVJvdXRlcyIsInVzZVJvdXRlcyIsIlJvdXRlQ29udGV4dCIsIkxpZmVjeWNsZSIsIkhpc3RvcnkiLCJSZWRpcmVjdCIsIkluZGV4UmVkaXJlY3QiLCJ3aXRoUm91dGVyIiwiSW5kZXhMaW5rIiwiTGluayIsIl9Sb3V0ZVV0aWxzIiwiX1Byb3BUeXBlczIiLCJfUGF0dGVyblV0aWxzIiwiX1JvdXRlcjIiLCJfUm91dGVyMyIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfTGluazIiLCJfTGluazMiLCJfSW5kZXhMaW5rMiIsIl9JbmRleExpbmszIiwiX3dpdGhSb3V0ZXIyIiwiX3dpdGhSb3V0ZXIzIiwiX0luZGV4UmVkaXJlY3QyIiwiX0luZGV4UmVkaXJlY3QzIiwiX0luZGV4Um91dGUyIiwiX0luZGV4Um91dGUzIiwiX1JlZGlyZWN0MiIsIl9SZWRpcmVjdDMiLCJfUm91dGUyIiwiX1JvdXRlMyIsIl9IaXN0b3J5MiIsIl9IaXN0b3J5MyIsIl9MaWZlY3ljbGUyIiwiX0xpZmVjeWNsZTMiLCJfUm91dGVDb250ZXh0MiIsIl9Sb3V0ZUNvbnRleHQzIiwiX3VzZVJvdXRlczIiLCJfdXNlUm91dGVzMyIsIl9Sb3V0ZXJDb250ZXh0MiIsIl9Sb3V0ZXJDb250ZXh0MyIsIl9Sb3V0aW5nQ29udGV4dDIiLCJfUm91dGluZ0NvbnRleHQzIiwiX1Byb3BUeXBlczMiLCJfbWF0Y2gyIiwiX21hdGNoMyIsIl91c2VSb3V0ZXJIaXN0b3J5MiIsIl91c2VSb3V0ZXJIaXN0b3J5MyIsIl9hcHBseVJvdXRlck1pZGRsZXdhcmUyIiwiX2FwcGx5Um91dGVyTWlkZGxld2FyZTMiLCJfYnJvd3Nlckhpc3RvcnkyIiwiX2Jyb3dzZXJIaXN0b3J5MyIsIl9oYXNoSGlzdG9yeTIiLCJfaGFzaEhpc3RvcnkzIiwiX2NyZWF0ZU1lbW9yeUhpc3RvcnkyIiwiX2NyZWF0ZU1lbW9yeUhpc3RvcnkzIiwiZGVmYXVsdCIsIl9leHRlbmRzIiwiaXNSZWFjdENoaWxkcmVuIiwiY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50IiwiY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW4iLCJfcmVhY3QiLCJfcmVhY3QyIiwiaXNWYWxpZENoaWxkIiwiY3JlYXRlUm91dGUiLCJyb3V0ZSIsImNoaWxkUm91dGVzIiwicGFyZW50Um91dGUiLCJyb3V0ZXMiLCJyb3V0ZXIiLCJjb21wb25lbnRzIiwiaGlzdG9yeSIsImZhbHN5IiwiX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMiLCJfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllczIiLCJfSW50ZXJuYWxQcm9wVHlwZXMiLCJJbnRlcm5hbFByb3BUeXBlcyIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwiX3JvdXRlcldhcm5pbmciLCJfcm91dGVyV2FybmluZzIiLCJuZXdPYmoiLCJnbyIsImdvQmFjayIsImdvRm9yd2FyZCIsInNldFJvdXRlTGVhdmVIb29rIiwiaXNBY3RpdmUiLCJwYXRobmFtZSIsInNlYXJjaCIsImRlcHJlY2F0ZVByb3BUeXBlIiwiZGVwcmVjYXRlSW50ZXJuYWxQcm9wVHlwZSIsImRlcHJlY2F0ZVJlbmFtZWRQcm9wVHlwZSIsImRlZmF1bHRFeHBvcnQiLCJjYW5Vc2VNZW1icmFuZSIsImRlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMiLCJtZW1icmFuZSIsIl9sb29wIiwiX3JldCIsInJvdXRlcldhcm5pbmciLCJfcmVzZXRXYXJuZWQiLCJfd2FybmluZyIsIl93YXJuaW5nMiIsImZhbHNlVG9XYXJuIiwiY29tcGlsZVBhdHRlcm4iLCJtYXRjaFBhdHRlcm4iLCJnZXRQYXJhbU5hbWVzIiwiZ2V0UGFyYW1zIiwiX2ludmFyaWFudCIsIl9pbnZhcmlhbnQyIiwiZXNjYXBlUmVnRXhwIiwiX2NvbXBpbGVQYXR0ZXJuIiwicmVnZXhwU291cmNlIiwicGFyYW1OYW1lcyIsInRva2VucyIsIm1hdGNoZXIiLCJleGVjIiwiQ29tcGlsZWRQYXR0ZXJuc0NhY2hlIiwiX2NvbXBpbGVQYXR0ZXJuMiIsIm1hdGNoZWRQYXRoIiwicmVtYWluaW5nUGF0aG5hbWUiLCJwYXJhbVZhbHVlcyIsInYiLCJkZWNvZGVVUklDb21wb25lbnQiLCJwYXJhbXMiLCJwYXJhbU5hbWUiLCJfY29tcGlsZVBhdHRlcm4zIiwicGFyZW5Db3VudCIsInNwbGF0SW5kZXgiLCJ0b2tlbiIsInBhcmFtVmFsdWUiLCJzcGxhdCIsImVuY29kZVVSSSIsImVuY29kZVVSSUNvbXBvbmVudCIsIl9jcmVhdGVIYXNoSGlzdG9yeSIsIl9jcmVhdGVIYXNoSGlzdG9yeTIiLCJfdXNlUXVlcmllcyIsIl91c2VRdWVyaWVzMiIsIl9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlciIsIl9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIiLCJfUm91dGVyQ29udGV4dCIsIl9Sb3V0ZXJVdGlscyIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsImlzRGVwcmVjYXRlZEhpc3RvcnkiLCJfX3YyX2NvbXBhdGlibGVfXyIsImlzVW5zdXBwb3J0ZWRIaXN0b3J5IiwiZ2V0Q3VycmVudExvY2F0aW9uIiwiX1JlYWN0JFByb3BUeXBlcyIsIm9uVXBkYXRlIiwicGFyc2VRdWVyeVN0cmluZyIsInN0cmluZ2lmeVF1ZXJ5IiwibWF0Y2hDb250ZXh0IiwiaGFuZGxlRXJyb3IiLCJfdGhpcyIsIl9wcm9wcyIsIl9jcmVhdGVSb3V0ZXJPYmplY3RzIiwiY3JlYXRlUm91dGVyT2JqZWN0cyIsInRyYW5zaXRpb25NYW5hZ2VyIiwiX3VubGlzdGVuIiwiX3Byb3BzMiIsIndyYXBEZXByZWNhdGVkSGlzdG9yeSIsImNyZWF0ZVJvdXRlck9iamVjdCIsInJvdXRpbmdIaXN0b3J5IiwiY3JlYXRlUm91dGluZ0hpc3RvcnkiLCJfcHJvcHMzIiwiY3JlYXRlSGlzdG9yeSIsIl9zdGF0ZSIsIl9wcm9wczQiLCJfQWN0aW9ucyIsIl9QYXRoVXRpbHMiLCJfRXhlY3V0aW9uRW52aXJvbm1lbnQiLCJfRE9NVXRpbHMiLCJfRE9NU3RhdGVTdG9yYWdlIiwiX2NyZWF0ZURPTUhpc3RvcnkiLCJfY3JlYXRlRE9NSGlzdG9yeTIiLCJpc0Fic29sdXRlUGF0aCIsImVuc3VyZVNsYXNoIiwiZ2V0SGFzaFBhdGgiLCJyZXBsYWNlSGFzaFBhdGgiLCJhZGRRdWVyeVN0cmluZ1ZhbHVlVG9QYXRoIiwic3RyaXBRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGgiLCJnZXRRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGgiLCJEZWZhdWx0UXVlcnlLZXkiLCJjcmVhdGVIYXNoSGlzdG9yeSIsInF1ZXJ5S2V5IiwicmVhZFN0YXRlIiwiY3JlYXRlS2V5IiwicGFyc2VQYXRoIiwiY3JlYXRlTG9jYXRpb24iLCJzdGFydEhhc2hDaGFuZ2VMaXN0ZW5lciIsIl9yZWYiLCJ0cmFuc2l0aW9uVG8iLCJoYXNoQ2hhbmdlTGlzdGVuZXIiLCJmaW5pc2hUcmFuc2l0aW9uIiwiYmFzZW5hbWUiLCJQT1AiLCJzYXZlU3RhdGUiLCJjdXJyZW50SGFzaCIsIlBVU0giLCJsaXN0ZW5lckNvdW50Iiwic3RvcEhhc2hDaGFuZ2VMaXN0ZW5lciIsImxpc3RlbkJlZm9yZSIsInVubGlzdGVuIiwiZ29Jc1N1cHBvcnRlZFdpdGhvdXRSZWxvYWQiLCJzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCIsIm4iLCJjcmVhdGVIcmVmIiwicmVnaXN0ZXJUcmFuc2l0aW9uSG9vayIsImhvb2siLCJ1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2siLCJwdXNoU3RhdGUiLCJSRVBMQUNFIiwiZXh0cmFjdFBhdGgiLCJoYXNoSW5kZXgiLCJzZWFyY2hJbmRleCIsImdldFdpbmRvd1BhdGgiLCJnZXRVc2VyQ29uZmlybWF0aW9uIiwic3VwcG9ydHNIaXN0b3J5IiwiY29uZmlybSIsInVhIiwiS2V5UHJlZml4IiwiUXVvdGFFeGNlZWRlZEVycm9ycyIsIlNlY3VyaXR5RXJyb3IiLCJzZXNzaW9uU3RvcmFnZSIsInJlbW92ZUl0ZW0iLCJzZXRJdGVtIiwianNvbiIsImdldEl0ZW0iLCJwYXJzZSIsIl9jcmVhdGVIaXN0b3J5IiwiX2NyZWF0ZUhpc3RvcnkyIiwiY3JlYXRlRE9NSGlzdG9yeSIsIl9kZWVwRXF1YWwiLCJfZGVlcEVxdWFsMiIsIl9Bc3luY1V0aWxzIiwiX2NyZWF0ZUxvY2F0aW9uMiIsIl9jcmVhdGVMb2NhdGlvbjMiLCJfcnVuVHJhbnNpdGlvbkhvb2siLCJfcnVuVHJhbnNpdGlvbkhvb2syIiwiX2RlcHJlY2F0ZSIsIl9kZXByZWNhdGUyIiwiY3JlYXRlUmFuZG9tS2V5IiwibG9jYXRpb25zQXJlRXF1YWwiLCJEZWZhdWx0S2V5TGVuZ3RoIiwia2V5TGVuZ3RoIiwidHJhbnNpdGlvbkhvb2tzIiwiZmlsdGVyIiwiYWxsS2V5cyIsImNoYW5nZUxpc3RlbmVycyIsImdldEN1cnJlbnQiLCJwZW5kaW5nTG9jYXRpb24iLCJ1cGRhdGVMb2NhdGlvbiIsIm5ld0xvY2F0aW9uIiwiX2xvY2F0aW9uIiwiY29uZmlybVRyYW5zaXRpb25UbyIsImxvb3BBc3luYyIsIm9rIiwibmV4dExvY2F0aW9uIiwicHJldlBhdGgiLCJjcmVhdGVQYXRoIiwibmV4dFBhdGgiLCJwcmV2SW5kZXgiLCJ1cGRhdGVMb2NhdGlvblN0YXRlIiwicFNsaWNlIiwib2JqZWN0S2V5cyIsImlzQXJndW1lbnRzIiwiZGVlcEVxdWFsIiwiYWN0dWFsIiwiZXhwZWN0ZWQiLCJvcHRzIiwiZ2V0VGltZSIsInN0cmljdCIsIm9iakVxdWl2IiwiaXNVbmRlZmluZWRPck51bGwiLCJpc0J1ZmZlciIsImthIiwia2IiLCJzaGltIiwic3VwcG9ydHNBcmd1bWVudHNDbGFzcyIsInN1cHBvcnRlZCIsInVuc3VwcG9ydGVkIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfc2xpY2UiLCJ0dXJucyIsIndvcmsiLCJjdXJyZW50VHVybiIsImlzRG9uZSIsInN5bmMiLCJoYXNOZXh0IiwiZG9uZUFyZ3MiLCJfZm91cnRoQXJnIiwicnVuVHJhbnNpdGlvbkhvb2siLCJkZXByZWNhdGUiLCJfcXVlcnlTdHJpbmciLCJTRUFSQ0hfQkFTRV9LRVkiLCJkZWZhdWx0U3RyaW5naWZ5UXVlcnkiLCJxdWVyeSIsImRlZmF1bHRQYXJzZVF1ZXJ5U3RyaW5nIiwiaXNOZXN0ZWRPYmplY3QiLCJ1c2VRdWVyaWVzIiwiYWRkUXVlcnkiLCJzZWFyY2hCYXNlIiwiYXBwZW5kUXVlcnkiLCJfZXh0ZW5kczIiLCJzZWFyY2hCYXNlU3BlYyIsInF1ZXJ5U3RyaW5nIiwiZnVsbExvY2F0aW9uIiwic3RyaWN0VXJpRW5jb2RlIiwiZXh0cmFjdCIsInN0ciIsInJlZHVjZSIsInBhcnRzIiwic2hpZnQiLCJ2YWwyIiwiY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIiLCJfY29tcHV0ZUNoYW5nZWRSb3V0ZXMyIiwiX2NvbXB1dGVDaGFuZ2VkUm91dGVzMyIsIl9UcmFuc2l0aW9uVXRpbHMiLCJfaXNBY3RpdmUyIiwiX2lzQWN0aXZlMyIsIl9nZXRDb21wb25lbnRzIiwiX2dldENvbXBvbmVudHMyIiwiX21hdGNoUm91dGVzIiwiX21hdGNoUm91dGVzMiIsImhhc0FueVByb3BlcnRpZXMiLCJpbmRleE9ubHlPckRlcHJlY2F0ZWRRdWVyeSIsImRlcHJlY2F0ZWRJbmRleE9ubHkiLCJpbmRleE9ubHkiLCJwYXJ0aWFsTmV4dFN0YXRlIiwiZmluaXNoTWF0Y2giLCJfY29tcHV0ZUNoYW5nZWRSb3V0ZXMiLCJsZWF2ZVJvdXRlcyIsImNoYW5nZVJvdXRlcyIsImVudGVyUm91dGVzIiwicnVuTGVhdmVIb29rcyIsInJlbW92ZUxpc3RlbkJlZm9yZUhvb2tzRm9yUm91dGUiLCJydW5DaGFuZ2VIb29rcyIsInJlZGlyZWN0SW5mbyIsImhhbmRsZUVycm9yT3JSZWRpcmVjdCIsInJ1bkVudGVySG9va3MiLCJmaW5pc2hFbnRlckhvb2tzIiwiUm91dGVHdWlkIiwiZ2V0Um91dGVJRCIsIl9faWRfXyIsIlJvdXRlSG9va3MiLCJnZXRSb3V0ZUhvb2tzRm9yUm91dGVzIiwiaG9va3MiLCJ0cmFuc2l0aW9uSG9vayIsImJlZm9yZVVubG9hZEhvb2siLCJ1bmxpc3RlbkJlZm9yZSIsInVubGlzdGVuQmVmb3JlVW5sb2FkIiwicm91dGVJRCIsImxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZSIsInRoZXJlV2VyZU5vUm91dGVIb29rcyIsImxpc3RlbkJlZm9yZVVubG9hZCIsIm5ld0hvb2tzIiwicmVkaXJlY3RMb2NhdGlvbiIsInJvdXRlUGFyYW1zQ2hhbmdlZCIsInNvbWUiLCJjb21wdXRlQ2hhbmdlZFJvdXRlcyIsInByZXZSb3V0ZXMiLCJuZXh0Um91dGVzIiwicGFyZW50SXNMZWF2aW5nIiwiaXNMZWF2aW5nIiwiaXNOZXciLCJwYXJhbXNDaGFuZ2VkIiwiY3JlYXRlVHJhbnNpdGlvbkhvb2siLCJhc3luY0FyaXR5IiwiZ2V0RW50ZXJIb29rcyIsIm9uRW50ZXIiLCJnZXRDaGFuZ2VIb29rcyIsInJ1blRyYW5zaXRpb25Ib29rcyIsIml0ZXIiLCJkZXByZWNhdGVkUGF0aG5hbWUiLCJkZXByZWNhdGVkUXVlcnkiLCJvbkxlYXZlIiwibWFwQXN5bmMiLCJ2YWx1ZXMiLCJkb25lQ291bnQiLCJfdHlwZW9mIiwicGF0aElzQWN0aXZlIiwiY3VycmVudFBhdGhuYW1lIiwicm91dGVJc0FjdGl2ZSIsIm1hdGNoZWQiLCJxdWVyeUlzQWN0aXZlIiwiYWN0aXZlUXVlcnkiLCJjdXJyZW50TG9jYXRpb24iLCJfbWFrZVN0YXRlV2l0aExvY2F0aW9uIiwiX21ha2VTdGF0ZVdpdGhMb2NhdGlvbjIiLCJnZXRDb21wb25lbnRzRm9yUm91dGUiLCJnZXRDb21wb25lbnQiLCJnZXRDb21wb25lbnRzIiwibmV4dFN0YXRlV2l0aExvY2F0aW9uIiwibWFrZVN0YXRlV2l0aExvY2F0aW9uIiwic3RhdGVXaXRoTG9jYXRpb24iLCJtYXRjaFJvdXRlcyIsImdldENoaWxkUm91dGVzIiwiY3JlYXRlUGFyYW1zIiwicGFydGlhbE5leHRTdGF0ZVdpdGhMb2NhdGlvbiIsImdldEluZGV4Um91dGUiLCJpbmRleFJvdXRlIiwicGF0aGxlc3MiLCJjaGlsZFJvdXRlIiwiYXNzaWduUGFyYW1zIiwibWF0Y2hSb3V0ZURlZXAiLCJfcmV0MiIsIl9tYXRjaCRyb3V0ZXMiLCJvbkNoaWxkUm91dGVzIiwidW5zaGlmdCIsIl9nZXRSb3V0ZVBhcmFtcyIsIl9nZXRSb3V0ZVBhcmFtczIiLCJyZWR1Y2VSaWdodCIsInJvdXRlUGFyYW1zIiwiZWxlbWVudHMiLCJnZXRSb3V0ZVBhcmFtcyIsIl9Qcm9wVHlwZXMiLCJpc0xlZnRDbGlja0V2ZW50IiwiaXNNb2RpZmllZEV2ZW50IiwiaXNFbXB0eU9iamVjdCIsImNyZWF0ZUxvY2F0aW9uRGVzY3JpcHRvciIsImFjdGl2ZVN0eWxlIiwiYWN0aXZlQ2xhc3NOYW1lIiwib25seUFjdGl2ZU9uSW5kZXgiLCJoYW5kbGVDbGljayIsIl9MaW5rIiwiX2hvaXN0Tm9uUmVhY3RTdGF0aWNzIiwiX2hvaXN0Tm9uUmVhY3RTdGF0aWNzMiIsImdldERpc3BsYXlOYW1lIiwiV3JhcHBlZENvbXBvbmVudCIsIndpdGhSZWYiLCJXaXRoUm91dGVyIiwiZ2V0V3JhcHBlZEluc3RhbmNlIiwid3JhcHBlZEluc3RhbmNlIiwiUkVBQ1RfU1RBVElDUyIsIktOT1dOX1NUQVRJQ1MiLCJjYWxsZXIiLCJhcml0eSIsImlzR2V0T3duUHJvcGVydHlTeW1ib2xzQXZhaWxhYmxlIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiaG9pc3ROb25SZWFjdFN0YXRpY3MiLCJ0YXJnZXRDb21wb25lbnQiLCJzb3VyY2VDb21wb25lbnQiLCJjdXN0b21TdGF0aWNzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIl9SZWRpcmVjdCIsInJvdXRlSW5kZXgiLCJwYXJlbnRQYXR0ZXJuIiwiZ2V0Um91dGVQYXR0ZXJuIiwicm91dGVyV2lsbExlYXZlIiwiX3VubGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlIiwiX2NyZWF0ZU1lbW9yeUhpc3RvcnkiLCJoaXN0b3J5TG9jYXRpb24iLCJfdXNlQmFzZW5hbWUiLCJfdXNlQmFzZW5hbWUyIiwibWVtb3J5SGlzdG9yeSIsInVzZUJhc2VuYW1lIiwiY2hlY2tlZEJhc2VIcmVmIiwiY2hlY2tCYXNlSHJlZiIsImJhc2VIcmVmIiwiYWRkQmFzZW5hbWUiLCJwcmVwZW5kQmFzZW5hbWUiLCJwbmFtZSIsIm5vcm1hbGl6ZWRCYXNlbmFtZSIsIm5vcm1hbGl6ZWRQYXRobmFtZSIsImNyZWF0ZVN0YXRlU3RvcmFnZSIsIm1lbW8iLCJfb3B0aW9ucyIsInN0b3JhZ2UiLCJjYW5HbyIsIm1pZGRsZXdhcmVzIiwibWlkZGxld2FyZSIsInJlbmRlclJvdXRlckNvbnRleHQiLCJyZW5kZXJSb3V0ZUNvbXBvbmVudCIsIndpdGhDb250ZXh0Iiwid2l0aENvbXBvbmVudCIsIm1ha2VDcmVhdGVFbGVtZW50IiwiYmFzZUNyZWF0ZUVsZW1lbnQiLCJwcmV2aW91cyIsInJlbmRlclByb3BzIiwiX2NyZWF0ZUJyb3dzZXJIaXN0b3J5IiwiX2NyZWF0ZUJyb3dzZXJIaXN0b3J5MiIsIl9jcmVhdGVSb3V0ZXJIaXN0b3J5IiwiX2NyZWF0ZVJvdXRlckhpc3RvcnkyIiwiY3JlYXRlQnJvd3Nlckhpc3RvcnkiLCJmb3JjZVJlZnJlc2giLCJ1c2VSZWZyZXNoIiwiaGlzdG9yeVN0YXRlIiwiX2hpc3RvcnlTdGF0ZSIsInN0YXJ0UG9wU3RhdGVMaXN0ZW5lciIsInBvcFN0YXRlTGlzdGVuZXIiLCJzdG9wUG9wU3RhdGVMaXN0ZW5lciIsIl91c2VSb3V0ZXJIaXN0b3J5IiwidXVpZCIsIlRvZG9MaXN0IiwiQWRkVG9kbyIsIlRvZG9TZWFyY2giLCJUb2RvQVBJIiwic2hvd0NvbXBsZXRlZCIsInNlYXJjaFRleHQiLCJ0b2RvcyIsImdldFRvZG9zIiwic2V0VG9kb3MiLCJoYW5kbGVUb2dnbGUiLCJ1cGRhdGVkVG9kb3MiLCJ0b2RvIiwiY29tcGxldGVkIiwiaGFuZGxlU2VhcmNoIiwiaGFuZGxlQWRkVG9kbyIsIm1vZHVsZXMiLCJtZWRpYVF1ZXJ5IiwiYWxyZWFkeUltcG9ydGVkTW9kdWxlcyIsIl93aW5kb3ciLCJfcm5nIiwiX21hdGhSTkciLCJfbm9kZVJORyIsIl93aGF0d2dSTkciLCJfcHJldmlvdXNSb290Iiwic2V0dXBCcm93c2VyIiwiX2NyeXB0byIsImNyeXB0byIsIm1zQ3J5cHRvIiwiZ2V0UmFuZG9tVmFsdWVzIiwiX3JuZHM4IiwiVWludDhBcnJheSIsIndoYXR3Z1JORyIsIl9ybmRzIiwid2FybiIsInNldHVwTm9kZSIsIl9yYiIsInJhbmRvbUJ5dGVzIiwiQnVmZmVyQ2xhc3MiLCJCdWZmZXIiLCJfYnl0ZVRvSGV4IiwiX2hleFRvQnl0ZSIsImJ1ZiIsIm9jdCIsInVucGFyc2UiLCJidGgiLCJfc2VlZEJ5dGVzIiwiX25vZGVJZCIsIl9jbG9ja3NlcSIsIl9sYXN0TVNlY3MiLCJfbGFzdE5TZWNzIiwidjEiLCJjbG9ja3NlcSIsIm1zZWNzIiwibnNlY3MiLCJ0bCIsInRtaCIsInY0Iiwicm5kcyIsInJuZyIsImRlZmluZSIsIm5vQ29uZmxpY3QiLCJiYXNlNjQiLCJpZWVlNzU0IiwiU2xvd0J1ZmZlciIsIklOU1BFQ1RfTUFYX0JZVEVTIiwiVFlQRURfQVJSQVlfU1VQUE9SVCIsImdsb2JhbCIsInR5cGVkQXJyYXlTdXBwb3J0Iiwia01heExlbmd0aCIsIl9fcHJvdG9fXyIsImZvbyIsInN1YmFycmF5IiwiYnl0ZUxlbmd0aCIsImNyZWF0ZUJ1ZmZlciIsInRoYXQiLCJSYW5nZUVycm9yIiwiZW5jb2RpbmdPck9mZnNldCIsImFsbG9jVW5zYWZlIiwiX2F1Z21lbnQiLCJBcnJheUJ1ZmZlciIsImZyb21BcnJheUJ1ZmZlciIsImZyb21TdHJpbmciLCJmcm9tT2JqZWN0Iiwic3BlY2llcyIsImFzc2VydFNpemUiLCJhbGxvYyIsImVuY29kaW5nIiwiYWxsb2NVbnNhZmVTbG93IiwiaXNFbmNvZGluZyIsImZyb21BcnJheUxpa2UiLCJieXRlT2Zmc2V0IiwiYnVmZmVyIiwiaXNuYW4iLCJfaXNCdWZmZXIiLCJjb21wYXJlIiwicG9zIiwiaXNWaWV3IiwibG93ZXJlZENhc2UiLCJ1dGY4VG9CeXRlcyIsImJhc2U2NFRvQnl0ZXMiLCJzbG93VG9TdHJpbmciLCJoZXhTbGljZSIsInV0ZjhTbGljZSIsImFzY2lpU2xpY2UiLCJsYXRpbjFTbGljZSIsImJhc2U2NFNsaWNlIiwidXRmMTZsZVNsaWNlIiwic3dhcCIsInN3YXAxNiIsInN3YXAzMiIsInN3YXA2NCIsImVxdWFscyIsImluc3BlY3QiLCJ0aGlzU3RhcnQiLCJ0aGlzRW5kIiwidGhpc0NvcHkiLCJ0YXJnZXRDb3B5IiwiYmlkaXJlY3Rpb25hbEluZGV4T2YiLCJhcnJheUluZGV4T2YiLCJpbmRleFNpemUiLCJhcnJMZW5ndGgiLCJ2YWxMZW5ndGgiLCJyZWFkIiwicmVhZFVJbnQxNkJFIiwiZm91bmRJbmRleCIsImZvdW5kIiwiaW5jbHVkZXMiLCJoZXhXcml0ZSIsIk51bWJlciIsInJlbWFpbmluZyIsInN0ckxlbiIsInBhcnNlZCIsInV0ZjhXcml0ZSIsImJsaXRCdWZmZXIiLCJhc2NpaVdyaXRlIiwiYXNjaWlUb0J5dGVzIiwibGF0aW4xV3JpdGUiLCJiYXNlNjRXcml0ZSIsInVjczJXcml0ZSIsInV0ZjE2bGVUb0J5dGVzIiwiaXNGaW5pdGUiLCJ0b0pTT04iLCJfYXJyIiwiZnJvbUJ5dGVBcnJheSIsImZpcnN0Qnl0ZSIsImNvZGVQb2ludCIsImJ5dGVzUGVyU2VxdWVuY2UiLCJzZWNvbmRCeXRlIiwidGhpcmRCeXRlIiwiZm91cnRoQnl0ZSIsInRlbXBDb2RlUG9pbnQiLCJkZWNvZGVDb2RlUG9pbnRzQXJyYXkiLCJNQVhfQVJHVU1FTlRTX0xFTkdUSCIsImNvZGVQb2ludHMiLCJvdXQiLCJ0b0hleCIsImJ5dGVzIiwibmV3QnVmIiwic2xpY2VMZW4iLCJjaGVja09mZnNldCIsImV4dCIsInJlYWRVSW50TEUiLCJub0Fzc2VydCIsIm11bCIsInJlYWRVSW50QkUiLCJyZWFkVUludDgiLCJyZWFkVUludDE2TEUiLCJyZWFkVUludDMyTEUiLCJyZWFkVUludDMyQkUiLCJyZWFkSW50TEUiLCJyZWFkSW50QkUiLCJyZWFkSW50OCIsInJlYWRJbnQxNkxFIiwicmVhZEludDE2QkUiLCJyZWFkSW50MzJMRSIsInJlYWRJbnQzMkJFIiwicmVhZEZsb2F0TEUiLCJyZWFkRmxvYXRCRSIsInJlYWREb3VibGVMRSIsInJlYWREb3VibGVCRSIsImNoZWNrSW50Iiwid3JpdGVVSW50TEUiLCJtYXhCeXRlcyIsIndyaXRlVUludEJFIiwid3JpdGVVSW50OCIsIm9iamVjdFdyaXRlVUludDE2IiwibGl0dGxlRW5kaWFuIiwid3JpdGVVSW50MTZMRSIsIndyaXRlVUludDE2QkUiLCJvYmplY3RXcml0ZVVJbnQzMiIsIndyaXRlVUludDMyTEUiLCJ3cml0ZVVJbnQzMkJFIiwid3JpdGVJbnRMRSIsImxpbWl0Iiwid3JpdGVJbnRCRSIsIndyaXRlSW50OCIsIndyaXRlSW50MTZMRSIsIndyaXRlSW50MTZCRSIsIndyaXRlSW50MzJMRSIsIndyaXRlSW50MzJCRSIsImNoZWNrSUVFRTc1NCIsIndyaXRlRmxvYXQiLCJ3cml0ZUZsb2F0TEUiLCJ3cml0ZUZsb2F0QkUiLCJ3cml0ZURvdWJsZSIsIndyaXRlRG91YmxlTEUiLCJ3cml0ZURvdWJsZUJFIiwidGFyZ2V0U3RhcnQiLCJJTlZBTElEX0JBU0U2NF9SRSIsImJhc2U2NGNsZWFuIiwic3RyaW5ndHJpbSIsInVuaXRzIiwiSW5maW5pdHkiLCJsZWFkU3Vycm9nYXRlIiwiYnl0ZUFycmF5IiwiaGkiLCJsbyIsInRvQnl0ZUFycmF5IiwiZHN0IiwibG9va3VwIiwicmV2TG9va3VwIiwiQXJyIiwicGxhY2VIb2xkZXJzQ291bnQiLCJiNjQiLCJ0bXAiLCJwbGFjZUhvbGRlcnMiLCJMIiwidHJpcGxldFRvQmFzZTY0IiwibnVtIiwiZW5jb2RlQ2h1bmsiLCJ1aW50OCIsImV4dHJhQnl0ZXMiLCJtYXhDaHVua0xlbmd0aCIsImxlbjIiLCJpc0xFIiwibUxlbiIsIm5CeXRlcyIsImVMZW4iLCJlTWF4IiwiZUJpYXMiLCJuQml0cyIsIk5hTiIsImFicyIsIkxOMiIsImNyZWF0ZUhhc2giLCJjcmVhdGVIbWFjIiwiZWFjaCIsImdldEhhc2hlcyIsInBia2RmMiIsInBia2RmMlN5bmMiLCJtZDUiLCJ0b0NvbnN0cnVjdG9yIiwicm1kMTYwIiwiYnVmZmVycyIsImVuYyIsImRpZ2VzdCIsImFsZyIsIkFsZyIsIkhhc2giLCJzaGExIiwic2hhMjU2Iiwic2hhNTEyIiwiYmxvY2tTaXplIiwiZmluYWxTaXplIiwiX2Jsb2NrIiwiX2ZpbmFsU2l6ZSIsIl9ibG9ja1NpemUiLCJfcyIsImluaXQiLCJ0IiwiY2giLCJfdXBkYXRlIiwiX2hhc2giLCJpbmhlcml0cyIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiVyIsIkludDMyQXJyYXkiLCJQT09MIiwiU2hhMSIsIl93IiwiX2giLCJfYSIsIl9iIiwiX2MiLCJfZCIsIl9lIiwiX1BPT0wiLCJYIiwidyIsInJvbCIsImFkZCIsInNoYTFfZnQiLCJzaGExX2t0IiwiSCIsImNudCIsImZvcm1hdFJlZ0V4cCIsImlzU3RyaW5nIiwib2JqZWN0cyIsImlzTnVsbCIsImlzT2JqZWN0IiwibXNnIiwiaXNVbmRlZmluZWQiLCJub0RlcHJlY2F0aW9uIiwidGhyb3dEZXByZWNhdGlvbiIsInRyYWNlRGVwcmVjYXRpb24iLCJ0cmFjZSIsImRlYnVncyIsImRlYnVnRW52aXJvbiIsImRlYnVnbG9nIiwiTk9ERV9ERUJVRyIsInBpZCIsInNlZW4iLCJzdHlsaXplIiwic3R5bGl6ZU5vQ29sb3IiLCJjb2xvcnMiLCJpc0Jvb2xlYW4iLCJzaG93SGlkZGVuIiwiX2V4dGVuZCIsImN1c3RvbUluc3BlY3QiLCJzdHlsaXplV2l0aENvbG9yIiwiZm9ybWF0VmFsdWUiLCJzdHlsZVR5cGUiLCJhcnJheVRvSGFzaCIsImlkeCIsInJlY3Vyc2VUaW1lcyIsInByaW1pdGl2ZSIsImZvcm1hdFByaW1pdGl2ZSIsInZpc2libGVLZXlzIiwiaXNFcnJvciIsImZvcm1hdEVycm9yIiwiaXNSZWdFeHAiLCJpc0RhdGUiLCJicmFjZXMiLCJ0b1VUQ1N0cmluZyIsImZvcm1hdEFycmF5IiwiZm9ybWF0UHJvcGVydHkiLCJyZWR1Y2VUb1NpbmdsZVN0cmluZyIsInNpbXBsZSIsImlzTnVtYmVyIiwiZGVzYyIsIm51bUxpbmVzRXN0IiwicHJldiIsImN1ciIsImFyIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJpc1N5bWJvbCIsInJlIiwib2JqZWN0VG9TdHJpbmciLCJpc1ByaW1pdGl2ZSIsIm8iLCJwYWQiLCJtb250aHMiLCJ0aW1lc3RhbXAiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiZ2V0RGF0ZSIsImdldE1vbnRoIiwib3JpZ2luIiwiY3RvciIsInN1cGVyQ3RvciIsInN1cGVyXyIsIlRlbXBDdG9yIiwiSyIsIlNoYTI1NiIsIl9mIiwiX2ciLCJTIiwiUiIsIkNoIiwieiIsIk1haiIsIlNpZ21hMDI1NiIsIlNpZ21hMTI1NiIsIkdhbW1hMDI1NiIsIkdhbW1hMTI1NiIsIk0iLCJoIiwiVDEiLCJUMiIsIlNoYTUxMiIsIl9hbCIsIl9ibCIsIl9jbCIsIl9kbCIsIl9lbCIsIl9mbCIsIl9nbCIsIl9obCIsIlhsIiwiYWwiLCJibCIsImNsIiwiZmwiLCJnbCIsImhsIiwiV2kiLCJXaWwiLCJ4bCIsImdhbW1hMCIsImdhbW1hMGwiLCJnYW1tYTEiLCJnYW1tYTFsIiwiV2k3IiwiV2k3bCIsIldpMTYiLCJXaTE2bCIsIm1haiIsIm1hamwiLCJzaWdtYTBoIiwic2lnbWEwbCIsInNpZ21hMWgiLCJzaWdtYTFsIiwiS2kiLCJLaWwiLCJjaGwiLCJ0MWwiLCJ0MSIsInQybCIsInQyIiwid3JpdGVJbnQ2NEJFIiwiaGVscGVycyIsImNvcmVfbWQ1Iiwib2xkYSIsIm9sZGIiLCJvbGRjIiwib2xkZCIsIm1kNV9mZiIsIm1kNV9nZyIsIm1kNV9oaCIsIm1kNV9paSIsInNhZmVfYWRkIiwibWQ1X2NtbiIsImJpdF9yb2wiLCJsc3ciLCJtc3ciLCJpbnRTaXplIiwiemVyb0J1ZmZlciIsImNocnN6IiwiYmlnRW5kaWFuIiwidG9CdWZmZXIiLCJoYXNoU2l6ZSIsInJpcGVtZDE2MCIsInpsIiwienIiLCJzbCIsInNyIiwiYnl0ZXNUb1dvcmRzIiwid29yZHMiLCJ3b3Jkc1RvQnl0ZXMiLCJwcm9jZXNzQmxvY2siLCJvZmZzZXRfaSIsIk1fb2Zmc2V0X2kiLCJjciIsImRyIiwiZXIiLCJmMSIsImYyIiwiZjMiLCJmNCIsImY1Iiwicm90bCIsIm5CaXRzTGVmdCIsIm5CaXRzVG90YWwiLCJIX2kiLCJkaWdlc3RieXRlcyIsIkhtYWMiLCJfb3BhZCIsIm9wYWQiLCJfYWxnIiwiYmxvY2tzaXplIiwiaXBhZCIsIl9pcGFkIiwicGJrZGYyRXhwb3J0IiwiZXhwb3J0ZWQiLCJwYXNzd29yZCIsInNhbHQiLCJpdGVyYXRpb25zIiwia2V5bGVuIiwiaExlbiIsIlQiLCJESyIsImJsb2NrMSIsIlUiLCJkZXN0UG9zIiwiVG9kbyIsIlRvRG9MaXN0IiwicmVuZGVyVG9kb3MiLCJvblRvZ2dsZSIsIlRvRG8iLCJoYW5kbGVTdWJtaXQiLCJ0b2RvVGV4dCIsIm9uQWRkVG9kbyIsIm9uU2VhcmNoIiwibG9jYWxTdG9yYWdlIiwic3RyaW5nVG9kb3MiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDdENBLDZDQUE4USxFOzs7Ozs7QUNBOVE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDVEEsa0NBQWlDLDRHQUE0RyxtQkFBbUIsRUFBRSxtQkFBbUIsa0lBQWtJLEdBQUcseUZBQXlGLHdMQUF3TCxxRkFBcUYsWUFBWSxLQUFLLFFBQVEsR0FBRyx1RUFBdUUsc0lBQXNJLG1FQUFtRSxxREFBcUQsaUNBQWlDLEtBQUssc0lBQXNJLDZCQUE2QixNQUFNLHNCQUFzQixvRkFBb0YsNEJBQTRCLE9BQU8sd0JBQXdCLGtGQUFrRixPQUFPLG9DQUFvQywrQ0FBK0Msd0RBQXdELE9BQU8sMEJBQTBCLCtCQUErQixPQUFPLHdCQUF3QiwyREFBMkQsaUNBQWlDLFNBQVMsR0FBRyxPQUFPLDJCQUEyQix3REFBd0QsT0FBTywyQkFBMkIsMEJBQTBCLE9BQU8seUJBQXlCLDJCQUEyQixPQUFPLHNCQUFzQixpRUFBaUUsd0RBQXdELE9BQU8sdUJBQXVC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U0FBRztBQUNEQSxlQUFReDhDLEtBQUt5ckMsS0FBTCxDQUFXNHZCLFdBQVgsQ0FBUjtBQUNELE1BRkQsQ0FFRSxPQUFNMXlHLENBQU4sRUFBUSxDQUVUOztBQUVELFlBQU9uRixFQUFFMEQsT0FBRixDQUFVczFGLEtBQVYsSUFBbUJBLEtBQW5CLEdBQTBCLEVBQWpDO0FBRUQ7QUFuQmEsRUFBaEIsQyIsImZpbGUiOiIuL3B1YmxpYy9idW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIDA4ZGUyNTE1Zjg4ZDZiYjA0OGI0XG4gKiovIiwicmVxdWlyZShcIiEhL2hvbWUvc3Rld2FydC9jb2RlL3JlYWN0LXRvZG8vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9ob21lL3N0ZXdhcnQvY29kZS9yZWFjdC10b2RvL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS9ob21lL3N0ZXdhcnQvY29kZS9yZWFjdC10b2RvL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvaW5kZXguanM/e1xcXCJwcmVzZXRzXFxcIjpbXFxcInJlYWN0XFxcIixcXFwiZXMyMDE1XFxcIixcXFwic3RhZ2UtMFxcXCJdfSEvaG9tZS9zdGV3YXJ0L2NvZGUvcmVhY3QtdG9kby9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5Lm1pbi5qc1wiKSlcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zY3JpcHQtbG9hZGVyIS4vfi9qcXVlcnkvZGlzdC9qcXVlcnkubWluLmpzXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzcmMpIHtcclxuXHRpZiAodHlwZW9mIGV4ZWNTY3JpcHQgPT09IFwiZnVuY3Rpb25cIilcclxuXHRcdGV4ZWNTY3JpcHQoc3JjKTtcclxuXHRlbHNlXHJcblx0XHRldmFsLmNhbGwobnVsbCwgc3JjKTtcclxufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqOyB9O1xcblxcbi8qISBqUXVlcnkgdjIuMi40IHwgKGMpIGpRdWVyeSBGb3VuZGF0aW9uIHwganF1ZXJ5Lm9yZy9saWNlbnNlICovXFxuIWZ1bmN0aW9uIChhLCBiKSB7XFxuICBcXFwib2JqZWN0XFxcIiA9PSAodHlwZW9mIG1vZHVsZSA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YobW9kdWxlKSkgJiYgXFxcIm9iamVjdFxcXCIgPT0gX3R5cGVvZihtb2R1bGUuZXhwb3J0cykgPyBtb2R1bGUuZXhwb3J0cyA9IGEuZG9jdW1lbnQgPyBiKGEsICEwKSA6IGZ1bmN0aW9uIChhKSB7XFxuICAgIGlmICghYS5kb2N1bWVudCkgdGhyb3cgbmV3IEVycm9yKFxcXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XFxcIik7cmV0dXJuIGIoYSk7XFxuICB9IDogYihhKTtcXG59KFxcXCJ1bmRlZmluZWRcXFwiICE9IHR5cGVvZiB3aW5kb3cgPyB3aW5kb3cgOiB1bmRlZmluZWQsIGZ1bmN0aW9uIChhLCBiKSB7XFxuICB2YXIgYyA9IFtdLFxcbiAgICAgIGQgPSBhLmRvY3VtZW50LFxcbiAgICAgIGUgPSBjLnNsaWNlLFxcbiAgICAgIGYgPSBjLmNvbmNhdCxcXG4gICAgICBnID0gYy5wdXNoLFxcbiAgICAgIGggPSBjLmluZGV4T2YsXFxuICAgICAgaSA9IHt9LFxcbiAgICAgIGogPSBpLnRvU3RyaW5nLFxcbiAgICAgIGsgPSBpLmhhc093blByb3BlcnR5LFxcbiAgICAgIGwgPSB7fSxcXG4gICAgICBtID0gXFxcIjIuMi40XFxcIixcXG4gICAgICBuID0gZnVuY3Rpb24gbihhLCBiKSB7XFxuICAgIHJldHVybiBuZXcgbi5mbi5pbml0KGEsIGIpO1xcbiAgfSxcXG4gICAgICBvID0gL15bXFxcXHNcXFxcdUZFRkZcXFxceEEwXSt8W1xcXFxzXFxcXHVGRUZGXFxcXHhBMF0rJC9nLFxcbiAgICAgIHAgPSAvXi1tcy0vLFxcbiAgICAgIHEgPSAvLShbXFxcXGRhLXpdKS9naSxcXG4gICAgICByID0gZnVuY3Rpb24gcihhLCBiKSB7XFxuICAgIHJldHVybiBiLnRvVXBwZXJDYXNlKCk7XFxuICB9O24uZm4gPSBuLnByb3RvdHlwZSA9IHsganF1ZXJ5OiBtLCBjb25zdHJ1Y3Rvcjogbiwgc2VsZWN0b3I6IFxcXCJcXFwiLCBsZW5ndGg6IDAsIHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XFxuICAgICAgcmV0dXJuIGUuY2FsbCh0aGlzKTtcXG4gICAgfSwgZ2V0OiBmdW5jdGlvbiBnZXQoYSkge1xcbiAgICAgIHJldHVybiBudWxsICE9IGEgPyAwID4gYSA/IHRoaXNbYSArIHRoaXMubGVuZ3RoXSA6IHRoaXNbYV0gOiBlLmNhbGwodGhpcyk7XFxuICAgIH0sIHB1c2hTdGFjazogZnVuY3Rpb24gcHVzaFN0YWNrKGEpIHtcXG4gICAgICB2YXIgYiA9IG4ubWVyZ2UodGhpcy5jb25zdHJ1Y3RvcigpLCBhKTtyZXR1cm4gYi5wcmV2T2JqZWN0ID0gdGhpcywgYi5jb250ZXh0ID0gdGhpcy5jb250ZXh0LCBiO1xcbiAgICB9LCBlYWNoOiBmdW5jdGlvbiBlYWNoKGEpIHtcXG4gICAgICByZXR1cm4gbi5lYWNoKHRoaXMsIGEpO1xcbiAgICB9LCBtYXA6IGZ1bmN0aW9uIG1hcChhKSB7XFxuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKG4ubWFwKHRoaXMsIGZ1bmN0aW9uIChiLCBjKSB7XFxuICAgICAgICByZXR1cm4gYS5jYWxsKGIsIGMsIGIpO1xcbiAgICAgIH0pKTtcXG4gICAgfSwgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKCkge1xcbiAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xcbiAgICB9LCBmaXJzdDogZnVuY3Rpb24gZmlyc3QoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZXEoMCk7XFxuICAgIH0sIGxhc3Q6IGZ1bmN0aW9uIGxhc3QoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZXEoLTEpO1xcbiAgICB9LCBlcTogZnVuY3Rpb24gZXEoYSkge1xcbiAgICAgIHZhciBiID0gdGhpcy5sZW5ndGgsXFxuICAgICAgICAgIGMgPSArYSArICgwID4gYSA/IGIgOiAwKTtyZXR1cm4gdGhpcy5wdXNoU3RhY2soYyA+PSAwICYmIGIgPiBjID8gW3RoaXNbY11dIDogW10pO1xcbiAgICB9LCBlbmQ6IGZ1bmN0aW9uIGVuZCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcXG4gICAgfSwgcHVzaDogZywgc29ydDogYy5zb3J0LCBzcGxpY2U6IGMuc3BsaWNlIH0sIG4uZXh0ZW5kID0gbi5mbi5leHRlbmQgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBhLFxcbiAgICAgICAgYixcXG4gICAgICAgIGMsXFxuICAgICAgICBkLFxcbiAgICAgICAgZSxcXG4gICAgICAgIGYsXFxuICAgICAgICBnID0gYXJndW1lbnRzWzBdIHx8IHt9LFxcbiAgICAgICAgaCA9IDEsXFxuICAgICAgICBpID0gYXJndW1lbnRzLmxlbmd0aCxcXG4gICAgICAgIGogPSAhMTtmb3IgKFxcXCJib29sZWFuXFxcIiA9PSB0eXBlb2YgZyAmJiAoaiA9IGcsIGcgPSBhcmd1bWVudHNbaF0gfHwge30sIGgrKyksIFxcXCJvYmplY3RcXFwiID09ICh0eXBlb2YgZyA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoZykpIHx8IG4uaXNGdW5jdGlvbihnKSB8fCAoZyA9IHt9KSwgaCA9PT0gaSAmJiAoZyA9IHRoaXMsIGgtLSk7IGkgPiBoOyBoKyspIHtcXG4gICAgICBpZiAobnVsbCAhPSAoYSA9IGFyZ3VtZW50c1toXSkpIGZvciAoYiBpbiBhKSB7XFxuICAgICAgICBjID0gZ1tiXSwgZCA9IGFbYl0sIGcgIT09IGQgJiYgKGogJiYgZCAmJiAobi5pc1BsYWluT2JqZWN0KGQpIHx8IChlID0gbi5pc0FycmF5KGQpKSkgPyAoZSA/IChlID0gITEsIGYgPSBjICYmIG4uaXNBcnJheShjKSA/IGMgOiBbXSkgOiBmID0gYyAmJiBuLmlzUGxhaW5PYmplY3QoYykgPyBjIDoge30sIGdbYl0gPSBuLmV4dGVuZChqLCBmLCBkKSkgOiB2b2lkIDAgIT09IGQgJiYgKGdbYl0gPSBkKSk7XFxuICAgICAgfVxcbiAgICB9cmV0dXJuIGc7XFxuICB9LCBuLmV4dGVuZCh7IGV4cGFuZG86IFxcXCJqUXVlcnlcXFwiICsgKG0gKyBNYXRoLnJhbmRvbSgpKS5yZXBsYWNlKC9cXFxcRC9nLCBcXFwiXFxcIiksIGlzUmVhZHk6ICEwLCBlcnJvcjogZnVuY3Rpb24gZXJyb3IoYSkge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcihhKTtcXG4gICAgfSwgbm9vcDogZnVuY3Rpb24gbm9vcCgpIHt9LCBpc0Z1bmN0aW9uOiBmdW5jdGlvbiBpc0Z1bmN0aW9uKGEpIHtcXG4gICAgICByZXR1cm4gXFxcImZ1bmN0aW9uXFxcIiA9PT0gbi50eXBlKGEpO1xcbiAgICB9LCBpc0FycmF5OiBBcnJheS5pc0FycmF5LCBpc1dpbmRvdzogZnVuY3Rpb24gaXNXaW5kb3coYSkge1xcbiAgICAgIHJldHVybiBudWxsICE9IGEgJiYgYSA9PT0gYS53aW5kb3c7XFxuICAgIH0sIGlzTnVtZXJpYzogZnVuY3Rpb24gaXNOdW1lcmljKGEpIHtcXG4gICAgICB2YXIgYiA9IGEgJiYgYS50b1N0cmluZygpO3JldHVybiAhbi5pc0FycmF5KGEpICYmIGIgLSBwYXJzZUZsb2F0KGIpICsgMSA+PSAwO1xcbiAgICB9LCBpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KGEpIHtcXG4gICAgICB2YXIgYjtpZiAoXFxcIm9iamVjdFxcXCIgIT09IG4udHlwZShhKSB8fCBhLm5vZGVUeXBlIHx8IG4uaXNXaW5kb3coYSkpIHJldHVybiAhMTtpZiAoYS5jb25zdHJ1Y3RvciAmJiAhay5jYWxsKGEsIFxcXCJjb25zdHJ1Y3RvclxcXCIpICYmICFrLmNhbGwoYS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgfHwge30sIFxcXCJpc1Byb3RvdHlwZU9mXFxcIikpIHJldHVybiAhMTtmb3IgKGIgaW4gYSkge31yZXR1cm4gdm9pZCAwID09PSBiIHx8IGsuY2FsbChhLCBiKTtcXG4gICAgfSwgaXNFbXB0eU9iamVjdDogZnVuY3Rpb24gaXNFbXB0eU9iamVjdChhKSB7XFxuICAgICAgdmFyIGI7Zm9yIChiIGluIGEpIHtcXG4gICAgICAgIHJldHVybiAhMTtcXG4gICAgICB9cmV0dXJuICEwO1xcbiAgICB9LCB0eXBlOiBmdW5jdGlvbiB0eXBlKGEpIHtcXG4gICAgICByZXR1cm4gbnVsbCA9PSBhID8gYSArIFxcXCJcXFwiIDogXFxcIm9iamVjdFxcXCIgPT0gKHR5cGVvZiBhID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihhKSkgfHwgXFxcImZ1bmN0aW9uXFxcIiA9PSB0eXBlb2YgYSA/IGlbai5jYWxsKGEpXSB8fCBcXFwib2JqZWN0XFxcIiA6IHR5cGVvZiBhID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihhKTtcXG4gICAgfSwgZ2xvYmFsRXZhbDogZnVuY3Rpb24gZ2xvYmFsRXZhbChhKSB7XFxuICAgICAgdmFyIGIsXFxuICAgICAgICAgIGMgPSBldmFsO2EgPSBuLnRyaW0oYSksIGEgJiYgKDEgPT09IGEuaW5kZXhPZihcXFwidXNlIHN0cmljdFxcXCIpID8gKGIgPSBkLmNyZWF0ZUVsZW1lbnQoXFxcInNjcmlwdFxcXCIpLCBiLnRleHQgPSBhLCBkLmhlYWQuYXBwZW5kQ2hpbGQoYikucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKSkgOiBjKGEpKTtcXG4gICAgfSwgY2FtZWxDYXNlOiBmdW5jdGlvbiBjYW1lbENhc2UoYSkge1xcbiAgICAgIHJldHVybiBhLnJlcGxhY2UocCwgXFxcIm1zLVxcXCIpLnJlcGxhY2UocSwgcik7XFxuICAgIH0sIG5vZGVOYW1lOiBmdW5jdGlvbiBub2RlTmFtZShhLCBiKSB7XFxuICAgICAgcmV0dXJuIGEubm9kZU5hbWUgJiYgYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBiLnRvTG93ZXJDYXNlKCk7XFxuICAgIH0sIGVhY2g6IGZ1bmN0aW9uIGVhY2goYSwgYikge1xcbiAgICAgIHZhciBjLFxcbiAgICAgICAgICBkID0gMDtpZiAocyhhKSkge1xcbiAgICAgICAgZm9yIChjID0gYS5sZW5ndGg7IGMgPiBkOyBkKyspIHtcXG4gICAgICAgICAgaWYgKGIuY2FsbChhW2RdLCBkLCBhW2RdKSA9PT0gITEpIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBmb3IgKGQgaW4gYSkge1xcbiAgICAgICAgaWYgKGIuY2FsbChhW2RdLCBkLCBhW2RdKSA9PT0gITEpIGJyZWFrO1xcbiAgICAgIH1yZXR1cm4gYTtcXG4gICAgfSwgdHJpbTogZnVuY3Rpb24gdHJpbShhKSB7XFxuICAgICAgcmV0dXJuIG51bGwgPT0gYSA/IFxcXCJcXFwiIDogKGEgKyBcXFwiXFxcIikucmVwbGFjZShvLCBcXFwiXFxcIik7XFxuICAgIH0sIG1ha2VBcnJheTogZnVuY3Rpb24gbWFrZUFycmF5KGEsIGIpIHtcXG4gICAgICB2YXIgYyA9IGIgfHwgW107cmV0dXJuIG51bGwgIT0gYSAmJiAocyhPYmplY3QoYSkpID8gbi5tZXJnZShjLCBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYSA/IFthXSA6IGEpIDogZy5jYWxsKGMsIGEpKSwgYztcXG4gICAgfSwgaW5BcnJheTogZnVuY3Rpb24gaW5BcnJheShhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIG51bGwgPT0gYiA/IC0xIDogaC5jYWxsKGIsIGEsIGMpO1xcbiAgICB9LCBtZXJnZTogZnVuY3Rpb24gbWVyZ2UoYSwgYikge1xcbiAgICAgIGZvciAodmFyIGMgPSArYi5sZW5ndGgsIGQgPSAwLCBlID0gYS5sZW5ndGg7IGMgPiBkOyBkKyspIHtcXG4gICAgICAgIGFbZSsrXSA9IGJbZF07XFxuICAgICAgfXJldHVybiBhLmxlbmd0aCA9IGUsIGE7XFxuICAgIH0sIGdyZXA6IGZ1bmN0aW9uIGdyZXAoYSwgYiwgYykge1xcbiAgICAgIGZvciAodmFyIGQsIGUgPSBbXSwgZiA9IDAsIGcgPSBhLmxlbmd0aCwgaCA9ICFjOyBnID4gZjsgZisrKSB7XFxuICAgICAgICBkID0gIWIoYVtmXSwgZiksIGQgIT09IGggJiYgZS5wdXNoKGFbZl0pO1xcbiAgICAgIH1yZXR1cm4gZTtcXG4gICAgfSwgbWFwOiBmdW5jdGlvbiBtYXAoYSwgYiwgYykge1xcbiAgICAgIHZhciBkLFxcbiAgICAgICAgICBlLFxcbiAgICAgICAgICBnID0gMCxcXG4gICAgICAgICAgaCA9IFtdO2lmIChzKGEpKSBmb3IgKGQgPSBhLmxlbmd0aDsgZCA+IGc7IGcrKykge1xcbiAgICAgICAgZSA9IGIoYVtnXSwgZywgYyksIG51bGwgIT0gZSAmJiBoLnB1c2goZSk7XFxuICAgICAgfSBlbHNlIGZvciAoZyBpbiBhKSB7XFxuICAgICAgICBlID0gYihhW2ddLCBnLCBjKSwgbnVsbCAhPSBlICYmIGgucHVzaChlKTtcXG4gICAgICB9cmV0dXJuIGYuYXBwbHkoW10sIGgpO1xcbiAgICB9LCBndWlkOiAxLCBwcm94eTogZnVuY3Rpb24gcHJveHkoYSwgYikge1xcbiAgICAgIHZhciBjLCBkLCBmO3JldHVybiBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYiAmJiAoYyA9IGFbYl0sIGIgPSBhLCBhID0gYyksIG4uaXNGdW5jdGlvbihhKSA/IChkID0gZS5jYWxsKGFyZ3VtZW50cywgMiksIGYgPSBmdW5jdGlvbiBmKCkge1xcbiAgICAgICAgcmV0dXJuIGEuYXBwbHkoYiB8fCB0aGlzLCBkLmNvbmNhdChlLmNhbGwoYXJndW1lbnRzKSkpO1xcbiAgICAgIH0sIGYuZ3VpZCA9IGEuZ3VpZCA9IGEuZ3VpZCB8fCBuLmd1aWQrKywgZikgOiB2b2lkIDA7XFxuICAgIH0sIG5vdzogRGF0ZS5ub3csIHN1cHBvcnQ6IGwgfSksIFxcXCJmdW5jdGlvblxcXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiAobi5mbltTeW1ib2wuaXRlcmF0b3JdID0gY1tTeW1ib2wuaXRlcmF0b3JdKSwgbi5lYWNoKFxcXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFxcXCIuc3BsaXQoXFxcIiBcXFwiKSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgaVtcXFwiW29iamVjdCBcXFwiICsgYiArIFxcXCJdXFxcIl0gPSBiLnRvTG93ZXJDYXNlKCk7XFxuICB9KTtmdW5jdGlvbiBzKGEpIHtcXG4gICAgdmFyIGIgPSAhIWEgJiYgXFxcImxlbmd0aFxcXCIgaW4gYSAmJiBhLmxlbmd0aCxcXG4gICAgICAgIGMgPSBuLnR5cGUoYSk7cmV0dXJuIFxcXCJmdW5jdGlvblxcXCIgPT09IGMgfHwgbi5pc1dpbmRvdyhhKSA/ICExIDogXFxcImFycmF5XFxcIiA9PT0gYyB8fCAwID09PSBiIHx8IFxcXCJudW1iZXJcXFwiID09IHR5cGVvZiBiICYmIGIgPiAwICYmIGIgLSAxIGluIGE7XFxuICB9dmFyIHQgPSBmdW5jdGlvbiAoYSkge1xcbiAgICB2YXIgYixcXG4gICAgICAgIGMsXFxuICAgICAgICBkLFxcbiAgICAgICAgZSxcXG4gICAgICAgIGYsXFxuICAgICAgICBnLFxcbiAgICAgICAgaCxcXG4gICAgICAgIGksXFxuICAgICAgICBqLFxcbiAgICAgICAgayxcXG4gICAgICAgIGwsXFxuICAgICAgICBtLFxcbiAgICAgICAgbixcXG4gICAgICAgIG8sXFxuICAgICAgICBwLFxcbiAgICAgICAgcSxcXG4gICAgICAgIHIsXFxuICAgICAgICBzLFxcbiAgICAgICAgdCxcXG4gICAgICAgIHUgPSBcXFwic2l6emxlXFxcIiArIDEgKiBuZXcgRGF0ZSgpLFxcbiAgICAgICAgdiA9IGEuZG9jdW1lbnQsXFxuICAgICAgICB3ID0gMCxcXG4gICAgICAgIHggPSAwLFxcbiAgICAgICAgeSA9IGdhKCksXFxuICAgICAgICB6ID0gZ2EoKSxcXG4gICAgICAgIEEgPSBnYSgpLFxcbiAgICAgICAgQiA9IGZ1bmN0aW9uIEIoYSwgYikge1xcbiAgICAgIHJldHVybiBhID09PSBiICYmIChsID0gITApLCAwO1xcbiAgICB9LFxcbiAgICAgICAgQyA9IDEgPDwgMzEsXFxuICAgICAgICBEID0ge30uaGFzT3duUHJvcGVydHksXFxuICAgICAgICBFID0gW10sXFxuICAgICAgICBGID0gRS5wb3AsXFxuICAgICAgICBHID0gRS5wdXNoLFxcbiAgICAgICAgSCA9IEUucHVzaCxcXG4gICAgICAgIEkgPSBFLnNsaWNlLFxcbiAgICAgICAgSiA9IGZ1bmN0aW9uIEooYSwgYikge1xcbiAgICAgIGZvciAodmFyIGMgPSAwLCBkID0gYS5sZW5ndGg7IGQgPiBjOyBjKyspIHtcXG4gICAgICAgIGlmIChhW2NdID09PSBiKSByZXR1cm4gYztcXG4gICAgICB9cmV0dXJuIC0xO1xcbiAgICB9LFxcbiAgICAgICAgSyA9IFxcXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFxcXCIsXFxuICAgICAgICBMID0gXFxcIltcXFxcXFxcXHgyMFxcXFxcXFxcdFxcXFxcXFxcclxcXFxcXFxcblxcXFxcXFxcZl1cXFwiLFxcbiAgICAgICAgTSA9IFxcXCIoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXFxcXFxcXFx3LV18W15cXFxcXFxcXHgwMC1cXFxcXFxcXHhhMF0pK1xcXCIsXFxuICAgICAgICBOID0gXFxcIlxcXFxcXFxcW1xcXCIgKyBMICsgXFxcIiooXFxcIiArIE0gKyBcXFwiKSg/OlxcXCIgKyBMICsgXFxcIiooWypeJHwhfl0/PSlcXFwiICsgTCArIFxcXCIqKD86JygoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcXFxcXFwnXSkqKSd8XFxcXFxcXCIoKD86XFxcXFxcXFxcXFxcXFxcXC58W15cXFxcXFxcXFxcXFxcXFxcXFxcXFxcXCJdKSopXFxcXFxcXCJ8KFxcXCIgKyBNICsgXFxcIikpfClcXFwiICsgTCArIFxcXCIqXFxcXFxcXFxdXFxcIixcXG4gICAgICAgIE8gPSBcXFwiOihcXFwiICsgTSArIFxcXCIpKD86XFxcXFxcXFwoKCgnKCg/OlxcXFxcXFxcXFxcXFxcXFwufFteXFxcXFxcXFxcXFxcXFxcXCddKSopJ3xcXFxcXFxcIigoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcIl0pKilcXFxcXFxcIil8KCg/OlxcXFxcXFxcXFxcXFxcXFwufFteXFxcXFxcXFxcXFxcXFxcXCgpW1xcXFxcXFxcXV18XFxcIiArIE4gKyBcXFwiKSopfC4qKVxcXFxcXFxcKXwpXFxcIixcXG4gICAgICAgIFAgPSBuZXcgUmVnRXhwKEwgKyBcXFwiK1xcXCIsIFxcXCJnXFxcIiksXFxuICAgICAgICBRID0gbmV3IFJlZ0V4cChcXFwiXlxcXCIgKyBMICsgXFxcIit8KCg/Ol58W15cXFxcXFxcXFxcXFxcXFxcXSkoPzpcXFxcXFxcXFxcXFxcXFxcLikqKVxcXCIgKyBMICsgXFxcIiskXFxcIiwgXFxcImdcXFwiKSxcXG4gICAgICAgIFIgPSBuZXcgUmVnRXhwKFxcXCJeXFxcIiArIEwgKyBcXFwiKixcXFwiICsgTCArIFxcXCIqXFxcIiksXFxuICAgICAgICBTID0gbmV3IFJlZ0V4cChcXFwiXlxcXCIgKyBMICsgXFxcIiooWz4rfl18XFxcIiArIEwgKyBcXFwiKVxcXCIgKyBMICsgXFxcIipcXFwiKSxcXG4gICAgICAgIFQgPSBuZXcgUmVnRXhwKFxcXCI9XFxcIiArIEwgKyBcXFwiKihbXlxcXFxcXFxcXSdcXFxcXFxcIl0qPylcXFwiICsgTCArIFxcXCIqXFxcXFxcXFxdXFxcIiwgXFxcImdcXFwiKSxcXG4gICAgICAgIFUgPSBuZXcgUmVnRXhwKE8pLFxcbiAgICAgICAgViA9IG5ldyBSZWdFeHAoXFxcIl5cXFwiICsgTSArIFxcXCIkXFxcIiksXFxuICAgICAgICBXID0geyBJRDogbmV3IFJlZ0V4cChcXFwiXiMoXFxcIiArIE0gKyBcXFwiKVxcXCIpLCBDTEFTUzogbmV3IFJlZ0V4cChcXFwiXlxcXFxcXFxcLihcXFwiICsgTSArIFxcXCIpXFxcIiksIFRBRzogbmV3IFJlZ0V4cChcXFwiXihcXFwiICsgTSArIFxcXCJ8WypdKVxcXCIpLCBBVFRSOiBuZXcgUmVnRXhwKFxcXCJeXFxcIiArIE4pLCBQU0VVRE86IG5ldyBSZWdFeHAoXFxcIl5cXFwiICsgTyksIENISUxEOiBuZXcgUmVnRXhwKFxcXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcXFxcXChcXFwiICsgTCArIFxcXCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxcXFxcZCopbnwpXFxcIiArIEwgKyBcXFwiKig/OihbKy1dfClcXFwiICsgTCArIFxcXCIqKFxcXFxcXFxcZCspfCkpXFxcIiArIEwgKyBcXFwiKlxcXFxcXFxcKXwpXFxcIiwgXFxcImlcXFwiKSwgYm9vbDogbmV3IFJlZ0V4cChcXFwiXig/OlxcXCIgKyBLICsgXFxcIikkXFxcIiwgXFxcImlcXFwiKSwgbmVlZHNDb250ZXh0OiBuZXcgUmVnRXhwKFxcXCJeXFxcIiArIEwgKyBcXFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXFxcXFwoXFxcIiArIEwgKyBcXFwiKigoPzotXFxcXFxcXFxkKT9cXFxcXFxcXGQqKVxcXCIgKyBMICsgXFxcIipcXFxcXFxcXCl8KSg/PVteLV18JClcXFwiLCBcXFwiaVxcXCIpIH0sXFxuICAgICAgICBYID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcXG4gICAgICAgIFkgPSAvXmhcXFxcZCQvaSxcXG4gICAgICAgIFogPSAvXltee10rXFxcXHtcXFxccypcXFxcW25hdGl2ZSBcXFxcdy8sXFxuICAgICAgICAkID0gL14oPzojKFtcXFxcdy1dKyl8KFxcXFx3Kyl8XFxcXC4oW1xcXFx3LV0rKSkkLyxcXG4gICAgICAgIF8gPSAvWyt+XS8sXFxuICAgICAgICBhYSA9IC8nfFxcXFxcXFxcL2csXFxuICAgICAgICBiYSA9IG5ldyBSZWdFeHAoXFxcIlxcXFxcXFxcXFxcXFxcXFwoW1xcXFxcXFxcZGEtZl17MSw2fVxcXCIgKyBMICsgXFxcIj98KFxcXCIgKyBMICsgXFxcIil8LilcXFwiLCBcXFwiaWdcXFwiKSxcXG4gICAgICAgIGNhID0gZnVuY3Rpb24gY2EoYSwgYiwgYykge1xcbiAgICAgIHZhciBkID0gXFxcIjB4XFxcIiArIGIgLSA2NTUzNjtyZXR1cm4gZCAhPT0gZCB8fCBjID8gYiA6IDAgPiBkID8gU3RyaW5nLmZyb21DaGFyQ29kZShkICsgNjU1MzYpIDogU3RyaW5nLmZyb21DaGFyQ29kZShkID4+IDEwIHwgNTUyOTYsIDEwMjMgJiBkIHwgNTYzMjApO1xcbiAgICB9LFxcbiAgICAgICAgZGEgPSBmdW5jdGlvbiBkYSgpIHtcXG4gICAgICBtKCk7XFxuICAgIH07dHJ5IHtcXG4gICAgICBILmFwcGx5KEUgPSBJLmNhbGwodi5jaGlsZE5vZGVzKSwgdi5jaGlsZE5vZGVzKSwgRVt2LmNoaWxkTm9kZXMubGVuZ3RoXS5ub2RlVHlwZTtcXG4gICAgfSBjYXRjaCAoZWEpIHtcXG4gICAgICBIID0geyBhcHBseTogRS5sZW5ndGggPyBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgICBHLmFwcGx5KGEsIEkuY2FsbChiKSk7XFxuICAgICAgICB9IDogZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgICAgdmFyIGMgPSBhLmxlbmd0aCxcXG4gICAgICAgICAgICAgIGQgPSAwO3doaWxlIChhW2MrK10gPSBiW2QrK10pIHt9YS5sZW5ndGggPSBjIC0gMTtcXG4gICAgICAgIH0gfTtcXG4gICAgfWZ1bmN0aW9uIGZhKGEsIGIsIGQsIGUpIHtcXG4gICAgICB2YXIgZixcXG4gICAgICAgICAgaCxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgayxcXG4gICAgICAgICAgbCxcXG4gICAgICAgICAgbyxcXG4gICAgICAgICAgcixcXG4gICAgICAgICAgcyxcXG4gICAgICAgICAgdyA9IGIgJiYgYi5vd25lckRvY3VtZW50LFxcbiAgICAgICAgICB4ID0gYiA/IGIubm9kZVR5cGUgOiA5O2lmIChkID0gZCB8fCBbXSwgXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGEgfHwgIWEgfHwgMSAhPT0geCAmJiA5ICE9PSB4ICYmIDExICE9PSB4KSByZXR1cm4gZDtpZiAoIWUgJiYgKChiID8gYi5vd25lckRvY3VtZW50IHx8IGIgOiB2KSAhPT0gbiAmJiBtKGIpLCBiID0gYiB8fCBuLCBwKSkge1xcbiAgICAgICAgaWYgKDExICE9PSB4ICYmIChvID0gJC5leGVjKGEpKSkgaWYgKGYgPSBvWzFdKSB7XFxuICAgICAgICAgIGlmICg5ID09PSB4KSB7XFxuICAgICAgICAgICAgaWYgKCEoaiA9IGIuZ2V0RWxlbWVudEJ5SWQoZikpKSByZXR1cm4gZDtpZiAoai5pZCA9PT0gZikgcmV0dXJuIGQucHVzaChqKSwgZDtcXG4gICAgICAgICAgfSBlbHNlIGlmICh3ICYmIChqID0gdy5nZXRFbGVtZW50QnlJZChmKSkgJiYgdChiLCBqKSAmJiBqLmlkID09PSBmKSByZXR1cm4gZC5wdXNoKGopLCBkO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgaWYgKG9bMl0pIHJldHVybiBILmFwcGx5KGQsIGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYSkpLCBkO2lmICgoZiA9IG9bM10pICYmIGMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBiLmdldEVsZW1lbnRzQnlDbGFzc05hbWUpIHJldHVybiBILmFwcGx5KGQsIGIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShmKSksIGQ7XFxuICAgICAgICB9aWYgKGMucXNhICYmICFBW2EgKyBcXFwiIFxcXCJdICYmICghcSB8fCAhcS50ZXN0KGEpKSkge1xcbiAgICAgICAgICBpZiAoMSAhPT0geCkgdyA9IGIsIHMgPSBhO2Vsc2UgaWYgKFxcXCJvYmplY3RcXFwiICE9PSBiLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcXG4gICAgICAgICAgICAoayA9IGIuZ2V0QXR0cmlidXRlKFxcXCJpZFxcXCIpKSA/IGsgPSBrLnJlcGxhY2UoYWEsIFxcXCJcXFxcXFxcXCQmXFxcIikgOiBiLnNldEF0dHJpYnV0ZShcXFwiaWRcXFwiLCBrID0gdSksIHIgPSBnKGEpLCBoID0gci5sZW5ndGgsIGwgPSBWLnRlc3QoaykgPyBcXFwiI1xcXCIgKyBrIDogXFxcIltpZD0nXFxcIiArIGsgKyBcXFwiJ11cXFwiO3doaWxlIChoLS0pIHtcXG4gICAgICAgICAgICAgIHJbaF0gPSBsICsgXFxcIiBcXFwiICsgcWEocltoXSk7XFxuICAgICAgICAgICAgfXMgPSByLmpvaW4oXFxcIixcXFwiKSwgdyA9IF8udGVzdChhKSAmJiBvYShiLnBhcmVudE5vZGUpIHx8IGI7XFxuICAgICAgICAgIH1pZiAocykgdHJ5IHtcXG4gICAgICAgICAgICByZXR1cm4gSC5hcHBseShkLCB3LnF1ZXJ5U2VsZWN0b3JBbGwocykpLCBkO1xcbiAgICAgICAgICB9IGNhdGNoICh5KSB7fSBmaW5hbGx5IHtcXG4gICAgICAgICAgICBrID09PSB1ICYmIGIucmVtb3ZlQXR0cmlidXRlKFxcXCJpZFxcXCIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfXJldHVybiBpKGEucmVwbGFjZShRLCBcXFwiJDFcXFwiKSwgYiwgZCwgZSk7XFxuICAgIH1mdW5jdGlvbiBnYSgpIHtcXG4gICAgICB2YXIgYSA9IFtdO2Z1bmN0aW9uIGIoYywgZSkge1xcbiAgICAgICAgcmV0dXJuIGEucHVzaChjICsgXFxcIiBcXFwiKSA+IGQuY2FjaGVMZW5ndGggJiYgZGVsZXRlIGJbYS5zaGlmdCgpXSwgYltjICsgXFxcIiBcXFwiXSA9IGU7XFxuICAgICAgfXJldHVybiBiO1xcbiAgICB9ZnVuY3Rpb24gaGEoYSkge1xcbiAgICAgIHJldHVybiBhW3VdID0gITAsIGE7XFxuICAgIH1mdW5jdGlvbiBpYShhKSB7XFxuICAgICAgdmFyIGIgPSBuLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO3RyeSB7XFxuICAgICAgICByZXR1cm4gISFhKGIpO1xcbiAgICAgIH0gY2F0Y2ggKGMpIHtcXG4gICAgICAgIHJldHVybiAhMTtcXG4gICAgICB9IGZpbmFsbHkge1xcbiAgICAgICAgYi5wYXJlbnROb2RlICYmIGIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKSwgYiA9IG51bGw7XFxuICAgICAgfVxcbiAgICB9ZnVuY3Rpb24gamEoYSwgYikge1xcbiAgICAgIHZhciBjID0gYS5zcGxpdChcXFwifFxcXCIpLFxcbiAgICAgICAgICBlID0gYy5sZW5ndGg7d2hpbGUgKGUtLSkge1xcbiAgICAgICAgZC5hdHRySGFuZGxlW2NbZV1dID0gYjtcXG4gICAgICB9XFxuICAgIH1mdW5jdGlvbiBrYShhLCBiKSB7XFxuICAgICAgdmFyIGMgPSBiICYmIGEsXFxuICAgICAgICAgIGQgPSBjICYmIDEgPT09IGEubm9kZVR5cGUgJiYgMSA9PT0gYi5ub2RlVHlwZSAmJiAofmIuc291cmNlSW5kZXggfHwgQykgLSAofmEuc291cmNlSW5kZXggfHwgQyk7aWYgKGQpIHJldHVybiBkO2lmIChjKSB3aGlsZSAoYyA9IGMubmV4dFNpYmxpbmcpIHtcXG4gICAgICAgIGlmIChjID09PSBiKSByZXR1cm4gLTE7XFxuICAgICAgfXJldHVybiBhID8gMSA6IC0xO1xcbiAgICB9ZnVuY3Rpb24gbGEoYSkge1xcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYikge1xcbiAgICAgICAgdmFyIGMgPSBiLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIFxcXCJpbnB1dFxcXCIgPT09IGMgJiYgYi50eXBlID09PSBhO1xcbiAgICAgIH07XFxuICAgIH1mdW5jdGlvbiBtYShhKSB7XFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICB2YXIgYyA9IGIubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gKFxcXCJpbnB1dFxcXCIgPT09IGMgfHwgXFxcImJ1dHRvblxcXCIgPT09IGMpICYmIGIudHlwZSA9PT0gYTtcXG4gICAgICB9O1xcbiAgICB9ZnVuY3Rpb24gbmEoYSkge1xcbiAgICAgIHJldHVybiBoYShmdW5jdGlvbiAoYikge1xcbiAgICAgICAgcmV0dXJuIGIgPSArYiwgaGEoZnVuY3Rpb24gKGMsIGQpIHtcXG4gICAgICAgICAgdmFyIGUsXFxuICAgICAgICAgICAgICBmID0gYShbXSwgYy5sZW5ndGgsIGIpLFxcbiAgICAgICAgICAgICAgZyA9IGYubGVuZ3RoO3doaWxlIChnLS0pIHtcXG4gICAgICAgICAgICBjW2UgPSBmW2ddXSAmJiAoY1tlXSA9ICEoZFtlXSA9IGNbZV0pKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgIH1mdW5jdGlvbiBvYShhKSB7XFxuICAgICAgcmV0dXJuIGEgJiYgXFxcInVuZGVmaW5lZFxcXCIgIT0gdHlwZW9mIGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUgJiYgYTtcXG4gICAgfWMgPSBmYS5zdXBwb3J0ID0ge30sIGYgPSBmYS5pc1hNTCA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgdmFyIGIgPSBhICYmIChhLm93bmVyRG9jdW1lbnQgfHwgYSkuZG9jdW1lbnRFbGVtZW50O3JldHVybiBiID8gXFxcIkhUTUxcXFwiICE9PSBiLm5vZGVOYW1lIDogITE7XFxuICAgIH0sIG0gPSBmYS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgdmFyIGIsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIGcgPSBhID8gYS5vd25lckRvY3VtZW50IHx8IGEgOiB2O3JldHVybiBnICE9PSBuICYmIDkgPT09IGcubm9kZVR5cGUgJiYgZy5kb2N1bWVudEVsZW1lbnQgPyAobiA9IGcsIG8gPSBuLmRvY3VtZW50RWxlbWVudCwgcCA9ICFmKG4pLCAoZSA9IG4uZGVmYXVsdFZpZXcpICYmIGUudG9wICE9PSBlICYmIChlLmFkZEV2ZW50TGlzdGVuZXIgPyBlLmFkZEV2ZW50TGlzdGVuZXIoXFxcInVubG9hZFxcXCIsIGRhLCAhMSkgOiBlLmF0dGFjaEV2ZW50ICYmIGUuYXR0YWNoRXZlbnQoXFxcIm9udW5sb2FkXFxcIiwgZGEpKSwgYy5hdHRyaWJ1dGVzID0gaWEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHJldHVybiBhLmNsYXNzTmFtZSA9IFxcXCJpXFxcIiwgIWEuZ2V0QXR0cmlidXRlKFxcXCJjbGFzc05hbWVcXFwiKTtcXG4gICAgICB9KSwgYy5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGlhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICByZXR1cm4gYS5hcHBlbmRDaGlsZChuLmNyZWF0ZUNvbW1lbnQoXFxcIlxcXCIpKSwgIWEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcIipcXFwiKS5sZW5ndGg7XFxuICAgICAgfSksIGMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IFoudGVzdChuLmdldEVsZW1lbnRzQnlDbGFzc05hbWUpLCBjLmdldEJ5SWQgPSBpYShmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgcmV0dXJuIG8uYXBwZW5kQ2hpbGQoYSkuaWQgPSB1LCAhbi5nZXRFbGVtZW50c0J5TmFtZSB8fCAhbi5nZXRFbGVtZW50c0J5TmFtZSh1KS5sZW5ndGg7XFxuICAgICAgfSksIGMuZ2V0QnlJZCA/IChkLmZpbmQuSUQgPSBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgaWYgKFxcXCJ1bmRlZmluZWRcXFwiICE9IHR5cGVvZiBiLmdldEVsZW1lbnRCeUlkICYmIHApIHtcXG4gICAgICAgICAgdmFyIGMgPSBiLmdldEVsZW1lbnRCeUlkKGEpO3JldHVybiBjID8gW2NdIDogW107XFxuICAgICAgICB9XFxuICAgICAgfSwgZC5maWx0ZXIuSUQgPSBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgdmFyIGIgPSBhLnJlcGxhY2UoYmEsIGNhKTtyZXR1cm4gZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIGEuZ2V0QXR0cmlidXRlKFxcXCJpZFxcXCIpID09PSBiO1xcbiAgICAgICAgfTtcXG4gICAgICB9KSA6IChkZWxldGUgZC5maW5kLklELCBkLmZpbHRlci5JRCA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICB2YXIgYiA9IGEucmVwbGFjZShiYSwgY2EpO3JldHVybiBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICB2YXIgYyA9IFxcXCJ1bmRlZmluZWRcXFwiICE9IHR5cGVvZiBhLmdldEF0dHJpYnV0ZU5vZGUgJiYgYS5nZXRBdHRyaWJ1dGVOb2RlKFxcXCJpZFxcXCIpO3JldHVybiBjICYmIGMudmFsdWUgPT09IGI7XFxuICAgICAgICB9O1xcbiAgICAgIH0pLCBkLmZpbmQuVEFHID0gYy5nZXRFbGVtZW50c0J5VGFnTmFtZSA/IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICByZXR1cm4gXFxcInVuZGVmaW5lZFxcXCIgIT0gdHlwZW9mIGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPyBiLmdldEVsZW1lbnRzQnlUYWdOYW1lKGEpIDogYy5xc2EgPyBiLnF1ZXJ5U2VsZWN0b3JBbGwoYSkgOiB2b2lkIDA7XFxuICAgICAgfSA6IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICB2YXIgYyxcXG4gICAgICAgICAgICBkID0gW10sXFxuICAgICAgICAgICAgZSA9IDAsXFxuICAgICAgICAgICAgZiA9IGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYSk7aWYgKFxcXCIqXFxcIiA9PT0gYSkge1xcbiAgICAgICAgICB3aGlsZSAoYyA9IGZbZSsrXSkge1xcbiAgICAgICAgICAgIDEgPT09IGMubm9kZVR5cGUgJiYgZC5wdXNoKGMpO1xcbiAgICAgICAgICB9cmV0dXJuIGQ7XFxuICAgICAgICB9cmV0dXJuIGY7XFxuICAgICAgfSwgZC5maW5kLkNMQVNTID0gYy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICByZXR1cm4gXFxcInVuZGVmaW5lZFxcXCIgIT0gdHlwZW9mIGIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBwID8gYi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGEpIDogdm9pZCAwO1xcbiAgICAgIH0sIHIgPSBbXSwgcSA9IFtdLCAoYy5xc2EgPSBaLnRlc3Qobi5xdWVyeVNlbGVjdG9yQWxsKSkgJiYgKGlhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICBvLmFwcGVuZENoaWxkKGEpLmlubmVySFRNTCA9IFxcXCI8YSBpZD0nXFxcIiArIHUgKyBcXFwiJz48L2E+PHNlbGVjdCBpZD0nXFxcIiArIHUgKyBcXFwiLVxcXFxyXFxcXFxcXFwnIG1zYWxsb3djYXB0dXJlPScnPjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XFxcIiwgYS5xdWVyeVNlbGVjdG9yQWxsKFxcXCJbbXNhbGxvd2NhcHR1cmVePScnXVxcXCIpLmxlbmd0aCAmJiBxLnB1c2goXFxcIlsqXiRdPVxcXCIgKyBMICsgXFxcIiooPzonJ3xcXFxcXFxcIlxcXFxcXFwiKVxcXCIpLCBhLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIltzZWxlY3RlZF1cXFwiKS5sZW5ndGggfHwgcS5wdXNoKFxcXCJcXFxcXFxcXFtcXFwiICsgTCArIFxcXCIqKD86dmFsdWV8XFxcIiArIEsgKyBcXFwiKVxcXCIpLCBhLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIltpZH49XFxcIiArIHUgKyBcXFwiLV1cXFwiKS5sZW5ndGggfHwgcS5wdXNoKFxcXCJ+PVxcXCIpLCBhLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIjpjaGVja2VkXFxcIikubGVuZ3RoIHx8IHEucHVzaChcXFwiOmNoZWNrZWRcXFwiKSwgYS5xdWVyeVNlbGVjdG9yQWxsKFxcXCJhI1xcXCIgKyB1ICsgXFxcIisqXFxcIikubGVuZ3RoIHx8IHEucHVzaChcXFwiLiMuK1srfl1cXFwiKTtcXG4gICAgICB9KSwgaWEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHZhciBiID0gbi5jcmVhdGVFbGVtZW50KFxcXCJpbnB1dFxcXCIpO2Iuc2V0QXR0cmlidXRlKFxcXCJ0eXBlXFxcIiwgXFxcImhpZGRlblxcXCIpLCBhLmFwcGVuZENoaWxkKGIpLnNldEF0dHJpYnV0ZShcXFwibmFtZVxcXCIsIFxcXCJEXFxcIiksIGEucXVlcnlTZWxlY3RvckFsbChcXFwiW25hbWU9ZF1cXFwiKS5sZW5ndGggJiYgcS5wdXNoKFxcXCJuYW1lXFxcIiArIEwgKyBcXFwiKlsqXiR8IX5dPz1cXFwiKSwgYS5xdWVyeVNlbGVjdG9yQWxsKFxcXCI6ZW5hYmxlZFxcXCIpLmxlbmd0aCB8fCBxLnB1c2goXFxcIjplbmFibGVkXFxcIiwgXFxcIjpkaXNhYmxlZFxcXCIpLCBhLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIiosOnhcXFwiKSwgcS5wdXNoKFxcXCIsLio6XFxcIik7XFxuICAgICAgfSkpLCAoYy5tYXRjaGVzU2VsZWN0b3IgPSBaLnRlc3QocyA9IG8ubWF0Y2hlcyB8fCBvLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBvLm1vek1hdGNoZXNTZWxlY3RvciB8fCBvLm9NYXRjaGVzU2VsZWN0b3IgfHwgby5tc01hdGNoZXNTZWxlY3RvcikpICYmIGlhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICBjLmRpc2Nvbm5lY3RlZE1hdGNoID0gcy5jYWxsKGEsIFxcXCJkaXZcXFwiKSwgcy5jYWxsKGEsIFxcXCJbcyE9JyddOnhcXFwiKSwgci5wdXNoKFxcXCIhPVxcXCIsIE8pO1xcbiAgICAgIH0pLCBxID0gcS5sZW5ndGggJiYgbmV3IFJlZ0V4cChxLmpvaW4oXFxcInxcXFwiKSksIHIgPSByLmxlbmd0aCAmJiBuZXcgUmVnRXhwKHIuam9pbihcXFwifFxcXCIpKSwgYiA9IFoudGVzdChvLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSwgdCA9IGIgfHwgWi50ZXN0KG8uY29udGFpbnMpID8gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgIHZhciBjID0gOSA9PT0gYS5ub2RlVHlwZSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcXG4gICAgICAgICAgICBkID0gYiAmJiBiLnBhcmVudE5vZGU7cmV0dXJuIGEgPT09IGQgfHwgISghZCB8fCAxICE9PSBkLm5vZGVUeXBlIHx8ICEoYy5jb250YWlucyA/IGMuY29udGFpbnMoZCkgOiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIDE2ICYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihkKSkpO1xcbiAgICAgIH0gOiBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgaWYgKGIpIHdoaWxlIChiID0gYi5wYXJlbnROb2RlKSB7XFxuICAgICAgICAgIGlmIChiID09PSBhKSByZXR1cm4gITA7XFxuICAgICAgICB9cmV0dXJuICExO1xcbiAgICAgIH0sIEIgPSBiID8gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgIGlmIChhID09PSBiKSByZXR1cm4gbCA9ICEwLCAwO3ZhciBkID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtyZXR1cm4gZCA/IGQgOiAoZCA9IChhLm93bmVyRG9jdW1lbnQgfHwgYSkgPT09IChiLm93bmVyRG9jdW1lbnQgfHwgYikgPyBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpIDogMSwgMSAmIGQgfHwgIWMuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYSkgPT09IGQgPyBhID09PSBuIHx8IGEub3duZXJEb2N1bWVudCA9PT0gdiAmJiB0KHYsIGEpID8gLTEgOiBiID09PSBuIHx8IGIub3duZXJEb2N1bWVudCA9PT0gdiAmJiB0KHYsIGIpID8gMSA6IGsgPyBKKGssIGEpIC0gSihrLCBiKSA6IDAgOiA0ICYgZCA/IC0xIDogMSk7XFxuICAgICAgfSA6IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICBpZiAoYSA9PT0gYikgcmV0dXJuIGwgPSAhMCwgMDt2YXIgYyxcXG4gICAgICAgICAgICBkID0gMCxcXG4gICAgICAgICAgICBlID0gYS5wYXJlbnROb2RlLFxcbiAgICAgICAgICAgIGYgPSBiLnBhcmVudE5vZGUsXFxuICAgICAgICAgICAgZyA9IFthXSxcXG4gICAgICAgICAgICBoID0gW2JdO2lmICghZSB8fCAhZikgcmV0dXJuIGEgPT09IG4gPyAtMSA6IGIgPT09IG4gPyAxIDogZSA/IC0xIDogZiA/IDEgOiBrID8gSihrLCBhKSAtIEooaywgYikgOiAwO2lmIChlID09PSBmKSByZXR1cm4ga2EoYSwgYik7YyA9IGE7d2hpbGUgKGMgPSBjLnBhcmVudE5vZGUpIHtcXG4gICAgICAgICAgZy51bnNoaWZ0KGMpO1xcbiAgICAgICAgfWMgPSBiO3doaWxlIChjID0gYy5wYXJlbnROb2RlKSB7XFxuICAgICAgICAgIGgudW5zaGlmdChjKTtcXG4gICAgICAgIH13aGlsZSAoZ1tkXSA9PT0gaFtkXSkge1xcbiAgICAgICAgICBkKys7XFxuICAgICAgICB9cmV0dXJuIGQgPyBrYShnW2RdLCBoW2RdKSA6IGdbZF0gPT09IHYgPyAtMSA6IGhbZF0gPT09IHYgPyAxIDogMDtcXG4gICAgICB9LCBuKSA6IG47XFxuICAgIH0sIGZhLm1hdGNoZXMgPSBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgIHJldHVybiBmYShhLCBudWxsLCBudWxsLCBiKTtcXG4gICAgfSwgZmEubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICBpZiAoKGEub3duZXJEb2N1bWVudCB8fCBhKSAhPT0gbiAmJiBtKGEpLCBiID0gYi5yZXBsYWNlKFQsIFxcXCI9JyQxJ11cXFwiKSwgYy5tYXRjaGVzU2VsZWN0b3IgJiYgcCAmJiAhQVtiICsgXFxcIiBcXFwiXSAmJiAoIXIgfHwgIXIudGVzdChiKSkgJiYgKCFxIHx8ICFxLnRlc3QoYikpKSB0cnkge1xcbiAgICAgICAgdmFyIGQgPSBzLmNhbGwoYSwgYik7aWYgKGQgfHwgYy5kaXNjb25uZWN0ZWRNYXRjaCB8fCBhLmRvY3VtZW50ICYmIDExICE9PSBhLmRvY3VtZW50Lm5vZGVUeXBlKSByZXR1cm4gZDtcXG4gICAgICB9IGNhdGNoIChlKSB7fXJldHVybiBmYShiLCBuLCBudWxsLCBbYV0pLmxlbmd0aCA+IDA7XFxuICAgIH0sIGZhLmNvbnRhaW5zID0gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICByZXR1cm4gKGEub3duZXJEb2N1bWVudCB8fCBhKSAhPT0gbiAmJiBtKGEpLCB0KGEsIGIpO1xcbiAgICB9LCBmYS5hdHRyID0gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAoYS5vd25lckRvY3VtZW50IHx8IGEpICE9PSBuICYmIG0oYSk7dmFyIGUgPSBkLmF0dHJIYW5kbGVbYi50b0xvd2VyQ2FzZSgpXSxcXG4gICAgICAgICAgZiA9IGUgJiYgRC5jYWxsKGQuYXR0ckhhbmRsZSwgYi50b0xvd2VyQ2FzZSgpKSA/IGUoYSwgYiwgIXApIDogdm9pZCAwO3JldHVybiB2b2lkIDAgIT09IGYgPyBmIDogYy5hdHRyaWJ1dGVzIHx8ICFwID8gYS5nZXRBdHRyaWJ1dGUoYikgOiAoZiA9IGEuZ2V0QXR0cmlidXRlTm9kZShiKSkgJiYgZi5zcGVjaWZpZWQgPyBmLnZhbHVlIDogbnVsbDtcXG4gICAgfSwgZmEuZXJyb3IgPSBmdW5jdGlvbiAoYSkge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXFxcIiArIGEpO1xcbiAgICB9LCBmYS51bmlxdWVTb3J0ID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgICB2YXIgYixcXG4gICAgICAgICAgZCA9IFtdLFxcbiAgICAgICAgICBlID0gMCxcXG4gICAgICAgICAgZiA9IDA7aWYgKGwgPSAhYy5kZXRlY3REdXBsaWNhdGVzLCBrID0gIWMuc29ydFN0YWJsZSAmJiBhLnNsaWNlKDApLCBhLnNvcnQoQiksIGwpIHtcXG4gICAgICAgIHdoaWxlIChiID0gYVtmKytdKSB7XFxuICAgICAgICAgIGIgPT09IGFbZl0gJiYgKGUgPSBkLnB1c2goZikpO1xcbiAgICAgICAgfXdoaWxlIChlLS0pIHtcXG4gICAgICAgICAgYS5zcGxpY2UoZFtlXSwgMSk7XFxuICAgICAgICB9XFxuICAgICAgfXJldHVybiBrID0gbnVsbCwgYTtcXG4gICAgfSwgZSA9IGZhLmdldFRleHQgPSBmdW5jdGlvbiAoYSkge1xcbiAgICAgIHZhciBiLFxcbiAgICAgICAgICBjID0gXFxcIlxcXCIsXFxuICAgICAgICAgIGQgPSAwLFxcbiAgICAgICAgICBmID0gYS5ub2RlVHlwZTtpZiAoZikge1xcbiAgICAgICAgaWYgKDEgPT09IGYgfHwgOSA9PT0gZiB8fCAxMSA9PT0gZikge1xcbiAgICAgICAgICBpZiAoXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGEudGV4dENvbnRlbnQpIHJldHVybiBhLnRleHRDb250ZW50O2ZvciAoYSA9IGEuZmlyc3RDaGlsZDsgYTsgYSA9IGEubmV4dFNpYmxpbmcpIHtcXG4gICAgICAgICAgICBjICs9IGUoYSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSBpZiAoMyA9PT0gZiB8fCA0ID09PSBmKSByZXR1cm4gYS5ub2RlVmFsdWU7XFxuICAgICAgfSBlbHNlIHdoaWxlIChiID0gYVtkKytdKSB7XFxuICAgICAgICBjICs9IGUoYik7XFxuICAgICAgfXJldHVybiBjO1xcbiAgICB9LCBkID0gZmEuc2VsZWN0b3JzID0geyBjYWNoZUxlbmd0aDogNTAsIGNyZWF0ZVBzZXVkbzogaGEsIG1hdGNoOiBXLCBhdHRySGFuZGxlOiB7fSwgZmluZDoge30sIHJlbGF0aXZlOiB7IFxcXCI+XFxcIjogeyBkaXI6IFxcXCJwYXJlbnROb2RlXFxcIiwgZmlyc3Q6ICEwIH0sIFxcXCIgXFxcIjogeyBkaXI6IFxcXCJwYXJlbnROb2RlXFxcIiB9LCBcXFwiK1xcXCI6IHsgZGlyOiBcXFwicHJldmlvdXNTaWJsaW5nXFxcIiwgZmlyc3Q6ICEwIH0sIFxcXCJ+XFxcIjogeyBkaXI6IFxcXCJwcmV2aW91c1NpYmxpbmdcXFwiIH0gfSwgcHJlRmlsdGVyOiB7IEFUVFI6IGZ1bmN0aW9uIEFUVFIoYSkge1xcbiAgICAgICAgICByZXR1cm4gYVsxXSA9IGFbMV0ucmVwbGFjZShiYSwgY2EpLCBhWzNdID0gKGFbM10gfHwgYVs0XSB8fCBhWzVdIHx8IFxcXCJcXFwiKS5yZXBsYWNlKGJhLCBjYSksIFxcXCJ+PVxcXCIgPT09IGFbMl0gJiYgKGFbM10gPSBcXFwiIFxcXCIgKyBhWzNdICsgXFxcIiBcXFwiKSwgYS5zbGljZSgwLCA0KTtcXG4gICAgICAgIH0sIENISUxEOiBmdW5jdGlvbiBDSElMRChhKSB7XFxuICAgICAgICAgIHJldHVybiBhWzFdID0gYVsxXS50b0xvd2VyQ2FzZSgpLCBcXFwibnRoXFxcIiA9PT0gYVsxXS5zbGljZSgwLCAzKSA/IChhWzNdIHx8IGZhLmVycm9yKGFbMF0pLCBhWzRdID0gKyhhWzRdID8gYVs1XSArIChhWzZdIHx8IDEpIDogMiAqIChcXFwiZXZlblxcXCIgPT09IGFbM10gfHwgXFxcIm9kZFxcXCIgPT09IGFbM10pKSwgYVs1XSA9ICsoYVs3XSArIGFbOF0gfHwgXFxcIm9kZFxcXCIgPT09IGFbM10pKSA6IGFbM10gJiYgZmEuZXJyb3IoYVswXSksIGE7XFxuICAgICAgICB9LCBQU0VVRE86IGZ1bmN0aW9uIFBTRVVETyhhKSB7XFxuICAgICAgICAgIHZhciBiLFxcbiAgICAgICAgICAgICAgYyA9ICFhWzZdICYmIGFbMl07cmV0dXJuIFcuQ0hJTEQudGVzdChhWzBdKSA/IG51bGwgOiAoYVszXSA/IGFbMl0gPSBhWzRdIHx8IGFbNV0gfHwgXFxcIlxcXCIgOiBjICYmIFUudGVzdChjKSAmJiAoYiA9IGcoYywgITApKSAmJiAoYiA9IGMuaW5kZXhPZihcXFwiKVxcXCIsIGMubGVuZ3RoIC0gYikgLSBjLmxlbmd0aCkgJiYgKGFbMF0gPSBhWzBdLnNsaWNlKDAsIGIpLCBhWzJdID0gYy5zbGljZSgwLCBiKSksIGEuc2xpY2UoMCwgMykpO1xcbiAgICAgICAgfSB9LCBmaWx0ZXI6IHsgVEFHOiBmdW5jdGlvbiBUQUcoYSkge1xcbiAgICAgICAgICB2YXIgYiA9IGEucmVwbGFjZShiYSwgY2EpLnRvTG93ZXJDYXNlKCk7cmV0dXJuIFxcXCIqXFxcIiA9PT0gYSA/IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICByZXR1cm4gITA7XFxuICAgICAgICAgIH0gOiBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICAgIHJldHVybiBhLm5vZGVOYW1lICYmIGEubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gYjtcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH0sIENMQVNTOiBmdW5jdGlvbiBDTEFTUyhhKSB7XFxuICAgICAgICAgIHZhciBiID0geVthICsgXFxcIiBcXFwiXTtyZXR1cm4gYiB8fCAoYiA9IG5ldyBSZWdFeHAoXFxcIihefFxcXCIgKyBMICsgXFxcIilcXFwiICsgYSArIFxcXCIoXFxcIiArIEwgKyBcXFwifCQpXFxcIikpICYmIHkoYSwgZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgICByZXR1cm4gYi50ZXN0KFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBhLmNsYXNzTmFtZSAmJiBhLmNsYXNzTmFtZSB8fCBcXFwidW5kZWZpbmVkXFxcIiAhPSB0eXBlb2YgYS5nZXRBdHRyaWJ1dGUgJiYgYS5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIikgfHwgXFxcIlxcXCIpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0sIEFUVFI6IGZ1bmN0aW9uIEFUVFIoYSwgYiwgYykge1xcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcXG4gICAgICAgICAgICB2YXIgZSA9IGZhLmF0dHIoZCwgYSk7cmV0dXJuIG51bGwgPT0gZSA/IFxcXCIhPVxcXCIgPT09IGIgOiBiID8gKGUgKz0gXFxcIlxcXCIsIFxcXCI9XFxcIiA9PT0gYiA/IGUgPT09IGMgOiBcXFwiIT1cXFwiID09PSBiID8gZSAhPT0gYyA6IFxcXCJePVxcXCIgPT09IGIgPyBjICYmIDAgPT09IGUuaW5kZXhPZihjKSA6IFxcXCIqPVxcXCIgPT09IGIgPyBjICYmIGUuaW5kZXhPZihjKSA+IC0xIDogXFxcIiQ9XFxcIiA9PT0gYiA/IGMgJiYgZS5zbGljZSgtYy5sZW5ndGgpID09PSBjIDogXFxcIn49XFxcIiA9PT0gYiA/IChcXFwiIFxcXCIgKyBlLnJlcGxhY2UoUCwgXFxcIiBcXFwiKSArIFxcXCIgXFxcIikuaW5kZXhPZihjKSA+IC0xIDogXFxcInw9XFxcIiA9PT0gYiA/IGUgPT09IGMgfHwgZS5zbGljZSgwLCBjLmxlbmd0aCArIDEpID09PSBjICsgXFxcIi1cXFwiIDogITEpIDogITA7XFxuICAgICAgICAgIH07XFxuICAgICAgICB9LCBDSElMRDogZnVuY3Rpb24gQ0hJTEQoYSwgYiwgYywgZCwgZSkge1xcbiAgICAgICAgICB2YXIgZiA9IFxcXCJudGhcXFwiICE9PSBhLnNsaWNlKDAsIDMpLFxcbiAgICAgICAgICAgICAgZyA9IFxcXCJsYXN0XFxcIiAhPT0gYS5zbGljZSgtNCksXFxuICAgICAgICAgICAgICBoID0gXFxcIm9mLXR5cGVcXFwiID09PSBiO3JldHVybiAxID09PSBkICYmIDAgPT09IGUgPyBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICAgIHJldHVybiAhIWEucGFyZW50Tm9kZTtcXG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChiLCBjLCBpKSB7XFxuICAgICAgICAgICAgdmFyIGosXFxuICAgICAgICAgICAgICAgIGssXFxuICAgICAgICAgICAgICAgIGwsXFxuICAgICAgICAgICAgICAgIG0sXFxuICAgICAgICAgICAgICAgIG4sXFxuICAgICAgICAgICAgICAgIG8sXFxuICAgICAgICAgICAgICAgIHAgPSBmICE9PSBnID8gXFxcIm5leHRTaWJsaW5nXFxcIiA6IFxcXCJwcmV2aW91c1NpYmxpbmdcXFwiLFxcbiAgICAgICAgICAgICAgICBxID0gYi5wYXJlbnROb2RlLFxcbiAgICAgICAgICAgICAgICByID0gaCAmJiBiLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXFxuICAgICAgICAgICAgICAgIHMgPSAhaSAmJiAhaCxcXG4gICAgICAgICAgICAgICAgdCA9ICExO2lmIChxKSB7XFxuICAgICAgICAgICAgICBpZiAoZikge1xcbiAgICAgICAgICAgICAgICB3aGlsZSAocCkge1xcbiAgICAgICAgICAgICAgICAgIG0gPSBiO3doaWxlIChtID0gbVtwXSkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGggPyBtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHIgOiAxID09PSBtLm5vZGVUeXBlKSByZXR1cm4gITE7XFxuICAgICAgICAgICAgICAgICAgfW8gPSBwID0gXFxcIm9ubHlcXFwiID09PSBhICYmICFvICYmIFxcXCJuZXh0U2libGluZ1xcXCI7XFxuICAgICAgICAgICAgICAgIH1yZXR1cm4gITA7XFxuICAgICAgICAgICAgICB9aWYgKG8gPSBbZyA/IHEuZmlyc3RDaGlsZCA6IHEubGFzdENoaWxkXSwgZyAmJiBzKSB7XFxuICAgICAgICAgICAgICAgIG0gPSBxLCBsID0gbVt1XSB8fCAobVt1XSA9IHt9KSwgayA9IGxbbS51bmlxdWVJRF0gfHwgKGxbbS51bmlxdWVJRF0gPSB7fSksIGogPSBrW2FdIHx8IFtdLCBuID0galswXSA9PT0gdyAmJiBqWzFdLCB0ID0gbiAmJiBqWzJdLCBtID0gbiAmJiBxLmNoaWxkTm9kZXNbbl07d2hpbGUgKG0gPSArK24gJiYgbSAmJiBtW3BdIHx8ICh0ID0gbiA9IDApIHx8IG8ucG9wKCkpIHtcXG4gICAgICAgICAgICAgICAgICBpZiAoMSA9PT0gbS5ub2RlVHlwZSAmJiArK3QgJiYgbSA9PT0gYikge1xcbiAgICAgICAgICAgICAgICAgICAga1thXSA9IFt3LCBuLCB0XTticmVhaztcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocyAmJiAobSA9IGIsIGwgPSBtW3VdIHx8IChtW3VdID0ge30pLCBrID0gbFttLnVuaXF1ZUlEXSB8fCAobFttLnVuaXF1ZUlEXSA9IHt9KSwgaiA9IGtbYV0gfHwgW10sIG4gPSBqWzBdID09PSB3ICYmIGpbMV0sIHQgPSBuKSwgdCA9PT0gITEpIHdoaWxlIChtID0gKytuICYmIG0gJiYgbVtwXSB8fCAodCA9IG4gPSAwKSB8fCBvLnBvcCgpKSB7XFxuICAgICAgICAgICAgICAgIGlmICgoaCA/IG0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gciA6IDEgPT09IG0ubm9kZVR5cGUpICYmICsrdCAmJiAocyAmJiAobCA9IG1bdV0gfHwgKG1bdV0gPSB7fSksIGsgPSBsW20udW5pcXVlSURdIHx8IChsW20udW5pcXVlSURdID0ge30pLCBrW2FdID0gW3csIHRdKSwgbSA9PT0gYikpIGJyZWFrO1xcbiAgICAgICAgICAgICAgfXJldHVybiB0IC09IGUsIHQgPT09IGQgfHwgdCAlIGQgPT09IDAgJiYgdCAvIGQgPj0gMDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH07XFxuICAgICAgICB9LCBQU0VVRE86IGZ1bmN0aW9uIFBTRVVETyhhLCBiKSB7XFxuICAgICAgICAgIHZhciBjLFxcbiAgICAgICAgICAgICAgZSA9IGQucHNldWRvc1thXSB8fCBkLnNldEZpbHRlcnNbYS50b0xvd2VyQ2FzZSgpXSB8fCBmYS5lcnJvcihcXFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcXFwiICsgYSk7cmV0dXJuIGVbdV0gPyBlKGIpIDogZS5sZW5ndGggPiAxID8gKGMgPSBbYSwgYSwgXFxcIlxcXCIsIGJdLCBkLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoYS50b0xvd2VyQ2FzZSgpKSA/IGhhKGZ1bmN0aW9uIChhLCBjKSB7XFxuICAgICAgICAgICAgdmFyIGQsXFxuICAgICAgICAgICAgICAgIGYgPSBlKGEsIGIpLFxcbiAgICAgICAgICAgICAgICBnID0gZi5sZW5ndGg7d2hpbGUgKGctLSkge1xcbiAgICAgICAgICAgICAgZCA9IEooYSwgZltnXSksIGFbZF0gPSAhKGNbZF0gPSBmW2ddKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0pIDogZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgICByZXR1cm4gZShhLCAwLCBjKTtcXG4gICAgICAgICAgfSkgOiBlO1xcbiAgICAgICAgfSB9LCBwc2V1ZG9zOiB7IG5vdDogaGEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgdmFyIGIgPSBbXSxcXG4gICAgICAgICAgICAgIGMgPSBbXSxcXG4gICAgICAgICAgICAgIGQgPSBoKGEucmVwbGFjZShRLCBcXFwiJDFcXFwiKSk7cmV0dXJuIGRbdV0gPyBoYShmdW5jdGlvbiAoYSwgYiwgYywgZSkge1xcbiAgICAgICAgICAgIHZhciBmLFxcbiAgICAgICAgICAgICAgICBnID0gZChhLCBudWxsLCBlLCBbXSksXFxuICAgICAgICAgICAgICAgIGggPSBhLmxlbmd0aDt3aGlsZSAoaC0tKSB7XFxuICAgICAgICAgICAgICAoZiA9IGdbaF0pICYmIChhW2hdID0gIShiW2hdID0gZikpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSkgOiBmdW5jdGlvbiAoYSwgZSwgZikge1xcbiAgICAgICAgICAgIHJldHVybiBiWzBdID0gYSwgZChiLCBudWxsLCBmLCBjKSwgYlswXSA9IG51bGwsICFjLnBvcCgpO1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgfSksIGhhczogaGEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhKGEsIGIpLmxlbmd0aCA+IDA7XFxuICAgICAgICAgIH07XFxuICAgICAgICB9KSwgY29udGFpbnM6IGhhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICAgIHJldHVybiBhID0gYS5yZXBsYWNlKGJhLCBjYSksIGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICAgICAgcmV0dXJuIChiLnRleHRDb250ZW50IHx8IGIuaW5uZXJUZXh0IHx8IGUoYikpLmluZGV4T2YoYSkgPiAtMTtcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH0pLCBsYW5nOiBoYShmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICByZXR1cm4gVi50ZXN0KGEgfHwgXFxcIlxcXCIpIHx8IGZhLmVycm9yKFxcXCJ1bnN1cHBvcnRlZCBsYW5nOiBcXFwiICsgYSksIGEgPSBhLnJlcGxhY2UoYmEsIGNhKS50b0xvd2VyQ2FzZSgpLCBmdW5jdGlvbiAoYikge1xcbiAgICAgICAgICAgIHZhciBjO2RvIHtcXG4gICAgICAgICAgICAgIGlmIChjID0gcCA/IGIubGFuZyA6IGIuZ2V0QXR0cmlidXRlKFxcXCJ4bWw6bGFuZ1xcXCIpIHx8IGIuZ2V0QXR0cmlidXRlKFxcXCJsYW5nXFxcIikpIHJldHVybiBjID0gYy50b0xvd2VyQ2FzZSgpLCBjID09PSBhIHx8IDAgPT09IGMuaW5kZXhPZihhICsgXFxcIi1cXFwiKTtcXG4gICAgICAgICAgICB9IHdoaWxlICgoYiA9IGIucGFyZW50Tm9kZSkgJiYgMSA9PT0gYi5ub2RlVHlwZSk7cmV0dXJuICExO1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgfSksIHRhcmdldDogZnVuY3Rpb24gdGFyZ2V0KGIpIHtcXG4gICAgICAgICAgdmFyIGMgPSBhLmxvY2F0aW9uICYmIGEubG9jYXRpb24uaGFzaDtyZXR1cm4gYyAmJiBjLnNsaWNlKDEpID09PSBiLmlkO1xcbiAgICAgICAgfSwgcm9vdDogZnVuY3Rpb24gcm9vdChhKSB7XFxuICAgICAgICAgIHJldHVybiBhID09PSBvO1xcbiAgICAgICAgfSwgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIGEgPT09IG4uYWN0aXZlRWxlbWVudCAmJiAoIW4uaGFzRm9jdXMgfHwgbi5oYXNGb2N1cygpKSAmJiAhIShhLnR5cGUgfHwgYS5ocmVmIHx8IH5hLnRhYkluZGV4KTtcXG4gICAgICAgIH0sIGVuYWJsZWQ6IGZ1bmN0aW9uIGVuYWJsZWQoYSkge1xcbiAgICAgICAgICByZXR1cm4gYS5kaXNhYmxlZCA9PT0gITE7XFxuICAgICAgICB9LCBkaXNhYmxlZDogZnVuY3Rpb24gZGlzYWJsZWQoYSkge1xcbiAgICAgICAgICByZXR1cm4gYS5kaXNhYmxlZCA9PT0gITA7XFxuICAgICAgICB9LCBjaGVja2VkOiBmdW5jdGlvbiBjaGVja2VkKGEpIHtcXG4gICAgICAgICAgdmFyIGIgPSBhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIFxcXCJpbnB1dFxcXCIgPT09IGIgJiYgISFhLmNoZWNrZWQgfHwgXFxcIm9wdGlvblxcXCIgPT09IGIgJiYgISFhLnNlbGVjdGVkO1xcbiAgICAgICAgfSwgc2VsZWN0ZWQ6IGZ1bmN0aW9uIHNlbGVjdGVkKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIGEucGFyZW50Tm9kZSAmJiBhLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleCwgYS5zZWxlY3RlZCA9PT0gITA7XFxuICAgICAgICB9LCBlbXB0eTogZnVuY3Rpb24gZW1wdHkoYSkge1xcbiAgICAgICAgICBmb3IgKGEgPSBhLmZpcnN0Q2hpbGQ7IGE7IGEgPSBhLm5leHRTaWJsaW5nKSB7XFxuICAgICAgICAgICAgaWYgKGEubm9kZVR5cGUgPCA2KSByZXR1cm4gITE7XFxuICAgICAgICAgIH1yZXR1cm4gITA7XFxuICAgICAgICB9LCBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChhKSB7XFxuICAgICAgICAgIHJldHVybiAhZC5wc2V1ZG9zLmVtcHR5KGEpO1xcbiAgICAgICAgfSwgaGVhZGVyOiBmdW5jdGlvbiBoZWFkZXIoYSkge1xcbiAgICAgICAgICByZXR1cm4gWS50ZXN0KGEubm9kZU5hbWUpO1xcbiAgICAgICAgfSwgaW5wdXQ6IGZ1bmN0aW9uIGlucHV0KGEpIHtcXG4gICAgICAgICAgcmV0dXJuIFgudGVzdChhLm5vZGVOYW1lKTtcXG4gICAgICAgIH0sIGJ1dHRvbjogZnVuY3Rpb24gYnV0dG9uKGEpIHtcXG4gICAgICAgICAgdmFyIGIgPSBhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIFxcXCJpbnB1dFxcXCIgPT09IGIgJiYgXFxcImJ1dHRvblxcXCIgPT09IGEudHlwZSB8fCBcXFwiYnV0dG9uXFxcIiA9PT0gYjtcXG4gICAgICAgIH0sIHRleHQ6IGZ1bmN0aW9uIHRleHQoYSkge1xcbiAgICAgICAgICB2YXIgYjtyZXR1cm4gXFxcImlucHV0XFxcIiA9PT0gYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICYmIFxcXCJ0ZXh0XFxcIiA9PT0gYS50eXBlICYmIChudWxsID09IChiID0gYS5nZXRBdHRyaWJ1dGUoXFxcInR5cGVcXFwiKSkgfHwgXFxcInRleHRcXFwiID09PSBiLnRvTG93ZXJDYXNlKCkpO1xcbiAgICAgICAgfSwgZmlyc3Q6IG5hKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcmV0dXJuIFswXTtcXG4gICAgICAgIH0pLCBsYXN0OiBuYShmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgICByZXR1cm4gW2IgLSAxXTtcXG4gICAgICAgIH0pLCBlcTogbmEoZnVuY3Rpb24gKGEsIGIsIGMpIHtcXG4gICAgICAgICAgcmV0dXJuIFswID4gYyA/IGMgKyBiIDogY107XFxuICAgICAgICB9KSwgZXZlbjogbmEoZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGIgPiBjOyBjICs9IDIpIHtcXG4gICAgICAgICAgICBhLnB1c2goYyk7XFxuICAgICAgICAgIH1yZXR1cm4gYTtcXG4gICAgICAgIH0pLCBvZGQ6IG5hKGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICAgIGZvciAodmFyIGMgPSAxOyBiID4gYzsgYyArPSAyKSB7XFxuICAgICAgICAgICAgYS5wdXNoKGMpO1xcbiAgICAgICAgICB9cmV0dXJuIGE7XFxuICAgICAgICB9KSwgbHQ6IG5hKGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgICAgICAgIGZvciAodmFyIGQgPSAwID4gYyA/IGMgKyBiIDogYzsgLS1kID49IDA7KSB7XFxuICAgICAgICAgICAgYS5wdXNoKGQpO1xcbiAgICAgICAgICB9cmV0dXJuIGE7XFxuICAgICAgICB9KSwgZ3Q6IG5hKGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgICAgICAgIGZvciAodmFyIGQgPSAwID4gYyA/IGMgKyBiIDogYzsgKytkIDwgYjspIHtcXG4gICAgICAgICAgICBhLnB1c2goZCk7XFxuICAgICAgICAgIH1yZXR1cm4gYTtcXG4gICAgICAgIH0pIH0gfSwgZC5wc2V1ZG9zLm50aCA9IGQucHNldWRvcy5lcTtmb3IgKGIgaW4geyByYWRpbzogITAsIGNoZWNrYm94OiAhMCwgZmlsZTogITAsIHBhc3N3b3JkOiAhMCwgaW1hZ2U6ICEwIH0pIHtcXG4gICAgICBkLnBzZXVkb3NbYl0gPSBsYShiKTtcXG4gICAgfWZvciAoYiBpbiB7IHN1Ym1pdDogITAsIHJlc2V0OiAhMCB9KSB7XFxuICAgICAgZC5wc2V1ZG9zW2JdID0gbWEoYik7XFxuICAgIH1mdW5jdGlvbiBwYSgpIHt9cGEucHJvdG90eXBlID0gZC5maWx0ZXJzID0gZC5wc2V1ZG9zLCBkLnNldEZpbHRlcnMgPSBuZXcgcGEoKSwgZyA9IGZhLnRva2VuaXplID0gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICB2YXIgYyxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZixcXG4gICAgICAgICAgZyxcXG4gICAgICAgICAgaCxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgayA9IHpbYSArIFxcXCIgXFxcIl07aWYgKGspIHJldHVybiBiID8gMCA6IGsuc2xpY2UoMCk7aCA9IGEsIGkgPSBbXSwgaiA9IGQucHJlRmlsdGVyO3doaWxlIChoKSB7XFxuICAgICAgICBjICYmICEoZSA9IFIuZXhlYyhoKSkgfHwgKGUgJiYgKGggPSBoLnNsaWNlKGVbMF0ubGVuZ3RoKSB8fCBoKSwgaS5wdXNoKGYgPSBbXSkpLCBjID0gITEsIChlID0gUy5leGVjKGgpKSAmJiAoYyA9IGUuc2hpZnQoKSwgZi5wdXNoKHsgdmFsdWU6IGMsIHR5cGU6IGVbMF0ucmVwbGFjZShRLCBcXFwiIFxcXCIpIH0pLCBoID0gaC5zbGljZShjLmxlbmd0aCkpO2ZvciAoZyBpbiBkLmZpbHRlcikge1xcbiAgICAgICAgICAhKGUgPSBXW2ddLmV4ZWMoaCkpIHx8IGpbZ10gJiYgIShlID0galtnXShlKSkgfHwgKGMgPSBlLnNoaWZ0KCksIGYucHVzaCh7IHZhbHVlOiBjLCB0eXBlOiBnLCBtYXRjaGVzOiBlIH0pLCBoID0gaC5zbGljZShjLmxlbmd0aCkpO1xcbiAgICAgICAgfWlmICghYykgYnJlYWs7XFxuICAgICAgfXJldHVybiBiID8gaC5sZW5ndGggOiBoID8gZmEuZXJyb3IoYSkgOiB6KGEsIGkpLnNsaWNlKDApO1xcbiAgICB9O2Z1bmN0aW9uIHFhKGEpIHtcXG4gICAgICBmb3IgKHZhciBiID0gMCwgYyA9IGEubGVuZ3RoLCBkID0gXFxcIlxcXCI7IGMgPiBiOyBiKyspIHtcXG4gICAgICAgIGQgKz0gYVtiXS52YWx1ZTtcXG4gICAgICB9cmV0dXJuIGQ7XFxuICAgIH1mdW5jdGlvbiByYShhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQgPSBiLmRpcixcXG4gICAgICAgICAgZSA9IGMgJiYgXFxcInBhcmVudE5vZGVcXFwiID09PSBkLFxcbiAgICAgICAgICBmID0geCsrO3JldHVybiBiLmZpcnN0ID8gZnVuY3Rpb24gKGIsIGMsIGYpIHtcXG4gICAgICAgIHdoaWxlIChiID0gYltkXSkge1xcbiAgICAgICAgICBpZiAoMSA9PT0gYi5ub2RlVHlwZSB8fCBlKSByZXR1cm4gYShiLCBjLCBmKTtcXG4gICAgICAgIH1cXG4gICAgICB9IDogZnVuY3Rpb24gKGIsIGMsIGcpIHtcXG4gICAgICAgIHZhciBoLFxcbiAgICAgICAgICAgIGksXFxuICAgICAgICAgICAgaixcXG4gICAgICAgICAgICBrID0gW3csIGZdO2lmIChnKSB7XFxuICAgICAgICAgIHdoaWxlIChiID0gYltkXSkge1xcbiAgICAgICAgICAgIGlmICgoMSA9PT0gYi5ub2RlVHlwZSB8fCBlKSAmJiBhKGIsIGMsIGcpKSByZXR1cm4gITA7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB3aGlsZSAoYiA9IGJbZF0pIHtcXG4gICAgICAgICAgaWYgKDEgPT09IGIubm9kZVR5cGUgfHwgZSkge1xcbiAgICAgICAgICAgIGlmIChqID0gYlt1XSB8fCAoYlt1XSA9IHt9KSwgaSA9IGpbYi51bmlxdWVJRF0gfHwgKGpbYi51bmlxdWVJRF0gPSB7fSksIChoID0gaVtkXSkgJiYgaFswXSA9PT0gdyAmJiBoWzFdID09PSBmKSByZXR1cm4ga1syXSA9IGhbMl07aWYgKGlbZF0gPSBrLCBrWzJdID0gYShiLCBjLCBnKSkgcmV0dXJuICEwO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgfWZ1bmN0aW9uIHNhKGEpIHtcXG4gICAgICByZXR1cm4gYS5sZW5ndGggPiAxID8gZnVuY3Rpb24gKGIsIGMsIGQpIHtcXG4gICAgICAgIHZhciBlID0gYS5sZW5ndGg7d2hpbGUgKGUtLSkge1xcbiAgICAgICAgICBpZiAoIWFbZV0oYiwgYywgZCkpIHJldHVybiAhMTtcXG4gICAgICAgIH1yZXR1cm4gITA7XFxuICAgICAgfSA6IGFbMF07XFxuICAgIH1mdW5jdGlvbiB0YShhLCBiLCBjKSB7XFxuICAgICAgZm9yICh2YXIgZCA9IDAsIGUgPSBiLmxlbmd0aDsgZSA+IGQ7IGQrKykge1xcbiAgICAgICAgZmEoYSwgYltkXSwgYyk7XFxuICAgICAgfXJldHVybiBjO1xcbiAgICB9ZnVuY3Rpb24gdWEoYSwgYiwgYywgZCwgZSkge1xcbiAgICAgIGZvciAodmFyIGYsIGcgPSBbXSwgaCA9IDAsIGkgPSBhLmxlbmd0aCwgaiA9IG51bGwgIT0gYjsgaSA+IGg7IGgrKykge1xcbiAgICAgICAgKGYgPSBhW2hdKSAmJiAoYyAmJiAhYyhmLCBkLCBlKSB8fCAoZy5wdXNoKGYpLCBqICYmIGIucHVzaChoKSkpO1xcbiAgICAgIH1yZXR1cm4gZztcXG4gICAgfWZ1bmN0aW9uIHZhKGEsIGIsIGMsIGQsIGUsIGYpIHtcXG4gICAgICByZXR1cm4gZCAmJiAhZFt1XSAmJiAoZCA9IHZhKGQpKSwgZSAmJiAhZVt1XSAmJiAoZSA9IHZhKGUsIGYpKSwgaGEoZnVuY3Rpb24gKGYsIGcsIGgsIGkpIHtcXG4gICAgICAgIHZhciBqLFxcbiAgICAgICAgICAgIGssXFxuICAgICAgICAgICAgbCxcXG4gICAgICAgICAgICBtID0gW10sXFxuICAgICAgICAgICAgbiA9IFtdLFxcbiAgICAgICAgICAgIG8gPSBnLmxlbmd0aCxcXG4gICAgICAgICAgICBwID0gZiB8fCB0YShiIHx8IFxcXCIqXFxcIiwgaC5ub2RlVHlwZSA/IFtoXSA6IGgsIFtdKSxcXG4gICAgICAgICAgICBxID0gIWEgfHwgIWYgJiYgYiA/IHAgOiB1YShwLCBtLCBhLCBoLCBpKSxcXG4gICAgICAgICAgICByID0gYyA/IGUgfHwgKGYgPyBhIDogbyB8fCBkKSA/IFtdIDogZyA6IHE7aWYgKGMgJiYgYyhxLCByLCBoLCBpKSwgZCkge1xcbiAgICAgICAgICBqID0gdWEociwgbiksIGQoaiwgW10sIGgsIGkpLCBrID0gai5sZW5ndGg7d2hpbGUgKGstLSkge1xcbiAgICAgICAgICAgIChsID0galtrXSkgJiYgKHJbbltrXV0gPSAhKHFbbltrXV0gPSBsKSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1pZiAoZikge1xcbiAgICAgICAgICBpZiAoZSB8fCBhKSB7XFxuICAgICAgICAgICAgaWYgKGUpIHtcXG4gICAgICAgICAgICAgIGogPSBbXSwgayA9IHIubGVuZ3RoO3doaWxlIChrLS0pIHtcXG4gICAgICAgICAgICAgICAgKGwgPSByW2tdKSAmJiBqLnB1c2gocVtrXSA9IGwpO1xcbiAgICAgICAgICAgICAgfWUobnVsbCwgciA9IFtdLCBqLCBpKTtcXG4gICAgICAgICAgICB9ayA9IHIubGVuZ3RoO3doaWxlIChrLS0pIHtcXG4gICAgICAgICAgICAgIChsID0gcltrXSkgJiYgKGogPSBlID8gSihmLCBsKSA6IG1ba10pID4gLTEgJiYgKGZbal0gPSAhKGdbal0gPSBsKSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgciA9IHVhKHIgPT09IGcgPyByLnNwbGljZShvLCByLmxlbmd0aCkgOiByKSwgZSA/IGUobnVsbCwgZywgciwgaSkgOiBILmFwcGx5KGcsIHIpO1xcbiAgICAgIH0pO1xcbiAgICB9ZnVuY3Rpb24gd2EoYSkge1xcbiAgICAgIGZvciAodmFyIGIsIGMsIGUsIGYgPSBhLmxlbmd0aCwgZyA9IGQucmVsYXRpdmVbYVswXS50eXBlXSwgaCA9IGcgfHwgZC5yZWxhdGl2ZVtcXFwiIFxcXCJdLCBpID0gZyA/IDEgOiAwLCBrID0gcmEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHJldHVybiBhID09PSBiO1xcbiAgICAgIH0sIGgsICEwKSwgbCA9IHJhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICByZXR1cm4gSihiLCBhKSA+IC0xO1xcbiAgICAgIH0sIGgsICEwKSwgbSA9IFtmdW5jdGlvbiAoYSwgYywgZCkge1xcbiAgICAgICAgdmFyIGUgPSAhZyAmJiAoZCB8fCBjICE9PSBqKSB8fCAoKGIgPSBjKS5ub2RlVHlwZSA/IGsoYSwgYywgZCkgOiBsKGEsIGMsIGQpKTtyZXR1cm4gYiA9IG51bGwsIGU7XFxuICAgICAgfV07IGYgPiBpOyBpKyspIHtcXG4gICAgICAgIGlmIChjID0gZC5yZWxhdGl2ZVthW2ldLnR5cGVdKSBtID0gW3JhKHNhKG0pLCBjKV07ZWxzZSB7XFxuICAgICAgICAgIGlmIChjID0gZC5maWx0ZXJbYVtpXS50eXBlXS5hcHBseShudWxsLCBhW2ldLm1hdGNoZXMpLCBjW3VdKSB7XFxuICAgICAgICAgICAgZm9yIChlID0gKytpOyBmID4gZTsgZSsrKSB7XFxuICAgICAgICAgICAgICBpZiAoZC5yZWxhdGl2ZVthW2VdLnR5cGVdKSBicmVhaztcXG4gICAgICAgICAgICB9cmV0dXJuIHZhKGkgPiAxICYmIHNhKG0pLCBpID4gMSAmJiBxYShhLnNsaWNlKDAsIGkgLSAxKS5jb25jYXQoeyB2YWx1ZTogXFxcIiBcXFwiID09PSBhW2kgLSAyXS50eXBlID8gXFxcIipcXFwiIDogXFxcIlxcXCIgfSkpLnJlcGxhY2UoUSwgXFxcIiQxXFxcIiksIGMsIGUgPiBpICYmIHdhKGEuc2xpY2UoaSwgZSkpLCBmID4gZSAmJiB3YShhID0gYS5zbGljZShlKSksIGYgPiBlICYmIHFhKGEpKTtcXG4gICAgICAgICAgfW0ucHVzaChjKTtcXG4gICAgICAgIH1cXG4gICAgICB9cmV0dXJuIHNhKG0pO1xcbiAgICB9ZnVuY3Rpb24geGEoYSwgYikge1xcbiAgICAgIHZhciBjID0gYi5sZW5ndGggPiAwLFxcbiAgICAgICAgICBlID0gYS5sZW5ndGggPiAwLFxcbiAgICAgICAgICBmID0gZnVuY3Rpb24gZihfZiwgZywgaCwgaSwgaykge1xcbiAgICAgICAgdmFyIGwsXFxuICAgICAgICAgICAgbyxcXG4gICAgICAgICAgICBxLFxcbiAgICAgICAgICAgIHIgPSAwLFxcbiAgICAgICAgICAgIHMgPSBcXFwiMFxcXCIsXFxuICAgICAgICAgICAgdCA9IF9mICYmIFtdLFxcbiAgICAgICAgICAgIHUgPSBbXSxcXG4gICAgICAgICAgICB2ID0gaixcXG4gICAgICAgICAgICB4ID0gX2YgfHwgZSAmJiBkLmZpbmQuVEFHKFxcXCIqXFxcIiwgayksXFxuICAgICAgICAgICAgeSA9IHcgKz0gbnVsbCA9PSB2ID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgLjEsXFxuICAgICAgICAgICAgeiA9IHgubGVuZ3RoO2ZvciAoayAmJiAoaiA9IGcgPT09IG4gfHwgZyB8fCBrKTsgcyAhPT0geiAmJiBudWxsICE9IChsID0geFtzXSk7IHMrKykge1xcbiAgICAgICAgICBpZiAoZSAmJiBsKSB7XFxuICAgICAgICAgICAgbyA9IDAsIGcgfHwgbC5vd25lckRvY3VtZW50ID09PSBuIHx8IChtKGwpLCBoID0gIXApO3doaWxlIChxID0gYVtvKytdKSB7XFxuICAgICAgICAgICAgICBpZiAocShsLCBnIHx8IG4sIGgpKSB7XFxuICAgICAgICAgICAgICAgIGkucHVzaChsKTticmVhaztcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9ayAmJiAodyA9IHkpO1xcbiAgICAgICAgICB9YyAmJiAoKGwgPSAhcSAmJiBsKSAmJiByLS0sIF9mICYmIHQucHVzaChsKSk7XFxuICAgICAgICB9aWYgKHIgKz0gcywgYyAmJiBzICE9PSByKSB7XFxuICAgICAgICAgIG8gPSAwO3doaWxlIChxID0gYltvKytdKSB7XFxuICAgICAgICAgICAgcSh0LCB1LCBnLCBoKTtcXG4gICAgICAgICAgfWlmIChfZikge1xcbiAgICAgICAgICAgIGlmIChyID4gMCkgd2hpbGUgKHMtLSkge1xcbiAgICAgICAgICAgICAgdFtzXSB8fCB1W3NdIHx8ICh1W3NdID0gRi5jYWxsKGkpKTtcXG4gICAgICAgICAgICB9dSA9IHVhKHUpO1xcbiAgICAgICAgICB9SC5hcHBseShpLCB1KSwgayAmJiAhX2YgJiYgdS5sZW5ndGggPiAwICYmIHIgKyBiLmxlbmd0aCA+IDEgJiYgZmEudW5pcXVlU29ydChpKTtcXG4gICAgICAgIH1yZXR1cm4gayAmJiAodyA9IHksIGogPSB2KSwgdDtcXG4gICAgICB9O3JldHVybiBjID8gaGEoZikgOiBmO1xcbiAgICB9cmV0dXJuIGggPSBmYS5jb21waWxlID0gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICB2YXIgYyxcXG4gICAgICAgICAgZCA9IFtdLFxcbiAgICAgICAgICBlID0gW10sXFxuICAgICAgICAgIGYgPSBBW2EgKyBcXFwiIFxcXCJdO2lmICghZikge1xcbiAgICAgICAgYiB8fCAoYiA9IGcoYSkpLCBjID0gYi5sZW5ndGg7d2hpbGUgKGMtLSkge1xcbiAgICAgICAgICBmID0gd2EoYltjXSksIGZbdV0gPyBkLnB1c2goZikgOiBlLnB1c2goZik7XFxuICAgICAgICB9ZiA9IEEoYSwgeGEoZSwgZCkpLCBmLnNlbGVjdG9yID0gYTtcXG4gICAgICB9cmV0dXJuIGY7XFxuICAgIH0sIGkgPSBmYS5zZWxlY3QgPSBmdW5jdGlvbiAoYSwgYiwgZSwgZikge1xcbiAgICAgIHZhciBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBrLFxcbiAgICAgICAgICBsLFxcbiAgICAgICAgICBtLFxcbiAgICAgICAgICBuID0gXFxcImZ1bmN0aW9uXFxcIiA9PSB0eXBlb2YgYSAmJiBhLFxcbiAgICAgICAgICBvID0gIWYgJiYgZyhhID0gbi5zZWxlY3RvciB8fCBhKTtpZiAoZSA9IGUgfHwgW10sIDEgPT09IG8ubGVuZ3RoKSB7XFxuICAgICAgICBpZiAoaiA9IG9bMF0gPSBvWzBdLnNsaWNlKDApLCBqLmxlbmd0aCA+IDIgJiYgXFxcIklEXFxcIiA9PT0gKGsgPSBqWzBdKS50eXBlICYmIGMuZ2V0QnlJZCAmJiA5ID09PSBiLm5vZGVUeXBlICYmIHAgJiYgZC5yZWxhdGl2ZVtqWzFdLnR5cGVdKSB7XFxuICAgICAgICAgIGlmIChiID0gKGQuZmluZC5JRChrLm1hdGNoZXNbMF0ucmVwbGFjZShiYSwgY2EpLCBiKSB8fCBbXSlbMF0sICFiKSByZXR1cm4gZTtuICYmIChiID0gYi5wYXJlbnROb2RlKSwgYSA9IGEuc2xpY2Uoai5zaGlmdCgpLnZhbHVlLmxlbmd0aCk7XFxuICAgICAgICB9aSA9IFcubmVlZHNDb250ZXh0LnRlc3QoYSkgPyAwIDogai5sZW5ndGg7d2hpbGUgKGktLSkge1xcbiAgICAgICAgICBpZiAoayA9IGpbaV0sIGQucmVsYXRpdmVbbCA9IGsudHlwZV0pIGJyZWFrO2lmICgobSA9IGQuZmluZFtsXSkgJiYgKGYgPSBtKGsubWF0Y2hlc1swXS5yZXBsYWNlKGJhLCBjYSksIF8udGVzdChqWzBdLnR5cGUpICYmIG9hKGIucGFyZW50Tm9kZSkgfHwgYikpKSB7XFxuICAgICAgICAgICAgaWYgKGouc3BsaWNlKGksIDEpLCBhID0gZi5sZW5ndGggJiYgcWEoaiksICFhKSByZXR1cm4gSC5hcHBseShlLCBmKSwgZTticmVhaztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1yZXR1cm4gKG4gfHwgaChhLCBvKSkoZiwgYiwgIXAsIGUsICFiIHx8IF8udGVzdChhKSAmJiBvYShiLnBhcmVudE5vZGUpIHx8IGIpLCBlO1xcbiAgICB9LCBjLnNvcnRTdGFibGUgPSB1LnNwbGl0KFxcXCJcXFwiKS5zb3J0KEIpLmpvaW4oXFxcIlxcXCIpID09PSB1LCBjLmRldGVjdER1cGxpY2F0ZXMgPSAhIWwsIG0oKSwgYy5zb3J0RGV0YWNoZWQgPSBpYShmdW5jdGlvbiAoYSkge1xcbiAgICAgIHJldHVybiAxICYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihuLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpKTtcXG4gICAgfSksIGlhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgcmV0dXJuIGEuaW5uZXJIVE1MID0gXFxcIjxhIGhyZWY9JyMnPjwvYT5cXFwiLCBcXFwiI1xcXCIgPT09IGEuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXFxcImhyZWZcXFwiKTtcXG4gICAgfSkgfHwgamEoXFxcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcXFwiLCBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICAgIHJldHVybiBjID8gdm9pZCAwIDogYS5nZXRBdHRyaWJ1dGUoYiwgXFxcInR5cGVcXFwiID09PSBiLnRvTG93ZXJDYXNlKCkgPyAxIDogMik7XFxuICAgIH0pLCBjLmF0dHJpYnV0ZXMgJiYgaWEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICByZXR1cm4gYS5pbm5lckhUTUwgPSBcXFwiPGlucHV0Lz5cXFwiLCBhLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKFxcXCJ2YWx1ZVxcXCIsIFxcXCJcXFwiKSwgXFxcIlxcXCIgPT09IGEuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXFxcInZhbHVlXFxcIik7XFxuICAgIH0pIHx8IGphKFxcXCJ2YWx1ZVxcXCIsIGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIGMgfHwgXFxcImlucHV0XFxcIiAhPT0gYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID8gdm9pZCAwIDogYS5kZWZhdWx0VmFsdWU7XFxuICAgIH0pLCBpYShmdW5jdGlvbiAoYSkge1xcbiAgICAgIHJldHVybiBudWxsID09IGEuZ2V0QXR0cmlidXRlKFxcXCJkaXNhYmxlZFxcXCIpO1xcbiAgICB9KSB8fCBqYShLLCBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICAgIHZhciBkO3JldHVybiBjID8gdm9pZCAwIDogYVtiXSA9PT0gITAgPyBiLnRvTG93ZXJDYXNlKCkgOiAoZCA9IGEuZ2V0QXR0cmlidXRlTm9kZShiKSkgJiYgZC5zcGVjaWZpZWQgPyBkLnZhbHVlIDogbnVsbDtcXG4gICAgfSksIGZhO1xcbiAgfShhKTtuLmZpbmQgPSB0LCBuLmV4cHIgPSB0LnNlbGVjdG9ycywgbi5leHByW1xcXCI6XFxcIl0gPSBuLmV4cHIucHNldWRvcywgbi51bmlxdWVTb3J0ID0gbi51bmlxdWUgPSB0LnVuaXF1ZVNvcnQsIG4udGV4dCA9IHQuZ2V0VGV4dCwgbi5pc1hNTERvYyA9IHQuaXNYTUwsIG4uY29udGFpbnMgPSB0LmNvbnRhaW5zO3ZhciB1ID0gZnVuY3Rpb24gdShhLCBiLCBjKSB7XFxuICAgIHZhciBkID0gW10sXFxuICAgICAgICBlID0gdm9pZCAwICE9PSBjO3doaWxlICgoYSA9IGFbYl0pICYmIDkgIT09IGEubm9kZVR5cGUpIHtcXG4gICAgICBpZiAoMSA9PT0gYS5ub2RlVHlwZSkge1xcbiAgICAgICAgaWYgKGUgJiYgbihhKS5pcyhjKSkgYnJlYWs7ZC5wdXNoKGEpO1xcbiAgICAgIH1cXG4gICAgfXJldHVybiBkO1xcbiAgfSxcXG4gICAgICB2ID0gZnVuY3Rpb24gdihhLCBiKSB7XFxuICAgIGZvciAodmFyIGMgPSBbXTsgYTsgYSA9IGEubmV4dFNpYmxpbmcpIHtcXG4gICAgICAxID09PSBhLm5vZGVUeXBlICYmIGEgIT09IGIgJiYgYy5wdXNoKGEpO1xcbiAgICB9cmV0dXJuIGM7XFxuICB9LFxcbiAgICAgIHcgPSBuLmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LFxcbiAgICAgIHggPSAvXjwoW1xcXFx3LV0rKVxcXFxzKlxcXFwvPz4oPzo8XFxcXC9cXFxcMT58KSQvLFxcbiAgICAgIHkgPSAvXi5bXjojXFxcXFtcXFxcLixdKiQvO2Z1bmN0aW9uIHooYSwgYiwgYykge1xcbiAgICBpZiAobi5pc0Z1bmN0aW9uKGIpKSByZXR1cm4gbi5ncmVwKGEsIGZ1bmN0aW9uIChhLCBkKSB7XFxuICAgICAgcmV0dXJuICEhYi5jYWxsKGEsIGQsIGEpICE9PSBjO1xcbiAgICB9KTtpZiAoYi5ub2RlVHlwZSkgcmV0dXJuIG4uZ3JlcChhLCBmdW5jdGlvbiAoYSkge1xcbiAgICAgIHJldHVybiBhID09PSBiICE9PSBjO1xcbiAgICB9KTtpZiAoXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGIpIHtcXG4gICAgICBpZiAoeS50ZXN0KGIpKSByZXR1cm4gbi5maWx0ZXIoYiwgYSwgYyk7YiA9IG4uZmlsdGVyKGIsIGEpO1xcbiAgICB9cmV0dXJuIG4uZ3JlcChhLCBmdW5jdGlvbiAoYSkge1xcbiAgICAgIHJldHVybiBoLmNhbGwoYiwgYSkgPiAtMSAhPT0gYztcXG4gICAgfSk7XFxuICB9bi5maWx0ZXIgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICB2YXIgZCA9IGJbMF07cmV0dXJuIGMgJiYgKGEgPSBcXFwiOm5vdChcXFwiICsgYSArIFxcXCIpXFxcIiksIDEgPT09IGIubGVuZ3RoICYmIDEgPT09IGQubm9kZVR5cGUgPyBuLmZpbmQubWF0Y2hlc1NlbGVjdG9yKGQsIGEpID8gW2RdIDogW10gOiBuLmZpbmQubWF0Y2hlcyhhLCBuLmdyZXAoYiwgZnVuY3Rpb24gKGEpIHtcXG4gICAgICByZXR1cm4gMSA9PT0gYS5ub2RlVHlwZTtcXG4gICAgfSkpO1xcbiAgfSwgbi5mbi5leHRlbmQoeyBmaW5kOiBmdW5jdGlvbiBmaW5kKGEpIHtcXG4gICAgICB2YXIgYixcXG4gICAgICAgICAgYyA9IHRoaXMubGVuZ3RoLFxcbiAgICAgICAgICBkID0gW10sXFxuICAgICAgICAgIGUgPSB0aGlzO2lmIChcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgYSkgcmV0dXJuIHRoaXMucHVzaFN0YWNrKG4oYSkuZmlsdGVyKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGZvciAoYiA9IDA7IGMgPiBiOyBiKyspIHtcXG4gICAgICAgICAgaWYgKG4uY29udGFpbnMoZVtiXSwgdGhpcykpIHJldHVybiAhMDtcXG4gICAgICAgIH1cXG4gICAgICB9KSk7Zm9yIChiID0gMDsgYyA+IGI7IGIrKykge1xcbiAgICAgICAgbi5maW5kKGEsIGVbYl0sIGQpO1xcbiAgICAgIH1yZXR1cm4gZCA9IHRoaXMucHVzaFN0YWNrKGMgPiAxID8gbi51bmlxdWUoZCkgOiBkKSwgZC5zZWxlY3RvciA9IHRoaXMuc2VsZWN0b3IgPyB0aGlzLnNlbGVjdG9yICsgXFxcIiBcXFwiICsgYSA6IGEsIGQ7XFxuICAgIH0sIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soeih0aGlzLCBhIHx8IFtdLCAhMSkpO1xcbiAgICB9LCBub3Q6IGZ1bmN0aW9uIG5vdChhKSB7XFxuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHoodGhpcywgYSB8fCBbXSwgITApKTtcXG4gICAgfSwgaXM6IGZ1bmN0aW9uIGlzKGEpIHtcXG4gICAgICByZXR1cm4gISF6KHRoaXMsIFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBhICYmIHcudGVzdChhKSA/IG4oYSkgOiBhIHx8IFtdLCAhMSkubGVuZ3RoO1xcbiAgICB9IH0pO3ZhciBBLFxcbiAgICAgIEIgPSAvXig/OlxcXFxzKig8W1xcXFx3XFxcXFddKz4pW14+XSp8IyhbXFxcXHctXSopKSQvLFxcbiAgICAgIEMgPSBuLmZuLmluaXQgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICB2YXIgZSwgZjtpZiAoIWEpIHJldHVybiB0aGlzO2lmIChjID0gYyB8fCBBLCBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYSkge1xcbiAgICAgIGlmIChlID0gXFxcIjxcXFwiID09PSBhWzBdICYmIFxcXCI+XFxcIiA9PT0gYVthLmxlbmd0aCAtIDFdICYmIGEubGVuZ3RoID49IDMgPyBbbnVsbCwgYSwgbnVsbF0gOiBCLmV4ZWMoYSksICFlIHx8ICFlWzFdICYmIGIpIHJldHVybiAhYiB8fCBiLmpxdWVyeSA/IChiIHx8IGMpLmZpbmQoYSkgOiB0aGlzLmNvbnN0cnVjdG9yKGIpLmZpbmQoYSk7aWYgKGVbMV0pIHtcXG4gICAgICAgIGlmIChiID0gYiBpbnN0YW5jZW9mIG4gPyBiWzBdIDogYiwgbi5tZXJnZSh0aGlzLCBuLnBhcnNlSFRNTChlWzFdLCBiICYmIGIubm9kZVR5cGUgPyBiLm93bmVyRG9jdW1lbnQgfHwgYiA6IGQsICEwKSksIHgudGVzdChlWzFdKSAmJiBuLmlzUGxhaW5PYmplY3QoYikpIGZvciAoZSBpbiBiKSB7XFxuICAgICAgICAgIG4uaXNGdW5jdGlvbih0aGlzW2VdKSA/IHRoaXNbZV0oYltlXSkgOiB0aGlzLmF0dHIoZSwgYltlXSk7XFxuICAgICAgICB9cmV0dXJuIHRoaXM7XFxuICAgICAgfXJldHVybiBmID0gZC5nZXRFbGVtZW50QnlJZChlWzJdKSwgZiAmJiBmLnBhcmVudE5vZGUgJiYgKHRoaXMubGVuZ3RoID0gMSwgdGhpc1swXSA9IGYpLCB0aGlzLmNvbnRleHQgPSBkLCB0aGlzLnNlbGVjdG9yID0gYSwgdGhpcztcXG4gICAgfXJldHVybiBhLm5vZGVUeXBlID8gKHRoaXMuY29udGV4dCA9IHRoaXNbMF0gPSBhLCB0aGlzLmxlbmd0aCA9IDEsIHRoaXMpIDogbi5pc0Z1bmN0aW9uKGEpID8gdm9pZCAwICE9PSBjLnJlYWR5ID8gYy5yZWFkeShhKSA6IGEobikgOiAodm9pZCAwICE9PSBhLnNlbGVjdG9yICYmICh0aGlzLnNlbGVjdG9yID0gYS5zZWxlY3RvciwgdGhpcy5jb250ZXh0ID0gYS5jb250ZXh0KSwgbi5tYWtlQXJyYXkoYSwgdGhpcykpO1xcbiAgfTtDLnByb3RvdHlwZSA9IG4uZm4sIEEgPSBuKGQpO3ZhciBEID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXFxuICAgICAgRSA9IHsgY2hpbGRyZW46ICEwLCBjb250ZW50czogITAsIG5leHQ6ICEwLCBwcmV2OiAhMCB9O24uZm4uZXh0ZW5kKHsgaGFzOiBmdW5jdGlvbiBoYXMoYSkge1xcbiAgICAgIHZhciBiID0gbihhLCB0aGlzKSxcXG4gICAgICAgICAgYyA9IGIubGVuZ3RoO3JldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbiAoKSB7XFxuICAgICAgICBmb3IgKHZhciBhID0gMDsgYyA+IGE7IGErKykge1xcbiAgICAgICAgICBpZiAobi5jb250YWlucyh0aGlzLCBiW2FdKSkgcmV0dXJuICEwO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9LCBjbG9zZXN0OiBmdW5jdGlvbiBjbG9zZXN0KGEsIGIpIHtcXG4gICAgICBmb3IgKHZhciBjLCBkID0gMCwgZSA9IHRoaXMubGVuZ3RoLCBmID0gW10sIGcgPSB3LnRlc3QoYSkgfHwgXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGEgPyBuKGEsIGIgfHwgdGhpcy5jb250ZXh0KSA6IDA7IGUgPiBkOyBkKyspIHtcXG4gICAgICAgIGZvciAoYyA9IHRoaXNbZF07IGMgJiYgYyAhPT0gYjsgYyA9IGMucGFyZW50Tm9kZSkge1xcbiAgICAgICAgICBpZiAoYy5ub2RlVHlwZSA8IDExICYmIChnID8gZy5pbmRleChjKSA+IC0xIDogMSA9PT0gYy5ub2RlVHlwZSAmJiBuLmZpbmQubWF0Y2hlc1NlbGVjdG9yKGMsIGEpKSkge1xcbiAgICAgICAgICAgIGYucHVzaChjKTticmVhaztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1yZXR1cm4gdGhpcy5wdXNoU3RhY2soZi5sZW5ndGggPiAxID8gbi51bmlxdWVTb3J0KGYpIDogZik7XFxuICAgIH0sIGluZGV4OiBmdW5jdGlvbiBpbmRleChhKSB7XFxuICAgICAgcmV0dXJuIGEgPyBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYSA/IGguY2FsbChuKGEpLCB0aGlzWzBdKSA6IGguY2FsbCh0aGlzLCBhLmpxdWVyeSA/IGFbMF0gOiBhKSA6IHRoaXNbMF0gJiYgdGhpc1swXS5wYXJlbnROb2RlID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcXG4gICAgfSwgYWRkOiBmdW5jdGlvbiBhZGQoYSwgYikge1xcbiAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhuLnVuaXF1ZVNvcnQobi5tZXJnZSh0aGlzLmdldCgpLCBuKGEsIGIpKSkpO1xcbiAgICB9LCBhZGRCYWNrOiBmdW5jdGlvbiBhZGRCYWNrKGEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5hZGQobnVsbCA9PSBhID8gdGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlcihhKSk7XFxuICAgIH0gfSk7ZnVuY3Rpb24gRihhLCBiKSB7XFxuICAgIHdoaWxlICgoYSA9IGFbYl0pICYmIDEgIT09IGEubm9kZVR5cGUpIHt9cmV0dXJuIGE7XFxuICB9bi5lYWNoKHsgcGFyZW50OiBmdW5jdGlvbiBwYXJlbnQoYSkge1xcbiAgICAgIHZhciBiID0gYS5wYXJlbnROb2RlO3JldHVybiBiICYmIDExICE9PSBiLm5vZGVUeXBlID8gYiA6IG51bGw7XFxuICAgIH0sIHBhcmVudHM6IGZ1bmN0aW9uIHBhcmVudHMoYSkge1xcbiAgICAgIHJldHVybiB1KGEsIFxcXCJwYXJlbnROb2RlXFxcIik7XFxuICAgIH0sIHBhcmVudHNVbnRpbDogZnVuY3Rpb24gcGFyZW50c1VudGlsKGEsIGIsIGMpIHtcXG4gICAgICByZXR1cm4gdShhLCBcXFwicGFyZW50Tm9kZVxcXCIsIGMpO1xcbiAgICB9LCBuZXh0OiBmdW5jdGlvbiBuZXh0KGEpIHtcXG4gICAgICByZXR1cm4gRihhLCBcXFwibmV4dFNpYmxpbmdcXFwiKTtcXG4gICAgfSwgcHJldjogZnVuY3Rpb24gcHJldihhKSB7XFxuICAgICAgcmV0dXJuIEYoYSwgXFxcInByZXZpb3VzU2libGluZ1xcXCIpO1xcbiAgICB9LCBuZXh0QWxsOiBmdW5jdGlvbiBuZXh0QWxsKGEpIHtcXG4gICAgICByZXR1cm4gdShhLCBcXFwibmV4dFNpYmxpbmdcXFwiKTtcXG4gICAgfSwgcHJldkFsbDogZnVuY3Rpb24gcHJldkFsbChhKSB7XFxuICAgICAgcmV0dXJuIHUoYSwgXFxcInByZXZpb3VzU2libGluZ1xcXCIpO1xcbiAgICB9LCBuZXh0VW50aWw6IGZ1bmN0aW9uIG5leHRVbnRpbChhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIHUoYSwgXFxcIm5leHRTaWJsaW5nXFxcIiwgYyk7XFxuICAgIH0sIHByZXZVbnRpbDogZnVuY3Rpb24gcHJldlVudGlsKGEsIGIsIGMpIHtcXG4gICAgICByZXR1cm4gdShhLCBcXFwicHJldmlvdXNTaWJsaW5nXFxcIiwgYyk7XFxuICAgIH0sIHNpYmxpbmdzOiBmdW5jdGlvbiBzaWJsaW5ncyhhKSB7XFxuICAgICAgcmV0dXJuIHYoKGEucGFyZW50Tm9kZSB8fCB7fSkuZmlyc3RDaGlsZCwgYSk7XFxuICAgIH0sIGNoaWxkcmVuOiBmdW5jdGlvbiBjaGlsZHJlbihhKSB7XFxuICAgICAgcmV0dXJuIHYoYS5maXJzdENoaWxkKTtcXG4gICAgfSwgY29udGVudHM6IGZ1bmN0aW9uIGNvbnRlbnRzKGEpIHtcXG4gICAgICByZXR1cm4gYS5jb250ZW50RG9jdW1lbnQgfHwgbi5tZXJnZShbXSwgYS5jaGlsZE5vZGVzKTtcXG4gICAgfSB9LCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBuLmZuW2FdID0gZnVuY3Rpb24gKGMsIGQpIHtcXG4gICAgICB2YXIgZSA9IG4ubWFwKHRoaXMsIGIsIGMpO3JldHVybiBcXFwiVW50aWxcXFwiICE9PSBhLnNsaWNlKC01KSAmJiAoZCA9IGMpLCBkICYmIFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBkICYmIChlID0gbi5maWx0ZXIoZCwgZSkpLCB0aGlzLmxlbmd0aCA+IDEgJiYgKEVbYV0gfHwgbi51bmlxdWVTb3J0KGUpLCBELnRlc3QoYSkgJiYgZS5yZXZlcnNlKCkpLCB0aGlzLnB1c2hTdGFjayhlKTtcXG4gICAgfTtcXG4gIH0pO3ZhciBHID0gL1xcXFxTKy9nO2Z1bmN0aW9uIEgoYSkge1xcbiAgICB2YXIgYiA9IHt9O3JldHVybiBuLmVhY2goYS5tYXRjaChHKSB8fCBbXSwgZnVuY3Rpb24gKGEsIGMpIHtcXG4gICAgICBiW2NdID0gITA7XFxuICAgIH0pLCBiO1xcbiAgfW4uQ2FsbGJhY2tzID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgYSA9IFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBhID8gSChhKSA6IG4uZXh0ZW5kKHt9LCBhKTt2YXIgYixcXG4gICAgICAgIGMsXFxuICAgICAgICBkLFxcbiAgICAgICAgZSxcXG4gICAgICAgIGYgPSBbXSxcXG4gICAgICAgIGcgPSBbXSxcXG4gICAgICAgIGggPSAtMSxcXG4gICAgICAgIGkgPSBmdW5jdGlvbiBpKCkge1xcbiAgICAgIGZvciAoZSA9IGEub25jZSwgZCA9IGIgPSAhMDsgZy5sZW5ndGg7IGggPSAtMSkge1xcbiAgICAgICAgYyA9IGcuc2hpZnQoKTt3aGlsZSAoKytoIDwgZi5sZW5ndGgpIHtcXG4gICAgICAgICAgZltoXS5hcHBseShjWzBdLCBjWzFdKSA9PT0gITEgJiYgYS5zdG9wT25GYWxzZSAmJiAoaCA9IGYubGVuZ3RoLCBjID0gITEpO1xcbiAgICAgICAgfVxcbiAgICAgIH1hLm1lbW9yeSB8fCAoYyA9ICExKSwgYiA9ICExLCBlICYmIChmID0gYyA/IFtdIDogXFxcIlxcXCIpO1xcbiAgICB9LFxcbiAgICAgICAgaiA9IHsgYWRkOiBmdW5jdGlvbiBhZGQoKSB7XFxuICAgICAgICByZXR1cm4gZiAmJiAoYyAmJiAhYiAmJiAoaCA9IGYubGVuZ3RoIC0gMSwgZy5wdXNoKGMpKSwgZnVuY3Rpb24gZChiKSB7XFxuICAgICAgICAgIG4uZWFjaChiLCBmdW5jdGlvbiAoYiwgYykge1xcbiAgICAgICAgICAgIG4uaXNGdW5jdGlvbihjKSA/IGEudW5pcXVlICYmIGouaGFzKGMpIHx8IGYucHVzaChjKSA6IGMgJiYgYy5sZW5ndGggJiYgXFxcInN0cmluZ1xcXCIgIT09IG4udHlwZShjKSAmJiBkKGMpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0oYXJndW1lbnRzKSwgYyAmJiAhYiAmJiBpKCkpLCB0aGlzO1xcbiAgICAgIH0sIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xcbiAgICAgICAgcmV0dXJuIG4uZWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICAgIHZhciBjO3doaWxlICgoYyA9IG4uaW5BcnJheShiLCBmLCBjKSkgPiAtMSkge1xcbiAgICAgICAgICAgIGYuc3BsaWNlKGMsIDEpLCBoID49IGMgJiYgaC0tO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KSwgdGhpcztcXG4gICAgICB9LCBoYXM6IGZ1bmN0aW9uIGhhcyhhKSB7XFxuICAgICAgICByZXR1cm4gYSA/IG4uaW5BcnJheShhLCBmKSA+IC0xIDogZi5sZW5ndGggPiAwO1xcbiAgICAgIH0sIGVtcHR5OiBmdW5jdGlvbiBlbXB0eSgpIHtcXG4gICAgICAgIHJldHVybiBmICYmIChmID0gW10pLCB0aGlzO1xcbiAgICAgIH0sIGRpc2FibGU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XFxuICAgICAgICByZXR1cm4gZSA9IGcgPSBbXSwgZiA9IGMgPSBcXFwiXFxcIiwgdGhpcztcXG4gICAgICB9LCBkaXNhYmxlZDogZnVuY3Rpb24gZGlzYWJsZWQoKSB7XFxuICAgICAgICByZXR1cm4gIWY7XFxuICAgICAgfSwgbG9jazogZnVuY3Rpb24gbG9jaygpIHtcXG4gICAgICAgIHJldHVybiBlID0gZyA9IFtdLCBjIHx8IChmID0gYyA9IFxcXCJcXFwiKSwgdGhpcztcXG4gICAgICB9LCBsb2NrZWQ6IGZ1bmN0aW9uIGxvY2tlZCgpIHtcXG4gICAgICAgIHJldHVybiAhIWU7XFxuICAgICAgfSwgZmlyZVdpdGg6IGZ1bmN0aW9uIGZpcmVXaXRoKGEsIGMpIHtcXG4gICAgICAgIHJldHVybiBlIHx8IChjID0gYyB8fCBbXSwgYyA9IFthLCBjLnNsaWNlID8gYy5zbGljZSgpIDogY10sIGcucHVzaChjKSwgYiB8fCBpKCkpLCB0aGlzO1xcbiAgICAgIH0sIGZpcmU6IGZ1bmN0aW9uIGZpcmUoKSB7XFxuICAgICAgICByZXR1cm4gai5maXJlV2l0aCh0aGlzLCBhcmd1bWVudHMpLCB0aGlzO1xcbiAgICAgIH0sIGZpcmVkOiBmdW5jdGlvbiBmaXJlZCgpIHtcXG4gICAgICAgIHJldHVybiAhIWQ7XFxuICAgICAgfSB9O3JldHVybiBqO1xcbiAgfSwgbi5leHRlbmQoeyBEZWZlcnJlZDogZnVuY3Rpb24gRGVmZXJyZWQoYSkge1xcbiAgICAgIHZhciBiID0gW1tcXFwicmVzb2x2ZVxcXCIsIFxcXCJkb25lXFxcIiwgbi5DYWxsYmFja3MoXFxcIm9uY2UgbWVtb3J5XFxcIiksIFxcXCJyZXNvbHZlZFxcXCJdLCBbXFxcInJlamVjdFxcXCIsIFxcXCJmYWlsXFxcIiwgbi5DYWxsYmFja3MoXFxcIm9uY2UgbWVtb3J5XFxcIiksIFxcXCJyZWplY3RlZFxcXCJdLCBbXFxcIm5vdGlmeVxcXCIsIFxcXCJwcm9ncmVzc1xcXCIsIG4uQ2FsbGJhY2tzKFxcXCJtZW1vcnlcXFwiKV1dLFxcbiAgICAgICAgICBjID0gXFxcInBlbmRpbmdcXFwiLFxcbiAgICAgICAgICBkID0geyBzdGF0ZTogZnVuY3Rpb24gc3RhdGUoKSB7XFxuICAgICAgICAgIHJldHVybiBjO1xcbiAgICAgICAgfSwgYWx3YXlzOiBmdW5jdGlvbiBhbHdheXMoKSB7XFxuICAgICAgICAgIHJldHVybiBlLmRvbmUoYXJndW1lbnRzKS5mYWlsKGFyZ3VtZW50cyksIHRoaXM7XFxuICAgICAgICB9LCB0aGVuOiBmdW5jdGlvbiB0aGVuKCkge1xcbiAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztyZXR1cm4gbi5EZWZlcnJlZChmdW5jdGlvbiAoYykge1xcbiAgICAgICAgICAgIG4uZWFjaChiLCBmdW5jdGlvbiAoYiwgZikge1xcbiAgICAgICAgICAgICAgdmFyIGcgPSBuLmlzRnVuY3Rpb24oYVtiXSkgJiYgYVtiXTtlW2ZbMV1dKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBnICYmIGcuYXBwbHkodGhpcywgYXJndW1lbnRzKTthICYmIG4uaXNGdW5jdGlvbihhLnByb21pc2UpID8gYS5wcm9taXNlKCkucHJvZ3Jlc3MoYy5ub3RpZnkpLmRvbmUoYy5yZXNvbHZlKS5mYWlsKGMucmVqZWN0KSA6IGNbZlswXSArIFxcXCJXaXRoXFxcIl0odGhpcyA9PT0gZCA/IGMucHJvbWlzZSgpIDogdGhpcywgZyA/IFthXSA6IGFyZ3VtZW50cyk7XFxuICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9KSwgYSA9IG51bGw7XFxuICAgICAgICAgIH0pLnByb21pc2UoKTtcXG4gICAgICAgIH0sIHByb21pc2U6IGZ1bmN0aW9uIHByb21pc2UoYSkge1xcbiAgICAgICAgICByZXR1cm4gbnVsbCAhPSBhID8gbi5leHRlbmQoYSwgZCkgOiBkO1xcbiAgICAgICAgfSB9LFxcbiAgICAgICAgICBlID0ge307cmV0dXJuIGQucGlwZSA9IGQudGhlbiwgbi5lYWNoKGIsIGZ1bmN0aW9uIChhLCBmKSB7XFxuICAgICAgICB2YXIgZyA9IGZbMl0sXFxuICAgICAgICAgICAgaCA9IGZbM107ZFtmWzFdXSA9IGcuYWRkLCBoICYmIGcuYWRkKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgYyA9IGg7XFxuICAgICAgICB9LCBiWzEgXiBhXVsyXS5kaXNhYmxlLCBiWzJdWzJdLmxvY2spLCBlW2ZbMF1dID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICByZXR1cm4gZVtmWzBdICsgXFxcIldpdGhcXFwiXSh0aGlzID09PSBlID8gZCA6IHRoaXMsIGFyZ3VtZW50cyksIHRoaXM7XFxuICAgICAgICB9LCBlW2ZbMF0gKyBcXFwiV2l0aFxcXCJdID0gZy5maXJlV2l0aDtcXG4gICAgICB9KSwgZC5wcm9taXNlKGUpLCBhICYmIGEuY2FsbChlLCBlKSwgZTtcXG4gICAgfSwgd2hlbjogZnVuY3Rpb24gd2hlbihhKSB7XFxuICAgICAgdmFyIGIgPSAwLFxcbiAgICAgICAgICBjID0gZS5jYWxsKGFyZ3VtZW50cyksXFxuICAgICAgICAgIGQgPSBjLmxlbmd0aCxcXG4gICAgICAgICAgZiA9IDEgIT09IGQgfHwgYSAmJiBuLmlzRnVuY3Rpb24oYS5wcm9taXNlKSA/IGQgOiAwLFxcbiAgICAgICAgICBnID0gMSA9PT0gZiA/IGEgOiBuLkRlZmVycmVkKCksXFxuICAgICAgICAgIGggPSBmdW5jdGlvbiBoKGEsIGIsIGMpIHtcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZCkge1xcbiAgICAgICAgICBiW2FdID0gdGhpcywgY1thXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gZS5jYWxsKGFyZ3VtZW50cykgOiBkLCBjID09PSBpID8gZy5ub3RpZnlXaXRoKGIsIGMpIDogLS1mIHx8IGcucmVzb2x2ZVdpdGgoYiwgYyk7XFxuICAgICAgICB9O1xcbiAgICAgIH0sXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGosXFxuICAgICAgICAgIGs7aWYgKGQgPiAxKSBmb3IgKGkgPSBuZXcgQXJyYXkoZCksIGogPSBuZXcgQXJyYXkoZCksIGsgPSBuZXcgQXJyYXkoZCk7IGQgPiBiOyBiKyspIHtcXG4gICAgICAgIGNbYl0gJiYgbi5pc0Z1bmN0aW9uKGNbYl0ucHJvbWlzZSkgPyBjW2JdLnByb21pc2UoKS5wcm9ncmVzcyhoKGIsIGosIGkpKS5kb25lKGgoYiwgaywgYykpLmZhaWwoZy5yZWplY3QpIDogLS1mO1xcbiAgICAgIH1yZXR1cm4gZiB8fCBnLnJlc29sdmVXaXRoKGssIGMpLCBnLnByb21pc2UoKTtcXG4gICAgfSB9KTt2YXIgSTtuLmZuLnJlYWR5ID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgcmV0dXJuIG4ucmVhZHkucHJvbWlzZSgpLmRvbmUoYSksIHRoaXM7XFxuICB9LCBuLmV4dGVuZCh7IGlzUmVhZHk6ICExLCByZWFkeVdhaXQ6IDEsIGhvbGRSZWFkeTogZnVuY3Rpb24gaG9sZFJlYWR5KGEpIHtcXG4gICAgICBhID8gbi5yZWFkeVdhaXQrKyA6IG4ucmVhZHkoITApO1xcbiAgICB9LCByZWFkeTogZnVuY3Rpb24gcmVhZHkoYSkge1xcbiAgICAgIChhID09PSAhMCA/IC0tbi5yZWFkeVdhaXQgOiBuLmlzUmVhZHkpIHx8IChuLmlzUmVhZHkgPSAhMCwgYSAhPT0gITAgJiYgLS1uLnJlYWR5V2FpdCA+IDAgfHwgKEkucmVzb2x2ZVdpdGgoZCwgW25dKSwgbi5mbi50cmlnZ2VySGFuZGxlciAmJiAobihkKS50cmlnZ2VySGFuZGxlcihcXFwicmVhZHlcXFwiKSwgbihkKS5vZmYoXFxcInJlYWR5XFxcIikpKSk7XFxuICAgIH0gfSk7ZnVuY3Rpb24gSigpIHtcXG4gICAgZC5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJET01Db250ZW50TG9hZGVkXFxcIiwgSiksIGEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcXFwibG9hZFxcXCIsIEopLCBuLnJlYWR5KCk7XFxuICB9bi5yZWFkeS5wcm9taXNlID0gZnVuY3Rpb24gKGIpIHtcXG4gICAgcmV0dXJuIEkgfHwgKEkgPSBuLkRlZmVycmVkKCksIFxcXCJjb21wbGV0ZVxcXCIgPT09IGQucmVhZHlTdGF0ZSB8fCBcXFwibG9hZGluZ1xcXCIgIT09IGQucmVhZHlTdGF0ZSAmJiAhZC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgPyBhLnNldFRpbWVvdXQobi5yZWFkeSkgOiAoZC5hZGRFdmVudExpc3RlbmVyKFxcXCJET01Db250ZW50TG9hZGVkXFxcIiwgSiksIGEuYWRkRXZlbnRMaXN0ZW5lcihcXFwibG9hZFxcXCIsIEopKSksIEkucHJvbWlzZShiKTtcXG4gIH0sIG4ucmVhZHkucHJvbWlzZSgpO3ZhciBLID0gZnVuY3Rpb24gSyhhLCBiLCBjLCBkLCBlLCBmLCBnKSB7XFxuICAgIHZhciBoID0gMCxcXG4gICAgICAgIGkgPSBhLmxlbmd0aCxcXG4gICAgICAgIGogPSBudWxsID09IGM7aWYgKFxcXCJvYmplY3RcXFwiID09PSBuLnR5cGUoYykpIHtcXG4gICAgICBlID0gITA7Zm9yIChoIGluIGMpIHtcXG4gICAgICAgIEsoYSwgYiwgaCwgY1toXSwgITAsIGYsIGcpO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmICh2b2lkIDAgIT09IGQgJiYgKGUgPSAhMCwgbi5pc0Z1bmN0aW9uKGQpIHx8IChnID0gITApLCBqICYmIChnID8gKGIuY2FsbChhLCBkKSwgYiA9IG51bGwpIDogKGogPSBiLCBiID0gZnVuY3Rpb24gYihhLCBfYiwgYykge1xcbiAgICAgIHJldHVybiBqLmNhbGwobihhKSwgYyk7XFxuICAgIH0pKSwgYikpIGZvciAoOyBpID4gaDsgaCsrKSB7XFxuICAgICAgYihhW2hdLCBjLCBnID8gZCA6IGQuY2FsbChhW2hdLCBoLCBiKGFbaF0sIGMpKSk7XFxuICAgIH1yZXR1cm4gZSA/IGEgOiBqID8gYi5jYWxsKGEpIDogaSA/IGIoYVswXSwgYykgOiBmO1xcbiAgfSxcXG4gICAgICBMID0gZnVuY3Rpb24gTChhKSB7XFxuICAgIHJldHVybiAxID09PSBhLm5vZGVUeXBlIHx8IDkgPT09IGEubm9kZVR5cGUgfHwgISthLm5vZGVUeXBlO1xcbiAgfTtmdW5jdGlvbiBNKCkge1xcbiAgICB0aGlzLmV4cGFuZG8gPSBuLmV4cGFuZG8gKyBNLnVpZCsrO1xcbiAgfU0udWlkID0gMSwgTS5wcm90b3R5cGUgPSB7IHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3RlcihhLCBiKSB7XFxuICAgICAgdmFyIGMgPSBiIHx8IHt9O3JldHVybiBhLm5vZGVUeXBlID8gYVt0aGlzLmV4cGFuZG9dID0gYyA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCB0aGlzLmV4cGFuZG8sIHsgdmFsdWU6IGMsIHdyaXRhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCB9KSwgYVt0aGlzLmV4cGFuZG9dO1xcbiAgICB9LCBjYWNoZTogZnVuY3Rpb24gY2FjaGUoYSkge1xcbiAgICAgIGlmICghTChhKSkgcmV0dXJuIHt9O3ZhciBiID0gYVt0aGlzLmV4cGFuZG9dO3JldHVybiBiIHx8IChiID0ge30sIEwoYSkgJiYgKGEubm9kZVR5cGUgPyBhW3RoaXMuZXhwYW5kb10gPSBiIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsIHRoaXMuZXhwYW5kbywgeyB2YWx1ZTogYiwgY29uZmlndXJhYmxlOiAhMCB9KSkpLCBiO1xcbiAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldChhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQsXFxuICAgICAgICAgIGUgPSB0aGlzLmNhY2hlKGEpO2lmIChcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYikgZVtiXSA9IGM7ZWxzZSBmb3IgKGQgaW4gYikge1xcbiAgICAgICAgZVtkXSA9IGJbZF07XFxuICAgICAgfXJldHVybiBlO1xcbiAgICB9LCBnZXQ6IGZ1bmN0aW9uIGdldChhLCBiKSB7XFxuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gYiA/IHRoaXMuY2FjaGUoYSkgOiBhW3RoaXMuZXhwYW5kb10gJiYgYVt0aGlzLmV4cGFuZG9dW2JdO1xcbiAgICB9LCBhY2Nlc3M6IGZ1bmN0aW9uIGFjY2VzcyhhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQ7cmV0dXJuIHZvaWQgMCA9PT0gYiB8fCBiICYmIFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBiICYmIHZvaWQgMCA9PT0gYyA/IChkID0gdGhpcy5nZXQoYSwgYiksIHZvaWQgMCAhPT0gZCA/IGQgOiB0aGlzLmdldChhLCBuLmNhbWVsQ2FzZShiKSkpIDogKHRoaXMuc2V0KGEsIGIsIGMpLCB2b2lkIDAgIT09IGMgPyBjIDogYik7XFxuICAgIH0sIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGEsIGIpIHtcXG4gICAgICB2YXIgYyxcXG4gICAgICAgICAgZCxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZiA9IGFbdGhpcy5leHBhbmRvXTtpZiAodm9pZCAwICE9PSBmKSB7XFxuICAgICAgICBpZiAodm9pZCAwID09PSBiKSB0aGlzLnJlZ2lzdGVyKGEpO2Vsc2Uge1xcbiAgICAgICAgICBuLmlzQXJyYXkoYikgPyBkID0gYi5jb25jYXQoYi5tYXAobi5jYW1lbENhc2UpKSA6IChlID0gbi5jYW1lbENhc2UoYiksIGIgaW4gZiA/IGQgPSBbYiwgZV0gOiAoZCA9IGUsIGQgPSBkIGluIGYgPyBbZF0gOiBkLm1hdGNoKEcpIHx8IFtdKSksIGMgPSBkLmxlbmd0aDt3aGlsZSAoYy0tKSB7XFxuICAgICAgICAgICAgZGVsZXRlIGZbZFtjXV07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0odm9pZCAwID09PSBiIHx8IG4uaXNFbXB0eU9iamVjdChmKSkgJiYgKGEubm9kZVR5cGUgPyBhW3RoaXMuZXhwYW5kb10gPSB2b2lkIDAgOiBkZWxldGUgYVt0aGlzLmV4cGFuZG9dKTtcXG4gICAgICB9XFxuICAgIH0sIGhhc0RhdGE6IGZ1bmN0aW9uIGhhc0RhdGEoYSkge1xcbiAgICAgIHZhciBiID0gYVt0aGlzLmV4cGFuZG9dO3JldHVybiB2b2lkIDAgIT09IGIgJiYgIW4uaXNFbXB0eU9iamVjdChiKTtcXG4gICAgfSB9O3ZhciBOID0gbmV3IE0oKSxcXG4gICAgICBPID0gbmV3IE0oKSxcXG4gICAgICBQID0gL14oPzpcXFxce1tcXFxcd1xcXFxXXSpcXFxcfXxcXFxcW1tcXFxcd1xcXFxXXSpcXFxcXSkkLyxcXG4gICAgICBRID0gL1tBLVpdL2c7ZnVuY3Rpb24gUihhLCBiLCBjKSB7XFxuICAgIHZhciBkO2lmICh2b2lkIDAgPT09IGMgJiYgMSA9PT0gYS5ub2RlVHlwZSkgaWYgKGQgPSBcXFwiZGF0YS1cXFwiICsgYi5yZXBsYWNlKFEsIFxcXCItJCZcXFwiKS50b0xvd2VyQ2FzZSgpLCBjID0gYS5nZXRBdHRyaWJ1dGUoZCksIFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBjKSB7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGMgPSBcXFwidHJ1ZVxcXCIgPT09IGMgPyAhMCA6IFxcXCJmYWxzZVxcXCIgPT09IGMgPyAhMSA6IFxcXCJudWxsXFxcIiA9PT0gYyA/IG51bGwgOiArYyArIFxcXCJcXFwiID09PSBjID8gK2MgOiBQLnRlc3QoYykgPyBuLnBhcnNlSlNPTihjKSA6IGM7XFxuICAgICAgfSBjYXRjaCAoZSkge31PLnNldChhLCBiLCBjKTtcXG4gICAgfSBlbHNlIGMgPSB2b2lkIDA7cmV0dXJuIGM7XFxuICB9bi5leHRlbmQoeyBoYXNEYXRhOiBmdW5jdGlvbiBoYXNEYXRhKGEpIHtcXG4gICAgICByZXR1cm4gTy5oYXNEYXRhKGEpIHx8IE4uaGFzRGF0YShhKTtcXG4gICAgfSwgZGF0YTogZnVuY3Rpb24gZGF0YShhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIE8uYWNjZXNzKGEsIGIsIGMpO1xcbiAgICB9LCByZW1vdmVEYXRhOiBmdW5jdGlvbiByZW1vdmVEYXRhKGEsIGIpIHtcXG4gICAgICBPLnJlbW92ZShhLCBiKTtcXG4gICAgfSwgX2RhdGE6IGZ1bmN0aW9uIF9kYXRhKGEsIGIsIGMpIHtcXG4gICAgICByZXR1cm4gTi5hY2Nlc3MoYSwgYiwgYyk7XFxuICAgIH0sIF9yZW1vdmVEYXRhOiBmdW5jdGlvbiBfcmVtb3ZlRGF0YShhLCBiKSB7XFxuICAgICAgTi5yZW1vdmUoYSwgYik7XFxuICAgIH0gfSksIG4uZm4uZXh0ZW5kKHsgZGF0YTogZnVuY3Rpb24gZGF0YShhLCBiKSB7XFxuICAgICAgdmFyIGMsXFxuICAgICAgICAgIGQsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIGYgPSB0aGlzWzBdLFxcbiAgICAgICAgICBnID0gZiAmJiBmLmF0dHJpYnV0ZXM7aWYgKHZvaWQgMCA9PT0gYSkge1xcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoICYmIChlID0gTy5nZXQoZiksIDEgPT09IGYubm9kZVR5cGUgJiYgIU4uZ2V0KGYsIFxcXCJoYXNEYXRhQXR0cnNcXFwiKSkpIHtcXG4gICAgICAgICAgYyA9IGcubGVuZ3RoO3doaWxlIChjLS0pIHtcXG4gICAgICAgICAgICBnW2NdICYmIChkID0gZ1tjXS5uYW1lLCAwID09PSBkLmluZGV4T2YoXFxcImRhdGEtXFxcIikgJiYgKGQgPSBuLmNhbWVsQ2FzZShkLnNsaWNlKDUpKSwgUihmLCBkLCBlW2RdKSkpO1xcbiAgICAgICAgICB9Ti5zZXQoZiwgXFxcImhhc0RhdGFBdHRyc1xcXCIsICEwKTtcXG4gICAgICAgIH1yZXR1cm4gZTtcXG4gICAgICB9cmV0dXJuIFxcXCJvYmplY3RcXFwiID09ICh0eXBlb2YgYSA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoYSkpID8gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIE8uc2V0KHRoaXMsIGEpO1xcbiAgICAgIH0pIDogSyh0aGlzLCBmdW5jdGlvbiAoYikge1xcbiAgICAgICAgdmFyIGMsIGQ7aWYgKGYgJiYgdm9pZCAwID09PSBiKSB7XFxuICAgICAgICAgIGlmIChjID0gTy5nZXQoZiwgYSkgfHwgTy5nZXQoZiwgYS5yZXBsYWNlKFEsIFxcXCItJCZcXFwiKS50b0xvd2VyQ2FzZSgpKSwgdm9pZCAwICE9PSBjKSByZXR1cm4gYztpZiAoZCA9IG4uY2FtZWxDYXNlKGEpLCBjID0gTy5nZXQoZiwgZCksIHZvaWQgMCAhPT0gYykgcmV0dXJuIGM7aWYgKGMgPSBSKGYsIGQsIHZvaWQgMCksIHZvaWQgMCAhPT0gYykgcmV0dXJuIGM7XFxuICAgICAgICB9IGVsc2UgZCA9IG4uY2FtZWxDYXNlKGEpLCB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgYyA9IE8uZ2V0KHRoaXMsIGQpO08uc2V0KHRoaXMsIGQsIGIpLCBhLmluZGV4T2YoXFxcIi1cXFwiKSA+IC0xICYmIHZvaWQgMCAhPT0gYyAmJiBPLnNldCh0aGlzLCBhLCBiKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0sIG51bGwsIGIsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCAhMCk7XFxuICAgIH0sIHJlbW92ZURhdGE6IGZ1bmN0aW9uIHJlbW92ZURhdGEoYSkge1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgTy5yZW1vdmUodGhpcywgYSk7XFxuICAgICAgfSk7XFxuICAgIH0gfSksIG4uZXh0ZW5kKHsgcXVldWU6IGZ1bmN0aW9uIHF1ZXVlKGEsIGIsIGMpIHtcXG4gICAgICB2YXIgZDtyZXR1cm4gYSA/IChiID0gKGIgfHwgXFxcImZ4XFxcIikgKyBcXFwicXVldWVcXFwiLCBkID0gTi5nZXQoYSwgYiksIGMgJiYgKCFkIHx8IG4uaXNBcnJheShjKSA/IGQgPSBOLmFjY2VzcyhhLCBiLCBuLm1ha2VBcnJheShjKSkgOiBkLnB1c2goYykpLCBkIHx8IFtdKSA6IHZvaWQgMDtcXG4gICAgfSwgZGVxdWV1ZTogZnVuY3Rpb24gZGVxdWV1ZShhLCBiKSB7XFxuICAgICAgYiA9IGIgfHwgXFxcImZ4XFxcIjt2YXIgYyA9IG4ucXVldWUoYSwgYiksXFxuICAgICAgICAgIGQgPSBjLmxlbmd0aCxcXG4gICAgICAgICAgZSA9IGMuc2hpZnQoKSxcXG4gICAgICAgICAgZiA9IG4uX3F1ZXVlSG9va3MoYSwgYiksXFxuICAgICAgICAgIGcgPSBmdW5jdGlvbiBnKCkge1xcbiAgICAgICAgbi5kZXF1ZXVlKGEsIGIpO1xcbiAgICAgIH07XFxcImlucHJvZ3Jlc3NcXFwiID09PSBlICYmIChlID0gYy5zaGlmdCgpLCBkLS0pLCBlICYmIChcXFwiZnhcXFwiID09PSBiICYmIGMudW5zaGlmdChcXFwiaW5wcm9ncmVzc1xcXCIpLCBkZWxldGUgZi5zdG9wLCBlLmNhbGwoYSwgZywgZikpLCAhZCAmJiBmICYmIGYuZW1wdHkuZmlyZSgpO1xcbiAgICB9LCBfcXVldWVIb29rczogZnVuY3Rpb24gX3F1ZXVlSG9va3MoYSwgYikge1xcbiAgICAgIHZhciBjID0gYiArIFxcXCJxdWV1ZUhvb2tzXFxcIjtyZXR1cm4gTi5nZXQoYSwgYykgfHwgTi5hY2Nlc3MoYSwgYywgeyBlbXB0eTogbi5DYWxsYmFja3MoXFxcIm9uY2UgbWVtb3J5XFxcIikuYWRkKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgTi5yZW1vdmUoYSwgW2IgKyBcXFwicXVldWVcXFwiLCBjXSk7XFxuICAgICAgICB9KSB9KTtcXG4gICAgfSB9KSwgbi5mbi5leHRlbmQoeyBxdWV1ZTogZnVuY3Rpb24gcXVldWUoYSwgYikge1xcbiAgICAgIHZhciBjID0gMjtyZXR1cm4gXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGEgJiYgKGIgPSBhLCBhID0gXFxcImZ4XFxcIiwgYy0tKSwgYXJndW1lbnRzLmxlbmd0aCA8IGMgPyBuLnF1ZXVlKHRoaXNbMF0sIGEpIDogdm9pZCAwID09PSBiID8gdGhpcyA6IHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYyA9IG4ucXVldWUodGhpcywgYSwgYik7bi5fcXVldWVIb29rcyh0aGlzLCBhKSwgXFxcImZ4XFxcIiA9PT0gYSAmJiBcXFwiaW5wcm9ncmVzc1xcXCIgIT09IGNbMF0gJiYgbi5kZXF1ZXVlKHRoaXMsIGEpO1xcbiAgICAgIH0pO1xcbiAgICB9LCBkZXF1ZXVlOiBmdW5jdGlvbiBkZXF1ZXVlKGEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIG4uZGVxdWV1ZSh0aGlzLCBhKTtcXG4gICAgICB9KTtcXG4gICAgfSwgY2xlYXJRdWV1ZTogZnVuY3Rpb24gY2xlYXJRdWV1ZShhKSB7XFxuICAgICAgcmV0dXJuIHRoaXMucXVldWUoYSB8fCBcXFwiZnhcXFwiLCBbXSk7XFxuICAgIH0sIHByb21pc2U6IGZ1bmN0aW9uIHByb21pc2UoYSwgYikge1xcbiAgICAgIHZhciBjLFxcbiAgICAgICAgICBkID0gMSxcXG4gICAgICAgICAgZSA9IG4uRGVmZXJyZWQoKSxcXG4gICAgICAgICAgZiA9IHRoaXMsXFxuICAgICAgICAgIGcgPSB0aGlzLmxlbmd0aCxcXG4gICAgICAgICAgaCA9IGZ1bmN0aW9uIGgoKSB7XFxuICAgICAgICAtLWQgfHwgZS5yZXNvbHZlV2l0aChmLCBbZl0pO1xcbiAgICAgIH07XFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGEgJiYgKGIgPSBhLCBhID0gdm9pZCAwKSwgYSA9IGEgfHwgXFxcImZ4XFxcIjt3aGlsZSAoZy0tKSB7XFxuICAgICAgICBjID0gTi5nZXQoZltnXSwgYSArIFxcXCJxdWV1ZUhvb2tzXFxcIiksIGMgJiYgYy5lbXB0eSAmJiAoZCsrLCBjLmVtcHR5LmFkZChoKSk7XFxuICAgICAgfXJldHVybiBoKCksIGUucHJvbWlzZShiKTtcXG4gICAgfSB9KTt2YXIgUyA9IC9bKy1dPyg/OlxcXFxkKlxcXFwufClcXFxcZCsoPzpbZUVdWystXT9cXFxcZCt8KS8uc291cmNlLFxcbiAgICAgIFQgPSBuZXcgUmVnRXhwKFxcXCJeKD86KFsrLV0pPXwpKFxcXCIgKyBTICsgXFxcIikoW2EteiVdKikkXFxcIiwgXFxcImlcXFwiKSxcXG4gICAgICBVID0gW1xcXCJUb3BcXFwiLCBcXFwiUmlnaHRcXFwiLCBcXFwiQm90dG9tXFxcIiwgXFxcIkxlZnRcXFwiXSxcXG4gICAgICBWID0gZnVuY3Rpb24gVihhLCBiKSB7XFxuICAgIHJldHVybiBhID0gYiB8fCBhLCBcXFwibm9uZVxcXCIgPT09IG4uY3NzKGEsIFxcXCJkaXNwbGF5XFxcIikgfHwgIW4uY29udGFpbnMoYS5vd25lckRvY3VtZW50LCBhKTtcXG4gIH07ZnVuY3Rpb24gVyhhLCBiLCBjLCBkKSB7XFxuICAgIHZhciBlLFxcbiAgICAgICAgZiA9IDEsXFxuICAgICAgICBnID0gMjAsXFxuICAgICAgICBoID0gZCA/IGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gZC5jdXIoKTtcXG4gICAgfSA6IGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gbi5jc3MoYSwgYiwgXFxcIlxcXCIpO1xcbiAgICB9LFxcbiAgICAgICAgaSA9IGgoKSxcXG4gICAgICAgIGogPSBjICYmIGNbM10gfHwgKG4uY3NzTnVtYmVyW2JdID8gXFxcIlxcXCIgOiBcXFwicHhcXFwiKSxcXG4gICAgICAgIGsgPSAobi5jc3NOdW1iZXJbYl0gfHwgXFxcInB4XFxcIiAhPT0gaiAmJiAraSkgJiYgVC5leGVjKG4uY3NzKGEsIGIpKTtpZiAoayAmJiBrWzNdICE9PSBqKSB7XFxuICAgICAgaiA9IGogfHwga1szXSwgYyA9IGMgfHwgW10sIGsgPSAraSB8fCAxO2RvIHtcXG4gICAgICAgIGYgPSBmIHx8IFxcXCIuNVxcXCIsIGsgLz0gZiwgbi5zdHlsZShhLCBiLCBrICsgaik7XFxuICAgICAgfSB3aGlsZSAoZiAhPT0gKGYgPSBoKCkgLyBpKSAmJiAxICE9PSBmICYmIC0tZyk7XFxuICAgIH1yZXR1cm4gYyAmJiAoayA9ICtrIHx8ICtpIHx8IDAsIGUgPSBjWzFdID8gayArIChjWzFdICsgMSkgKiBjWzJdIDogK2NbMl0sIGQgJiYgKGQudW5pdCA9IGosIGQuc3RhcnQgPSBrLCBkLmVuZCA9IGUpKSwgZTtcXG4gIH12YXIgWCA9IC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pLFxcbiAgICAgIFkgPSAvPChbXFxcXHc6LV0rKS8sXFxuICAgICAgWiA9IC9eJHxcXFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSxcXG4gICAgICAkID0geyBvcHRpb246IFsxLCBcXFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlxcXCIsIFxcXCI8L3NlbGVjdD5cXFwiXSwgdGhlYWQ6IFsxLCBcXFwiPHRhYmxlPlxcXCIsIFxcXCI8L3RhYmxlPlxcXCJdLCBjb2w6IFsyLCBcXFwiPHRhYmxlPjxjb2xncm91cD5cXFwiLCBcXFwiPC9jb2xncm91cD48L3RhYmxlPlxcXCJdLCB0cjogWzIsIFxcXCI8dGFibGU+PHRib2R5PlxcXCIsIFxcXCI8L3Rib2R5PjwvdGFibGU+XFxcIl0sIHRkOiBbMywgXFxcIjx0YWJsZT48dGJvZHk+PHRyPlxcXCIsIFxcXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cXFwiXSwgX2RlZmF1bHQ6IFswLCBcXFwiXFxcIiwgXFxcIlxcXCJdIH07JC5vcHRncm91cCA9ICQub3B0aW9uLCAkLnRib2R5ID0gJC50Zm9vdCA9ICQuY29sZ3JvdXAgPSAkLmNhcHRpb24gPSAkLnRoZWFkLCAkLnRoID0gJC50ZDtmdW5jdGlvbiBfKGEsIGIpIHtcXG4gICAgdmFyIGMgPSBcXFwidW5kZWZpbmVkXFxcIiAhPSB0eXBlb2YgYS5nZXRFbGVtZW50c0J5VGFnTmFtZSA/IGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYiB8fCBcXFwiKlxcXCIpIDogXFxcInVuZGVmaW5lZFxcXCIgIT0gdHlwZW9mIGEucXVlcnlTZWxlY3RvckFsbCA/IGEucXVlcnlTZWxlY3RvckFsbChiIHx8IFxcXCIqXFxcIikgOiBbXTtyZXR1cm4gdm9pZCAwID09PSBiIHx8IGIgJiYgbi5ub2RlTmFtZShhLCBiKSA/IG4ubWVyZ2UoW2FdLCBjKSA6IGM7XFxuICB9ZnVuY3Rpb24gYWEoYSwgYikge1xcbiAgICBmb3IgKHZhciBjID0gMCwgZCA9IGEubGVuZ3RoOyBkID4gYzsgYysrKSB7XFxuICAgICAgTi5zZXQoYVtjXSwgXFxcImdsb2JhbEV2YWxcXFwiLCAhYiB8fCBOLmdldChiW2NdLCBcXFwiZ2xvYmFsRXZhbFxcXCIpKTtcXG4gICAgfVxcbiAgfXZhciBiYSA9IC88fCYjP1xcXFx3KzsvO2Z1bmN0aW9uIGNhKGEsIGIsIGMsIGQsIGUpIHtcXG4gICAgZm9yICh2YXIgZiwgZywgaCwgaSwgaiwgaywgbCA9IGIuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBtID0gW10sIG8gPSAwLCBwID0gYS5sZW5ndGg7IHAgPiBvOyBvKyspIHtcXG4gICAgICBpZiAoZiA9IGFbb10sIGYgfHwgMCA9PT0gZikgaWYgKFxcXCJvYmplY3RcXFwiID09PSBuLnR5cGUoZikpIG4ubWVyZ2UobSwgZi5ub2RlVHlwZSA/IFtmXSA6IGYpO2Vsc2UgaWYgKGJhLnRlc3QoZikpIHtcXG4gICAgICAgIGcgPSBnIHx8IGwuYXBwZW5kQ2hpbGQoYi5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKSksIGggPSAoWS5leGVjKGYpIHx8IFtcXFwiXFxcIiwgXFxcIlxcXCJdKVsxXS50b0xvd2VyQ2FzZSgpLCBpID0gJFtoXSB8fCAkLl9kZWZhdWx0LCBnLmlubmVySFRNTCA9IGlbMV0gKyBuLmh0bWxQcmVmaWx0ZXIoZikgKyBpWzJdLCBrID0gaVswXTt3aGlsZSAoay0tKSB7XFxuICAgICAgICAgIGcgPSBnLmxhc3RDaGlsZDtcXG4gICAgICAgIH1uLm1lcmdlKG0sIGcuY2hpbGROb2RlcyksIGcgPSBsLmZpcnN0Q2hpbGQsIGcudGV4dENvbnRlbnQgPSBcXFwiXFxcIjtcXG4gICAgICB9IGVsc2UgbS5wdXNoKGIuY3JlYXRlVGV4dE5vZGUoZikpO1xcbiAgICB9bC50ZXh0Q29udGVudCA9IFxcXCJcXFwiLCBvID0gMDt3aGlsZSAoZiA9IG1bbysrXSkge1xcbiAgICAgIGlmIChkICYmIG4uaW5BcnJheShmLCBkKSA+IC0xKSBlICYmIGUucHVzaChmKTtlbHNlIGlmIChqID0gbi5jb250YWlucyhmLm93bmVyRG9jdW1lbnQsIGYpLCBnID0gXyhsLmFwcGVuZENoaWxkKGYpLCBcXFwic2NyaXB0XFxcIiksIGogJiYgYWEoZyksIGMpIHtcXG4gICAgICAgIGsgPSAwO3doaWxlIChmID0gZ1trKytdKSB7XFxuICAgICAgICAgIFoudGVzdChmLnR5cGUgfHwgXFxcIlxcXCIpICYmIGMucHVzaChmKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1yZXR1cm4gbDtcXG4gIH0hZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgYSA9IGQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxcbiAgICAgICAgYiA9IGEuYXBwZW5kQ2hpbGQoZC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKSksXFxuICAgICAgICBjID0gZC5jcmVhdGVFbGVtZW50KFxcXCJpbnB1dFxcXCIpO2Muc2V0QXR0cmlidXRlKFxcXCJ0eXBlXFxcIiwgXFxcInJhZGlvXFxcIiksIGMuc2V0QXR0cmlidXRlKFxcXCJjaGVja2VkXFxcIiwgXFxcImNoZWNrZWRcXFwiKSwgYy5zZXRBdHRyaWJ1dGUoXFxcIm5hbWVcXFwiLCBcXFwidFxcXCIpLCBiLmFwcGVuZENoaWxkKGMpLCBsLmNoZWNrQ2xvbmUgPSBiLmNsb25lTm9kZSghMCkuY2xvbmVOb2RlKCEwKS5sYXN0Q2hpbGQuY2hlY2tlZCwgYi5pbm5lckhUTUwgPSBcXFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlxcXCIsIGwubm9DbG9uZUNoZWNrZWQgPSAhIWIuY2xvbmVOb2RlKCEwKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xcbiAgfSgpO3ZhciBkYSA9IC9ea2V5LyxcXG4gICAgICBlYSA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcXG4gICAgICBmYSA9IC9eKFteLl0qKSg/OlxcXFwuKC4rKXwpLztmdW5jdGlvbiBnYSgpIHtcXG4gICAgcmV0dXJuICEwO1xcbiAgfWZ1bmN0aW9uIGhhKCkge1xcbiAgICByZXR1cm4gITE7XFxuICB9ZnVuY3Rpb24gaWEoKSB7XFxuICAgIHRyeSB7XFxuICAgICAgcmV0dXJuIGQuYWN0aXZlRWxlbWVudDtcXG4gICAgfSBjYXRjaCAoYSkge31cXG4gIH1mdW5jdGlvbiBqYShhLCBiLCBjLCBkLCBlLCBmKSB7XFxuICAgIHZhciBnLCBoO2lmIChcXFwib2JqZWN0XFxcIiA9PSAodHlwZW9mIGIgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGIpKSkge1xcbiAgICAgIFxcXCJzdHJpbmdcXFwiICE9IHR5cGVvZiBjICYmIChkID0gZCB8fCBjLCBjID0gdm9pZCAwKTtmb3IgKGggaW4gYikge1xcbiAgICAgICAgamEoYSwgaCwgYywgZCwgYltoXSwgZik7XFxuICAgICAgfXJldHVybiBhO1xcbiAgICB9aWYgKG51bGwgPT0gZCAmJiBudWxsID09IGUgPyAoZSA9IGMsIGQgPSBjID0gdm9pZCAwKSA6IG51bGwgPT0gZSAmJiAoXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGMgPyAoZSA9IGQsIGQgPSB2b2lkIDApIDogKGUgPSBkLCBkID0gYywgYyA9IHZvaWQgMCkpLCBlID09PSAhMSkgZSA9IGhhO2Vsc2UgaWYgKCFlKSByZXR1cm4gYTtyZXR1cm4gMSA9PT0gZiAmJiAoZyA9IGUsIGUgPSBmdW5jdGlvbiBlKGEpIHtcXG4gICAgICByZXR1cm4gbigpLm9mZihhKSwgZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICB9LCBlLmd1aWQgPSBnLmd1aWQgfHwgKGcuZ3VpZCA9IG4uZ3VpZCsrKSksIGEuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgbi5ldmVudC5hZGQodGhpcywgYiwgZSwgZCwgYyk7XFxuICAgIH0pO1xcbiAgfW4uZXZlbnQgPSB7IGdsb2JhbDoge30sIGFkZDogZnVuY3Rpb24gYWRkKGEsIGIsIGMsIGQsIGUpIHtcXG4gICAgICB2YXIgZixcXG4gICAgICAgICAgZyxcXG4gICAgICAgICAgaCxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgayxcXG4gICAgICAgICAgbCxcXG4gICAgICAgICAgbSxcXG4gICAgICAgICAgbyxcXG4gICAgICAgICAgcCxcXG4gICAgICAgICAgcSxcXG4gICAgICAgICAgciA9IE4uZ2V0KGEpO2lmIChyKSB7XFxuICAgICAgICBjLmhhbmRsZXIgJiYgKGYgPSBjLCBjID0gZi5oYW5kbGVyLCBlID0gZi5zZWxlY3RvciksIGMuZ3VpZCB8fCAoYy5ndWlkID0gbi5ndWlkKyspLCAoaSA9IHIuZXZlbnRzKSB8fCAoaSA9IHIuZXZlbnRzID0ge30pLCAoZyA9IHIuaGFuZGxlKSB8fCAoZyA9IHIuaGFuZGxlID0gZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgICAgcmV0dXJuIFxcXCJ1bmRlZmluZWRcXFwiICE9IHR5cGVvZiBuICYmIG4uZXZlbnQudHJpZ2dlcmVkICE9PSBiLnR5cGUgPyBuLmV2ZW50LmRpc3BhdGNoLmFwcGx5KGEsIGFyZ3VtZW50cykgOiB2b2lkIDA7XFxuICAgICAgICB9KSwgYiA9IChiIHx8IFxcXCJcXFwiKS5tYXRjaChHKSB8fCBbXFxcIlxcXCJdLCBqID0gYi5sZW5ndGg7d2hpbGUgKGotLSkge1xcbiAgICAgICAgICBoID0gZmEuZXhlYyhiW2pdKSB8fCBbXSwgbyA9IHEgPSBoWzFdLCBwID0gKGhbMl0gfHwgXFxcIlxcXCIpLnNwbGl0KFxcXCIuXFxcIikuc29ydCgpLCBvICYmIChsID0gbi5ldmVudC5zcGVjaWFsW29dIHx8IHt9LCBvID0gKGUgPyBsLmRlbGVnYXRlVHlwZSA6IGwuYmluZFR5cGUpIHx8IG8sIGwgPSBuLmV2ZW50LnNwZWNpYWxbb10gfHwge30sIGsgPSBuLmV4dGVuZCh7IHR5cGU6IG8sIG9yaWdUeXBlOiBxLCBkYXRhOiBkLCBoYW5kbGVyOiBjLCBndWlkOiBjLmd1aWQsIHNlbGVjdG9yOiBlLCBuZWVkc0NvbnRleHQ6IGUgJiYgbi5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KGUpLCBuYW1lc3BhY2U6IHAuam9pbihcXFwiLlxcXCIpIH0sIGYpLCAobSA9IGlbb10pIHx8IChtID0gaVtvXSA9IFtdLCBtLmRlbGVnYXRlQ291bnQgPSAwLCBsLnNldHVwICYmIGwuc2V0dXAuY2FsbChhLCBkLCBwLCBnKSAhPT0gITEgfHwgYS5hZGRFdmVudExpc3RlbmVyICYmIGEuYWRkRXZlbnRMaXN0ZW5lcihvLCBnKSksIGwuYWRkICYmIChsLmFkZC5jYWxsKGEsIGspLCBrLmhhbmRsZXIuZ3VpZCB8fCAoay5oYW5kbGVyLmd1aWQgPSBjLmd1aWQpKSwgZSA/IG0uc3BsaWNlKG0uZGVsZWdhdGVDb3VudCsrLCAwLCBrKSA6IG0ucHVzaChrKSwgbi5ldmVudC5nbG9iYWxbb10gPSAhMCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LCByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShhLCBiLCBjLCBkLCBlKSB7XFxuICAgICAgdmFyIGYsXFxuICAgICAgICAgIGcsXFxuICAgICAgICAgIGgsXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGosXFxuICAgICAgICAgIGssXFxuICAgICAgICAgIGwsXFxuICAgICAgICAgIG0sXFxuICAgICAgICAgIG8sXFxuICAgICAgICAgIHAsXFxuICAgICAgICAgIHEsXFxuICAgICAgICAgIHIgPSBOLmhhc0RhdGEoYSkgJiYgTi5nZXQoYSk7aWYgKHIgJiYgKGkgPSByLmV2ZW50cykpIHtcXG4gICAgICAgIGIgPSAoYiB8fCBcXFwiXFxcIikubWF0Y2goRykgfHwgW1xcXCJcXFwiXSwgaiA9IGIubGVuZ3RoO3doaWxlIChqLS0pIHtcXG4gICAgICAgICAgaWYgKGggPSBmYS5leGVjKGJbal0pIHx8IFtdLCBvID0gcSA9IGhbMV0sIHAgPSAoaFsyXSB8fCBcXFwiXFxcIikuc3BsaXQoXFxcIi5cXFwiKS5zb3J0KCksIG8pIHtcXG4gICAgICAgICAgICBsID0gbi5ldmVudC5zcGVjaWFsW29dIHx8IHt9LCBvID0gKGQgPyBsLmRlbGVnYXRlVHlwZSA6IGwuYmluZFR5cGUpIHx8IG8sIG0gPSBpW29dIHx8IFtdLCBoID0gaFsyXSAmJiBuZXcgUmVnRXhwKFxcXCIoXnxcXFxcXFxcXC4pXFxcIiArIHAuam9pbihcXFwiXFxcXFxcXFwuKD86LipcXFxcXFxcXC58KVxcXCIpICsgXFxcIihcXFxcXFxcXC58JClcXFwiKSwgZyA9IGYgPSBtLmxlbmd0aDt3aGlsZSAoZi0tKSB7XFxuICAgICAgICAgICAgICBrID0gbVtmXSwgIWUgJiYgcSAhPT0gay5vcmlnVHlwZSB8fCBjICYmIGMuZ3VpZCAhPT0gay5ndWlkIHx8IGggJiYgIWgudGVzdChrLm5hbWVzcGFjZSkgfHwgZCAmJiBkICE9PSBrLnNlbGVjdG9yICYmIChcXFwiKipcXFwiICE9PSBkIHx8ICFrLnNlbGVjdG9yKSB8fCAobS5zcGxpY2UoZiwgMSksIGsuc2VsZWN0b3IgJiYgbS5kZWxlZ2F0ZUNvdW50LS0sIGwucmVtb3ZlICYmIGwucmVtb3ZlLmNhbGwoYSwgaykpO1xcbiAgICAgICAgICAgIH1nICYmICFtLmxlbmd0aCAmJiAobC50ZWFyZG93biAmJiBsLnRlYXJkb3duLmNhbGwoYSwgcCwgci5oYW5kbGUpICE9PSAhMSB8fCBuLnJlbW92ZUV2ZW50KGEsIG8sIHIuaGFuZGxlKSwgZGVsZXRlIGlbb10pO1xcbiAgICAgICAgICB9IGVsc2UgZm9yIChvIGluIGkpIHtcXG4gICAgICAgICAgICBuLmV2ZW50LnJlbW92ZShhLCBvICsgYltqXSwgYywgZCwgITApO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9bi5pc0VtcHR5T2JqZWN0KGkpICYmIE4ucmVtb3ZlKGEsIFxcXCJoYW5kbGUgZXZlbnRzXFxcIik7XFxuICAgICAgfVxcbiAgICB9LCBkaXNwYXRjaDogZnVuY3Rpb24gZGlzcGF0Y2goYSkge1xcbiAgICAgIGEgPSBuLmV2ZW50LmZpeChhKTt2YXIgYixcXG4gICAgICAgICAgYyxcXG4gICAgICAgICAgZCxcXG4gICAgICAgICAgZixcXG4gICAgICAgICAgZyxcXG4gICAgICAgICAgaCA9IFtdLFxcbiAgICAgICAgICBpID0gZS5jYWxsKGFyZ3VtZW50cyksXFxuICAgICAgICAgIGogPSAoTi5nZXQodGhpcywgXFxcImV2ZW50c1xcXCIpIHx8IHt9KVthLnR5cGVdIHx8IFtdLFxcbiAgICAgICAgICBrID0gbi5ldmVudC5zcGVjaWFsW2EudHlwZV0gfHwge307aWYgKGlbMF0gPSBhLCBhLmRlbGVnYXRlVGFyZ2V0ID0gdGhpcywgIWsucHJlRGlzcGF0Y2ggfHwgay5wcmVEaXNwYXRjaC5jYWxsKHRoaXMsIGEpICE9PSAhMSkge1xcbiAgICAgICAgaCA9IG4uZXZlbnQuaGFuZGxlcnMuY2FsbCh0aGlzLCBhLCBqKSwgYiA9IDA7d2hpbGUgKChmID0gaFtiKytdKSAmJiAhYS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XFxuICAgICAgICAgIGEuY3VycmVudFRhcmdldCA9IGYuZWxlbSwgYyA9IDA7d2hpbGUgKChnID0gZi5oYW5kbGVyc1tjKytdKSAmJiAhYS5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XFxuICAgICAgICAgICAgYS5ybmFtZXNwYWNlICYmICFhLnJuYW1lc3BhY2UudGVzdChnLm5hbWVzcGFjZSkgfHwgKGEuaGFuZGxlT2JqID0gZywgYS5kYXRhID0gZy5kYXRhLCBkID0gKChuLmV2ZW50LnNwZWNpYWxbZy5vcmlnVHlwZV0gfHwge30pLmhhbmRsZSB8fCBnLmhhbmRsZXIpLmFwcGx5KGYuZWxlbSwgaSksIHZvaWQgMCAhPT0gZCAmJiAoYS5yZXN1bHQgPSBkKSA9PT0gITEgJiYgKGEucHJldmVudERlZmF1bHQoKSwgYS5zdG9wUHJvcGFnYXRpb24oKSkpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9cmV0dXJuIGsucG9zdERpc3BhdGNoICYmIGsucG9zdERpc3BhdGNoLmNhbGwodGhpcywgYSksIGEucmVzdWx0O1xcbiAgICAgIH1cXG4gICAgfSwgaGFuZGxlcnM6IGZ1bmN0aW9uIGhhbmRsZXJzKGEsIGIpIHtcXG4gICAgICB2YXIgYyxcXG4gICAgICAgICAgZCxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZixcXG4gICAgICAgICAgZyA9IFtdLFxcbiAgICAgICAgICBoID0gYi5kZWxlZ2F0ZUNvdW50LFxcbiAgICAgICAgICBpID0gYS50YXJnZXQ7aWYgKGggJiYgaS5ub2RlVHlwZSAmJiAoXFxcImNsaWNrXFxcIiAhPT0gYS50eXBlIHx8IGlzTmFOKGEuYnV0dG9uKSB8fCBhLmJ1dHRvbiA8IDEpKSBmb3IgKDsgaSAhPT0gdGhpczsgaSA9IGkucGFyZW50Tm9kZSB8fCB0aGlzKSB7XFxuICAgICAgICBpZiAoMSA9PT0gaS5ub2RlVHlwZSAmJiAoaS5kaXNhYmxlZCAhPT0gITAgfHwgXFxcImNsaWNrXFxcIiAhPT0gYS50eXBlKSkge1xcbiAgICAgICAgICBmb3IgKGQgPSBbXSwgYyA9IDA7IGggPiBjOyBjKyspIHtcXG4gICAgICAgICAgICBmID0gYltjXSwgZSA9IGYuc2VsZWN0b3IgKyBcXFwiIFxcXCIsIHZvaWQgMCA9PT0gZFtlXSAmJiAoZFtlXSA9IGYubmVlZHNDb250ZXh0ID8gbihlLCB0aGlzKS5pbmRleChpKSA+IC0xIDogbi5maW5kKGUsIHRoaXMsIG51bGwsIFtpXSkubGVuZ3RoKSwgZFtlXSAmJiBkLnB1c2goZik7XFxuICAgICAgICAgIH1kLmxlbmd0aCAmJiBnLnB1c2goeyBlbGVtOiBpLCBoYW5kbGVyczogZCB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9cmV0dXJuIGggPCBiLmxlbmd0aCAmJiBnLnB1c2goeyBlbGVtOiB0aGlzLCBoYW5kbGVyczogYi5zbGljZShoKSB9KSwgZztcXG4gICAgfSwgcHJvcHM6IFxcXCJhbHRLZXkgYnViYmxlcyBjYW5jZWxhYmxlIGN0cmxLZXkgY3VycmVudFRhcmdldCBkZXRhaWwgZXZlbnRQaGFzZSBtZXRhS2V5IHJlbGF0ZWRUYXJnZXQgc2hpZnRLZXkgdGFyZ2V0IHRpbWVTdGFtcCB2aWV3IHdoaWNoXFxcIi5zcGxpdChcXFwiIFxcXCIpLCBmaXhIb29rczoge30sIGtleUhvb2tzOiB7IHByb3BzOiBcXFwiY2hhciBjaGFyQ29kZSBrZXkga2V5Q29kZVxcXCIuc3BsaXQoXFxcIiBcXFwiKSwgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoYSwgYikge1xcbiAgICAgICAgcmV0dXJuIG51bGwgPT0gYS53aGljaCAmJiAoYS53aGljaCA9IG51bGwgIT0gYi5jaGFyQ29kZSA/IGIuY2hhckNvZGUgOiBiLmtleUNvZGUpLCBhO1xcbiAgICAgIH0gfSwgbW91c2VIb29rczogeyBwcm9wczogXFxcImJ1dHRvbiBidXR0b25zIGNsaWVudFggY2xpZW50WSBvZmZzZXRYIG9mZnNldFkgcGFnZVggcGFnZVkgc2NyZWVuWCBzY3JlZW5ZIHRvRWxlbWVudFxcXCIuc3BsaXQoXFxcIiBcXFwiKSwgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoYSwgYikge1xcbiAgICAgICAgdmFyIGMsXFxuICAgICAgICAgICAgZSxcXG4gICAgICAgICAgICBmLFxcbiAgICAgICAgICAgIGcgPSBiLmJ1dHRvbjtyZXR1cm4gbnVsbCA9PSBhLnBhZ2VYICYmIG51bGwgIT0gYi5jbGllbnRYICYmIChjID0gYS50YXJnZXQub3duZXJEb2N1bWVudCB8fCBkLCBlID0gYy5kb2N1bWVudEVsZW1lbnQsIGYgPSBjLmJvZHksIGEucGFnZVggPSBiLmNsaWVudFggKyAoZSAmJiBlLnNjcm9sbExlZnQgfHwgZiAmJiBmLnNjcm9sbExlZnQgfHwgMCkgLSAoZSAmJiBlLmNsaWVudExlZnQgfHwgZiAmJiBmLmNsaWVudExlZnQgfHwgMCksIGEucGFnZVkgPSBiLmNsaWVudFkgKyAoZSAmJiBlLnNjcm9sbFRvcCB8fCBmICYmIGYuc2Nyb2xsVG9wIHx8IDApIC0gKGUgJiYgZS5jbGllbnRUb3AgfHwgZiAmJiBmLmNsaWVudFRvcCB8fCAwKSksIGEud2hpY2ggfHwgdm9pZCAwID09PSBnIHx8IChhLndoaWNoID0gMSAmIGcgPyAxIDogMiAmIGcgPyAzIDogNCAmIGcgPyAyIDogMCksIGE7XFxuICAgICAgfSB9LCBmaXg6IGZ1bmN0aW9uIGZpeChhKSB7XFxuICAgICAgaWYgKGFbbi5leHBhbmRvXSkgcmV0dXJuIGE7dmFyIGIsXFxuICAgICAgICAgIGMsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIGYgPSBhLnR5cGUsXFxuICAgICAgICAgIGcgPSBhLFxcbiAgICAgICAgICBoID0gdGhpcy5maXhIb29rc1tmXTtoIHx8ICh0aGlzLmZpeEhvb2tzW2ZdID0gaCA9IGVhLnRlc3QoZikgPyB0aGlzLm1vdXNlSG9va3MgOiBkYS50ZXN0KGYpID8gdGhpcy5rZXlIb29rcyA6IHt9KSwgZSA9IGgucHJvcHMgPyB0aGlzLnByb3BzLmNvbmNhdChoLnByb3BzKSA6IHRoaXMucHJvcHMsIGEgPSBuZXcgbi5FdmVudChnKSwgYiA9IGUubGVuZ3RoO3doaWxlIChiLS0pIHtcXG4gICAgICAgIGMgPSBlW2JdLCBhW2NdID0gZ1tjXTtcXG4gICAgICB9cmV0dXJuIGEudGFyZ2V0IHx8IChhLnRhcmdldCA9IGQpLCAzID09PSBhLnRhcmdldC5ub2RlVHlwZSAmJiAoYS50YXJnZXQgPSBhLnRhcmdldC5wYXJlbnROb2RlKSwgaC5maWx0ZXIgPyBoLmZpbHRlcihhLCBnKSA6IGE7XFxuICAgIH0sIHNwZWNpYWw6IHsgbG9hZDogeyBub0J1YmJsZTogITAgfSwgZm9jdXM6IHsgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlcigpIHtcXG4gICAgICAgICAgcmV0dXJuIHRoaXMgIT09IGlhKCkgJiYgdGhpcy5mb2N1cyA/ICh0aGlzLmZvY3VzKCksICExKSA6IHZvaWQgMDtcXG4gICAgICAgIH0sIGRlbGVnYXRlVHlwZTogXFxcImZvY3VzaW5cXFwiIH0sIGJsdXI6IHsgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlcigpIHtcXG4gICAgICAgICAgcmV0dXJuIHRoaXMgPT09IGlhKCkgJiYgdGhpcy5ibHVyID8gKHRoaXMuYmx1cigpLCAhMSkgOiB2b2lkIDA7XFxuICAgICAgICB9LCBkZWxlZ2F0ZVR5cGU6IFxcXCJmb2N1c291dFxcXCIgfSwgY2xpY2s6IHsgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlcigpIHtcXG4gICAgICAgICAgcmV0dXJuIFxcXCJjaGVja2JveFxcXCIgPT09IHRoaXMudHlwZSAmJiB0aGlzLmNsaWNrICYmIG4ubm9kZU5hbWUodGhpcywgXFxcImlucHV0XFxcIikgPyAodGhpcy5jbGljaygpLCAhMSkgOiB2b2lkIDA7XFxuICAgICAgICB9LCBfZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoYSkge1xcbiAgICAgICAgICByZXR1cm4gbi5ub2RlTmFtZShhLnRhcmdldCwgXFxcImFcXFwiKTtcXG4gICAgICAgIH0gfSwgYmVmb3JldW5sb2FkOiB7IHBvc3REaXNwYXRjaDogZnVuY3Rpb24gcG9zdERpc3BhdGNoKGEpIHtcXG4gICAgICAgICAgdm9pZCAwICE9PSBhLnJlc3VsdCAmJiBhLm9yaWdpbmFsRXZlbnQgJiYgKGEub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGEucmVzdWx0KTtcXG4gICAgICAgIH0gfSB9IH0sIG4ucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICBhLnJlbW92ZUV2ZW50TGlzdGVuZXIgJiYgYS5yZW1vdmVFdmVudExpc3RlbmVyKGIsIGMpO1xcbiAgfSwgbi5FdmVudCA9IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2Ygbi5FdmVudCA/IChhICYmIGEudHlwZSA/ICh0aGlzLm9yaWdpbmFsRXZlbnQgPSBhLCB0aGlzLnR5cGUgPSBhLnR5cGUsIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gYS5kZWZhdWx0UHJldmVudGVkIHx8IHZvaWQgMCA9PT0gYS5kZWZhdWx0UHJldmVudGVkICYmIGEucmV0dXJuVmFsdWUgPT09ICExID8gZ2EgOiBoYSkgOiB0aGlzLnR5cGUgPSBhLCBiICYmIG4uZXh0ZW5kKHRoaXMsIGIpLCB0aGlzLnRpbWVTdGFtcCA9IGEgJiYgYS50aW1lU3RhbXAgfHwgbi5ub3coKSwgdm9pZCAodGhpc1tuLmV4cGFuZG9dID0gITApKSA6IG5ldyBuLkV2ZW50KGEsIGIpO1xcbiAgfSwgbi5FdmVudC5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBuLkV2ZW50LCBpc0RlZmF1bHRQcmV2ZW50ZWQ6IGhhLCBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogaGEsIGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiBoYSwgaXNTaW11bGF0ZWQ6ICExLCBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XFxuICAgICAgdmFyIGEgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBnYSwgYSAmJiAhdGhpcy5pc1NpbXVsYXRlZCAmJiBhLnByZXZlbnREZWZhdWx0KCk7XFxuICAgIH0sIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKCkge1xcbiAgICAgIHZhciBhID0gdGhpcy5vcmlnaW5hbEV2ZW50O3RoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBnYSwgYSAmJiAhdGhpcy5pc1NpbXVsYXRlZCAmJiBhLnN0b3BQcm9wYWdhdGlvbigpO1xcbiAgICB9LCBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIHtcXG4gICAgICB2YXIgYSA9IHRoaXMub3JpZ2luYWxFdmVudDt0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gZ2EsIGEgJiYgIXRoaXMuaXNTaW11bGF0ZWQgJiYgYS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSwgdGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcXG4gICAgfSB9LCBuLmVhY2goeyBtb3VzZWVudGVyOiBcXFwibW91c2VvdmVyXFxcIiwgbW91c2VsZWF2ZTogXFxcIm1vdXNlb3V0XFxcIiwgcG9pbnRlcmVudGVyOiBcXFwicG9pbnRlcm92ZXJcXFwiLCBwb2ludGVybGVhdmU6IFxcXCJwb2ludGVyb3V0XFxcIiB9LCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBuLmV2ZW50LnNwZWNpYWxbYV0gPSB7IGRlbGVnYXRlVHlwZTogYiwgYmluZFR5cGU6IGIsIGhhbmRsZTogZnVuY3Rpb24gaGFuZGxlKGEpIHtcXG4gICAgICAgIHZhciBjLFxcbiAgICAgICAgICAgIGQgPSB0aGlzLFxcbiAgICAgICAgICAgIGUgPSBhLnJlbGF0ZWRUYXJnZXQsXFxuICAgICAgICAgICAgZiA9IGEuaGFuZGxlT2JqO3JldHVybiBlICYmIChlID09PSBkIHx8IG4uY29udGFpbnMoZCwgZSkpIHx8IChhLnR5cGUgPSBmLm9yaWdUeXBlLCBjID0gZi5oYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIGEudHlwZSA9IGIpLCBjO1xcbiAgICAgIH0gfTtcXG4gIH0pLCBuLmZuLmV4dGVuZCh7IG9uOiBmdW5jdGlvbiBvbihhLCBiLCBjLCBkKSB7XFxuICAgICAgcmV0dXJuIGphKHRoaXMsIGEsIGIsIGMsIGQpO1xcbiAgICB9LCBvbmU6IGZ1bmN0aW9uIG9uZShhLCBiLCBjLCBkKSB7XFxuICAgICAgcmV0dXJuIGphKHRoaXMsIGEsIGIsIGMsIGQsIDEpO1xcbiAgICB9LCBvZmY6IGZ1bmN0aW9uIG9mZihhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQsIGU7aWYgKGEgJiYgYS5wcmV2ZW50RGVmYXVsdCAmJiBhLmhhbmRsZU9iaikgcmV0dXJuIGQgPSBhLmhhbmRsZU9iaiwgbihhLmRlbGVnYXRlVGFyZ2V0KS5vZmYoZC5uYW1lc3BhY2UgPyBkLm9yaWdUeXBlICsgXFxcIi5cXFwiICsgZC5uYW1lc3BhY2UgOiBkLm9yaWdUeXBlLCBkLnNlbGVjdG9yLCBkLmhhbmRsZXIpLCB0aGlzO2lmIChcXFwib2JqZWN0XFxcIiA9PSAodHlwZW9mIGEgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGEpKSkge1xcbiAgICAgICAgZm9yIChlIGluIGEpIHtcXG4gICAgICAgICAgdGhpcy5vZmYoZSwgYiwgYVtlXSk7XFxuICAgICAgICB9cmV0dXJuIHRoaXM7XFxuICAgICAgfXJldHVybiBiICE9PSAhMSAmJiBcXFwiZnVuY3Rpb25cXFwiICE9IHR5cGVvZiBiIHx8IChjID0gYiwgYiA9IHZvaWQgMCksIGMgPT09ICExICYmIChjID0gaGEpLCB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgbi5ldmVudC5yZW1vdmUodGhpcywgYSwgYywgYik7XFxuICAgICAgfSk7XFxuICAgIH0gfSk7dmFyIGthID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcXFx3Oi1dKylbXj5dKilcXFxcLz4vZ2ksXFxuICAgICAgbGEgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcXG4gICAgICBtYSA9IC9jaGVja2VkXFxcXHMqKD86W149XXw9XFxcXHMqLmNoZWNrZWQuKS9pLFxcbiAgICAgIG5hID0gL150cnVlXFxcXC8oLiopLyxcXG4gICAgICBvYSA9IC9eXFxcXHMqPCEoPzpcXFxcW0NEQVRBXFxcXFt8LS0pfCg/OlxcXFxdXFxcXF18LS0pPlxcXFxzKiQvZztmdW5jdGlvbiBwYShhLCBiKSB7XFxuICAgIHJldHVybiBuLm5vZGVOYW1lKGEsIFxcXCJ0YWJsZVxcXCIpICYmIG4ubm9kZU5hbWUoMTEgIT09IGIubm9kZVR5cGUgPyBiIDogYi5maXJzdENoaWxkLCBcXFwidHJcXFwiKSA/IGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcInRib2R5XFxcIilbMF0gfHwgYS5hcHBlbmRDaGlsZChhLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwidGJvZHlcXFwiKSkgOiBhO1xcbiAgfWZ1bmN0aW9uIHFhKGEpIHtcXG4gICAgcmV0dXJuIGEudHlwZSA9IChudWxsICE9PSBhLmdldEF0dHJpYnV0ZShcXFwidHlwZVxcXCIpKSArIFxcXCIvXFxcIiArIGEudHlwZSwgYTtcXG4gIH1mdW5jdGlvbiByYShhKSB7XFxuICAgIHZhciBiID0gbmEuZXhlYyhhLnR5cGUpO3JldHVybiBiID8gYS50eXBlID0gYlsxXSA6IGEucmVtb3ZlQXR0cmlidXRlKFxcXCJ0eXBlXFxcIiksIGE7XFxuICB9ZnVuY3Rpb24gc2EoYSwgYikge1xcbiAgICB2YXIgYywgZCwgZSwgZiwgZywgaCwgaSwgajtpZiAoMSA9PT0gYi5ub2RlVHlwZSkge1xcbiAgICAgIGlmIChOLmhhc0RhdGEoYSkgJiYgKGYgPSBOLmFjY2VzcyhhKSwgZyA9IE4uc2V0KGIsIGYpLCBqID0gZi5ldmVudHMpKSB7XFxuICAgICAgICBkZWxldGUgZy5oYW5kbGUsIGcuZXZlbnRzID0ge307Zm9yIChlIGluIGopIHtcXG4gICAgICAgICAgZm9yIChjID0gMCwgZCA9IGpbZV0ubGVuZ3RoOyBkID4gYzsgYysrKSB7XFxuICAgICAgICAgICAgbi5ldmVudC5hZGQoYiwgZSwgaltlXVtjXSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9Ty5oYXNEYXRhKGEpICYmIChoID0gTy5hY2Nlc3MoYSksIGkgPSBuLmV4dGVuZCh7fSwgaCksIE8uc2V0KGIsIGkpKTtcXG4gICAgfVxcbiAgfWZ1bmN0aW9uIHRhKGEsIGIpIHtcXG4gICAgdmFyIGMgPSBiLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxcImlucHV0XFxcIiA9PT0gYyAmJiBYLnRlc3QoYS50eXBlKSA/IGIuY2hlY2tlZCA9IGEuY2hlY2tlZCA6IFxcXCJpbnB1dFxcXCIgIT09IGMgJiYgXFxcInRleHRhcmVhXFxcIiAhPT0gYyB8fCAoYi5kZWZhdWx0VmFsdWUgPSBhLmRlZmF1bHRWYWx1ZSk7XFxuICB9ZnVuY3Rpb24gdWEoYSwgYiwgYywgZCkge1xcbiAgICBiID0gZi5hcHBseShbXSwgYik7dmFyIGUsXFxuICAgICAgICBnLFxcbiAgICAgICAgaCxcXG4gICAgICAgIGksXFxuICAgICAgICBqLFxcbiAgICAgICAgayxcXG4gICAgICAgIG0gPSAwLFxcbiAgICAgICAgbyA9IGEubGVuZ3RoLFxcbiAgICAgICAgcCA9IG8gLSAxLFxcbiAgICAgICAgcSA9IGJbMF0sXFxuICAgICAgICByID0gbi5pc0Z1bmN0aW9uKHEpO2lmIChyIHx8IG8gPiAxICYmIFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBxICYmICFsLmNoZWNrQ2xvbmUgJiYgbWEudGVzdChxKSkgcmV0dXJuIGEuZWFjaChmdW5jdGlvbiAoZSkge1xcbiAgICAgIHZhciBmID0gYS5lcShlKTtyICYmIChiWzBdID0gcS5jYWxsKHRoaXMsIGUsIGYuaHRtbCgpKSksIHVhKGYsIGIsIGMsIGQpO1xcbiAgICB9KTtpZiAobyAmJiAoZSA9IGNhKGIsIGFbMF0ub3duZXJEb2N1bWVudCwgITEsIGEsIGQpLCBnID0gZS5maXJzdENoaWxkLCAxID09PSBlLmNoaWxkTm9kZXMubGVuZ3RoICYmIChlID0gZyksIGcgfHwgZCkpIHtcXG4gICAgICBmb3IgKGggPSBuLm1hcChfKGUsIFxcXCJzY3JpcHRcXFwiKSwgcWEpLCBpID0gaC5sZW5ndGg7IG8gPiBtOyBtKyspIHtcXG4gICAgICAgIGogPSBlLCBtICE9PSBwICYmIChqID0gbi5jbG9uZShqLCAhMCwgITApLCBpICYmIG4ubWVyZ2UoaCwgXyhqLCBcXFwic2NyaXB0XFxcIikpKSwgYy5jYWxsKGFbbV0sIGosIG0pO1xcbiAgICAgIH1pZiAoaSkgZm9yIChrID0gaFtoLmxlbmd0aCAtIDFdLm93bmVyRG9jdW1lbnQsIG4ubWFwKGgsIHJhKSwgbSA9IDA7IGkgPiBtOyBtKyspIHtcXG4gICAgICAgIGogPSBoW21dLCBaLnRlc3Qoai50eXBlIHx8IFxcXCJcXFwiKSAmJiAhTi5hY2Nlc3MoaiwgXFxcImdsb2JhbEV2YWxcXFwiKSAmJiBuLmNvbnRhaW5zKGssIGopICYmIChqLnNyYyA/IG4uX2V2YWxVcmwgJiYgbi5fZXZhbFVybChqLnNyYykgOiBuLmdsb2JhbEV2YWwoai50ZXh0Q29udGVudC5yZXBsYWNlKG9hLCBcXFwiXFxcIikpKTtcXG4gICAgICB9XFxuICAgIH1yZXR1cm4gYTtcXG4gIH1mdW5jdGlvbiB2YShhLCBiLCBjKSB7XFxuICAgIGZvciAodmFyIGQsIGUgPSBiID8gbi5maWx0ZXIoYiwgYSkgOiBhLCBmID0gMDsgbnVsbCAhPSAoZCA9IGVbZl0pOyBmKyspIHtcXG4gICAgICBjIHx8IDEgIT09IGQubm9kZVR5cGUgfHwgbi5jbGVhbkRhdGEoXyhkKSksIGQucGFyZW50Tm9kZSAmJiAoYyAmJiBuLmNvbnRhaW5zKGQub3duZXJEb2N1bWVudCwgZCkgJiYgYWEoXyhkLCBcXFwic2NyaXB0XFxcIikpLCBkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZCkpO1xcbiAgICB9cmV0dXJuIGE7XFxuICB9bi5leHRlbmQoeyBodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiBodG1sUHJlZmlsdGVyKGEpIHtcXG4gICAgICByZXR1cm4gYS5yZXBsYWNlKGthLCBcXFwiPCQxPjwvJDI+XFxcIik7XFxuICAgIH0sIGNsb25lOiBmdW5jdGlvbiBjbG9uZShhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIGYsXFxuICAgICAgICAgIGcsXFxuICAgICAgICAgIGggPSBhLmNsb25lTm9kZSghMCksXFxuICAgICAgICAgIGkgPSBuLmNvbnRhaW5zKGEub3duZXJEb2N1bWVudCwgYSk7aWYgKCEobC5ub0Nsb25lQ2hlY2tlZCB8fCAxICE9PSBhLm5vZGVUeXBlICYmIDExICE9PSBhLm5vZGVUeXBlIHx8IG4uaXNYTUxEb2MoYSkpKSBmb3IgKGcgPSBfKGgpLCBmID0gXyhhKSwgZCA9IDAsIGUgPSBmLmxlbmd0aDsgZSA+IGQ7IGQrKykge1xcbiAgICAgICAgdGEoZltkXSwgZ1tkXSk7XFxuICAgICAgfWlmIChiKSBpZiAoYykgZm9yIChmID0gZiB8fCBfKGEpLCBnID0gZyB8fCBfKGgpLCBkID0gMCwgZSA9IGYubGVuZ3RoOyBlID4gZDsgZCsrKSB7XFxuICAgICAgICBzYShmW2RdLCBnW2RdKTtcXG4gICAgICB9IGVsc2Ugc2EoYSwgaCk7cmV0dXJuIGcgPSBfKGgsIFxcXCJzY3JpcHRcXFwiKSwgZy5sZW5ndGggPiAwICYmIGFhKGcsICFpICYmIF8oYSwgXFxcInNjcmlwdFxcXCIpKSwgaDtcXG4gICAgfSwgY2xlYW5EYXRhOiBmdW5jdGlvbiBjbGVhbkRhdGEoYSkge1xcbiAgICAgIGZvciAodmFyIGIsIGMsIGQsIGUgPSBuLmV2ZW50LnNwZWNpYWwsIGYgPSAwOyB2b2lkIDAgIT09IChjID0gYVtmXSk7IGYrKykge1xcbiAgICAgICAgaWYgKEwoYykpIHtcXG4gICAgICAgICAgaWYgKGIgPSBjW04uZXhwYW5kb10pIHtcXG4gICAgICAgICAgICBpZiAoYi5ldmVudHMpIGZvciAoZCBpbiBiLmV2ZW50cykge1xcbiAgICAgICAgICAgICAgZVtkXSA/IG4uZXZlbnQucmVtb3ZlKGMsIGQpIDogbi5yZW1vdmVFdmVudChjLCBkLCBiLmhhbmRsZSk7XFxuICAgICAgICAgICAgfWNbTi5leHBhbmRvXSA9IHZvaWQgMDtcXG4gICAgICAgICAgfWNbTy5leHBhbmRvXSAmJiAoY1tPLmV4cGFuZG9dID0gdm9pZCAwKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0gfSksIG4uZm4uZXh0ZW5kKHsgZG9tTWFuaXA6IHVhLCBkZXRhY2g6IGZ1bmN0aW9uIGRldGFjaChhKSB7XFxuICAgICAgcmV0dXJuIHZhKHRoaXMsIGEsICEwKTtcXG4gICAgfSwgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoYSkge1xcbiAgICAgIHJldHVybiB2YSh0aGlzLCBhKTtcXG4gICAgfSwgdGV4dDogZnVuY3Rpb24gdGV4dChhKSB7XFxuICAgICAgcmV0dXJuIEsodGhpcywgZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHJldHVybiB2b2lkIDAgPT09IGEgPyBuLnRleHQodGhpcykgOiB0aGlzLmVtcHR5KCkuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIDEgIT09IHRoaXMubm9kZVR5cGUgJiYgMTEgIT09IHRoaXMubm9kZVR5cGUgJiYgOSAhPT0gdGhpcy5ub2RlVHlwZSB8fCAodGhpcy50ZXh0Q29udGVudCA9IGEpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSwgbnVsbCwgYSwgYXJndW1lbnRzLmxlbmd0aCk7XFxuICAgIH0sIGFwcGVuZDogZnVuY3Rpb24gYXBwZW5kKCkge1xcbiAgICAgIHJldHVybiB1YSh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICBpZiAoMSA9PT0gdGhpcy5ub2RlVHlwZSB8fCAxMSA9PT0gdGhpcy5ub2RlVHlwZSB8fCA5ID09PSB0aGlzLm5vZGVUeXBlKSB7XFxuICAgICAgICAgIHZhciBiID0gcGEodGhpcywgYSk7Yi5hcHBlbmRDaGlsZChhKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfSwgcHJlcGVuZDogZnVuY3Rpb24gcHJlcGVuZCgpIHtcXG4gICAgICByZXR1cm4gdWEodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgaWYgKDEgPT09IHRoaXMubm9kZVR5cGUgfHwgMTEgPT09IHRoaXMubm9kZVR5cGUgfHwgOSA9PT0gdGhpcy5ub2RlVHlwZSkge1xcbiAgICAgICAgICB2YXIgYiA9IHBhKHRoaXMsIGEpO2IuaW5zZXJ0QmVmb3JlKGEsIGIuZmlyc3RDaGlsZCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH0sIGJlZm9yZTogZnVuY3Rpb24gYmVmb3JlKCkge1xcbiAgICAgIHJldHVybiB1YSh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICB0aGlzLnBhcmVudE5vZGUgJiYgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLCB0aGlzKTtcXG4gICAgICB9KTtcXG4gICAgfSwgYWZ0ZXI6IGZ1bmN0aW9uIGFmdGVyKCkge1xcbiAgICAgIHJldHVybiB1YSh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICB0aGlzLnBhcmVudE5vZGUgJiYgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLCB0aGlzLm5leHRTaWJsaW5nKTtcXG4gICAgICB9KTtcXG4gICAgfSwgZW1wdHk6IGZ1bmN0aW9uIGVtcHR5KCkge1xcbiAgICAgIGZvciAodmFyIGEsIGIgPSAwOyBudWxsICE9IChhID0gdGhpc1tiXSk7IGIrKykge1xcbiAgICAgICAgMSA9PT0gYS5ub2RlVHlwZSAmJiAobi5jbGVhbkRhdGEoXyhhLCAhMSkpLCBhLnRleHRDb250ZW50ID0gXFxcIlxcXCIpO1xcbiAgICAgIH1yZXR1cm4gdGhpcztcXG4gICAgfSwgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKGEsIGIpIHtcXG4gICAgICByZXR1cm4gYSA9IG51bGwgPT0gYSA/ICExIDogYSwgYiA9IG51bGwgPT0gYiA/IGEgOiBiLCB0aGlzLm1hcChmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gbi5jbG9uZSh0aGlzLCBhLCBiKTtcXG4gICAgICB9KTtcXG4gICAgfSwgaHRtbDogZnVuY3Rpb24gaHRtbChhKSB7XFxuICAgICAgcmV0dXJuIEsodGhpcywgZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHZhciBiID0gdGhpc1swXSB8fCB7fSxcXG4gICAgICAgICAgICBjID0gMCxcXG4gICAgICAgICAgICBkID0gdGhpcy5sZW5ndGg7aWYgKHZvaWQgMCA9PT0gYSAmJiAxID09PSBiLm5vZGVUeXBlKSByZXR1cm4gYi5pbm5lckhUTUw7aWYgKFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBhICYmICFsYS50ZXN0KGEpICYmICEkWyhZLmV4ZWMoYSkgfHwgW1xcXCJcXFwiLCBcXFwiXFxcIl0pWzFdLnRvTG93ZXJDYXNlKCldKSB7XFxuICAgICAgICAgIGEgPSBuLmh0bWxQcmVmaWx0ZXIoYSk7dHJ5IHtcXG4gICAgICAgICAgICBmb3IgKDsgZCA+IGM7IGMrKykge1xcbiAgICAgICAgICAgICAgYiA9IHRoaXNbY10gfHwge30sIDEgPT09IGIubm9kZVR5cGUgJiYgKG4uY2xlYW5EYXRhKF8oYiwgITEpKSwgYi5pbm5lckhUTUwgPSBhKTtcXG4gICAgICAgICAgICB9YiA9IDA7XFxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XFxuICAgICAgICB9YiAmJiB0aGlzLmVtcHR5KCkuYXBwZW5kKGEpO1xcbiAgICAgIH0sIG51bGwsIGEsIGFyZ3VtZW50cy5sZW5ndGgpO1xcbiAgICB9LCByZXBsYWNlV2l0aDogZnVuY3Rpb24gcmVwbGFjZVdpdGgoKSB7XFxuICAgICAgdmFyIGEgPSBbXTtyZXR1cm4gdWEodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiAoYikge1xcbiAgICAgICAgdmFyIGMgPSB0aGlzLnBhcmVudE5vZGU7bi5pbkFycmF5KHRoaXMsIGEpIDwgMCAmJiAobi5jbGVhbkRhdGEoXyh0aGlzKSksIGMgJiYgYy5yZXBsYWNlQ2hpbGQoYiwgdGhpcykpO1xcbiAgICAgIH0sIGEpO1xcbiAgICB9IH0pLCBuLmVhY2goeyBhcHBlbmRUbzogXFxcImFwcGVuZFxcXCIsIHByZXBlbmRUbzogXFxcInByZXBlbmRcXFwiLCBpbnNlcnRCZWZvcmU6IFxcXCJiZWZvcmVcXFwiLCBpbnNlcnRBZnRlcjogXFxcImFmdGVyXFxcIiwgcmVwbGFjZUFsbDogXFxcInJlcGxhY2VXaXRoXFxcIiB9LCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBuLmZuW2FdID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgICBmb3IgKHZhciBjLCBkID0gW10sIGUgPSBuKGEpLCBmID0gZS5sZW5ndGggLSAxLCBoID0gMDsgZiA+PSBoOyBoKyspIHtcXG4gICAgICAgIGMgPSBoID09PSBmID8gdGhpcyA6IHRoaXMuY2xvbmUoITApLCBuKGVbaF0pW2JdKGMpLCBnLmFwcGx5KGQsIGMuZ2V0KCkpO1xcbiAgICAgIH1yZXR1cm4gdGhpcy5wdXNoU3RhY2soZCk7XFxuICAgIH07XFxuICB9KTt2YXIgd2EsXFxuICAgICAgeGEgPSB7IEhUTUw6IFxcXCJibG9ja1xcXCIsIEJPRFk6IFxcXCJibG9ja1xcXCIgfTtmdW5jdGlvbiB5YShhLCBiKSB7XFxuICAgIHZhciBjID0gbihiLmNyZWF0ZUVsZW1lbnQoYSkpLmFwcGVuZFRvKGIuYm9keSksXFxuICAgICAgICBkID0gbi5jc3MoY1swXSwgXFxcImRpc3BsYXlcXFwiKTtyZXR1cm4gYy5kZXRhY2goKSwgZDtcXG4gIH1mdW5jdGlvbiB6YShhKSB7XFxuICAgIHZhciBiID0gZCxcXG4gICAgICAgIGMgPSB4YVthXTtyZXR1cm4gYyB8fCAoYyA9IHlhKGEsIGIpLCBcXFwibm9uZVxcXCIgIT09IGMgJiYgYyB8fCAod2EgPSAod2EgfHwgbihcXFwiPGlmcmFtZSBmcmFtZWJvcmRlcj0nMCcgd2lkdGg9JzAnIGhlaWdodD0nMCcvPlxcXCIpKS5hcHBlbmRUbyhiLmRvY3VtZW50RWxlbWVudCksIGIgPSB3YVswXS5jb250ZW50RG9jdW1lbnQsIGIud3JpdGUoKSwgYi5jbG9zZSgpLCBjID0geWEoYSwgYiksIHdhLmRldGFjaCgpKSwgeGFbYV0gPSBjKSwgYztcXG4gIH12YXIgQWEgPSAvXm1hcmdpbi8sXFxuICAgICAgQmEgPSBuZXcgUmVnRXhwKFxcXCJeKFxcXCIgKyBTICsgXFxcIikoPyFweClbYS16JV0rJFxcXCIsIFxcXCJpXFxcIiksXFxuICAgICAgQ2EgPSBmdW5jdGlvbiBDYShiKSB7XFxuICAgIHZhciBjID0gYi5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O3JldHVybiBjICYmIGMub3BlbmVyIHx8IChjID0gYSksIGMuZ2V0Q29tcHV0ZWRTdHlsZShiKTtcXG4gIH0sXFxuICAgICAgRGEgPSBmdW5jdGlvbiBEYShhLCBiLCBjLCBkKSB7XFxuICAgIHZhciBlLFxcbiAgICAgICAgZixcXG4gICAgICAgIGcgPSB7fTtmb3IgKGYgaW4gYikge1xcbiAgICAgIGdbZl0gPSBhLnN0eWxlW2ZdLCBhLnN0eWxlW2ZdID0gYltmXTtcXG4gICAgfWUgPSBjLmFwcGx5KGEsIGQgfHwgW10pO2ZvciAoZiBpbiBiKSB7XFxuICAgICAgYS5zdHlsZVtmXSA9IGdbZl07XFxuICAgIH1yZXR1cm4gZTtcXG4gIH0sXFxuICAgICAgRWEgPSBkLmRvY3VtZW50RWxlbWVudDshZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgYixcXG4gICAgICAgIGMsXFxuICAgICAgICBlLFxcbiAgICAgICAgZixcXG4gICAgICAgIGcgPSBkLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpLFxcbiAgICAgICAgaCA9IGQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7aWYgKGguc3R5bGUpIHtcXG4gICAgICAoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGkgPSBmdW5jdGlvbiBpKCkge1xcbiAgICAgICAgICBoLnN0eWxlLmNzc1RleHQgPSBcXFwiLXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7LW1vei1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7bWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDt0b3A6MSU7d2lkdGg6NTAlXFxcIiwgaC5pbm5lckhUTUwgPSBcXFwiXFxcIiwgRWEuYXBwZW5kQ2hpbGQoZyk7dmFyIGQgPSBhLmdldENvbXB1dGVkU3R5bGUoaCk7YiA9IFxcXCIxJVxcXCIgIT09IGQudG9wLCBmID0gXFxcIjJweFxcXCIgPT09IGQubWFyZ2luTGVmdCwgYyA9IFxcXCI0cHhcXFwiID09PSBkLndpZHRoLCBoLnN0eWxlLm1hcmdpblJpZ2h0ID0gXFxcIjUwJVxcXCIsIGUgPSBcXFwiNHB4XFxcIiA9PT0gZC5tYXJnaW5SaWdodCwgRWEucmVtb3ZlQ2hpbGQoZyk7XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgaC5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFxcXCJjb250ZW50LWJveFxcXCIsIGguY2xvbmVOb2RlKCEwKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFxcXCJcXFwiLCBsLmNsZWFyQ2xvbmVTdHlsZSA9IFxcXCJjb250ZW50LWJveFxcXCIgPT09IGguc3R5bGUuYmFja2dyb3VuZENsaXAsIGcuc3R5bGUuY3NzVGV4dCA9IFxcXCJib3JkZXI6MDt3aWR0aDo4cHg7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4O3BhZGRpbmc6MDttYXJnaW4tdG9wOjFweDtwb3NpdGlvbjphYnNvbHV0ZVxcXCIsIGcuYXBwZW5kQ2hpbGQoaCk7bi5leHRlbmQobCwgeyBwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbiBwaXhlbFBvc2l0aW9uKCkge1xcbiAgICAgICAgICAgIHJldHVybiBpKCksIGI7XFxuICAgICAgICAgIH0sIGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbiBib3hTaXppbmdSZWxpYWJsZSgpIHtcXG4gICAgICAgICAgICByZXR1cm4gbnVsbCA9PSBjICYmIGkoKSwgYztcXG4gICAgICAgICAgfSwgcGl4ZWxNYXJnaW5SaWdodDogZnVuY3Rpb24gcGl4ZWxNYXJnaW5SaWdodCgpIHtcXG4gICAgICAgICAgICByZXR1cm4gbnVsbCA9PSBjICYmIGkoKSwgZTtcXG4gICAgICAgICAgfSwgcmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbiByZWxpYWJsZU1hcmdpbkxlZnQoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gYyAmJiBpKCksIGY7XFxuICAgICAgICAgIH0sIHJlbGlhYmxlTWFyZ2luUmlnaHQ6IGZ1bmN0aW9uIHJlbGlhYmxlTWFyZ2luUmlnaHQoKSB7XFxuICAgICAgICAgICAgdmFyIGIsXFxuICAgICAgICAgICAgICAgIGMgPSBoLmFwcGVuZENoaWxkKGQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIikpO3JldHVybiBjLnN0eWxlLmNzc1RleHQgPSBoLnN0eWxlLmNzc1RleHQgPSBcXFwiLXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94O2JveC1zaXppbmc6Y29udGVudC1ib3g7ZGlzcGxheTpibG9jazttYXJnaW46MDtib3JkZXI6MDtwYWRkaW5nOjBcXFwiLCBjLnN0eWxlLm1hcmdpblJpZ2h0ID0gYy5zdHlsZS53aWR0aCA9IFxcXCIwXFxcIiwgaC5zdHlsZS53aWR0aCA9IFxcXCIxcHhcXFwiLCBFYS5hcHBlbmRDaGlsZChnKSwgYiA9ICFwYXJzZUZsb2F0KGEuZ2V0Q29tcHV0ZWRTdHlsZShjKS5tYXJnaW5SaWdodCksIEVhLnJlbW92ZUNoaWxkKGcpLCBoLnJlbW92ZUNoaWxkKGMpLCBiO1xcbiAgICAgICAgICB9IH0pO1xcbiAgICAgIH0pKCk7XFxuICAgIH1cXG4gIH0oKTtmdW5jdGlvbiBGYShhLCBiLCBjKSB7XFxuICAgIHZhciBkLFxcbiAgICAgICAgZSxcXG4gICAgICAgIGYsXFxuICAgICAgICBnLFxcbiAgICAgICAgaCA9IGEuc3R5bGU7cmV0dXJuIGMgPSBjIHx8IENhKGEpLCBnID0gYyA/IGMuZ2V0UHJvcGVydHlWYWx1ZShiKSB8fCBjW2JdIDogdm9pZCAwLCBcXFwiXFxcIiAhPT0gZyAmJiB2b2lkIDAgIT09IGcgfHwgbi5jb250YWlucyhhLm93bmVyRG9jdW1lbnQsIGEpIHx8IChnID0gbi5zdHlsZShhLCBiKSksIGMgJiYgIWwucGl4ZWxNYXJnaW5SaWdodCgpICYmIEJhLnRlc3QoZykgJiYgQWEudGVzdChiKSAmJiAoZCA9IGgud2lkdGgsIGUgPSBoLm1pbldpZHRoLCBmID0gaC5tYXhXaWR0aCwgaC5taW5XaWR0aCA9IGgubWF4V2lkdGggPSBoLndpZHRoID0gZywgZyA9IGMud2lkdGgsIGgud2lkdGggPSBkLCBoLm1pbldpZHRoID0gZSwgaC5tYXhXaWR0aCA9IGYpLCB2b2lkIDAgIT09IGcgPyBnICsgXFxcIlxcXCIgOiBnO1xcbiAgfWZ1bmN0aW9uIEdhKGEsIGIpIHtcXG4gICAgcmV0dXJuIHsgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgICByZXR1cm4gYSgpID8gdm9pZCBkZWxldGUgdGhpcy5nZXQgOiAodGhpcy5nZXQgPSBiKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH0gfTtcXG4gIH12YXIgSGEgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXFxuICAgICAgSWEgPSB7IHBvc2l0aW9uOiBcXFwiYWJzb2x1dGVcXFwiLCB2aXNpYmlsaXR5OiBcXFwiaGlkZGVuXFxcIiwgZGlzcGxheTogXFxcImJsb2NrXFxcIiB9LFxcbiAgICAgIEphID0geyBsZXR0ZXJTcGFjaW5nOiBcXFwiMFxcXCIsIGZvbnRXZWlnaHQ6IFxcXCI0MDBcXFwiIH0sXFxuICAgICAgS2EgPSBbXFxcIldlYmtpdFxcXCIsIFxcXCJPXFxcIiwgXFxcIk1velxcXCIsIFxcXCJtc1xcXCJdLFxcbiAgICAgIExhID0gZC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKS5zdHlsZTtmdW5jdGlvbiBNYShhKSB7XFxuICAgIGlmIChhIGluIExhKSByZXR1cm4gYTt2YXIgYiA9IGFbMF0udG9VcHBlckNhc2UoKSArIGEuc2xpY2UoMSksXFxuICAgICAgICBjID0gS2EubGVuZ3RoO3doaWxlIChjLS0pIHtcXG4gICAgICBpZiAoYSA9IEthW2NdICsgYiwgYSBpbiBMYSkgcmV0dXJuIGE7XFxuICAgIH1cXG4gIH1mdW5jdGlvbiBOYShhLCBiLCBjKSB7XFxuICAgIHZhciBkID0gVC5leGVjKGIpO3JldHVybiBkID8gTWF0aC5tYXgoMCwgZFsyXSAtIChjIHx8IDApKSArIChkWzNdIHx8IFxcXCJweFxcXCIpIDogYjtcXG4gIH1mdW5jdGlvbiBPYShhLCBiLCBjLCBkLCBlKSB7XFxuICAgIGZvciAodmFyIGYgPSBjID09PSAoZCA/IFxcXCJib3JkZXJcXFwiIDogXFxcImNvbnRlbnRcXFwiKSA/IDQgOiBcXFwid2lkdGhcXFwiID09PSBiID8gMSA6IDAsIGcgPSAwOyA0ID4gZjsgZiArPSAyKSB7XFxuICAgICAgXFxcIm1hcmdpblxcXCIgPT09IGMgJiYgKGcgKz0gbi5jc3MoYSwgYyArIFVbZl0sICEwLCBlKSksIGQgPyAoXFxcImNvbnRlbnRcXFwiID09PSBjICYmIChnIC09IG4uY3NzKGEsIFxcXCJwYWRkaW5nXFxcIiArIFVbZl0sICEwLCBlKSksIFxcXCJtYXJnaW5cXFwiICE9PSBjICYmIChnIC09IG4uY3NzKGEsIFxcXCJib3JkZXJcXFwiICsgVVtmXSArIFxcXCJXaWR0aFxcXCIsICEwLCBlKSkpIDogKGcgKz0gbi5jc3MoYSwgXFxcInBhZGRpbmdcXFwiICsgVVtmXSwgITAsIGUpLCBcXFwicGFkZGluZ1xcXCIgIT09IGMgJiYgKGcgKz0gbi5jc3MoYSwgXFxcImJvcmRlclxcXCIgKyBVW2ZdICsgXFxcIldpZHRoXFxcIiwgITAsIGUpKSk7XFxuICAgIH1yZXR1cm4gZztcXG4gIH1mdW5jdGlvbiBQYShhLCBiLCBjKSB7XFxuICAgIHZhciBkID0gITAsXFxuICAgICAgICBlID0gXFxcIndpZHRoXFxcIiA9PT0gYiA/IGEub2Zmc2V0V2lkdGggOiBhLm9mZnNldEhlaWdodCxcXG4gICAgICAgIGYgPSBDYShhKSxcXG4gICAgICAgIGcgPSBcXFwiYm9yZGVyLWJveFxcXCIgPT09IG4uY3NzKGEsIFxcXCJib3hTaXppbmdcXFwiLCAhMSwgZik7aWYgKDAgPj0gZSB8fCBudWxsID09IGUpIHtcXG4gICAgICBpZiAoZSA9IEZhKGEsIGIsIGYpLCAoMCA+IGUgfHwgbnVsbCA9PSBlKSAmJiAoZSA9IGEuc3R5bGVbYl0pLCBCYS50ZXN0KGUpKSByZXR1cm4gZTtkID0gZyAmJiAobC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IGUgPT09IGEuc3R5bGVbYl0pLCBlID0gcGFyc2VGbG9hdChlKSB8fCAwO1xcbiAgICB9cmV0dXJuIGUgKyBPYShhLCBiLCBjIHx8IChnID8gXFxcImJvcmRlclxcXCIgOiBcXFwiY29udGVudFxcXCIpLCBkLCBmKSArIFxcXCJweFxcXCI7XFxuICB9ZnVuY3Rpb24gUWEoYSwgYikge1xcbiAgICBmb3IgKHZhciBjLCBkLCBlLCBmID0gW10sIGcgPSAwLCBoID0gYS5sZW5ndGg7IGggPiBnOyBnKyspIHtcXG4gICAgICBkID0gYVtnXSwgZC5zdHlsZSAmJiAoZltnXSA9IE4uZ2V0KGQsIFxcXCJvbGRkaXNwbGF5XFxcIiksIGMgPSBkLnN0eWxlLmRpc3BsYXksIGIgPyAoZltnXSB8fCBcXFwibm9uZVxcXCIgIT09IGMgfHwgKGQuc3R5bGUuZGlzcGxheSA9IFxcXCJcXFwiKSwgXFxcIlxcXCIgPT09IGQuc3R5bGUuZGlzcGxheSAmJiBWKGQpICYmIChmW2ddID0gTi5hY2Nlc3MoZCwgXFxcIm9sZGRpc3BsYXlcXFwiLCB6YShkLm5vZGVOYW1lKSkpKSA6IChlID0gVihkKSwgXFxcIm5vbmVcXFwiID09PSBjICYmIGUgfHwgTi5zZXQoZCwgXFxcIm9sZGRpc3BsYXlcXFwiLCBlID8gYyA6IG4uY3NzKGQsIFxcXCJkaXNwbGF5XFxcIikpKSk7XFxuICAgIH1mb3IgKGcgPSAwOyBoID4gZzsgZysrKSB7XFxuICAgICAgZCA9IGFbZ10sIGQuc3R5bGUgJiYgKGIgJiYgXFxcIm5vbmVcXFwiICE9PSBkLnN0eWxlLmRpc3BsYXkgJiYgXFxcIlxcXCIgIT09IGQuc3R5bGUuZGlzcGxheSB8fCAoZC5zdHlsZS5kaXNwbGF5ID0gYiA/IGZbZ10gfHwgXFxcIlxcXCIgOiBcXFwibm9uZVxcXCIpKTtcXG4gICAgfXJldHVybiBhO1xcbiAgfW4uZXh0ZW5kKHsgY3NzSG9va3M6IHsgb3BhY2l0eTogeyBnZXQ6IGZ1bmN0aW9uIGdldChhLCBiKSB7XFxuICAgICAgICAgIGlmIChiKSB7XFxuICAgICAgICAgICAgdmFyIGMgPSBGYShhLCBcXFwib3BhY2l0eVxcXCIpO3JldHVybiBcXFwiXFxcIiA9PT0gYyA/IFxcXCIxXFxcIiA6IGM7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gfSB9LCBjc3NOdW1iZXI6IHsgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6ICEwLCBjb2x1bW5Db3VudDogITAsIGZpbGxPcGFjaXR5OiAhMCwgZmxleEdyb3c6ICEwLCBmbGV4U2hyaW5rOiAhMCwgZm9udFdlaWdodDogITAsIGxpbmVIZWlnaHQ6ICEwLCBvcGFjaXR5OiAhMCwgb3JkZXI6ICEwLCBvcnBoYW5zOiAhMCwgd2lkb3dzOiAhMCwgekluZGV4OiAhMCwgem9vbTogITAgfSwgY3NzUHJvcHM6IHsgXFxcImZsb2F0XFxcIjogXFxcImNzc0Zsb2F0XFxcIiB9LCBzdHlsZTogZnVuY3Rpb24gc3R5bGUoYSwgYiwgYywgZCkge1xcbiAgICAgIGlmIChhICYmIDMgIT09IGEubm9kZVR5cGUgJiYgOCAhPT0gYS5ub2RlVHlwZSAmJiBhLnN0eWxlKSB7XFxuICAgICAgICB2YXIgZSxcXG4gICAgICAgICAgICBmLFxcbiAgICAgICAgICAgIGcsXFxuICAgICAgICAgICAgaCA9IG4uY2FtZWxDYXNlKGIpLFxcbiAgICAgICAgICAgIGkgPSBhLnN0eWxlO3JldHVybiBiID0gbi5jc3NQcm9wc1toXSB8fCAobi5jc3NQcm9wc1toXSA9IE1hKGgpIHx8IGgpLCBnID0gbi5jc3NIb29rc1tiXSB8fCBuLmNzc0hvb2tzW2hdLCB2b2lkIDAgPT09IGMgPyBnICYmIFxcXCJnZXRcXFwiIGluIGcgJiYgdm9pZCAwICE9PSAoZSA9IGcuZ2V0KGEsICExLCBkKSkgPyBlIDogaVtiXSA6IChmID0gdHlwZW9mIGMgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGMpLCBcXFwic3RyaW5nXFxcIiA9PT0gZiAmJiAoZSA9IFQuZXhlYyhjKSkgJiYgZVsxXSAmJiAoYyA9IFcoYSwgYiwgZSksIGYgPSBcXFwibnVtYmVyXFxcIiksIG51bGwgIT0gYyAmJiBjID09PSBjICYmIChcXFwibnVtYmVyXFxcIiA9PT0gZiAmJiAoYyArPSBlICYmIGVbM10gfHwgKG4uY3NzTnVtYmVyW2hdID8gXFxcIlxcXCIgOiBcXFwicHhcXFwiKSksIGwuY2xlYXJDbG9uZVN0eWxlIHx8IFxcXCJcXFwiICE9PSBjIHx8IDAgIT09IGIuaW5kZXhPZihcXFwiYmFja2dyb3VuZFxcXCIpIHx8IChpW2JdID0gXFxcImluaGVyaXRcXFwiKSwgZyAmJiBcXFwic2V0XFxcIiBpbiBnICYmIHZvaWQgMCA9PT0gKGMgPSBnLnNldChhLCBjLCBkKSkgfHwgKGlbYl0gPSBjKSksIHZvaWQgMCk7XFxuICAgICAgfVxcbiAgICB9LCBjc3M6IGZ1bmN0aW9uIGNzcyhhLCBiLCBjLCBkKSB7XFxuICAgICAgdmFyIGUsXFxuICAgICAgICAgIGYsXFxuICAgICAgICAgIGcsXFxuICAgICAgICAgIGggPSBuLmNhbWVsQ2FzZShiKTtyZXR1cm4gYiA9IG4uY3NzUHJvcHNbaF0gfHwgKG4uY3NzUHJvcHNbaF0gPSBNYShoKSB8fCBoKSwgZyA9IG4uY3NzSG9va3NbYl0gfHwgbi5jc3NIb29rc1toXSwgZyAmJiBcXFwiZ2V0XFxcIiBpbiBnICYmIChlID0gZy5nZXQoYSwgITAsIGMpKSwgdm9pZCAwID09PSBlICYmIChlID0gRmEoYSwgYiwgZCkpLCBcXFwibm9ybWFsXFxcIiA9PT0gZSAmJiBiIGluIEphICYmIChlID0gSmFbYl0pLCBcXFwiXFxcIiA9PT0gYyB8fCBjID8gKGYgPSBwYXJzZUZsb2F0KGUpLCBjID09PSAhMCB8fCBpc0Zpbml0ZShmKSA/IGYgfHwgMCA6IGUpIDogZTtcXG4gICAgfSB9KSwgbi5lYWNoKFtcXFwiaGVpZ2h0XFxcIiwgXFxcIndpZHRoXFxcIl0sIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIG4uY3NzSG9va3NbYl0gPSB7IGdldDogZnVuY3Rpb24gZ2V0KGEsIGMsIGQpIHtcXG4gICAgICAgIHJldHVybiBjID8gSGEudGVzdChuLmNzcyhhLCBcXFwiZGlzcGxheVxcXCIpKSAmJiAwID09PSBhLm9mZnNldFdpZHRoID8gRGEoYSwgSWEsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcmV0dXJuIFBhKGEsIGIsIGQpO1xcbiAgICAgICAgfSkgOiBQYShhLCBiLCBkKSA6IHZvaWQgMDtcXG4gICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldChhLCBjLCBkKSB7XFxuICAgICAgICB2YXIgZSxcXG4gICAgICAgICAgICBmID0gZCAmJiBDYShhKSxcXG4gICAgICAgICAgICBnID0gZCAmJiBPYShhLCBiLCBkLCBcXFwiYm9yZGVyLWJveFxcXCIgPT09IG4uY3NzKGEsIFxcXCJib3hTaXppbmdcXFwiLCAhMSwgZiksIGYpO3JldHVybiBnICYmIChlID0gVC5leGVjKGMpKSAmJiBcXFwicHhcXFwiICE9PSAoZVszXSB8fCBcXFwicHhcXFwiKSAmJiAoYS5zdHlsZVtiXSA9IGMsIGMgPSBuLmNzcyhhLCBiKSksIE5hKGEsIGMsIGcpO1xcbiAgICAgIH0gfTtcXG4gIH0pLCBuLmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBHYShsLnJlbGlhYmxlTWFyZ2luTGVmdCwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgcmV0dXJuIGIgPyAocGFyc2VGbG9hdChGYShhLCBcXFwibWFyZ2luTGVmdFxcXCIpKSB8fCBhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLSBEYShhLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiBhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XFxuICAgIH0pKSArIFxcXCJweFxcXCIgOiB2b2lkIDA7XFxuICB9KSwgbi5jc3NIb29rcy5tYXJnaW5SaWdodCA9IEdhKGwucmVsaWFibGVNYXJnaW5SaWdodCwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgcmV0dXJuIGIgPyBEYShhLCB7IGRpc3BsYXk6IFxcXCJpbmxpbmUtYmxvY2tcXFwiIH0sIEZhLCBbYSwgXFxcIm1hcmdpblJpZ2h0XFxcIl0pIDogdm9pZCAwO1xcbiAgfSksIG4uZWFjaCh7IG1hcmdpbjogXFxcIlxcXCIsIHBhZGRpbmc6IFxcXCJcXFwiLCBib3JkZXI6IFxcXCJXaWR0aFxcXCIgfSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgbi5jc3NIb29rc1thICsgYl0gPSB7IGV4cGFuZDogZnVuY3Rpb24gZXhwYW5kKGMpIHtcXG4gICAgICAgIGZvciAodmFyIGQgPSAwLCBlID0ge30sIGYgPSBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYyA/IGMuc3BsaXQoXFxcIiBcXFwiKSA6IFtjXTsgNCA+IGQ7IGQrKykge1xcbiAgICAgICAgICBlW2EgKyBVW2RdICsgYl0gPSBmW2RdIHx8IGZbZCAtIDJdIHx8IGZbMF07XFxuICAgICAgICB9cmV0dXJuIGU7XFxuICAgICAgfSB9LCBBYS50ZXN0KGEpIHx8IChuLmNzc0hvb2tzW2EgKyBiXS5zZXQgPSBOYSk7XFxuICB9KSwgbi5mbi5leHRlbmQoeyBjc3M6IGZ1bmN0aW9uIGNzcyhhLCBiKSB7XFxuICAgICAgcmV0dXJuIEsodGhpcywgZnVuY3Rpb24gKGEsIGIsIGMpIHtcXG4gICAgICAgIHZhciBkLFxcbiAgICAgICAgICAgIGUsXFxuICAgICAgICAgICAgZiA9IHt9LFxcbiAgICAgICAgICAgIGcgPSAwO2lmIChuLmlzQXJyYXkoYikpIHtcXG4gICAgICAgICAgZm9yIChkID0gQ2EoYSksIGUgPSBiLmxlbmd0aDsgZSA+IGc7IGcrKykge1xcbiAgICAgICAgICAgIGZbYltnXV0gPSBuLmNzcyhhLCBiW2ddLCAhMSwgZCk7XFxuICAgICAgICAgIH1yZXR1cm4gZjtcXG4gICAgICAgIH1yZXR1cm4gdm9pZCAwICE9PSBjID8gbi5zdHlsZShhLCBiLCBjKSA6IG4uY3NzKGEsIGIpO1xcbiAgICAgIH0sIGEsIGIsIGFyZ3VtZW50cy5sZW5ndGggPiAxKTtcXG4gICAgfSwgc2hvdzogZnVuY3Rpb24gc2hvdygpIHtcXG4gICAgICByZXR1cm4gUWEodGhpcywgITApO1xcbiAgICB9LCBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xcbiAgICAgIHJldHVybiBRYSh0aGlzKTtcXG4gICAgfSwgdG9nZ2xlOiBmdW5jdGlvbiB0b2dnbGUoYSkge1xcbiAgICAgIHJldHVybiBcXFwiYm9vbGVhblxcXCIgPT0gdHlwZW9mIGEgPyBhID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKSA6IHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBWKHRoaXMpID8gbih0aGlzKS5zaG93KCkgOiBuKHRoaXMpLmhpZGUoKTtcXG4gICAgICB9KTtcXG4gICAgfSB9KTtmdW5jdGlvbiBSYShhLCBiLCBjLCBkLCBlKSB7XFxuICAgIHJldHVybiBuZXcgUmEucHJvdG90eXBlLmluaXQoYSwgYiwgYywgZCwgZSk7XFxuICB9bi5Ud2VlbiA9IFJhLCBSYS5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBSYSwgaW5pdDogZnVuY3Rpb24gaW5pdChhLCBiLCBjLCBkLCBlLCBmKSB7XFxuICAgICAgdGhpcy5lbGVtID0gYSwgdGhpcy5wcm9wID0gYywgdGhpcy5lYXNpbmcgPSBlIHx8IG4uZWFzaW5nLl9kZWZhdWx0LCB0aGlzLm9wdGlvbnMgPSBiLCB0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpLCB0aGlzLmVuZCA9IGQsIHRoaXMudW5pdCA9IGYgfHwgKG4uY3NzTnVtYmVyW2NdID8gXFxcIlxcXCIgOiBcXFwicHhcXFwiKTtcXG4gICAgfSwgY3VyOiBmdW5jdGlvbiBjdXIoKSB7XFxuICAgICAgdmFyIGEgPSBSYS5wcm9wSG9va3NbdGhpcy5wcm9wXTtyZXR1cm4gYSAmJiBhLmdldCA/IGEuZ2V0KHRoaXMpIDogUmEucHJvcEhvb2tzLl9kZWZhdWx0LmdldCh0aGlzKTtcXG4gICAgfSwgcnVuOiBmdW5jdGlvbiBydW4oYSkge1xcbiAgICAgIHZhciBiLFxcbiAgICAgICAgICBjID0gUmEucHJvcEhvb2tzW3RoaXMucHJvcF07cmV0dXJuIHRoaXMub3B0aW9ucy5kdXJhdGlvbiA/IHRoaXMucG9zID0gYiA9IG4uZWFzaW5nW3RoaXMuZWFzaW5nXShhLCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBhLCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb24pIDogdGhpcy5wb3MgPSBiID0gYSwgdGhpcy5ub3cgPSAodGhpcy5lbmQgLSB0aGlzLnN0YXJ0KSAqIGIgKyB0aGlzLnN0YXJ0LCB0aGlzLm9wdGlvbnMuc3RlcCAmJiB0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMpLCBjICYmIGMuc2V0ID8gYy5zZXQodGhpcykgOiBSYS5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KHRoaXMpLCB0aGlzO1xcbiAgICB9IH0sIFJhLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFJhLnByb3RvdHlwZSwgUmEucHJvcEhvb2tzID0geyBfZGVmYXVsdDogeyBnZXQ6IGZ1bmN0aW9uIGdldChhKSB7XFxuICAgICAgICB2YXIgYjtyZXR1cm4gMSAhPT0gYS5lbGVtLm5vZGVUeXBlIHx8IG51bGwgIT0gYS5lbGVtW2EucHJvcF0gJiYgbnVsbCA9PSBhLmVsZW0uc3R5bGVbYS5wcm9wXSA/IGEuZWxlbVthLnByb3BdIDogKGIgPSBuLmNzcyhhLmVsZW0sIGEucHJvcCwgXFxcIlxcXCIpLCBiICYmIFxcXCJhdXRvXFxcIiAhPT0gYiA/IGIgOiAwKTtcXG4gICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldChhKSB7XFxuICAgICAgICBuLmZ4LnN0ZXBbYS5wcm9wXSA/IG4uZnguc3RlcFthLnByb3BdKGEpIDogMSAhPT0gYS5lbGVtLm5vZGVUeXBlIHx8IG51bGwgPT0gYS5lbGVtLnN0eWxlW24uY3NzUHJvcHNbYS5wcm9wXV0gJiYgIW4uY3NzSG9va3NbYS5wcm9wXSA/IGEuZWxlbVthLnByb3BdID0gYS5ub3cgOiBuLnN0eWxlKGEuZWxlbSwgYS5wcm9wLCBhLm5vdyArIGEudW5pdCk7XFxuICAgICAgfSB9IH0sIFJhLnByb3BIb29rcy5zY3JvbGxUb3AgPSBSYS5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHsgc2V0OiBmdW5jdGlvbiBzZXQoYSkge1xcbiAgICAgIGEuZWxlbS5ub2RlVHlwZSAmJiBhLmVsZW0ucGFyZW50Tm9kZSAmJiAoYS5lbGVtW2EucHJvcF0gPSBhLm5vdyk7XFxuICAgIH0gfSwgbi5lYXNpbmcgPSB7IGxpbmVhcjogZnVuY3Rpb24gbGluZWFyKGEpIHtcXG4gICAgICByZXR1cm4gYTtcXG4gICAgfSwgc3dpbmc6IGZ1bmN0aW9uIHN3aW5nKGEpIHtcXG4gICAgICByZXR1cm4gLjUgLSBNYXRoLmNvcyhhICogTWF0aC5QSSkgLyAyO1xcbiAgICB9LCBfZGVmYXVsdDogXFxcInN3aW5nXFxcIiB9LCBuLmZ4ID0gUmEucHJvdG90eXBlLmluaXQsIG4uZnguc3RlcCA9IHt9O3ZhciBTYSxcXG4gICAgICBUYSxcXG4gICAgICBVYSA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcXG4gICAgICBWYSA9IC9xdWV1ZUhvb2tzJC87ZnVuY3Rpb24gV2EoKSB7XFxuICAgIHJldHVybiBhLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgIFNhID0gdm9pZCAwO1xcbiAgICB9KSwgU2EgPSBuLm5vdygpO1xcbiAgfWZ1bmN0aW9uIFhhKGEsIGIpIHtcXG4gICAgdmFyIGMsXFxuICAgICAgICBkID0gMCxcXG4gICAgICAgIGUgPSB7IGhlaWdodDogYSB9O2ZvciAoYiA9IGIgPyAxIDogMDsgNCA+IGQ7IGQgKz0gMiAtIGIpIHtcXG4gICAgICBjID0gVVtkXSwgZVtcXFwibWFyZ2luXFxcIiArIGNdID0gZVtcXFwicGFkZGluZ1xcXCIgKyBjXSA9IGE7XFxuICAgIH1yZXR1cm4gYiAmJiAoZS5vcGFjaXR5ID0gZS53aWR0aCA9IGEpLCBlO1xcbiAgfWZ1bmN0aW9uIFlhKGEsIGIsIGMpIHtcXG4gICAgZm9yICh2YXIgZCwgZSA9IChfYS50d2VlbmVyc1tiXSB8fCBbXSkuY29uY2F0KF9hLnR3ZWVuZXJzW1xcXCIqXFxcIl0pLCBmID0gMCwgZyA9IGUubGVuZ3RoOyBnID4gZjsgZisrKSB7XFxuICAgICAgaWYgKGQgPSBlW2ZdLmNhbGwoYywgYiwgYSkpIHJldHVybiBkO1xcbiAgICB9XFxuICB9ZnVuY3Rpb24gWmEoYSwgYiwgYykge1xcbiAgICB2YXIgZCxcXG4gICAgICAgIGUsXFxuICAgICAgICBmLFxcbiAgICAgICAgZyxcXG4gICAgICAgIGgsXFxuICAgICAgICBpLFxcbiAgICAgICAgaixcXG4gICAgICAgIGssXFxuICAgICAgICBsID0gdGhpcyxcXG4gICAgICAgIG0gPSB7fSxcXG4gICAgICAgIG8gPSBhLnN0eWxlLFxcbiAgICAgICAgcCA9IGEubm9kZVR5cGUgJiYgVihhKSxcXG4gICAgICAgIHEgPSBOLmdldChhLCBcXFwiZnhzaG93XFxcIik7Yy5xdWV1ZSB8fCAoaCA9IG4uX3F1ZXVlSG9va3MoYSwgXFxcImZ4XFxcIiksIG51bGwgPT0gaC51bnF1ZXVlZCAmJiAoaC51bnF1ZXVlZCA9IDAsIGkgPSBoLmVtcHR5LmZpcmUsIGguZW1wdHkuZmlyZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBoLnVucXVldWVkIHx8IGkoKTtcXG4gICAgfSksIGgudW5xdWV1ZWQrKywgbC5hbHdheXMoZnVuY3Rpb24gKCkge1xcbiAgICAgIGwuYWx3YXlzKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGgudW5xdWV1ZWQtLSwgbi5xdWV1ZShhLCBcXFwiZnhcXFwiKS5sZW5ndGggfHwgaC5lbXB0eS5maXJlKCk7XFxuICAgICAgfSk7XFxuICAgIH0pKSwgMSA9PT0gYS5ub2RlVHlwZSAmJiAoXFxcImhlaWdodFxcXCIgaW4gYiB8fCBcXFwid2lkdGhcXFwiIGluIGIpICYmIChjLm92ZXJmbG93ID0gW28ub3ZlcmZsb3csIG8ub3ZlcmZsb3dYLCBvLm92ZXJmbG93WV0sIGogPSBuLmNzcyhhLCBcXFwiZGlzcGxheVxcXCIpLCBrID0gXFxcIm5vbmVcXFwiID09PSBqID8gTi5nZXQoYSwgXFxcIm9sZGRpc3BsYXlcXFwiKSB8fCB6YShhLm5vZGVOYW1lKSA6IGosIFxcXCJpbmxpbmVcXFwiID09PSBrICYmIFxcXCJub25lXFxcIiA9PT0gbi5jc3MoYSwgXFxcImZsb2F0XFxcIikgJiYgKG8uZGlzcGxheSA9IFxcXCJpbmxpbmUtYmxvY2tcXFwiKSksIGMub3ZlcmZsb3cgJiYgKG8ub3ZlcmZsb3cgPSBcXFwiaGlkZGVuXFxcIiwgbC5hbHdheXMoZnVuY3Rpb24gKCkge1xcbiAgICAgIG8ub3ZlcmZsb3cgPSBjLm92ZXJmbG93WzBdLCBvLm92ZXJmbG93WCA9IGMub3ZlcmZsb3dbMV0sIG8ub3ZlcmZsb3dZID0gYy5vdmVyZmxvd1syXTtcXG4gICAgfSkpO2ZvciAoZCBpbiBiKSB7XFxuICAgICAgaWYgKGUgPSBiW2RdLCBVYS5leGVjKGUpKSB7XFxuICAgICAgICBpZiAoZGVsZXRlIGJbZF0sIGYgPSBmIHx8IFxcXCJ0b2dnbGVcXFwiID09PSBlLCBlID09PSAocCA/IFxcXCJoaWRlXFxcIiA6IFxcXCJzaG93XFxcIikpIHtcXG4gICAgICAgICAgaWYgKFxcXCJzaG93XFxcIiAhPT0gZSB8fCAhcSB8fCB2b2lkIDAgPT09IHFbZF0pIGNvbnRpbnVlO3AgPSAhMDtcXG4gICAgICAgIH1tW2RdID0gcSAmJiBxW2RdIHx8IG4uc3R5bGUoYSwgZCk7XFxuICAgICAgfSBlbHNlIGogPSB2b2lkIDA7XFxuICAgIH1pZiAobi5pc0VtcHR5T2JqZWN0KG0pKSBcXFwiaW5saW5lXFxcIiA9PT0gKFxcXCJub25lXFxcIiA9PT0gaiA/IHphKGEubm9kZU5hbWUpIDogaikgJiYgKG8uZGlzcGxheSA9IGopO2Vsc2Uge1xcbiAgICAgIHEgPyBcXFwiaGlkZGVuXFxcIiBpbiBxICYmIChwID0gcS5oaWRkZW4pIDogcSA9IE4uYWNjZXNzKGEsIFxcXCJmeHNob3dcXFwiLCB7fSksIGYgJiYgKHEuaGlkZGVuID0gIXApLCBwID8gbihhKS5zaG93KCkgOiBsLmRvbmUoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgbihhKS5oaWRlKCk7XFxuICAgICAgfSksIGwuZG9uZShmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYjtOLnJlbW92ZShhLCBcXFwiZnhzaG93XFxcIik7Zm9yIChiIGluIG0pIHtcXG4gICAgICAgICAgbi5zdHlsZShhLCBiLCBtW2JdKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtmb3IgKGQgaW4gbSkge1xcbiAgICAgICAgZyA9IFlhKHAgPyBxW2RdIDogMCwgZCwgbCksIGQgaW4gcSB8fCAocVtkXSA9IGcuc3RhcnQsIHAgJiYgKGcuZW5kID0gZy5zdGFydCwgZy5zdGFydCA9IFxcXCJ3aWR0aFxcXCIgPT09IGQgfHwgXFxcImhlaWdodFxcXCIgPT09IGQgPyAxIDogMCkpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfWZ1bmN0aW9uICRhKGEsIGIpIHtcXG4gICAgdmFyIGMsIGQsIGUsIGYsIGc7Zm9yIChjIGluIGEpIHtcXG4gICAgICBpZiAoZCA9IG4uY2FtZWxDYXNlKGMpLCBlID0gYltkXSwgZiA9IGFbY10sIG4uaXNBcnJheShmKSAmJiAoZSA9IGZbMV0sIGYgPSBhW2NdID0gZlswXSksIGMgIT09IGQgJiYgKGFbZF0gPSBmLCBkZWxldGUgYVtjXSksIGcgPSBuLmNzc0hvb2tzW2RdLCBnICYmIFxcXCJleHBhbmRcXFwiIGluIGcpIHtcXG4gICAgICAgIGYgPSBnLmV4cGFuZChmKSwgZGVsZXRlIGFbZF07Zm9yIChjIGluIGYpIHtcXG4gICAgICAgICAgYyBpbiBhIHx8IChhW2NdID0gZltjXSwgYltjXSA9IGUpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBiW2RdID0gZTtcXG4gICAgfVxcbiAgfWZ1bmN0aW9uIF9hKGEsIGIsIGMpIHtcXG4gICAgdmFyIGQsXFxuICAgICAgICBlLFxcbiAgICAgICAgZiA9IDAsXFxuICAgICAgICBnID0gX2EucHJlZmlsdGVycy5sZW5ndGgsXFxuICAgICAgICBoID0gbi5EZWZlcnJlZCgpLmFsd2F5cyhmdW5jdGlvbiAoKSB7XFxuICAgICAgZGVsZXRlIGkuZWxlbTtcXG4gICAgfSksXFxuICAgICAgICBpID0gZnVuY3Rpb24gaSgpIHtcXG4gICAgICBpZiAoZSkgcmV0dXJuICExO2ZvciAodmFyIGIgPSBTYSB8fCBXYSgpLCBjID0gTWF0aC5tYXgoMCwgai5zdGFydFRpbWUgKyBqLmR1cmF0aW9uIC0gYiksIGQgPSBjIC8gai5kdXJhdGlvbiB8fCAwLCBmID0gMSAtIGQsIGcgPSAwLCBpID0gai50d2VlbnMubGVuZ3RoOyBpID4gZzsgZysrKSB7XFxuICAgICAgICBqLnR3ZWVuc1tnXS5ydW4oZik7XFxuICAgICAgfXJldHVybiBoLm5vdGlmeVdpdGgoYSwgW2osIGYsIGNdKSwgMSA+IGYgJiYgaSA/IGMgOiAoaC5yZXNvbHZlV2l0aChhLCBbal0pLCAhMSk7XFxuICAgIH0sXFxuICAgICAgICBqID0gaC5wcm9taXNlKHsgZWxlbTogYSwgcHJvcHM6IG4uZXh0ZW5kKHt9LCBiKSwgb3B0czogbi5leHRlbmQoITAsIHsgc3BlY2lhbEVhc2luZzoge30sIGVhc2luZzogbi5lYXNpbmcuX2RlZmF1bHQgfSwgYyksIG9yaWdpbmFsUHJvcGVydGllczogYiwgb3JpZ2luYWxPcHRpb25zOiBjLCBzdGFydFRpbWU6IFNhIHx8IFdhKCksIGR1cmF0aW9uOiBjLmR1cmF0aW9uLCB0d2VlbnM6IFtdLCBjcmVhdGVUd2VlbjogZnVuY3Rpb24gY3JlYXRlVHdlZW4oYiwgYykge1xcbiAgICAgICAgdmFyIGQgPSBuLlR3ZWVuKGEsIGoub3B0cywgYiwgYywgai5vcHRzLnNwZWNpYWxFYXNpbmdbYl0gfHwgai5vcHRzLmVhc2luZyk7cmV0dXJuIGoudHdlZW5zLnB1c2goZCksIGQ7XFxuICAgICAgfSwgc3RvcDogZnVuY3Rpb24gc3RvcChiKSB7XFxuICAgICAgICB2YXIgYyA9IDAsXFxuICAgICAgICAgICAgZCA9IGIgPyBqLnR3ZWVucy5sZW5ndGggOiAwO2lmIChlKSByZXR1cm4gdGhpcztmb3IgKGUgPSAhMDsgZCA+IGM7IGMrKykge1xcbiAgICAgICAgICBqLnR3ZWVuc1tjXS5ydW4oMSk7XFxuICAgICAgICB9cmV0dXJuIGIgPyAoaC5ub3RpZnlXaXRoKGEsIFtqLCAxLCAwXSksIGgucmVzb2x2ZVdpdGgoYSwgW2osIGJdKSkgOiBoLnJlamVjdFdpdGgoYSwgW2osIGJdKSwgdGhpcztcXG4gICAgICB9IH0pLFxcbiAgICAgICAgayA9IGoucHJvcHM7Zm9yICgkYShrLCBqLm9wdHMuc3BlY2lhbEVhc2luZyk7IGcgPiBmOyBmKyspIHtcXG4gICAgICBpZiAoZCA9IF9hLnByZWZpbHRlcnNbZl0uY2FsbChqLCBhLCBrLCBqLm9wdHMpKSByZXR1cm4gbi5pc0Z1bmN0aW9uKGQuc3RvcCkgJiYgKG4uX3F1ZXVlSG9va3Moai5lbGVtLCBqLm9wdHMucXVldWUpLnN0b3AgPSBuLnByb3h5KGQuc3RvcCwgZCkpLCBkO1xcbiAgICB9cmV0dXJuIG4ubWFwKGssIFlhLCBqKSwgbi5pc0Z1bmN0aW9uKGoub3B0cy5zdGFydCkgJiYgai5vcHRzLnN0YXJ0LmNhbGwoYSwgaiksIG4uZngudGltZXIobi5leHRlbmQoaSwgeyBlbGVtOiBhLCBhbmltOiBqLCBxdWV1ZTogai5vcHRzLnF1ZXVlIH0pKSwgai5wcm9ncmVzcyhqLm9wdHMucHJvZ3Jlc3MpLmRvbmUoai5vcHRzLmRvbmUsIGoub3B0cy5jb21wbGV0ZSkuZmFpbChqLm9wdHMuZmFpbCkuYWx3YXlzKGoub3B0cy5hbHdheXMpO1xcbiAgfW4uQW5pbWF0aW9uID0gbi5leHRlbmQoX2EsIHsgdHdlZW5lcnM6IHsgXFxcIipcXFwiOiBbZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVUd2VlbihhLCBiKTtyZXR1cm4gVyhjLmVsZW0sIGEsIFQuZXhlYyhiKSwgYyksIGM7XFxuICAgICAgfV0gfSwgdHdlZW5lcjogZnVuY3Rpb24gdHdlZW5lcihhLCBiKSB7XFxuICAgICAgbi5pc0Z1bmN0aW9uKGEpID8gKGIgPSBhLCBhID0gW1xcXCIqXFxcIl0pIDogYSA9IGEubWF0Y2goRyk7Zm9yICh2YXIgYywgZCA9IDAsIGUgPSBhLmxlbmd0aDsgZSA+IGQ7IGQrKykge1xcbiAgICAgICAgYyA9IGFbZF0sIF9hLnR3ZWVuZXJzW2NdID0gX2EudHdlZW5lcnNbY10gfHwgW10sIF9hLnR3ZWVuZXJzW2NdLnVuc2hpZnQoYik7XFxuICAgICAgfVxcbiAgICB9LCBwcmVmaWx0ZXJzOiBbWmFdLCBwcmVmaWx0ZXI6IGZ1bmN0aW9uIHByZWZpbHRlcihhLCBiKSB7XFxuICAgICAgYiA/IF9hLnByZWZpbHRlcnMudW5zaGlmdChhKSA6IF9hLnByZWZpbHRlcnMucHVzaChhKTtcXG4gICAgfSB9KSwgbi5zcGVlZCA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgIHZhciBkID0gYSAmJiBcXFwib2JqZWN0XFxcIiA9PSAodHlwZW9mIGEgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGEpKSA/IG4uZXh0ZW5kKHt9LCBhKSA6IHsgY29tcGxldGU6IGMgfHwgIWMgJiYgYiB8fCBuLmlzRnVuY3Rpb24oYSkgJiYgYSwgZHVyYXRpb246IGEsIGVhc2luZzogYyAmJiBiIHx8IGIgJiYgIW4uaXNGdW5jdGlvbihiKSAmJiBiIH07cmV0dXJuIGQuZHVyYXRpb24gPSBuLmZ4Lm9mZiA/IDAgOiBcXFwibnVtYmVyXFxcIiA9PSB0eXBlb2YgZC5kdXJhdGlvbiA/IGQuZHVyYXRpb24gOiBkLmR1cmF0aW9uIGluIG4uZnguc3BlZWRzID8gbi5meC5zcGVlZHNbZC5kdXJhdGlvbl0gOiBuLmZ4LnNwZWVkcy5fZGVmYXVsdCwgbnVsbCAhPSBkLnF1ZXVlICYmIGQucXVldWUgIT09ICEwIHx8IChkLnF1ZXVlID0gXFxcImZ4XFxcIiksIGQub2xkID0gZC5jb21wbGV0ZSwgZC5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBuLmlzRnVuY3Rpb24oZC5vbGQpICYmIGQub2xkLmNhbGwodGhpcyksIGQucXVldWUgJiYgbi5kZXF1ZXVlKHRoaXMsIGQucXVldWUpO1xcbiAgICB9LCBkO1xcbiAgfSwgbi5mbi5leHRlbmQoeyBmYWRlVG86IGZ1bmN0aW9uIGZhZGVUbyhhLCBiLCBjLCBkKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKFYpLmNzcyhcXFwib3BhY2l0eVxcXCIsIDApLnNob3coKS5lbmQoKS5hbmltYXRlKHsgb3BhY2l0eTogYiB9LCBhLCBjLCBkKTtcXG4gICAgfSwgYW5pbWF0ZTogZnVuY3Rpb24gYW5pbWF0ZShhLCBiLCBjLCBkKSB7XFxuICAgICAgdmFyIGUgPSBuLmlzRW1wdHlPYmplY3QoYSksXFxuICAgICAgICAgIGYgPSBuLnNwZWVkKGIsIGMsIGQpLFxcbiAgICAgICAgICBnID0gZnVuY3Rpb24gZygpIHtcXG4gICAgICAgIHZhciBiID0gX2EodGhpcywgbi5leHRlbmQoe30sIGEpLCBmKTsoZSB8fCBOLmdldCh0aGlzLCBcXFwiZmluaXNoXFxcIikpICYmIGIuc3RvcCghMCk7XFxuICAgICAgfTtyZXR1cm4gZy5maW5pc2ggPSBnLCBlIHx8IGYucXVldWUgPT09ICExID8gdGhpcy5lYWNoKGcpIDogdGhpcy5xdWV1ZShmLnF1ZXVlLCBnKTtcXG4gICAgfSwgc3RvcDogZnVuY3Rpb24gc3RvcChhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQgPSBmdW5jdGlvbiBkKGEpIHtcXG4gICAgICAgIHZhciBiID0gYS5zdG9wO2RlbGV0ZSBhLnN0b3AsIGIoYyk7XFxuICAgICAgfTtyZXR1cm4gXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGEgJiYgKGMgPSBiLCBiID0gYSwgYSA9IHZvaWQgMCksIGIgJiYgYSAhPT0gITEgJiYgdGhpcy5xdWV1ZShhIHx8IFxcXCJmeFxcXCIsIFtdKSwgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBiID0gITAsXFxuICAgICAgICAgICAgZSA9IG51bGwgIT0gYSAmJiBhICsgXFxcInF1ZXVlSG9va3NcXFwiLFxcbiAgICAgICAgICAgIGYgPSBuLnRpbWVycyxcXG4gICAgICAgICAgICBnID0gTi5nZXQodGhpcyk7aWYgKGUpIGdbZV0gJiYgZ1tlXS5zdG9wICYmIGQoZ1tlXSk7ZWxzZSBmb3IgKGUgaW4gZykge1xcbiAgICAgICAgICBnW2VdICYmIGdbZV0uc3RvcCAmJiBWYS50ZXN0KGUpICYmIGQoZ1tlXSk7XFxuICAgICAgICB9Zm9yIChlID0gZi5sZW5ndGg7IGUtLTspIHtcXG4gICAgICAgICAgZltlXS5lbGVtICE9PSB0aGlzIHx8IG51bGwgIT0gYSAmJiBmW2VdLnF1ZXVlICE9PSBhIHx8IChmW2VdLmFuaW0uc3RvcChjKSwgYiA9ICExLCBmLnNwbGljZShlLCAxKSk7XFxuICAgICAgICB9IWIgJiYgYyB8fCBuLmRlcXVldWUodGhpcywgYSk7XFxuICAgICAgfSk7XFxuICAgIH0sIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKGEpIHtcXG4gICAgICByZXR1cm4gYSAhPT0gITEgJiYgKGEgPSBhIHx8IFxcXCJmeFxcXCIpLCB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGIsXFxuICAgICAgICAgICAgYyA9IE4uZ2V0KHRoaXMpLFxcbiAgICAgICAgICAgIGQgPSBjW2EgKyBcXFwicXVldWVcXFwiXSxcXG4gICAgICAgICAgICBlID0gY1thICsgXFxcInF1ZXVlSG9va3NcXFwiXSxcXG4gICAgICAgICAgICBmID0gbi50aW1lcnMsXFxuICAgICAgICAgICAgZyA9IGQgPyBkLmxlbmd0aCA6IDA7Zm9yIChjLmZpbmlzaCA9ICEwLCBuLnF1ZXVlKHRoaXMsIGEsIFtdKSwgZSAmJiBlLnN0b3AgJiYgZS5zdG9wLmNhbGwodGhpcywgITApLCBiID0gZi5sZW5ndGg7IGItLTspIHtcXG4gICAgICAgICAgZltiXS5lbGVtID09PSB0aGlzICYmIGZbYl0ucXVldWUgPT09IGEgJiYgKGZbYl0uYW5pbS5zdG9wKCEwKSwgZi5zcGxpY2UoYiwgMSkpO1xcbiAgICAgICAgfWZvciAoYiA9IDA7IGcgPiBiOyBiKyspIHtcXG4gICAgICAgICAgZFtiXSAmJiBkW2JdLmZpbmlzaCAmJiBkW2JdLmZpbmlzaC5jYWxsKHRoaXMpO1xcbiAgICAgICAgfWRlbGV0ZSBjLmZpbmlzaDtcXG4gICAgICB9KTtcXG4gICAgfSB9KSwgbi5lYWNoKFtcXFwidG9nZ2xlXFxcIiwgXFxcInNob3dcXFwiLCBcXFwiaGlkZVxcXCJdLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICB2YXIgYyA9IG4uZm5bYl07bi5mbltiXSA9IGZ1bmN0aW9uIChhLCBkLCBlKSB7XFxuICAgICAgcmV0dXJuIG51bGwgPT0gYSB8fCBcXFwiYm9vbGVhblxcXCIgPT0gdHlwZW9mIGEgPyBjLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB0aGlzLmFuaW1hdGUoWGEoYiwgITApLCBhLCBkLCBlKTtcXG4gICAgfTtcXG4gIH0pLCBuLmVhY2goeyBzbGlkZURvd246IFhhKFxcXCJzaG93XFxcIiksIHNsaWRlVXA6IFhhKFxcXCJoaWRlXFxcIiksIHNsaWRlVG9nZ2xlOiBYYShcXFwidG9nZ2xlXFxcIiksIGZhZGVJbjogeyBvcGFjaXR5OiBcXFwic2hvd1xcXCIgfSwgZmFkZU91dDogeyBvcGFjaXR5OiBcXFwiaGlkZVxcXCIgfSwgZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcXFwidG9nZ2xlXFxcIiB9IH0sIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIG4uZm5bYV0gPSBmdW5jdGlvbiAoYSwgYywgZCkge1xcbiAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoYiwgYSwgYywgZCk7XFxuICAgIH07XFxuICB9KSwgbi50aW1lcnMgPSBbXSwgbi5meC50aWNrID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgYSxcXG4gICAgICAgIGIgPSAwLFxcbiAgICAgICAgYyA9IG4udGltZXJzO2ZvciAoU2EgPSBuLm5vdygpOyBiIDwgYy5sZW5ndGg7IGIrKykge1xcbiAgICAgIGEgPSBjW2JdLCBhKCkgfHwgY1tiXSAhPT0gYSB8fCBjLnNwbGljZShiLS0sIDEpO1xcbiAgICB9Yy5sZW5ndGggfHwgbi5meC5zdG9wKCksIFNhID0gdm9pZCAwO1xcbiAgfSwgbi5meC50aW1lciA9IGZ1bmN0aW9uIChhKSB7XFxuICAgIG4udGltZXJzLnB1c2goYSksIGEoKSA/IG4uZnguc3RhcnQoKSA6IG4udGltZXJzLnBvcCgpO1xcbiAgfSwgbi5meC5pbnRlcnZhbCA9IDEzLCBuLmZ4LnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xcbiAgICBUYSB8fCAoVGEgPSBhLnNldEludGVydmFsKG4uZngudGljaywgbi5meC5pbnRlcnZhbCkpO1xcbiAgfSwgbi5meC5zdG9wID0gZnVuY3Rpb24gKCkge1xcbiAgICBhLmNsZWFySW50ZXJ2YWwoVGEpLCBUYSA9IG51bGw7XFxuICB9LCBuLmZ4LnNwZWVkcyA9IHsgc2xvdzogNjAwLCBmYXN0OiAyMDAsIF9kZWZhdWx0OiA0MDAgfSwgbi5mbi5kZWxheSA9IGZ1bmN0aW9uIChiLCBjKSB7XFxuICAgIHJldHVybiBiID0gbi5meCA/IG4uZnguc3BlZWRzW2JdIHx8IGIgOiBiLCBjID0gYyB8fCBcXFwiZnhcXFwiLCB0aGlzLnF1ZXVlKGMsIGZ1bmN0aW9uIChjLCBkKSB7XFxuICAgICAgdmFyIGUgPSBhLnNldFRpbWVvdXQoYywgYik7ZC5zdG9wID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgYS5jbGVhclRpbWVvdXQoZSk7XFxuICAgICAgfTtcXG4gICAgfSk7XFxuICB9LCBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBhID0gZC5jcmVhdGVFbGVtZW50KFxcXCJpbnB1dFxcXCIpLFxcbiAgICAgICAgYiA9IGQuY3JlYXRlRWxlbWVudChcXFwic2VsZWN0XFxcIiksXFxuICAgICAgICBjID0gYi5hcHBlbmRDaGlsZChkLmNyZWF0ZUVsZW1lbnQoXFxcIm9wdGlvblxcXCIpKTthLnR5cGUgPSBcXFwiY2hlY2tib3hcXFwiLCBsLmNoZWNrT24gPSBcXFwiXFxcIiAhPT0gYS52YWx1ZSwgbC5vcHRTZWxlY3RlZCA9IGMuc2VsZWN0ZWQsIGIuZGlzYWJsZWQgPSAhMCwgbC5vcHREaXNhYmxlZCA9ICFjLmRpc2FibGVkLCBhID0gZC5jcmVhdGVFbGVtZW50KFxcXCJpbnB1dFxcXCIpLCBhLnZhbHVlID0gXFxcInRcXFwiLCBhLnR5cGUgPSBcXFwicmFkaW9cXFwiLCBsLnJhZGlvVmFsdWUgPSBcXFwidFxcXCIgPT09IGEudmFsdWU7XFxuICB9KCk7dmFyIGFiLFxcbiAgICAgIGJiID0gbi5leHByLmF0dHJIYW5kbGU7bi5mbi5leHRlbmQoeyBhdHRyOiBmdW5jdGlvbiBhdHRyKGEsIGIpIHtcXG4gICAgICByZXR1cm4gSyh0aGlzLCBuLmF0dHIsIGEsIGIsIGFyZ3VtZW50cy5sZW5ndGggPiAxKTtcXG4gICAgfSwgcmVtb3ZlQXR0cjogZnVuY3Rpb24gcmVtb3ZlQXR0cihhKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBuLnJlbW92ZUF0dHIodGhpcywgYSk7XFxuICAgICAgfSk7XFxuICAgIH0gfSksIG4uZXh0ZW5kKHsgYXR0cjogZnVuY3Rpb24gYXR0cihhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIGYgPSBhLm5vZGVUeXBlO2lmICgzICE9PSBmICYmIDggIT09IGYgJiYgMiAhPT0gZikgcmV0dXJuIFxcXCJ1bmRlZmluZWRcXFwiID09IHR5cGVvZiBhLmdldEF0dHJpYnV0ZSA/IG4ucHJvcChhLCBiLCBjKSA6ICgxID09PSBmICYmIG4uaXNYTUxEb2MoYSkgfHwgKGIgPSBiLnRvTG93ZXJDYXNlKCksIGUgPSBuLmF0dHJIb29rc1tiXSB8fCAobi5leHByLm1hdGNoLmJvb2wudGVzdChiKSA/IGFiIDogdm9pZCAwKSksIHZvaWQgMCAhPT0gYyA/IG51bGwgPT09IGMgPyB2b2lkIG4ucmVtb3ZlQXR0cihhLCBiKSA6IGUgJiYgXFxcInNldFxcXCIgaW4gZSAmJiB2b2lkIDAgIT09IChkID0gZS5zZXQoYSwgYywgYikpID8gZCA6IChhLnNldEF0dHJpYnV0ZShiLCBjICsgXFxcIlxcXCIpLCBjKSA6IGUgJiYgXFxcImdldFxcXCIgaW4gZSAmJiBudWxsICE9PSAoZCA9IGUuZ2V0KGEsIGIpKSA/IGQgOiAoZCA9IG4uZmluZC5hdHRyKGEsIGIpLCBudWxsID09IGQgPyB2b2lkIDAgOiBkKSk7XFxuICAgIH0sIGF0dHJIb29rczogeyB0eXBlOiB7IHNldDogZnVuY3Rpb24gc2V0KGEsIGIpIHtcXG4gICAgICAgICAgaWYgKCFsLnJhZGlvVmFsdWUgJiYgXFxcInJhZGlvXFxcIiA9PT0gYiAmJiBuLm5vZGVOYW1lKGEsIFxcXCJpbnB1dFxcXCIpKSB7XFxuICAgICAgICAgICAgdmFyIGMgPSBhLnZhbHVlO3JldHVybiBhLnNldEF0dHJpYnV0ZShcXFwidHlwZVxcXCIsIGIpLCBjICYmIChhLnZhbHVlID0gYyksIGI7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gfSB9LCByZW1vdmVBdHRyOiBmdW5jdGlvbiByZW1vdmVBdHRyKGEsIGIpIHtcXG4gICAgICB2YXIgYyxcXG4gICAgICAgICAgZCxcXG4gICAgICAgICAgZSA9IDAsXFxuICAgICAgICAgIGYgPSBiICYmIGIubWF0Y2goRyk7aWYgKGYgJiYgMSA9PT0gYS5ub2RlVHlwZSkgd2hpbGUgKGMgPSBmW2UrK10pIHtcXG4gICAgICAgIGQgPSBuLnByb3BGaXhbY10gfHwgYywgbi5leHByLm1hdGNoLmJvb2wudGVzdChjKSAmJiAoYVtkXSA9ICExKSwgYS5yZW1vdmVBdHRyaWJ1dGUoYyk7XFxuICAgICAgfVxcbiAgICB9IH0pLCBhYiA9IHsgc2V0OiBmdW5jdGlvbiBzZXQoYSwgYiwgYykge1xcbiAgICAgIHJldHVybiBiID09PSAhMSA/IG4ucmVtb3ZlQXR0cihhLCBjKSA6IGEuc2V0QXR0cmlidXRlKGMsIGMpLCBjO1xcbiAgICB9IH0sIG4uZWFjaChuLmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goL1xcXFx3Ky9nKSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgdmFyIGMgPSBiYltiXSB8fCBuLmZpbmQuYXR0cjtiYltiXSA9IGZ1bmN0aW9uIChhLCBiLCBkKSB7XFxuICAgICAgdmFyIGUsIGY7cmV0dXJuIGQgfHwgKGYgPSBiYltiXSwgYmJbYl0gPSBlLCBlID0gbnVsbCAhPSBjKGEsIGIsIGQpID8gYi50b0xvd2VyQ2FzZSgpIDogbnVsbCwgYmJbYl0gPSBmKSwgZTtcXG4gICAgfTtcXG4gIH0pO3ZhciBjYiA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXFxuICAgICAgZGIgPSAvXig/OmF8YXJlYSkkL2k7bi5mbi5leHRlbmQoeyBwcm9wOiBmdW5jdGlvbiBwcm9wKGEsIGIpIHtcXG4gICAgICByZXR1cm4gSyh0aGlzLCBuLnByb3AsIGEsIGIsIGFyZ3VtZW50cy5sZW5ndGggPiAxKTtcXG4gICAgfSwgcmVtb3ZlUHJvcDogZnVuY3Rpb24gcmVtb3ZlUHJvcChhKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBkZWxldGUgdGhpc1tuLnByb3BGaXhbYV0gfHwgYV07XFxuICAgICAgfSk7XFxuICAgIH0gfSksIG4uZXh0ZW5kKHsgcHJvcDogZnVuY3Rpb24gcHJvcChhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIGYgPSBhLm5vZGVUeXBlO2lmICgzICE9PSBmICYmIDggIT09IGYgJiYgMiAhPT0gZikgcmV0dXJuIDEgPT09IGYgJiYgbi5pc1hNTERvYyhhKSB8fCAoYiA9IG4ucHJvcEZpeFtiXSB8fCBiLCBlID0gbi5wcm9wSG9va3NbYl0pLCB2b2lkIDAgIT09IGMgPyBlICYmIFxcXCJzZXRcXFwiIGluIGUgJiYgdm9pZCAwICE9PSAoZCA9IGUuc2V0KGEsIGMsIGIpKSA/IGQgOiBhW2JdID0gYyA6IGUgJiYgXFxcImdldFxcXCIgaW4gZSAmJiBudWxsICE9PSAoZCA9IGUuZ2V0KGEsIGIpKSA/IGQgOiBhW2JdO1xcbiAgICB9LCBwcm9wSG9va3M6IHsgdGFiSW5kZXg6IHsgZ2V0OiBmdW5jdGlvbiBnZXQoYSkge1xcbiAgICAgICAgICB2YXIgYiA9IG4uZmluZC5hdHRyKGEsIFxcXCJ0YWJpbmRleFxcXCIpO3JldHVybiBiID8gcGFyc2VJbnQoYiwgMTApIDogY2IudGVzdChhLm5vZGVOYW1lKSB8fCBkYi50ZXN0KGEubm9kZU5hbWUpICYmIGEuaHJlZiA/IDAgOiAtMTtcXG4gICAgICAgIH0gfSB9LCBwcm9wRml4OiB7IFxcXCJmb3JcXFwiOiBcXFwiaHRtbEZvclxcXCIsIFxcXCJjbGFzc1xcXCI6IFxcXCJjbGFzc05hbWVcXFwiIH0gfSksIGwub3B0U2VsZWN0ZWQgfHwgKG4ucHJvcEhvb2tzLnNlbGVjdGVkID0geyBnZXQ6IGZ1bmN0aW9uIGdldChhKSB7XFxuICAgICAgdmFyIGIgPSBhLnBhcmVudE5vZGU7cmV0dXJuIGIgJiYgYi5wYXJlbnROb2RlICYmIGIucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4LCBudWxsO1xcbiAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldChhKSB7XFxuICAgICAgdmFyIGIgPSBhLnBhcmVudE5vZGU7YiAmJiAoYi5zZWxlY3RlZEluZGV4LCBiLnBhcmVudE5vZGUgJiYgYi5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXgpO1xcbiAgICB9IH0pLCBuLmVhY2goW1xcXCJ0YWJJbmRleFxcXCIsIFxcXCJyZWFkT25seVxcXCIsIFxcXCJtYXhMZW5ndGhcXFwiLCBcXFwiY2VsbFNwYWNpbmdcXFwiLCBcXFwiY2VsbFBhZGRpbmdcXFwiLCBcXFwicm93U3BhblxcXCIsIFxcXCJjb2xTcGFuXFxcIiwgXFxcInVzZU1hcFxcXCIsIFxcXCJmcmFtZUJvcmRlclxcXCIsIFxcXCJjb250ZW50RWRpdGFibGVcXFwiXSwgZnVuY3Rpb24gKCkge1xcbiAgICBuLnByb3BGaXhbdGhpcy50b0xvd2VyQ2FzZSgpXSA9IHRoaXM7XFxuICB9KTt2YXIgZWIgPSAvW1xcXFx0XFxcXHJcXFxcblxcXFxmXS9nO2Z1bmN0aW9uIGZiKGEpIHtcXG4gICAgcmV0dXJuIGEuZ2V0QXR0cmlidXRlICYmIGEuZ2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIpIHx8IFxcXCJcXFwiO1xcbiAgfW4uZm4uZXh0ZW5kKHsgYWRkQ2xhc3M6IGZ1bmN0aW9uIGFkZENsYXNzKGEpIHtcXG4gICAgICB2YXIgYixcXG4gICAgICAgICAgYyxcXG4gICAgICAgICAgZCxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZixcXG4gICAgICAgICAgZyxcXG4gICAgICAgICAgaCxcXG4gICAgICAgICAgaSA9IDA7aWYgKG4uaXNGdW5jdGlvbihhKSkgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoYikge1xcbiAgICAgICAgbih0aGlzKS5hZGRDbGFzcyhhLmNhbGwodGhpcywgYiwgZmIodGhpcykpKTtcXG4gICAgICB9KTtpZiAoXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGEgJiYgYSkge1xcbiAgICAgICAgYiA9IGEubWF0Y2goRykgfHwgW107d2hpbGUgKGMgPSB0aGlzW2krK10pIHtcXG4gICAgICAgICAgaWYgKGUgPSBmYihjKSwgZCA9IDEgPT09IGMubm9kZVR5cGUgJiYgKFxcXCIgXFxcIiArIGUgKyBcXFwiIFxcXCIpLnJlcGxhY2UoZWIsIFxcXCIgXFxcIikpIHtcXG4gICAgICAgICAgICBnID0gMDt3aGlsZSAoZiA9IGJbZysrXSkge1xcbiAgICAgICAgICAgICAgZC5pbmRleE9mKFxcXCIgXFxcIiArIGYgKyBcXFwiIFxcXCIpIDwgMCAmJiAoZCArPSBmICsgXFxcIiBcXFwiKTtcXG4gICAgICAgICAgICB9aCA9IG4udHJpbShkKSwgZSAhPT0gaCAmJiBjLnNldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiLCBoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1yZXR1cm4gdGhpcztcXG4gICAgfSwgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGEpIHtcXG4gICAgICB2YXIgYixcXG4gICAgICAgICAgYyxcXG4gICAgICAgICAgZCxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZixcXG4gICAgICAgICAgZyxcXG4gICAgICAgICAgaCxcXG4gICAgICAgICAgaSA9IDA7aWYgKG4uaXNGdW5jdGlvbihhKSkgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoYikge1xcbiAgICAgICAgbih0aGlzKS5yZW1vdmVDbGFzcyhhLmNhbGwodGhpcywgYiwgZmIodGhpcykpKTtcXG4gICAgICB9KTtpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLmF0dHIoXFxcImNsYXNzXFxcIiwgXFxcIlxcXCIpO2lmIChcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYSAmJiBhKSB7XFxuICAgICAgICBiID0gYS5tYXRjaChHKSB8fCBbXTt3aGlsZSAoYyA9IHRoaXNbaSsrXSkge1xcbiAgICAgICAgICBpZiAoZSA9IGZiKGMpLCBkID0gMSA9PT0gYy5ub2RlVHlwZSAmJiAoXFxcIiBcXFwiICsgZSArIFxcXCIgXFxcIikucmVwbGFjZShlYiwgXFxcIiBcXFwiKSkge1xcbiAgICAgICAgICAgIGcgPSAwO3doaWxlIChmID0gYltnKytdKSB7XFxuICAgICAgICAgICAgICB3aGlsZSAoZC5pbmRleE9mKFxcXCIgXFxcIiArIGYgKyBcXFwiIFxcXCIpID4gLTEpIHtcXG4gICAgICAgICAgICAgICAgZCA9IGQucmVwbGFjZShcXFwiIFxcXCIgKyBmICsgXFxcIiBcXFwiLCBcXFwiIFxcXCIpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1oID0gbi50cmltKGQpLCBlICE9PSBoICYmIGMuc2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIsIGgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfXJldHVybiB0aGlzO1xcbiAgICB9LCB0b2dnbGVDbGFzczogZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoYSwgYikge1xcbiAgICAgIHZhciBjID0gdHlwZW9mIGEgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGEpO3JldHVybiBcXFwiYm9vbGVhblxcXCIgPT0gdHlwZW9mIGIgJiYgXFxcInN0cmluZ1xcXCIgPT09IGMgPyBiID8gdGhpcy5hZGRDbGFzcyhhKSA6IHRoaXMucmVtb3ZlQ2xhc3MoYSkgOiBuLmlzRnVuY3Rpb24oYSkgPyB0aGlzLmVhY2goZnVuY3Rpb24gKGMpIHtcXG4gICAgICAgIG4odGhpcykudG9nZ2xlQ2xhc3MoYS5jYWxsKHRoaXMsIGMsIGZiKHRoaXMpLCBiKSwgYik7XFxuICAgICAgfSkgOiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGIsIGQsIGUsIGY7aWYgKFxcXCJzdHJpbmdcXFwiID09PSBjKSB7XFxuICAgICAgICAgIGQgPSAwLCBlID0gbih0aGlzKSwgZiA9IGEubWF0Y2goRykgfHwgW107d2hpbGUgKGIgPSBmW2QrK10pIHtcXG4gICAgICAgICAgICBlLmhhc0NsYXNzKGIpID8gZS5yZW1vdmVDbGFzcyhiKSA6IGUuYWRkQ2xhc3MoYik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB2b2lkIDAgIT09IGEgJiYgXFxcImJvb2xlYW5cXFwiICE9PSBjIHx8IChiID0gZmIodGhpcyksIGIgJiYgTi5zZXQodGhpcywgXFxcIl9fY2xhc3NOYW1lX19cXFwiLCBiKSwgdGhpcy5zZXRBdHRyaWJ1dGUgJiYgdGhpcy5zZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIiwgYiB8fCBhID09PSAhMSA/IFxcXCJcXFwiIDogTi5nZXQodGhpcywgXFxcIl9fY2xhc3NOYW1lX19cXFwiKSB8fCBcXFwiXFxcIikpO1xcbiAgICAgIH0pO1xcbiAgICB9LCBoYXNDbGFzczogZnVuY3Rpb24gaGFzQ2xhc3MoYSkge1xcbiAgICAgIHZhciBiLFxcbiAgICAgICAgICBjLFxcbiAgICAgICAgICBkID0gMDtiID0gXFxcIiBcXFwiICsgYSArIFxcXCIgXFxcIjt3aGlsZSAoYyA9IHRoaXNbZCsrXSkge1xcbiAgICAgICAgaWYgKDEgPT09IGMubm9kZVR5cGUgJiYgKFxcXCIgXFxcIiArIGZiKGMpICsgXFxcIiBcXFwiKS5yZXBsYWNlKGViLCBcXFwiIFxcXCIpLmluZGV4T2YoYikgPiAtMSkgcmV0dXJuICEwO1xcbiAgICAgIH1yZXR1cm4gITE7XFxuICAgIH0gfSk7dmFyIGdiID0gL1xcXFxyL2csXFxuICAgICAgaGIgPSAvW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl0rL2c7bi5mbi5leHRlbmQoeyB2YWw6IGZ1bmN0aW9uIHZhbChhKSB7XFxuICAgICAgdmFyIGIsXFxuICAgICAgICAgIGMsXFxuICAgICAgICAgIGQsXFxuICAgICAgICAgIGUgPSB0aGlzWzBdO3tcXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZCA9IG4uaXNGdW5jdGlvbihhKSwgdGhpcy5lYWNoKGZ1bmN0aW9uIChjKSB7XFxuICAgICAgICAgIHZhciBlOzEgPT09IHRoaXMubm9kZVR5cGUgJiYgKGUgPSBkID8gYS5jYWxsKHRoaXMsIGMsIG4odGhpcykudmFsKCkpIDogYSwgbnVsbCA9PSBlID8gZSA9IFxcXCJcXFwiIDogXFxcIm51bWJlclxcXCIgPT0gdHlwZW9mIGUgPyBlICs9IFxcXCJcXFwiIDogbi5pc0FycmF5KGUpICYmIChlID0gbi5tYXAoZSwgZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgICByZXR1cm4gbnVsbCA9PSBhID8gXFxcIlxcXCIgOiBhICsgXFxcIlxcXCI7XFxuICAgICAgICAgIH0pKSwgYiA9IG4udmFsSG9va3NbdGhpcy50eXBlXSB8fCBuLnZhbEhvb2tzW3RoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0sIGIgJiYgXFxcInNldFxcXCIgaW4gYiAmJiB2b2lkIDAgIT09IGIuc2V0KHRoaXMsIGUsIFxcXCJ2YWx1ZVxcXCIpIHx8ICh0aGlzLnZhbHVlID0gZSkpO1xcbiAgICAgICAgfSk7aWYgKGUpIHJldHVybiBiID0gbi52YWxIb29rc1tlLnR5cGVdIHx8IG4udmFsSG9va3NbZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSwgYiAmJiBcXFwiZ2V0XFxcIiBpbiBiICYmIHZvaWQgMCAhPT0gKGMgPSBiLmdldChlLCBcXFwidmFsdWVcXFwiKSkgPyBjIDogKGMgPSBlLnZhbHVlLCBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYyA/IGMucmVwbGFjZShnYiwgXFxcIlxcXCIpIDogbnVsbCA9PSBjID8gXFxcIlxcXCIgOiBjKTtcXG4gICAgICB9XFxuICAgIH0gfSksIG4uZXh0ZW5kKHsgdmFsSG9va3M6IHsgb3B0aW9uOiB7IGdldDogZnVuY3Rpb24gZ2V0KGEpIHtcXG4gICAgICAgICAgdmFyIGIgPSBuLmZpbmQuYXR0cihhLCBcXFwidmFsdWVcXFwiKTtyZXR1cm4gbnVsbCAhPSBiID8gYiA6IG4udHJpbShuLnRleHQoYSkpLnJlcGxhY2UoaGIsIFxcXCIgXFxcIik7XFxuICAgICAgICB9IH0sIHNlbGVjdDogeyBnZXQ6IGZ1bmN0aW9uIGdldChhKSB7XFxuICAgICAgICAgIGZvciAodmFyIGIsIGMsIGQgPSBhLm9wdGlvbnMsIGUgPSBhLnNlbGVjdGVkSW5kZXgsIGYgPSBcXFwic2VsZWN0LW9uZVxcXCIgPT09IGEudHlwZSB8fCAwID4gZSwgZyA9IGYgPyBudWxsIDogW10sIGggPSBmID8gZSArIDEgOiBkLmxlbmd0aCwgaSA9IDAgPiBlID8gaCA6IGYgPyBlIDogMDsgaCA+IGk7IGkrKykge1xcbiAgICAgICAgICAgIGlmIChjID0gZFtpXSwgKGMuc2VsZWN0ZWQgfHwgaSA9PT0gZSkgJiYgKGwub3B0RGlzYWJsZWQgPyAhYy5kaXNhYmxlZCA6IG51bGwgPT09IGMuZ2V0QXR0cmlidXRlKFxcXCJkaXNhYmxlZFxcXCIpKSAmJiAoIWMucGFyZW50Tm9kZS5kaXNhYmxlZCB8fCAhbi5ub2RlTmFtZShjLnBhcmVudE5vZGUsIFxcXCJvcHRncm91cFxcXCIpKSkge1xcbiAgICAgICAgICAgICAgaWYgKGIgPSBuKGMpLnZhbCgpLCBmKSByZXR1cm4gYjtnLnB1c2goYik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9cmV0dXJuIGc7XFxuICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldChhLCBiKSB7XFxuICAgICAgICAgIHZhciBjLFxcbiAgICAgICAgICAgICAgZCxcXG4gICAgICAgICAgICAgIGUgPSBhLm9wdGlvbnMsXFxuICAgICAgICAgICAgICBmID0gbi5tYWtlQXJyYXkoYiksXFxuICAgICAgICAgICAgICBnID0gZS5sZW5ndGg7d2hpbGUgKGctLSkge1xcbiAgICAgICAgICAgIGQgPSBlW2ddLCAoZC5zZWxlY3RlZCA9IG4uaW5BcnJheShuLnZhbEhvb2tzLm9wdGlvbi5nZXQoZCksIGYpID4gLTEpICYmIChjID0gITApO1xcbiAgICAgICAgICB9cmV0dXJuIGMgfHwgKGEuc2VsZWN0ZWRJbmRleCA9IC0xKSwgZjtcXG4gICAgICAgIH0gfSB9IH0pLCBuLmVhY2goW1xcXCJyYWRpb1xcXCIsIFxcXCJjaGVja2JveFxcXCJdLCBmdW5jdGlvbiAoKSB7XFxuICAgIG4udmFsSG9va3NbdGhpc10gPSB7IHNldDogZnVuY3Rpb24gc2V0KGEsIGIpIHtcXG4gICAgICAgIHJldHVybiBuLmlzQXJyYXkoYikgPyBhLmNoZWNrZWQgPSBuLmluQXJyYXkobihhKS52YWwoKSwgYikgPiAtMSA6IHZvaWQgMDtcXG4gICAgICB9IH0sIGwuY2hlY2tPbiB8fCAobi52YWxIb29rc1t0aGlzXS5nZXQgPSBmdW5jdGlvbiAoYSkge1xcbiAgICAgIHJldHVybiBudWxsID09PSBhLmdldEF0dHJpYnV0ZShcXFwidmFsdWVcXFwiKSA/IFxcXCJvblxcXCIgOiBhLnZhbHVlO1xcbiAgICB9KTtcXG4gIH0pO3ZhciBpYiA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLztuLmV4dGVuZChuLmV2ZW50LCB7IHRyaWdnZXI6IGZ1bmN0aW9uIHRyaWdnZXIoYiwgYywgZSwgZikge1xcbiAgICAgIHZhciBnLFxcbiAgICAgICAgICBoLFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBsLFxcbiAgICAgICAgICBtLFxcbiAgICAgICAgICBvLFxcbiAgICAgICAgICBwID0gW2UgfHwgZF0sXFxuICAgICAgICAgIHEgPSBrLmNhbGwoYiwgXFxcInR5cGVcXFwiKSA/IGIudHlwZSA6IGIsXFxuICAgICAgICAgIHIgPSBrLmNhbGwoYiwgXFxcIm5hbWVzcGFjZVxcXCIpID8gYi5uYW1lc3BhY2Uuc3BsaXQoXFxcIi5cXFwiKSA6IFtdO2lmIChoID0gaSA9IGUgPSBlIHx8IGQsIDMgIT09IGUubm9kZVR5cGUgJiYgOCAhPT0gZS5ub2RlVHlwZSAmJiAhaWIudGVzdChxICsgbi5ldmVudC50cmlnZ2VyZWQpICYmIChxLmluZGV4T2YoXFxcIi5cXFwiKSA+IC0xICYmIChyID0gcS5zcGxpdChcXFwiLlxcXCIpLCBxID0gci5zaGlmdCgpLCByLnNvcnQoKSksIGwgPSBxLmluZGV4T2YoXFxcIjpcXFwiKSA8IDAgJiYgXFxcIm9uXFxcIiArIHEsIGIgPSBiW24uZXhwYW5kb10gPyBiIDogbmV3IG4uRXZlbnQocSwgXFxcIm9iamVjdFxcXCIgPT0gKHR5cGVvZiBiID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihiKSkgJiYgYiksIGIuaXNUcmlnZ2VyID0gZiA/IDIgOiAzLCBiLm5hbWVzcGFjZSA9IHIuam9pbihcXFwiLlxcXCIpLCBiLnJuYW1lc3BhY2UgPSBiLm5hbWVzcGFjZSA/IG5ldyBSZWdFeHAoXFxcIihefFxcXFxcXFxcLilcXFwiICsgci5qb2luKFxcXCJcXFxcXFxcXC4oPzouKlxcXFxcXFxcLnwpXFxcIikgKyBcXFwiKFxcXFxcXFxcLnwkKVxcXCIpIDogbnVsbCwgYi5yZXN1bHQgPSB2b2lkIDAsIGIudGFyZ2V0IHx8IChiLnRhcmdldCA9IGUpLCBjID0gbnVsbCA9PSBjID8gW2JdIDogbi5tYWtlQXJyYXkoYywgW2JdKSwgbyA9IG4uZXZlbnQuc3BlY2lhbFtxXSB8fCB7fSwgZiB8fCAhby50cmlnZ2VyIHx8IG8udHJpZ2dlci5hcHBseShlLCBjKSAhPT0gITEpKSB7XFxuICAgICAgICBpZiAoIWYgJiYgIW8ubm9CdWJibGUgJiYgIW4uaXNXaW5kb3coZSkpIHtcXG4gICAgICAgICAgZm9yIChqID0gby5kZWxlZ2F0ZVR5cGUgfHwgcSwgaWIudGVzdChqICsgcSkgfHwgKGggPSBoLnBhcmVudE5vZGUpOyBoOyBoID0gaC5wYXJlbnROb2RlKSB7XFxuICAgICAgICAgICAgcC5wdXNoKGgpLCBpID0gaDtcXG4gICAgICAgICAgfWkgPT09IChlLm93bmVyRG9jdW1lbnQgfHwgZCkgJiYgcC5wdXNoKGkuZGVmYXVsdFZpZXcgfHwgaS5wYXJlbnRXaW5kb3cgfHwgYSk7XFxuICAgICAgICB9ZyA9IDA7d2hpbGUgKChoID0gcFtnKytdKSAmJiAhYi5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XFxuICAgICAgICAgIGIudHlwZSA9IGcgPiAxID8gaiA6IG8uYmluZFR5cGUgfHwgcSwgbSA9IChOLmdldChoLCBcXFwiZXZlbnRzXFxcIikgfHwge30pW2IudHlwZV0gJiYgTi5nZXQoaCwgXFxcImhhbmRsZVxcXCIpLCBtICYmIG0uYXBwbHkoaCwgYyksIG0gPSBsICYmIGhbbF0sIG0gJiYgbS5hcHBseSAmJiBMKGgpICYmIChiLnJlc3VsdCA9IG0uYXBwbHkoaCwgYyksIGIucmVzdWx0ID09PSAhMSAmJiBiLnByZXZlbnREZWZhdWx0KCkpO1xcbiAgICAgICAgfXJldHVybiBiLnR5cGUgPSBxLCBmIHx8IGIuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgby5fZGVmYXVsdCAmJiBvLl9kZWZhdWx0LmFwcGx5KHAucG9wKCksIGMpICE9PSAhMSB8fCAhTChlKSB8fCBsICYmIG4uaXNGdW5jdGlvbihlW3FdKSAmJiAhbi5pc1dpbmRvdyhlKSAmJiAoaSA9IGVbbF0sIGkgJiYgKGVbbF0gPSBudWxsKSwgbi5ldmVudC50cmlnZ2VyZWQgPSBxLCBlW3FdKCksIG4uZXZlbnQudHJpZ2dlcmVkID0gdm9pZCAwLCBpICYmIChlW2xdID0gaSkpLCBiLnJlc3VsdDtcXG4gICAgICB9XFxuICAgIH0sIHNpbXVsYXRlOiBmdW5jdGlvbiBzaW11bGF0ZShhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQgPSBuLmV4dGVuZChuZXcgbi5FdmVudCgpLCBjLCB7IHR5cGU6IGEsIGlzU2ltdWxhdGVkOiAhMCB9KTtuLmV2ZW50LnRyaWdnZXIoZCwgbnVsbCwgYik7XFxuICAgIH0gfSksIG4uZm4uZXh0ZW5kKHsgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlcihhLCBiKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBuLmV2ZW50LnRyaWdnZXIoYSwgYiwgdGhpcyk7XFxuICAgICAgfSk7XFxuICAgIH0sIHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiB0cmlnZ2VySGFuZGxlcihhLCBiKSB7XFxuICAgICAgdmFyIGMgPSB0aGlzWzBdO3JldHVybiBjID8gbi5ldmVudC50cmlnZ2VyKGEsIGIsIGMsICEwKSA6IHZvaWQgMDtcXG4gICAgfSB9KSwgbi5lYWNoKFxcXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgbG9hZCByZXNpemUgc2Nyb2xsIHVubG9hZCBjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGVycm9yIGNvbnRleHRtZW51XFxcIi5zcGxpdChcXFwiIFxcXCIpLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBuLmZuW2JdID0gZnVuY3Rpb24gKGEsIGMpIHtcXG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgPyB0aGlzLm9uKGIsIG51bGwsIGEsIGMpIDogdGhpcy50cmlnZ2VyKGIpO1xcbiAgICB9O1xcbiAgfSksIG4uZm4uZXh0ZW5kKHsgaG92ZXI6IGZ1bmN0aW9uIGhvdmVyKGEsIGIpIHtcXG4gICAgICByZXR1cm4gdGhpcy5tb3VzZWVudGVyKGEpLm1vdXNlbGVhdmUoYiB8fCBhKTtcXG4gICAgfSB9KSwgbC5mb2N1c2luID0gXFxcIm9uZm9jdXNpblxcXCIgaW4gYSwgbC5mb2N1c2luIHx8IG4uZWFjaCh7IGZvY3VzOiBcXFwiZm9jdXNpblxcXCIsIGJsdXI6IFxcXCJmb2N1c291dFxcXCIgfSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgdmFyIGMgPSBmdW5jdGlvbiBjKGEpIHtcXG4gICAgICBuLmV2ZW50LnNpbXVsYXRlKGIsIGEudGFyZ2V0LCBuLmV2ZW50LmZpeChhKSk7XFxuICAgIH07bi5ldmVudC5zcGVjaWFsW2JdID0geyBzZXR1cDogZnVuY3Rpb24gc2V0dXAoKSB7XFxuICAgICAgICB2YXIgZCA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxcbiAgICAgICAgICAgIGUgPSBOLmFjY2VzcyhkLCBiKTtlIHx8IGQuYWRkRXZlbnRMaXN0ZW5lcihhLCBjLCAhMCksIE4uYWNjZXNzKGQsIGIsIChlIHx8IDApICsgMSk7XFxuICAgICAgfSwgdGVhcmRvd246IGZ1bmN0aW9uIHRlYXJkb3duKCkge1xcbiAgICAgICAgdmFyIGQgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcXG4gICAgICAgICAgICBlID0gTi5hY2Nlc3MoZCwgYikgLSAxO2UgPyBOLmFjY2VzcyhkLCBiLCBlKSA6IChkLnJlbW92ZUV2ZW50TGlzdGVuZXIoYSwgYywgITApLCBOLnJlbW92ZShkLCBiKSk7XFxuICAgICAgfSB9O1xcbiAgfSk7dmFyIGpiID0gYS5sb2NhdGlvbixcXG4gICAgICBrYiA9IG4ubm93KCksXFxuICAgICAgbGIgPSAvXFxcXD8vO24ucGFyc2VKU09OID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoYSArIFxcXCJcXFwiKTtcXG4gIH0sIG4ucGFyc2VYTUwgPSBmdW5jdGlvbiAoYikge1xcbiAgICB2YXIgYztpZiAoIWIgfHwgXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGIpIHJldHVybiBudWxsO3RyeSB7XFxuICAgICAgYyA9IG5ldyBhLkRPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhiLCBcXFwidGV4dC94bWxcXFwiKTtcXG4gICAgfSBjYXRjaCAoZCkge1xcbiAgICAgIGMgPSB2b2lkIDA7XFxuICAgIH1yZXR1cm4gYyAmJiAhYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwicGFyc2VyZXJyb3JcXFwiKS5sZW5ndGggfHwgbi5lcnJvcihcXFwiSW52YWxpZCBYTUw6IFxcXCIgKyBiKSwgYztcXG4gIH07dmFyIG1iID0gLyMuKiQvLFxcbiAgICAgIG5iID0gLyhbPyZdKV89W14mXSovLFxcbiAgICAgIG9iID0gL14oLio/KTpbIFxcXFx0XSooW15cXFxcclxcXFxuXSopJC9nbSxcXG4gICAgICBwYiA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxcbiAgICAgIHFiID0gL14oPzpHRVR8SEVBRCkkLyxcXG4gICAgICByYiA9IC9eXFxcXC9cXFxcLy8sXFxuICAgICAgc2IgPSB7fSxcXG4gICAgICB0YiA9IHt9LFxcbiAgICAgIHViID0gXFxcIiovXFxcIi5jb25jYXQoXFxcIipcXFwiKSxcXG4gICAgICB2YiA9IGQuY3JlYXRlRWxlbWVudChcXFwiYVxcXCIpO3ZiLmhyZWYgPSBqYi5ocmVmO2Z1bmN0aW9uIHdiKGEpIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChiLCBjKSB7XFxuICAgICAgXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGIgJiYgKGMgPSBiLCBiID0gXFxcIipcXFwiKTt2YXIgZCxcXG4gICAgICAgICAgZSA9IDAsXFxuICAgICAgICAgIGYgPSBiLnRvTG93ZXJDYXNlKCkubWF0Y2goRykgfHwgW107aWYgKG4uaXNGdW5jdGlvbihjKSkgd2hpbGUgKGQgPSBmW2UrK10pIHtcXG4gICAgICAgIFxcXCIrXFxcIiA9PT0gZFswXSA/IChkID0gZC5zbGljZSgxKSB8fCBcXFwiKlxcXCIsIChhW2RdID0gYVtkXSB8fCBbXSkudW5zaGlmdChjKSkgOiAoYVtkXSA9IGFbZF0gfHwgW10pLnB1c2goYyk7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfWZ1bmN0aW9uIHhiKGEsIGIsIGMsIGQpIHtcXG4gICAgdmFyIGUgPSB7fSxcXG4gICAgICAgIGYgPSBhID09PSB0YjtmdW5jdGlvbiBnKGgpIHtcXG4gICAgICB2YXIgaTtyZXR1cm4gZVtoXSA9ICEwLCBuLmVhY2goYVtoXSB8fCBbXSwgZnVuY3Rpb24gKGEsIGgpIHtcXG4gICAgICAgIHZhciBqID0gaChiLCBjLCBkKTtyZXR1cm4gXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGogfHwgZiB8fCBlW2pdID8gZiA/ICEoaSA9IGopIDogdm9pZCAwIDogKGIuZGF0YVR5cGVzLnVuc2hpZnQoaiksIGcoaiksICExKTtcXG4gICAgICB9KSwgaTtcXG4gICAgfXJldHVybiBnKGIuZGF0YVR5cGVzWzBdKSB8fCAhZVtcXFwiKlxcXCJdICYmIGcoXFxcIipcXFwiKTtcXG4gIH1mdW5jdGlvbiB5YihhLCBiKSB7XFxuICAgIHZhciBjLFxcbiAgICAgICAgZCxcXG4gICAgICAgIGUgPSBuLmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtmb3IgKGMgaW4gYikge1xcbiAgICAgIHZvaWQgMCAhPT0gYltjXSAmJiAoKGVbY10gPyBhIDogZCB8fCAoZCA9IHt9KSlbY10gPSBiW2NdKTtcXG4gICAgfXJldHVybiBkICYmIG4uZXh0ZW5kKCEwLCBhLCBkKSwgYTtcXG4gIH1mdW5jdGlvbiB6YihhLCBiLCBjKSB7XFxuICAgIHZhciBkLFxcbiAgICAgICAgZSxcXG4gICAgICAgIGYsXFxuICAgICAgICBnLFxcbiAgICAgICAgaCA9IGEuY29udGVudHMsXFxuICAgICAgICBpID0gYS5kYXRhVHlwZXM7d2hpbGUgKFxcXCIqXFxcIiA9PT0gaVswXSkge1xcbiAgICAgIGkuc2hpZnQoKSwgdm9pZCAwID09PSBkICYmIChkID0gYS5taW1lVHlwZSB8fCBiLmdldFJlc3BvbnNlSGVhZGVyKFxcXCJDb250ZW50LVR5cGVcXFwiKSk7XFxuICAgIH1pZiAoZCkgZm9yIChlIGluIGgpIHtcXG4gICAgICBpZiAoaFtlXSAmJiBoW2VdLnRlc3QoZCkpIHtcXG4gICAgICAgIGkudW5zaGlmdChlKTticmVhaztcXG4gICAgICB9XFxuICAgIH1pZiAoaVswXSBpbiBjKSBmID0gaVswXTtlbHNlIHtcXG4gICAgICBmb3IgKGUgaW4gYykge1xcbiAgICAgICAgaWYgKCFpWzBdIHx8IGEuY29udmVydGVyc1tlICsgXFxcIiBcXFwiICsgaVswXV0pIHtcXG4gICAgICAgICAgZiA9IGU7YnJlYWs7XFxuICAgICAgICB9ZyB8fCAoZyA9IGUpO1xcbiAgICAgIH1mID0gZiB8fCBnO1xcbiAgICB9cmV0dXJuIGYgPyAoZiAhPT0gaVswXSAmJiBpLnVuc2hpZnQoZiksIGNbZl0pIDogdm9pZCAwO1xcbiAgfWZ1bmN0aW9uIEFiKGEsIGIsIGMsIGQpIHtcXG4gICAgdmFyIGUsXFxuICAgICAgICBmLFxcbiAgICAgICAgZyxcXG4gICAgICAgIGgsXFxuICAgICAgICBpLFxcbiAgICAgICAgaiA9IHt9LFxcbiAgICAgICAgayA9IGEuZGF0YVR5cGVzLnNsaWNlKCk7aWYgKGtbMV0pIGZvciAoZyBpbiBhLmNvbnZlcnRlcnMpIHtcXG4gICAgICBqW2cudG9Mb3dlckNhc2UoKV0gPSBhLmNvbnZlcnRlcnNbZ107XFxuICAgIH1mID0gay5zaGlmdCgpO3doaWxlIChmKSB7XFxuICAgICAgaWYgKGEucmVzcG9uc2VGaWVsZHNbZl0gJiYgKGNbYS5yZXNwb25zZUZpZWxkc1tmXV0gPSBiKSwgIWkgJiYgZCAmJiBhLmRhdGFGaWx0ZXIgJiYgKGIgPSBhLmRhdGFGaWx0ZXIoYiwgYS5kYXRhVHlwZSkpLCBpID0gZiwgZiA9IGsuc2hpZnQoKSkgaWYgKFxcXCIqXFxcIiA9PT0gZikgZiA9IGk7ZWxzZSBpZiAoXFxcIipcXFwiICE9PSBpICYmIGkgIT09IGYpIHtcXG4gICAgICAgIGlmIChnID0galtpICsgXFxcIiBcXFwiICsgZl0gfHwgaltcXFwiKiBcXFwiICsgZl0sICFnKSBmb3IgKGUgaW4gaikge1xcbiAgICAgICAgICBpZiAoaCA9IGUuc3BsaXQoXFxcIiBcXFwiKSwgaFsxXSA9PT0gZiAmJiAoZyA9IGpbaSArIFxcXCIgXFxcIiArIGhbMF1dIHx8IGpbXFxcIiogXFxcIiArIGhbMF1dKSkge1xcbiAgICAgICAgICAgIGcgPT09ICEwID8gZyA9IGpbZV0gOiBqW2VdICE9PSAhMCAmJiAoZiA9IGhbMF0sIGsudW5zaGlmdChoWzFdKSk7YnJlYWs7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1pZiAoZyAhPT0gITApIGlmIChnICYmIGFbXFxcInRocm93c1xcXCJdKSBiID0gZyhiKTtlbHNlIHRyeSB7XFxuICAgICAgICAgIGIgPSBnKGIpO1xcbiAgICAgICAgfSBjYXRjaCAobCkge1xcbiAgICAgICAgICByZXR1cm4geyBzdGF0ZTogXFxcInBhcnNlcmVycm9yXFxcIiwgZXJyb3I6IGcgPyBsIDogXFxcIk5vIGNvbnZlcnNpb24gZnJvbSBcXFwiICsgaSArIFxcXCIgdG8gXFxcIiArIGYgfTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1yZXR1cm4geyBzdGF0ZTogXFxcInN1Y2Nlc3NcXFwiLCBkYXRhOiBiIH07XFxuICB9bi5leHRlbmQoeyBhY3RpdmU6IDAsIGxhc3RNb2RpZmllZDoge30sIGV0YWc6IHt9LCBhamF4U2V0dGluZ3M6IHsgdXJsOiBqYi5ocmVmLCB0eXBlOiBcXFwiR0VUXFxcIiwgaXNMb2NhbDogcGIudGVzdChqYi5wcm90b2NvbCksIGdsb2JhbDogITAsIHByb2Nlc3NEYXRhOiAhMCwgYXN5bmM6ICEwLCBjb250ZW50VHlwZTogXFxcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFxcXCIsIGFjY2VwdHM6IHsgXFxcIipcXFwiOiB1YiwgdGV4dDogXFxcInRleHQvcGxhaW5cXFwiLCBodG1sOiBcXFwidGV4dC9odG1sXFxcIiwgeG1sOiBcXFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFxcXCIsIGpzb246IFxcXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcXFwiIH0sIGNvbnRlbnRzOiB7IHhtbDogL1xcXFxieG1sXFxcXGIvLCBodG1sOiAvXFxcXGJodG1sLywganNvbjogL1xcXFxianNvblxcXFxiLyB9LCByZXNwb25zZUZpZWxkczogeyB4bWw6IFxcXCJyZXNwb25zZVhNTFxcXCIsIHRleHQ6IFxcXCJyZXNwb25zZVRleHRcXFwiLCBqc29uOiBcXFwicmVzcG9uc2VKU09OXFxcIiB9LCBjb252ZXJ0ZXJzOiB7IFxcXCIqIHRleHRcXFwiOiBTdHJpbmcsIFxcXCJ0ZXh0IGh0bWxcXFwiOiAhMCwgXFxcInRleHQganNvblxcXCI6IG4ucGFyc2VKU09OLCBcXFwidGV4dCB4bWxcXFwiOiBuLnBhcnNlWE1MIH0sIGZsYXRPcHRpb25zOiB7IHVybDogITAsIGNvbnRleHQ6ICEwIH0gfSwgYWpheFNldHVwOiBmdW5jdGlvbiBhamF4U2V0dXAoYSwgYikge1xcbiAgICAgIHJldHVybiBiID8geWIoeWIoYSwgbi5hamF4U2V0dGluZ3MpLCBiKSA6IHliKG4uYWpheFNldHRpbmdzLCBhKTtcXG4gICAgfSwgYWpheFByZWZpbHRlcjogd2Ioc2IpLCBhamF4VHJhbnNwb3J0OiB3Yih0YiksIGFqYXg6IGZ1bmN0aW9uIGFqYXgoYiwgYykge1xcbiAgICAgIFxcXCJvYmplY3RcXFwiID09ICh0eXBlb2YgYiA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoYikpICYmIChjID0gYiwgYiA9IHZvaWQgMCksIGMgPSBjIHx8IHt9O3ZhciBlLFxcbiAgICAgICAgICBmLFxcbiAgICAgICAgICBnLFxcbiAgICAgICAgICBoLFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBrLFxcbiAgICAgICAgICBsLFxcbiAgICAgICAgICBtID0gbi5hamF4U2V0dXAoe30sIGMpLFxcbiAgICAgICAgICBvID0gbS5jb250ZXh0IHx8IG0sXFxuICAgICAgICAgIHAgPSBtLmNvbnRleHQgJiYgKG8ubm9kZVR5cGUgfHwgby5qcXVlcnkpID8gbihvKSA6IG4uZXZlbnQsXFxuICAgICAgICAgIHEgPSBuLkRlZmVycmVkKCksXFxuICAgICAgICAgIHIgPSBuLkNhbGxiYWNrcyhcXFwib25jZSBtZW1vcnlcXFwiKSxcXG4gICAgICAgICAgcyA9IG0uc3RhdHVzQ29kZSB8fCB7fSxcXG4gICAgICAgICAgdCA9IHt9LFxcbiAgICAgICAgICB1ID0ge30sXFxuICAgICAgICAgIHYgPSAwLFxcbiAgICAgICAgICB3ID0gXFxcImNhbmNlbGVkXFxcIixcXG4gICAgICAgICAgeCA9IHsgcmVhZHlTdGF0ZTogMCwgZ2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uIGdldFJlc3BvbnNlSGVhZGVyKGEpIHtcXG4gICAgICAgICAgdmFyIGI7aWYgKDIgPT09IHYpIHtcXG4gICAgICAgICAgICBpZiAoIWgpIHtcXG4gICAgICAgICAgICAgIGggPSB7fTt3aGlsZSAoYiA9IG9iLmV4ZWMoZykpIHtcXG4gICAgICAgICAgICAgICAgaFtiWzFdLnRvTG93ZXJDYXNlKCldID0gYlsyXTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9YiA9IGhbYS50b0xvd2VyQ2FzZSgpXTtcXG4gICAgICAgICAgfXJldHVybiBudWxsID09IGIgPyBudWxsIDogYjtcXG4gICAgICAgIH0sIGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24gZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkge1xcbiAgICAgICAgICByZXR1cm4gMiA9PT0gdiA/IGcgOiBudWxsO1xcbiAgICAgICAgfSwgc2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcihhLCBiKSB7XFxuICAgICAgICAgIHZhciBjID0gYS50b0xvd2VyQ2FzZSgpO3JldHVybiB2IHx8IChhID0gdVtjXSA9IHVbY10gfHwgYSwgdFthXSA9IGIpLCB0aGlzO1xcbiAgICAgICAgfSwgb3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24gb3ZlcnJpZGVNaW1lVHlwZShhKSB7XFxuICAgICAgICAgIHJldHVybiB2IHx8IChtLm1pbWVUeXBlID0gYSksIHRoaXM7XFxuICAgICAgICB9LCBzdGF0dXNDb2RlOiBmdW5jdGlvbiBzdGF0dXNDb2RlKGEpIHtcXG4gICAgICAgICAgdmFyIGI7aWYgKGEpIGlmICgyID4gdikgZm9yIChiIGluIGEpIHtcXG4gICAgICAgICAgICBzW2JdID0gW3NbYl0sIGFbYl1dO1xcbiAgICAgICAgICB9IGVsc2UgeC5hbHdheXMoYVt4LnN0YXR1c10pO3JldHVybiB0aGlzO1xcbiAgICAgICAgfSwgYWJvcnQ6IGZ1bmN0aW9uIGFib3J0KGEpIHtcXG4gICAgICAgICAgdmFyIGIgPSBhIHx8IHc7cmV0dXJuIGUgJiYgZS5hYm9ydChiKSwgeigwLCBiKSwgdGhpcztcXG4gICAgICAgIH0gfTtpZiAocS5wcm9taXNlKHgpLmNvbXBsZXRlID0gci5hZGQsIHguc3VjY2VzcyA9IHguZG9uZSwgeC5lcnJvciA9IHguZmFpbCwgbS51cmwgPSAoKGIgfHwgbS51cmwgfHwgamIuaHJlZikgKyBcXFwiXFxcIikucmVwbGFjZShtYiwgXFxcIlxcXCIpLnJlcGxhY2UocmIsIGpiLnByb3RvY29sICsgXFxcIi8vXFxcIiksIG0udHlwZSA9IGMubWV0aG9kIHx8IGMudHlwZSB8fCBtLm1ldGhvZCB8fCBtLnR5cGUsIG0uZGF0YVR5cGVzID0gbi50cmltKG0uZGF0YVR5cGUgfHwgXFxcIipcXFwiKS50b0xvd2VyQ2FzZSgpLm1hdGNoKEcpIHx8IFtcXFwiXFxcIl0sIG51bGwgPT0gbS5jcm9zc0RvbWFpbikge1xcbiAgICAgICAgaiA9IGQuY3JlYXRlRWxlbWVudChcXFwiYVxcXCIpO3RyeSB7XFxuICAgICAgICAgIGouaHJlZiA9IG0udXJsLCBqLmhyZWYgPSBqLmhyZWYsIG0uY3Jvc3NEb21haW4gPSB2Yi5wcm90b2NvbCArIFxcXCIvL1xcXCIgKyB2Yi5ob3N0ICE9IGoucHJvdG9jb2wgKyBcXFwiLy9cXFwiICsgai5ob3N0O1xcbiAgICAgICAgfSBjYXRjaCAoeSkge1xcbiAgICAgICAgICBtLmNyb3NzRG9tYWluID0gITA7XFxuICAgICAgICB9XFxuICAgICAgfWlmIChtLmRhdGEgJiYgbS5wcm9jZXNzRGF0YSAmJiBcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgbS5kYXRhICYmIChtLmRhdGEgPSBuLnBhcmFtKG0uZGF0YSwgbS50cmFkaXRpb25hbCkpLCB4YihzYiwgbSwgYywgeCksIDIgPT09IHYpIHJldHVybiB4O2sgPSBuLmV2ZW50ICYmIG0uZ2xvYmFsLCBrICYmIDAgPT09IG4uYWN0aXZlKysgJiYgbi5ldmVudC50cmlnZ2VyKFxcXCJhamF4U3RhcnRcXFwiKSwgbS50eXBlID0gbS50eXBlLnRvVXBwZXJDYXNlKCksIG0uaGFzQ29udGVudCA9ICFxYi50ZXN0KG0udHlwZSksIGYgPSBtLnVybCwgbS5oYXNDb250ZW50IHx8IChtLmRhdGEgJiYgKGYgPSBtLnVybCArPSAobGIudGVzdChmKSA/IFxcXCImXFxcIiA6IFxcXCI/XFxcIikgKyBtLmRhdGEsIGRlbGV0ZSBtLmRhdGEpLCBtLmNhY2hlID09PSAhMSAmJiAobS51cmwgPSBuYi50ZXN0KGYpID8gZi5yZXBsYWNlKG5iLCBcXFwiJDFfPVxcXCIgKyBrYisrKSA6IGYgKyAobGIudGVzdChmKSA/IFxcXCImXFxcIiA6IFxcXCI/XFxcIikgKyBcXFwiXz1cXFwiICsga2IrKykpLCBtLmlmTW9kaWZpZWQgJiYgKG4ubGFzdE1vZGlmaWVkW2ZdICYmIHguc2V0UmVxdWVzdEhlYWRlcihcXFwiSWYtTW9kaWZpZWQtU2luY2VcXFwiLCBuLmxhc3RNb2RpZmllZFtmXSksIG4uZXRhZ1tmXSAmJiB4LnNldFJlcXVlc3RIZWFkZXIoXFxcIklmLU5vbmUtTWF0Y2hcXFwiLCBuLmV0YWdbZl0pKSwgKG0uZGF0YSAmJiBtLmhhc0NvbnRlbnQgJiYgbS5jb250ZW50VHlwZSAhPT0gITEgfHwgYy5jb250ZW50VHlwZSkgJiYgeC5zZXRSZXF1ZXN0SGVhZGVyKFxcXCJDb250ZW50LVR5cGVcXFwiLCBtLmNvbnRlbnRUeXBlKSwgeC5zZXRSZXF1ZXN0SGVhZGVyKFxcXCJBY2NlcHRcXFwiLCBtLmRhdGFUeXBlc1swXSAmJiBtLmFjY2VwdHNbbS5kYXRhVHlwZXNbMF1dID8gbS5hY2NlcHRzW20uZGF0YVR5cGVzWzBdXSArIChcXFwiKlxcXCIgIT09IG0uZGF0YVR5cGVzWzBdID8gXFxcIiwgXFxcIiArIHViICsgXFxcIjsgcT0wLjAxXFxcIiA6IFxcXCJcXFwiKSA6IG0uYWNjZXB0c1tcXFwiKlxcXCJdKTtmb3IgKGwgaW4gbS5oZWFkZXJzKSB7XFxuICAgICAgICB4LnNldFJlcXVlc3RIZWFkZXIobCwgbS5oZWFkZXJzW2xdKTtcXG4gICAgICB9aWYgKG0uYmVmb3JlU2VuZCAmJiAobS5iZWZvcmVTZW5kLmNhbGwobywgeCwgbSkgPT09ICExIHx8IDIgPT09IHYpKSByZXR1cm4geC5hYm9ydCgpO3cgPSBcXFwiYWJvcnRcXFwiO2ZvciAobCBpbiB7IHN1Y2Nlc3M6IDEsIGVycm9yOiAxLCBjb21wbGV0ZTogMSB9KSB7XFxuICAgICAgICB4W2xdKG1bbF0pO1xcbiAgICAgIH1pZiAoZSA9IHhiKHRiLCBtLCBjLCB4KSkge1xcbiAgICAgICAgaWYgKHgucmVhZHlTdGF0ZSA9IDEsIGsgJiYgcC50cmlnZ2VyKFxcXCJhamF4U2VuZFxcXCIsIFt4LCBtXSksIDIgPT09IHYpIHJldHVybiB4O20uYXN5bmMgJiYgbS50aW1lb3V0ID4gMCAmJiAoaSA9IGEuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHguYWJvcnQoXFxcInRpbWVvdXRcXFwiKTtcXG4gICAgICAgIH0sIG0udGltZW91dCkpO3RyeSB7XFxuICAgICAgICAgIHYgPSAxLCBlLnNlbmQodCwgeik7XFxuICAgICAgICB9IGNhdGNoICh5KSB7XFxuICAgICAgICAgIGlmICghKDIgPiB2KSkgdGhyb3cgeTt6KC0xLCB5KTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgeigtMSwgXFxcIk5vIFRyYW5zcG9ydFxcXCIpO2Z1bmN0aW9uIHooYiwgYywgZCwgaCkge1xcbiAgICAgICAgdmFyIGosXFxuICAgICAgICAgICAgbCxcXG4gICAgICAgICAgICB0LFxcbiAgICAgICAgICAgIHUsXFxuICAgICAgICAgICAgdyxcXG4gICAgICAgICAgICB5ID0gYzsyICE9PSB2ICYmICh2ID0gMiwgaSAmJiBhLmNsZWFyVGltZW91dChpKSwgZSA9IHZvaWQgMCwgZyA9IGggfHwgXFxcIlxcXCIsIHgucmVhZHlTdGF0ZSA9IGIgPiAwID8gNCA6IDAsIGogPSBiID49IDIwMCAmJiAzMDAgPiBiIHx8IDMwNCA9PT0gYiwgZCAmJiAodSA9IHpiKG0sIHgsIGQpKSwgdSA9IEFiKG0sIHUsIHgsIGopLCBqID8gKG0uaWZNb2RpZmllZCAmJiAodyA9IHguZ2V0UmVzcG9uc2VIZWFkZXIoXFxcIkxhc3QtTW9kaWZpZWRcXFwiKSwgdyAmJiAobi5sYXN0TW9kaWZpZWRbZl0gPSB3KSwgdyA9IHguZ2V0UmVzcG9uc2VIZWFkZXIoXFxcImV0YWdcXFwiKSwgdyAmJiAobi5ldGFnW2ZdID0gdykpLCAyMDQgPT09IGIgfHwgXFxcIkhFQURcXFwiID09PSBtLnR5cGUgPyB5ID0gXFxcIm5vY29udGVudFxcXCIgOiAzMDQgPT09IGIgPyB5ID0gXFxcIm5vdG1vZGlmaWVkXFxcIiA6ICh5ID0gdS5zdGF0ZSwgbCA9IHUuZGF0YSwgdCA9IHUuZXJyb3IsIGogPSAhdCkpIDogKHQgPSB5LCAhYiAmJiB5IHx8ICh5ID0gXFxcImVycm9yXFxcIiwgMCA+IGIgJiYgKGIgPSAwKSkpLCB4LnN0YXR1cyA9IGIsIHguc3RhdHVzVGV4dCA9IChjIHx8IHkpICsgXFxcIlxcXCIsIGogPyBxLnJlc29sdmVXaXRoKG8sIFtsLCB5LCB4XSkgOiBxLnJlamVjdFdpdGgobywgW3gsIHksIHRdKSwgeC5zdGF0dXNDb2RlKHMpLCBzID0gdm9pZCAwLCBrICYmIHAudHJpZ2dlcihqID8gXFxcImFqYXhTdWNjZXNzXFxcIiA6IFxcXCJhamF4RXJyb3JcXFwiLCBbeCwgbSwgaiA/IGwgOiB0XSksIHIuZmlyZVdpdGgobywgW3gsIHldKSwgayAmJiAocC50cmlnZ2VyKFxcXCJhamF4Q29tcGxldGVcXFwiLCBbeCwgbV0pLCAtLW4uYWN0aXZlIHx8IG4uZXZlbnQudHJpZ2dlcihcXFwiYWpheFN0b3BcXFwiKSkpO1xcbiAgICAgIH1yZXR1cm4geDtcXG4gICAgfSwgZ2V0SlNPTjogZnVuY3Rpb24gZ2V0SlNPTihhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIG4uZ2V0KGEsIGIsIGMsIFxcXCJqc29uXFxcIik7XFxuICAgIH0sIGdldFNjcmlwdDogZnVuY3Rpb24gZ2V0U2NyaXB0KGEsIGIpIHtcXG4gICAgICByZXR1cm4gbi5nZXQoYSwgdm9pZCAwLCBiLCBcXFwic2NyaXB0XFxcIik7XFxuICAgIH0gfSksIG4uZWFjaChbXFxcImdldFxcXCIsIFxcXCJwb3N0XFxcIl0sIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIG5bYl0gPSBmdW5jdGlvbiAoYSwgYywgZCwgZSkge1xcbiAgICAgIHJldHVybiBuLmlzRnVuY3Rpb24oYykgJiYgKGUgPSBlIHx8IGQsIGQgPSBjLCBjID0gdm9pZCAwKSwgbi5hamF4KG4uZXh0ZW5kKHsgdXJsOiBhLCB0eXBlOiBiLCBkYXRhVHlwZTogZSwgZGF0YTogYywgc3VjY2VzczogZCB9LCBuLmlzUGxhaW5PYmplY3QoYSkgJiYgYSkpO1xcbiAgICB9O1xcbiAgfSksIG4uX2V2YWxVcmwgPSBmdW5jdGlvbiAoYSkge1xcbiAgICByZXR1cm4gbi5hamF4KHsgdXJsOiBhLCB0eXBlOiBcXFwiR0VUXFxcIiwgZGF0YVR5cGU6IFxcXCJzY3JpcHRcXFwiLCBhc3luYzogITEsIGdsb2JhbDogITEsIFxcXCJ0aHJvd3NcXFwiOiAhMCB9KTtcXG4gIH0sIG4uZm4uZXh0ZW5kKHsgd3JhcEFsbDogZnVuY3Rpb24gd3JhcEFsbChhKSB7XFxuICAgICAgdmFyIGI7cmV0dXJuIG4uaXNGdW5jdGlvbihhKSA/IHRoaXMuZWFjaChmdW5jdGlvbiAoYikge1xcbiAgICAgICAgbih0aGlzKS53cmFwQWxsKGEuY2FsbCh0aGlzLCBiKSk7XFxuICAgICAgfSkgOiAodGhpc1swXSAmJiAoYiA9IG4oYSwgdGhpc1swXS5vd25lckRvY3VtZW50KS5lcSgwKS5jbG9uZSghMCksIHRoaXNbMF0ucGFyZW50Tm9kZSAmJiBiLmluc2VydEJlZm9yZSh0aGlzWzBdKSwgYi5tYXAoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGEgPSB0aGlzO3doaWxlIChhLmZpcnN0RWxlbWVudENoaWxkKSB7XFxuICAgICAgICAgIGEgPSBhLmZpcnN0RWxlbWVudENoaWxkO1xcbiAgICAgICAgfXJldHVybiBhO1xcbiAgICAgIH0pLmFwcGVuZCh0aGlzKSksIHRoaXMpO1xcbiAgICB9LCB3cmFwSW5uZXI6IGZ1bmN0aW9uIHdyYXBJbm5lcihhKSB7XFxuICAgICAgcmV0dXJuIG4uaXNGdW5jdGlvbihhKSA/IHRoaXMuZWFjaChmdW5jdGlvbiAoYikge1xcbiAgICAgICAgbih0aGlzKS53cmFwSW5uZXIoYS5jYWxsKHRoaXMsIGIpKTtcXG4gICAgICB9KSA6IHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYiA9IG4odGhpcyksXFxuICAgICAgICAgICAgYyA9IGIuY29udGVudHMoKTtjLmxlbmd0aCA/IGMud3JhcEFsbChhKSA6IGIuYXBwZW5kKGEpO1xcbiAgICAgIH0pO1xcbiAgICB9LCB3cmFwOiBmdW5jdGlvbiB3cmFwKGEpIHtcXG4gICAgICB2YXIgYiA9IG4uaXNGdW5jdGlvbihhKTtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChjKSB7XFxuICAgICAgICBuKHRoaXMpLndyYXBBbGwoYiA/IGEuY2FsbCh0aGlzLCBjKSA6IGEpO1xcbiAgICAgIH0pO1xcbiAgICB9LCB1bndyYXA6IGZ1bmN0aW9uIHVud3JhcCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIG4ubm9kZU5hbWUodGhpcywgXFxcImJvZHlcXFwiKSB8fCBuKHRoaXMpLnJlcGxhY2VXaXRoKHRoaXMuY2hpbGROb2Rlcyk7XFxuICAgICAgfSkuZW5kKCk7XFxuICAgIH0gfSksIG4uZXhwci5maWx0ZXJzLmhpZGRlbiA9IGZ1bmN0aW9uIChhKSB7XFxuICAgIHJldHVybiAhbi5leHByLmZpbHRlcnMudmlzaWJsZShhKTtcXG4gIH0sIG4uZXhwci5maWx0ZXJzLnZpc2libGUgPSBmdW5jdGlvbiAoYSkge1xcbiAgICByZXR1cm4gYS5vZmZzZXRXaWR0aCA+IDAgfHwgYS5vZmZzZXRIZWlnaHQgPiAwIHx8IGEuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPiAwO1xcbiAgfTt2YXIgQmIgPSAvJTIwL2csXFxuICAgICAgQ2IgPSAvXFxcXFtcXFxcXSQvLFxcbiAgICAgIERiID0gL1xcXFxyP1xcXFxuL2csXFxuICAgICAgRWIgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXFxuICAgICAgRmIgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7ZnVuY3Rpb24gR2IoYSwgYiwgYywgZCkge1xcbiAgICB2YXIgZTtpZiAobi5pc0FycmF5KGIpKSBuLmVhY2goYiwgZnVuY3Rpb24gKGIsIGUpIHtcXG4gICAgICBjIHx8IENiLnRlc3QoYSkgPyBkKGEsIGUpIDogR2IoYSArIFxcXCJbXFxcIiArIChcXFwib2JqZWN0XFxcIiA9PSAodHlwZW9mIGUgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGUpKSAmJiBudWxsICE9IGUgPyBiIDogXFxcIlxcXCIpICsgXFxcIl1cXFwiLCBlLCBjLCBkKTtcXG4gICAgfSk7ZWxzZSBpZiAoYyB8fCBcXFwib2JqZWN0XFxcIiAhPT0gbi50eXBlKGIpKSBkKGEsIGIpO2Vsc2UgZm9yIChlIGluIGIpIHtcXG4gICAgICBHYihhICsgXFxcIltcXFwiICsgZSArIFxcXCJdXFxcIiwgYltlXSwgYywgZCk7XFxuICAgIH1cXG4gIH1uLnBhcmFtID0gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgdmFyIGMsXFxuICAgICAgICBkID0gW10sXFxuICAgICAgICBlID0gZnVuY3Rpb24gZShhLCBiKSB7XFxuICAgICAgYiA9IG4uaXNGdW5jdGlvbihiKSA/IGIoKSA6IG51bGwgPT0gYiA/IFxcXCJcXFwiIDogYiwgZFtkLmxlbmd0aF0gPSBlbmNvZGVVUklDb21wb25lbnQoYSkgKyBcXFwiPVxcXCIgKyBlbmNvZGVVUklDb21wb25lbnQoYik7XFxuICAgIH07aWYgKHZvaWQgMCA9PT0gYiAmJiAoYiA9IG4uYWpheFNldHRpbmdzICYmIG4uYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsKSwgbi5pc0FycmF5KGEpIHx8IGEuanF1ZXJ5ICYmICFuLmlzUGxhaW5PYmplY3QoYSkpIG4uZWFjaChhLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgZSh0aGlzLm5hbWUsIHRoaXMudmFsdWUpO1xcbiAgICB9KTtlbHNlIGZvciAoYyBpbiBhKSB7XFxuICAgICAgR2IoYywgYVtjXSwgYiwgZSk7XFxuICAgIH1yZXR1cm4gZC5qb2luKFxcXCImXFxcIikucmVwbGFjZShCYiwgXFxcIitcXFwiKTtcXG4gIH0sIG4uZm4uZXh0ZW5kKHsgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XFxuICAgICAgcmV0dXJuIG4ucGFyYW0odGhpcy5zZXJpYWxpemVBcnJheSgpKTtcXG4gICAgfSwgc2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uIHNlcmlhbGl6ZUFycmF5KCkge1xcbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYSA9IG4ucHJvcCh0aGlzLCBcXFwiZWxlbWVudHNcXFwiKTtyZXR1cm4gYSA/IG4ubWFrZUFycmF5KGEpIDogdGhpcztcXG4gICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGEgPSB0aGlzLnR5cGU7cmV0dXJuIHRoaXMubmFtZSAmJiAhbih0aGlzKS5pcyhcXFwiOmRpc2FibGVkXFxcIikgJiYgRmIudGVzdCh0aGlzLm5vZGVOYW1lKSAmJiAhRWIudGVzdChhKSAmJiAodGhpcy5jaGVja2VkIHx8ICFYLnRlc3QoYSkpO1xcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgdmFyIGMgPSBuKHRoaXMpLnZhbCgpO3JldHVybiBudWxsID09IGMgPyBudWxsIDogbi5pc0FycmF5KGMpID8gbi5tYXAoYywgZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIHsgbmFtZTogYi5uYW1lLCB2YWx1ZTogYS5yZXBsYWNlKERiLCBcXFwiXFxcXHJcXFxcblxcXCIpIH07XFxuICAgICAgICB9KSA6IHsgbmFtZTogYi5uYW1lLCB2YWx1ZTogYy5yZXBsYWNlKERiLCBcXFwiXFxcXHJcXFxcblxcXCIpIH07XFxuICAgICAgfSkuZ2V0KCk7XFxuICAgIH0gfSksIG4uYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdHJ5IHtcXG4gICAgICByZXR1cm4gbmV3IGEuWE1MSHR0cFJlcXVlc3QoKTtcXG4gICAgfSBjYXRjaCAoYikge31cXG4gIH07dmFyIEhiID0geyAwOiAyMDAsIDEyMjM6IDIwNCB9LFxcbiAgICAgIEliID0gbi5hamF4U2V0dGluZ3MueGhyKCk7bC5jb3JzID0gISFJYiAmJiBcXFwid2l0aENyZWRlbnRpYWxzXFxcIiBpbiBJYiwgbC5hamF4ID0gSWIgPSAhIUliLCBuLmFqYXhUcmFuc3BvcnQoZnVuY3Rpb24gKGIpIHtcXG4gICAgdmFyIF9jLCBkO3JldHVybiBsLmNvcnMgfHwgSWIgJiYgIWIuY3Jvc3NEb21haW4gPyB7IHNlbmQ6IGZ1bmN0aW9uIHNlbmQoZSwgZikge1xcbiAgICAgICAgdmFyIGcsXFxuICAgICAgICAgICAgaCA9IGIueGhyKCk7aWYgKGgub3BlbihiLnR5cGUsIGIudXJsLCBiLmFzeW5jLCBiLnVzZXJuYW1lLCBiLnBhc3N3b3JkKSwgYi54aHJGaWVsZHMpIGZvciAoZyBpbiBiLnhockZpZWxkcykge1xcbiAgICAgICAgICBoW2ddID0gYi54aHJGaWVsZHNbZ107XFxuICAgICAgICB9Yi5taW1lVHlwZSAmJiBoLm92ZXJyaWRlTWltZVR5cGUgJiYgaC5vdmVycmlkZU1pbWVUeXBlKGIubWltZVR5cGUpLCBiLmNyb3NzRG9tYWluIHx8IGVbXFxcIlgtUmVxdWVzdGVkLVdpdGhcXFwiXSB8fCAoZVtcXFwiWC1SZXF1ZXN0ZWQtV2l0aFxcXCJdID0gXFxcIlhNTEh0dHBSZXF1ZXN0XFxcIik7Zm9yIChnIGluIGUpIHtcXG4gICAgICAgICAgaC5zZXRSZXF1ZXN0SGVhZGVyKGcsIGVbZ10pO1xcbiAgICAgICAgfV9jID0gZnVuY3Rpb24gYyhhKSB7XFxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgX2MgJiYgKF9jID0gZCA9IGgub25sb2FkID0gaC5vbmVycm9yID0gaC5vbmFib3J0ID0gaC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsLCBcXFwiYWJvcnRcXFwiID09PSBhID8gaC5hYm9ydCgpIDogXFxcImVycm9yXFxcIiA9PT0gYSA/IFxcXCJudW1iZXJcXFwiICE9IHR5cGVvZiBoLnN0YXR1cyA/IGYoMCwgXFxcImVycm9yXFxcIikgOiBmKGguc3RhdHVzLCBoLnN0YXR1c1RleHQpIDogZihIYltoLnN0YXR1c10gfHwgaC5zdGF0dXMsIGguc3RhdHVzVGV4dCwgXFxcInRleHRcXFwiICE9PSAoaC5yZXNwb25zZVR5cGUgfHwgXFxcInRleHRcXFwiKSB8fCBcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgaC5yZXNwb25zZVRleHQgPyB7IGJpbmFyeTogaC5yZXNwb25zZSB9IDogeyB0ZXh0OiBoLnJlc3BvbnNlVGV4dCB9LCBoLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSk7XFxuICAgICAgICAgIH07XFxuICAgICAgICB9LCBoLm9ubG9hZCA9IF9jKCksIGQgPSBoLm9uZXJyb3IgPSBfYyhcXFwiZXJyb3JcXFwiKSwgdm9pZCAwICE9PSBoLm9uYWJvcnQgPyBoLm9uYWJvcnQgPSBkIDogaC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIDQgPT09IGgucmVhZHlTdGF0ZSAmJiBhLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIF9jICYmIGQoKTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9LCBfYyA9IF9jKFxcXCJhYm9ydFxcXCIpO3RyeSB7XFxuICAgICAgICAgIGguc2VuZChiLmhhc0NvbnRlbnQgJiYgYi5kYXRhIHx8IG51bGwpO1xcbiAgICAgICAgfSBjYXRjaCAoaSkge1xcbiAgICAgICAgICBpZiAoX2MpIHRocm93IGk7XFxuICAgICAgICB9XFxuICAgICAgfSwgYWJvcnQ6IGZ1bmN0aW9uIGFib3J0KCkge1xcbiAgICAgICAgX2MgJiYgX2MoKTtcXG4gICAgICB9IH0gOiB2b2lkIDA7XFxuICB9KSwgbi5hamF4U2V0dXAoeyBhY2NlcHRzOiB7IHNjcmlwdDogXFxcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XFxcIiB9LCBjb250ZW50czogeyBzY3JpcHQ6IC9cXFxcYig/OmphdmF8ZWNtYSlzY3JpcHRcXFxcYi8gfSwgY29udmVydGVyczogeyBcXFwidGV4dCBzY3JpcHRcXFwiOiBmdW5jdGlvbiB0ZXh0U2NyaXB0KGEpIHtcXG4gICAgICAgIHJldHVybiBuLmdsb2JhbEV2YWwoYSksIGE7XFxuICAgICAgfSB9IH0pLCBuLmFqYXhQcmVmaWx0ZXIoXFxcInNjcmlwdFxcXCIsIGZ1bmN0aW9uIChhKSB7XFxuICAgIHZvaWQgMCA9PT0gYS5jYWNoZSAmJiAoYS5jYWNoZSA9ICExKSwgYS5jcm9zc0RvbWFpbiAmJiAoYS50eXBlID0gXFxcIkdFVFxcXCIpO1xcbiAgfSksIG4uYWpheFRyYW5zcG9ydChcXFwic2NyaXB0XFxcIiwgZnVuY3Rpb24gKGEpIHtcXG4gICAgaWYgKGEuY3Jvc3NEb21haW4pIHtcXG4gICAgICB2YXIgYiwgX2MyO3JldHVybiB7IHNlbmQ6IGZ1bmN0aW9uIHNlbmQoZSwgZikge1xcbiAgICAgICAgICBiID0gbihcXFwiPHNjcmlwdD5cXFwiKS5wcm9wKHsgY2hhcnNldDogYS5zY3JpcHRDaGFyc2V0LCBzcmM6IGEudXJsIH0pLm9uKFxcXCJsb2FkIGVycm9yXFxcIiwgX2MyID0gZnVuY3Rpb24gYyhhKSB7XFxuICAgICAgICAgICAgYi5yZW1vdmUoKSwgX2MyID0gbnVsbCwgYSAmJiBmKFxcXCJlcnJvclxcXCIgPT09IGEudHlwZSA/IDQwNCA6IDIwMCwgYS50eXBlKTtcXG4gICAgICAgICAgfSksIGQuaGVhZC5hcHBlbmRDaGlsZChiWzBdKTtcXG4gICAgICAgIH0sIGFib3J0OiBmdW5jdGlvbiBhYm9ydCgpIHtcXG4gICAgICAgICAgX2MyICYmIF9jMigpO1xcbiAgICAgICAgfSB9O1xcbiAgICB9XFxuICB9KTt2YXIgSmIgPSBbXSxcXG4gICAgICBLYiA9IC8oPSlcXFxcPyg/PSZ8JCl8XFxcXD9cXFxcPy87bi5hamF4U2V0dXAoeyBqc29ucDogXFxcImNhbGxiYWNrXFxcIiwganNvbnBDYWxsYmFjazogZnVuY3Rpb24ganNvbnBDYWxsYmFjaygpIHtcXG4gICAgICB2YXIgYSA9IEpiLnBvcCgpIHx8IG4uZXhwYW5kbyArIFxcXCJfXFxcIiArIGtiKys7cmV0dXJuIHRoaXNbYV0gPSAhMCwgYTtcXG4gICAgfSB9KSwgbi5hamF4UHJlZmlsdGVyKFxcXCJqc29uIGpzb25wXFxcIiwgZnVuY3Rpb24gKGIsIGMsIGQpIHtcXG4gICAgdmFyIGUsXFxuICAgICAgICBmLFxcbiAgICAgICAgZyxcXG4gICAgICAgIGggPSBiLmpzb25wICE9PSAhMSAmJiAoS2IudGVzdChiLnVybCkgPyBcXFwidXJsXFxcIiA6IFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBiLmRhdGEgJiYgMCA9PT0gKGIuY29udGVudFR5cGUgfHwgXFxcIlxcXCIpLmluZGV4T2YoXFxcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFxcXCIpICYmIEtiLnRlc3QoYi5kYXRhKSAmJiBcXFwiZGF0YVxcXCIpO3JldHVybiBoIHx8IFxcXCJqc29ucFxcXCIgPT09IGIuZGF0YVR5cGVzWzBdID8gKGUgPSBiLmpzb25wQ2FsbGJhY2sgPSBuLmlzRnVuY3Rpb24oYi5qc29ucENhbGxiYWNrKSA/IGIuanNvbnBDYWxsYmFjaygpIDogYi5qc29ucENhbGxiYWNrLCBoID8gYltoXSA9IGJbaF0ucmVwbGFjZShLYiwgXFxcIiQxXFxcIiArIGUpIDogYi5qc29ucCAhPT0gITEgJiYgKGIudXJsICs9IChsYi50ZXN0KGIudXJsKSA/IFxcXCImXFxcIiA6IFxcXCI/XFxcIikgKyBiLmpzb25wICsgXFxcIj1cXFwiICsgZSksIGIuY29udmVydGVyc1tcXFwic2NyaXB0IGpzb25cXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gZyB8fCBuLmVycm9yKGUgKyBcXFwiIHdhcyBub3QgY2FsbGVkXFxcIiksIGdbMF07XFxuICAgIH0sIGIuZGF0YVR5cGVzWzBdID0gXFxcImpzb25cXFwiLCBmID0gYVtlXSwgYVtlXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBnID0gYXJndW1lbnRzO1xcbiAgICB9LCBkLmFsd2F5cyhmdW5jdGlvbiAoKSB7XFxuICAgICAgdm9pZCAwID09PSBmID8gbihhKS5yZW1vdmVQcm9wKGUpIDogYVtlXSA9IGYsIGJbZV0gJiYgKGIuanNvbnBDYWxsYmFjayA9IGMuanNvbnBDYWxsYmFjaywgSmIucHVzaChlKSksIGcgJiYgbi5pc0Z1bmN0aW9uKGYpICYmIGYoZ1swXSksIGcgPSBmID0gdm9pZCAwO1xcbiAgICB9KSwgXFxcInNjcmlwdFxcXCIpIDogdm9pZCAwO1xcbiAgfSksIG4ucGFyc2VIVE1MID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcXG4gICAgaWYgKCFhIHx8IFxcXCJzdHJpbmdcXFwiICE9IHR5cGVvZiBhKSByZXR1cm4gbnVsbDtcXFwiYm9vbGVhblxcXCIgPT0gdHlwZW9mIGIgJiYgKGMgPSBiLCBiID0gITEpLCBiID0gYiB8fCBkO3ZhciBlID0geC5leGVjKGEpLFxcbiAgICAgICAgZiA9ICFjICYmIFtdO3JldHVybiBlID8gW2IuY3JlYXRlRWxlbWVudChlWzFdKV0gOiAoZSA9IGNhKFthXSwgYiwgZiksIGYgJiYgZi5sZW5ndGggJiYgbihmKS5yZW1vdmUoKSwgbi5tZXJnZShbXSwgZS5jaGlsZE5vZGVzKSk7XFxuICB9O3ZhciBMYiA9IG4uZm4ubG9hZDtuLmZuLmxvYWQgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICBpZiAoXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGEgJiYgTGIpIHJldHVybiBMYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO3ZhciBkLFxcbiAgICAgICAgZSxcXG4gICAgICAgIGYsXFxuICAgICAgICBnID0gdGhpcyxcXG4gICAgICAgIGggPSBhLmluZGV4T2YoXFxcIiBcXFwiKTtyZXR1cm4gaCA+IC0xICYmIChkID0gbi50cmltKGEuc2xpY2UoaCkpLCBhID0gYS5zbGljZSgwLCBoKSksIG4uaXNGdW5jdGlvbihiKSA/IChjID0gYiwgYiA9IHZvaWQgMCkgOiBiICYmIFxcXCJvYmplY3RcXFwiID09ICh0eXBlb2YgYiA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoYikpICYmIChlID0gXFxcIlBPU1RcXFwiKSwgZy5sZW5ndGggPiAwICYmIG4uYWpheCh7IHVybDogYSwgdHlwZTogZSB8fCBcXFwiR0VUXFxcIiwgZGF0YVR5cGU6IFxcXCJodG1sXFxcIiwgZGF0YTogYiB9KS5kb25lKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgZiA9IGFyZ3VtZW50cywgZy5odG1sKGQgPyBuKFxcXCI8ZGl2PlxcXCIpLmFwcGVuZChuLnBhcnNlSFRNTChhKSkuZmluZChkKSA6IGEpO1xcbiAgICB9KS5hbHdheXMoYyAmJiBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgIGcuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBjLmFwcGx5KHRoaXMsIGYgfHwgW2EucmVzcG9uc2VUZXh0LCBiLCBhXSk7XFxuICAgICAgfSk7XFxuICAgIH0pLCB0aGlzO1xcbiAgfSwgbi5lYWNoKFtcXFwiYWpheFN0YXJ0XFxcIiwgXFxcImFqYXhTdG9wXFxcIiwgXFxcImFqYXhDb21wbGV0ZVxcXCIsIFxcXCJhamF4RXJyb3JcXFwiLCBcXFwiYWpheFN1Y2Nlc3NcXFwiLCBcXFwiYWpheFNlbmRcXFwiXSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgbi5mbltiXSA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgcmV0dXJuIHRoaXMub24oYiwgYSk7XFxuICAgIH07XFxuICB9KSwgbi5leHByLmZpbHRlcnMuYW5pbWF0ZWQgPSBmdW5jdGlvbiAoYSkge1xcbiAgICByZXR1cm4gbi5ncmVwKG4udGltZXJzLCBmdW5jdGlvbiAoYikge1xcbiAgICAgIHJldHVybiBhID09PSBiLmVsZW07XFxuICAgIH0pLmxlbmd0aDtcXG4gIH07ZnVuY3Rpb24gTWIoYSkge1xcbiAgICByZXR1cm4gbi5pc1dpbmRvdyhhKSA/IGEgOiA5ID09PSBhLm5vZGVUeXBlICYmIGEuZGVmYXVsdFZpZXc7XFxuICB9bi5vZmZzZXQgPSB7IHNldE9mZnNldDogZnVuY3Rpb24gc2V0T2Zmc2V0KGEsIGIsIGMpIHtcXG4gICAgICB2YXIgZCxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZixcXG4gICAgICAgICAgZyxcXG4gICAgICAgICAgaCxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgayA9IG4uY3NzKGEsIFxcXCJwb3NpdGlvblxcXCIpLFxcbiAgICAgICAgICBsID0gbihhKSxcXG4gICAgICAgICAgbSA9IHt9O1xcXCJzdGF0aWNcXFwiID09PSBrICYmIChhLnN0eWxlLnBvc2l0aW9uID0gXFxcInJlbGF0aXZlXFxcIiksIGggPSBsLm9mZnNldCgpLCBmID0gbi5jc3MoYSwgXFxcInRvcFxcXCIpLCBpID0gbi5jc3MoYSwgXFxcImxlZnRcXFwiKSwgaiA9IChcXFwiYWJzb2x1dGVcXFwiID09PSBrIHx8IFxcXCJmaXhlZFxcXCIgPT09IGspICYmIChmICsgaSkuaW5kZXhPZihcXFwiYXV0b1xcXCIpID4gLTEsIGogPyAoZCA9IGwucG9zaXRpb24oKSwgZyA9IGQudG9wLCBlID0gZC5sZWZ0KSA6IChnID0gcGFyc2VGbG9hdChmKSB8fCAwLCBlID0gcGFyc2VGbG9hdChpKSB8fCAwKSwgbi5pc0Z1bmN0aW9uKGIpICYmIChiID0gYi5jYWxsKGEsIGMsIG4uZXh0ZW5kKHt9LCBoKSkpLCBudWxsICE9IGIudG9wICYmIChtLnRvcCA9IGIudG9wIC0gaC50b3AgKyBnKSwgbnVsbCAhPSBiLmxlZnQgJiYgKG0ubGVmdCA9IGIubGVmdCAtIGgubGVmdCArIGUpLCBcXFwidXNpbmdcXFwiIGluIGIgPyBiLnVzaW5nLmNhbGwoYSwgbSkgOiBsLmNzcyhtKTtcXG4gICAgfSB9LCBuLmZuLmV4dGVuZCh7IG9mZnNldDogZnVuY3Rpb24gb2Zmc2V0KGEpIHtcXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHZvaWQgMCA9PT0gYSA/IHRoaXMgOiB0aGlzLmVhY2goZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgIG4ub2Zmc2V0LnNldE9mZnNldCh0aGlzLCBhLCBiKTtcXG4gICAgICB9KTt2YXIgYixcXG4gICAgICAgICAgYyxcXG4gICAgICAgICAgZCA9IHRoaXNbMF0sXFxuICAgICAgICAgIGUgPSB7IHRvcDogMCwgbGVmdDogMCB9LFxcbiAgICAgICAgICBmID0gZCAmJiBkLm93bmVyRG9jdW1lbnQ7aWYgKGYpIHJldHVybiBiID0gZi5kb2N1bWVudEVsZW1lbnQsIG4uY29udGFpbnMoYiwgZCkgPyAoZSA9IGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGMgPSBNYihmKSwgeyB0b3A6IGUudG9wICsgYy5wYWdlWU9mZnNldCAtIGIuY2xpZW50VG9wLCBsZWZ0OiBlLmxlZnQgKyBjLnBhZ2VYT2Zmc2V0IC0gYi5jbGllbnRMZWZ0IH0pIDogZTtcXG4gICAgfSwgcG9zaXRpb246IGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xcbiAgICAgIGlmICh0aGlzWzBdKSB7XFxuICAgICAgICB2YXIgYSxcXG4gICAgICAgICAgICBiLFxcbiAgICAgICAgICAgIGMgPSB0aGlzWzBdLFxcbiAgICAgICAgICAgIGQgPSB7IHRvcDogMCwgbGVmdDogMCB9O3JldHVybiBcXFwiZml4ZWRcXFwiID09PSBuLmNzcyhjLCBcXFwicG9zaXRpb25cXFwiKSA/IGIgPSBjLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogKGEgPSB0aGlzLm9mZnNldFBhcmVudCgpLCBiID0gdGhpcy5vZmZzZXQoKSwgbi5ub2RlTmFtZShhWzBdLCBcXFwiaHRtbFxcXCIpIHx8IChkID0gYS5vZmZzZXQoKSksIGQudG9wICs9IG4uY3NzKGFbMF0sIFxcXCJib3JkZXJUb3BXaWR0aFxcXCIsICEwKSwgZC5sZWZ0ICs9IG4uY3NzKGFbMF0sIFxcXCJib3JkZXJMZWZ0V2lkdGhcXFwiLCAhMCkpLCB7IHRvcDogYi50b3AgLSBkLnRvcCAtIG4uY3NzKGMsIFxcXCJtYXJnaW5Ub3BcXFwiLCAhMCksIGxlZnQ6IGIubGVmdCAtIGQubGVmdCAtIG4uY3NzKGMsIFxcXCJtYXJnaW5MZWZ0XFxcIiwgITApIH07XFxuICAgICAgfVxcbiAgICB9LCBvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uIG9mZnNldFBhcmVudCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGEgPSB0aGlzLm9mZnNldFBhcmVudDt3aGlsZSAoYSAmJiBcXFwic3RhdGljXFxcIiA9PT0gbi5jc3MoYSwgXFxcInBvc2l0aW9uXFxcIikpIHtcXG4gICAgICAgICAgYSA9IGEub2Zmc2V0UGFyZW50O1xcbiAgICAgICAgfXJldHVybiBhIHx8IEVhO1xcbiAgICAgIH0pO1xcbiAgICB9IH0pLCBuLmVhY2goeyBzY3JvbGxMZWZ0OiBcXFwicGFnZVhPZmZzZXRcXFwiLCBzY3JvbGxUb3A6IFxcXCJwYWdlWU9mZnNldFxcXCIgfSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgdmFyIGMgPSBcXFwicGFnZVlPZmZzZXRcXFwiID09PSBiO24uZm5bYV0gPSBmdW5jdGlvbiAoZCkge1xcbiAgICAgIHJldHVybiBLKHRoaXMsIGZ1bmN0aW9uIChhLCBkLCBlKSB7XFxuICAgICAgICB2YXIgZiA9IE1iKGEpO3JldHVybiB2b2lkIDAgPT09IGUgPyBmID8gZltiXSA6IGFbZF0gOiB2b2lkIChmID8gZi5zY3JvbGxUbyhjID8gZi5wYWdlWE9mZnNldCA6IGUsIGMgPyBlIDogZi5wYWdlWU9mZnNldCkgOiBhW2RdID0gZSk7XFxuICAgICAgfSwgYSwgZCwgYXJndW1lbnRzLmxlbmd0aCk7XFxuICAgIH07XFxuICB9KSwgbi5lYWNoKFtcXFwidG9wXFxcIiwgXFxcImxlZnRcXFwiXSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgbi5jc3NIb29rc1tiXSA9IEdhKGwucGl4ZWxQb3NpdGlvbiwgZnVuY3Rpb24gKGEsIGMpIHtcXG4gICAgICByZXR1cm4gYyA/IChjID0gRmEoYSwgYiksIEJhLnRlc3QoYykgPyBuKGEpLnBvc2l0aW9uKClbYl0gKyBcXFwicHhcXFwiIDogYykgOiB2b2lkIDA7XFxuICAgIH0pO1xcbiAgfSksIG4uZWFjaCh7IEhlaWdodDogXFxcImhlaWdodFxcXCIsIFdpZHRoOiBcXFwid2lkdGhcXFwiIH0sIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIG4uZWFjaCh7IHBhZGRpbmc6IFxcXCJpbm5lclxcXCIgKyBhLCBjb250ZW50OiBiLCBcXFwiXFxcIjogXFxcIm91dGVyXFxcIiArIGEgfSwgZnVuY3Rpb24gKGMsIGQpIHtcXG4gICAgICBuLmZuW2RdID0gZnVuY3Rpb24gKGQsIGUpIHtcXG4gICAgICAgIHZhciBmID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoYyB8fCBcXFwiYm9vbGVhblxcXCIgIT0gdHlwZW9mIGQpLFxcbiAgICAgICAgICAgIGcgPSBjIHx8IChkID09PSAhMCB8fCBlID09PSAhMCA/IFxcXCJtYXJnaW5cXFwiIDogXFxcImJvcmRlclxcXCIpO3JldHVybiBLKHRoaXMsIGZ1bmN0aW9uIChiLCBjLCBkKSB7XFxuICAgICAgICAgIHZhciBlO3JldHVybiBuLmlzV2luZG93KGIpID8gYi5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbXFxcImNsaWVudFxcXCIgKyBhXSA6IDkgPT09IGIubm9kZVR5cGUgPyAoZSA9IGIuZG9jdW1lbnRFbGVtZW50LCBNYXRoLm1heChiLmJvZHlbXFxcInNjcm9sbFxcXCIgKyBhXSwgZVtcXFwic2Nyb2xsXFxcIiArIGFdLCBiLmJvZHlbXFxcIm9mZnNldFxcXCIgKyBhXSwgZVtcXFwib2Zmc2V0XFxcIiArIGFdLCBlW1xcXCJjbGllbnRcXFwiICsgYV0pKSA6IHZvaWQgMCA9PT0gZCA/IG4uY3NzKGIsIGMsIGcpIDogbi5zdHlsZShiLCBjLCBkLCBnKTtcXG4gICAgICAgIH0sIGIsIGYgPyBkIDogdm9pZCAwLCBmLCBudWxsKTtcXG4gICAgICB9O1xcbiAgICB9KTtcXG4gIH0pLCBuLmZuLmV4dGVuZCh7IGJpbmQ6IGZ1bmN0aW9uIGJpbmQoYSwgYiwgYykge1xcbiAgICAgIHJldHVybiB0aGlzLm9uKGEsIG51bGwsIGIsIGMpO1xcbiAgICB9LCB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZChhLCBiKSB7XFxuICAgICAgcmV0dXJuIHRoaXMub2ZmKGEsIG51bGwsIGIpO1xcbiAgICB9LCBkZWxlZ2F0ZTogZnVuY3Rpb24gZGVsZWdhdGUoYSwgYiwgYywgZCkge1xcbiAgICAgIHJldHVybiB0aGlzLm9uKGIsIGEsIGMsIGQpO1xcbiAgICB9LCB1bmRlbGVnYXRlOiBmdW5jdGlvbiB1bmRlbGVnYXRlKGEsIGIsIGMpIHtcXG4gICAgICByZXR1cm4gMSA9PT0gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMub2ZmKGEsIFxcXCIqKlxcXCIpIDogdGhpcy5vZmYoYiwgYSB8fCBcXFwiKipcXFwiLCBjKTtcXG4gICAgfSwgc2l6ZTogZnVuY3Rpb24gc2l6ZSgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XFxuICAgIH0gfSksIG4uZm4uYW5kU2VsZiA9IG4uZm4uYWRkQmFjaywgXFxcImZ1bmN0aW9uXFxcIiA9PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQgJiYgZGVmaW5lKFxcXCJqcXVlcnlcXFwiLCBbXSwgZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gbjtcXG4gIH0pO3ZhciBOYiA9IGEualF1ZXJ5LFxcbiAgICAgIE9iID0gYS4kO3JldHVybiBuLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoYikge1xcbiAgICByZXR1cm4gYS4kID09PSBuICYmIChhLiQgPSBPYiksIGIgJiYgYS5qUXVlcnkgPT09IG4gJiYgKGEualF1ZXJ5ID0gTmIpLCBuO1xcbiAgfSwgYiB8fCAoYS5qUXVlcnkgPSBhLiQgPSBuKSwgbjtcXG59KTtcIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Jhdy1sb2FkZXIhLi9+L2JhYmVsLWxvYWRlcj97XCJwcmVzZXRzXCI6W1wicmVhY3RcIixcImVzMjAxNVwiLFwic3RhZ2UtMFwiXX0hLi9+L2pxdWVyeS9kaXN0L2pxdWVyeS5taW4uanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKFwiISEvaG9tZS9zdGV3YXJ0L2NvZGUvcmVhY3QtdG9kby9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL2hvbWUvc3Rld2FydC9jb2RlL3JlYWN0LXRvZG8vbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL2hvbWUvc3Rld2FydC9jb2RlL3JlYWN0LXRvZG8vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9pbmRleC5qcz97XFxcInByZXNldHNcXFwiOltcXFwicmVhY3RcXFwiLFxcXCJlczIwMTVcXFwiLFxcXCJzdGFnZS0wXFxcIl19IS9ob21lL3N0ZXdhcnQvY29kZS9yZWFjdC10b2RvL25vZGVfbW9kdWxlcy9mb3VuZGF0aW9uLXNpdGVzL2Rpc3QvZm91bmRhdGlvbi5taW4uanNcIikpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2NyaXB0LWxvYWRlciEuL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2ZvdW5kYXRpb24ubWluLmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcXCJ1c2Ugc3RyaWN0XFxcIjt2YXIgX3R5cGVvZj10eXBlb2YgU3ltYm9sPT09XFxcImZ1bmN0aW9uXFxcIiYmdHlwZW9mIFN5bWJvbC5pdGVyYXRvcj09PVxcXCJzeW1ib2xcXFwiP2Z1bmN0aW9uKG9iail7cmV0dXJuIHR5cGVvZiBvYmo7fTpmdW5jdGlvbihvYmope3JldHVybiBvYmomJnR5cGVvZiBTeW1ib2w9PT1cXFwiZnVuY3Rpb25cXFwiJiZvYmouY29uc3RydWN0b3I9PT1TeW1ib2wmJm9iaiE9PVN5bWJvbC5wcm90b3R5cGU/XFxcInN5bWJvbFxcXCI6dHlwZW9mIG9iajt9O2Z1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO31mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTt9ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7fWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO30hZnVuY3Rpb24odCl7XFxcInVzZSBzdHJpY3RcXFwiO2Z1bmN0aW9uIGUodCl7aWYodm9pZCAwPT09RnVuY3Rpb24ucHJvdG90eXBlLm5hbWUpe3ZhciBlPS9mdW5jdGlvblxcXFxzKFteKF17MSx9KVxcXFwoLyxpPWUuZXhlYyh0LnRvU3RyaW5nKCkpO3JldHVybiBpJiZpLmxlbmd0aD4xP2lbMV0udHJpbSgpOlxcXCJcXFwiO31yZXR1cm4gdm9pZCAwPT09dC5wcm90b3R5cGU/dC5jb25zdHJ1Y3Rvci5uYW1lOnQucHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWU7fWZ1bmN0aW9uIGkodCl7cmV0dXJuIC90cnVlLy50ZXN0KHQpPyEwOi9mYWxzZS8udGVzdCh0KT8hMTppc05hTigxKnQpP3Q6cGFyc2VGbG9hdCh0KTt9ZnVuY3Rpb24gbih0KXtyZXR1cm4gdC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLFxcXCIkMS0kMlxcXCIpLnRvTG93ZXJDYXNlKCk7fXZhciBzPVxcXCI2LjIuM1xcXCIsbz17dmVyc2lvbjpzLF9wbHVnaW5zOnt9LF91dWlkczpbXSxydGw6ZnVuY3Rpb24gcnRsKCl7cmV0dXJuXFxcInJ0bFxcXCI9PT10KFxcXCJodG1sXFxcIikuYXR0cihcXFwiZGlyXFxcIik7fSxwbHVnaW46ZnVuY3Rpb24gcGx1Z2luKHQsaSl7dmFyIHM9aXx8ZSh0KSxvPW4ocyk7dGhpcy5fcGx1Z2luc1tvXT10aGlzW3NdPXQ7fSxyZWdpc3RlclBsdWdpbjpmdW5jdGlvbiByZWdpc3RlclBsdWdpbih0LGkpe3ZhciBzPWk/bihpKTplKHQuY29uc3RydWN0b3IpLnRvTG93ZXJDYXNlKCk7dC51dWlkPXRoaXMuR2V0WW9EaWdpdHMoNixzKSx0LiRlbGVtZW50LmF0dHIoXFxcImRhdGEtXFxcIitzKXx8dC4kZWxlbWVudC5hdHRyKFxcXCJkYXRhLVxcXCIrcyx0LnV1aWQpLHQuJGVsZW1lbnQuZGF0YShcXFwiemZQbHVnaW5cXFwiKXx8dC4kZWxlbWVudC5kYXRhKFxcXCJ6ZlBsdWdpblxcXCIsdCksdC4kZWxlbWVudC50cmlnZ2VyKFxcXCJpbml0LnpmLlxcXCIrcyksdGhpcy5fdXVpZHMucHVzaCh0LnV1aWQpO30sdW5yZWdpc3RlclBsdWdpbjpmdW5jdGlvbiB1bnJlZ2lzdGVyUGx1Z2luKHQpe3ZhciBpPW4oZSh0LiRlbGVtZW50LmRhdGEoXFxcInpmUGx1Z2luXFxcIikuY29uc3RydWN0b3IpKTt0aGlzLl91dWlkcy5zcGxpY2UodGhpcy5fdXVpZHMuaW5kZXhPZih0LnV1aWQpLDEpLHQuJGVsZW1lbnQucmVtb3ZlQXR0cihcXFwiZGF0YS1cXFwiK2kpLnJlbW92ZURhdGEoXFxcInpmUGx1Z2luXFxcIikudHJpZ2dlcihcXFwiZGVzdHJveWVkLnpmLlxcXCIraSk7Zm9yKHZhciBzIGluIHQpe3Rbc109bnVsbDt9fSxyZUluaXQ6ZnVuY3Rpb24gcmVJbml0KGUpe3ZhciBpPWUgaW5zdGFuY2VvZiB0O3RyeXtpZihpKWUuZWFjaChmdW5jdGlvbigpe3QodGhpcykuZGF0YShcXFwiemZQbHVnaW5cXFwiKS5faW5pdCgpO30pO2Vsc2V7dmFyIHM9dHlwZW9mIGU9PT1cXFwidW5kZWZpbmVkXFxcIj9cXFwidW5kZWZpbmVkXFxcIjpfdHlwZW9mKGUpLG89dGhpcyxhPXtvYmplY3Q6ZnVuY3Rpb24gb2JqZWN0KGUpe2UuZm9yRWFjaChmdW5jdGlvbihlKXtlPW4oZSksdChcXFwiW2RhdGEtXFxcIitlK1xcXCJdXFxcIikuZm91bmRhdGlvbihcXFwiX2luaXRcXFwiKTt9KTt9LHN0cmluZzpmdW5jdGlvbiBzdHJpbmcoKXtlPW4oZSksdChcXFwiW2RhdGEtXFxcIitlK1xcXCJdXFxcIikuZm91bmRhdGlvbihcXFwiX2luaXRcXFwiKTt9LHVuZGVmaW5lZDpmdW5jdGlvbiB1bmRlZmluZWQoKXt0aGlzLm9iamVjdChPYmplY3Qua2V5cyhvLl9wbHVnaW5zKSk7fX07YVtzXShlKTt9fWNhdGNoKHIpe2NvbnNvbGUuZXJyb3Iocik7fWZpbmFsbHl7cmV0dXJuIGU7fX0sR2V0WW9EaWdpdHM6ZnVuY3Rpb24gR2V0WW9EaWdpdHModCxlKXtyZXR1cm4gdD10fHw2LE1hdGgucm91bmQoTWF0aC5wb3coMzYsdCsxKS1NYXRoLnJhbmRvbSgpKk1hdGgucG93KDM2LHQpKS50b1N0cmluZygzNikuc2xpY2UoMSkrKGU/XFxcIi1cXFwiK2U6XFxcIlxcXCIpO30scmVmbG93OmZ1bmN0aW9uIHJlZmxvdyhlLG4pe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2Ygbj9uPU9iamVjdC5rZXlzKHRoaXMuX3BsdWdpbnMpOlxcXCJzdHJpbmdcXFwiPT10eXBlb2YgbiYmKG49W25dKTt2YXIgcz10aGlzO3QuZWFjaChuLGZ1bmN0aW9uKG4sbyl7dmFyIGE9cy5fcGx1Z2luc1tvXSxyPXQoZSkuZmluZChcXFwiW2RhdGEtXFxcIitvK1xcXCJdXFxcIikuYWRkQmFjayhcXFwiW2RhdGEtXFxcIitvK1xcXCJdXFxcIik7ci5lYWNoKGZ1bmN0aW9uKCl7dmFyIGU9dCh0aGlzKSxuPXt9O2lmKGUuZGF0YShcXFwiemZQbHVnaW5cXFwiKSlyZXR1cm4gdm9pZCBjb25zb2xlLndhcm4oXFxcIlRyaWVkIHRvIGluaXRpYWxpemUgXFxcIitvK1xcXCIgb24gYW4gZWxlbWVudCB0aGF0IGFscmVhZHkgaGFzIGEgRm91bmRhdGlvbiBwbHVnaW4uXFxcIik7aWYoZS5hdHRyKFxcXCJkYXRhLW9wdGlvbnNcXFwiKSl7ZS5hdHRyKFxcXCJkYXRhLW9wdGlvbnNcXFwiKS5zcGxpdChcXFwiO1xcXCIpLmZvckVhY2goZnVuY3Rpb24odCxlKXt2YXIgcz10LnNwbGl0KFxcXCI6XFxcIikubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRyaW0oKTt9KTtzWzBdJiYobltzWzBdXT1pKHNbMV0pKTt9KTt9dHJ5e2UuZGF0YShcXFwiemZQbHVnaW5cXFwiLG5ldyBhKHQodGhpcyksbikpO31jYXRjaChzKXtjb25zb2xlLmVycm9yKHMpO31maW5hbGx5e3JldHVybjt9fSk7fSk7fSxnZXRGbk5hbWU6ZSx0cmFuc2l0aW9uZW5kOmZ1bmN0aW9uIHRyYW5zaXRpb25lbmQodCl7dmFyIGUsaT17dHJhbnNpdGlvbjpcXFwidHJhbnNpdGlvbmVuZFxcXCIsV2Via2l0VHJhbnNpdGlvbjpcXFwid2Via2l0VHJhbnNpdGlvbkVuZFxcXCIsTW96VHJhbnNpdGlvbjpcXFwidHJhbnNpdGlvbmVuZFxcXCIsT1RyYW5zaXRpb246XFxcIm90cmFuc2l0aW9uZW5kXFxcIn0sbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTtmb3IodmFyIHMgaW4gaSl7XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBuLnN0eWxlW3NdJiYoZT1pW3NdKTt9cmV0dXJuIGU/ZTooZT1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dC50cmlnZ2VySGFuZGxlcihcXFwidHJhbnNpdGlvbmVuZFxcXCIsW3RdKTt9LDEpLFxcXCJ0cmFuc2l0aW9uZW5kXFxcIik7fX07by51dGlsPXt0aHJvdHRsZTpmdW5jdGlvbiB0aHJvdHRsZSh0LGUpe3ZhciBpPW51bGw7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIG49dGhpcyxzPWFyZ3VtZW50cztudWxsPT09aSYmKGk9c2V0VGltZW91dChmdW5jdGlvbigpe3QuYXBwbHkobixzKSxpPW51bGw7fSxlKSk7fTt9fTt2YXIgYT1mdW5jdGlvbiBhKGkpe3ZhciBuPXR5cGVvZiBpPT09XFxcInVuZGVmaW5lZFxcXCI/XFxcInVuZGVmaW5lZFxcXCI6X3R5cGVvZihpKSxzPXQoXFxcIm1ldGEuZm91bmRhdGlvbi1tcVxcXCIpLGE9dChcXFwiLm5vLWpzXFxcIik7aWYocy5sZW5ndGh8fHQoJzxtZXRhIGNsYXNzPVxcXCJmb3VuZGF0aW9uLW1xXFxcIj4nKS5hcHBlbmRUbyhkb2N1bWVudC5oZWFkKSxhLmxlbmd0aCYmYS5yZW1vdmVDbGFzcyhcXFwibm8tanNcXFwiKSxcXFwidW5kZWZpbmVkXFxcIj09PW4pby5NZWRpYVF1ZXJ5Ll9pbml0KCksby5yZWZsb3codGhpcyk7ZWxzZXtpZihcXFwic3RyaW5nXFxcIiE9PW4pdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiV2UncmUgc29ycnksIFxcXCIrbitcXFwiIGlzIG5vdCBhIHZhbGlkIHBhcmFtZXRlci4gWW91IG11c3QgdXNlIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbWV0aG9kIHlvdSB3aXNoIHRvIGludm9rZS5cXFwiKTt2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSksbD10aGlzLmRhdGEoXFxcInpmUGx1Z2luXFxcIik7aWYodm9pZCAwPT09bHx8dm9pZCAwPT09bFtpXSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXFxcIldlJ3JlIHNvcnJ5LCAnXFxcIitpK1xcXCInIGlzIG5vdCBhbiBhdmFpbGFibGUgbWV0aG9kIGZvciBcXFwiKyhsP2UobCk6XFxcInRoaXMgZWxlbWVudFxcXCIpK1xcXCIuXFxcIik7MT09PXRoaXMubGVuZ3RoP2xbaV0uYXBwbHkobCxyKTp0aGlzLmVhY2goZnVuY3Rpb24oZSxuKXtsW2ldLmFwcGx5KHQobikuZGF0YShcXFwiemZQbHVnaW5cXFwiKSxyKTt9KTt9cmV0dXJuIHRoaXM7fTt3aW5kb3cuRm91bmRhdGlvbj1vLHQuZm4uZm91bmRhdGlvbj1hLGZ1bmN0aW9uKCl7RGF0ZS5ub3cmJndpbmRvdy5EYXRlLm5vd3x8KHdpbmRvdy5EYXRlLm5vdz1EYXRlLm5vdz1mdW5jdGlvbigpe3JldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTt9KTtmb3IodmFyIHQ9W1xcXCJ3ZWJraXRcXFwiLFxcXCJtb3pcXFwiXSxlPTA7ZTx0Lmxlbmd0aCYmIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7KytlKXt2YXIgaT10W2VdO3dpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU9d2luZG93W2krXFxcIlJlcXVlc3RBbmltYXRpb25GcmFtZVxcXCJdLHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZT13aW5kb3dbaStcXFwiQ2FuY2VsQW5pbWF0aW9uRnJhbWVcXFwiXXx8d2luZG93W2krXFxcIkNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZVxcXCJdO31pZigvaVAoYWR8aG9uZXxvZCkuKk9TIDYvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpfHwhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZXx8IXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSl7dmFyIG49MDt3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lPWZ1bmN0aW9uKHQpe3ZhciBlPURhdGUubm93KCksaT1NYXRoLm1heChuKzE2LGUpO3JldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dChuPWkpO30saS1lKTt9LHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZT1jbGVhclRpbWVvdXQ7fXdpbmRvdy5wZXJmb3JtYW5jZSYmd2luZG93LnBlcmZvcm1hbmNlLm5vd3x8KHdpbmRvdy5wZXJmb3JtYW5jZT17c3RhcnQ6RGF0ZS5ub3coKSxub3c6ZnVuY3Rpb24gbm93KCl7cmV0dXJuIERhdGUubm93KCktdGhpcy5zdGFydDt9fSk7fSgpLEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kfHwoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQ9ZnVuY3Rpb24odCl7aWYoXFxcImZ1bmN0aW9uXFxcIiE9dHlwZW9mIHRoaXMpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgLSB3aGF0IGlzIHRyeWluZyB0byBiZSBib3VuZCBpcyBub3QgY2FsbGFibGVcXFwiKTt2YXIgZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSksaT10aGlzLG49ZnVuY3Rpb24gbigpe30scz1mdW5jdGlvbiBzKCl7cmV0dXJuIGkuYXBwbHkodGhpcyBpbnN0YW5jZW9mIG4/dGhpczp0LGUuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTt9O3JldHVybiB0aGlzLnByb3RvdHlwZSYmKG4ucHJvdG90eXBlPXRoaXMucHJvdG90eXBlKSxzLnByb3RvdHlwZT1uZXcgbigpLHM7fSk7fShqUXVlcnkpLCFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQsZSxuLHMpe3ZhciBvLGEscixsLHU9aSh0KTtpZihlKXt2YXIgZD1pKGUpO2E9dS5vZmZzZXQudG9wK3UuaGVpZ2h0PD1kLmhlaWdodCtkLm9mZnNldC50b3Asbz11Lm9mZnNldC50b3A+PWQub2Zmc2V0LnRvcCxyPXUub2Zmc2V0LmxlZnQ+PWQub2Zmc2V0LmxlZnQsbD11Lm9mZnNldC5sZWZ0K3Uud2lkdGg8PWQud2lkdGgrZC5vZmZzZXQubGVmdDt9ZWxzZSBhPXUub2Zmc2V0LnRvcCt1LmhlaWdodDw9dS53aW5kb3dEaW1zLmhlaWdodCt1LndpbmRvd0RpbXMub2Zmc2V0LnRvcCxvPXUub2Zmc2V0LnRvcD49dS53aW5kb3dEaW1zLm9mZnNldC50b3Ascj11Lm9mZnNldC5sZWZ0Pj11LndpbmRvd0RpbXMub2Zmc2V0LmxlZnQsbD11Lm9mZnNldC5sZWZ0K3Uud2lkdGg8PXUud2luZG93RGltcy53aWR0aDt2YXIgaD1bYSxvLHIsbF07cmV0dXJuIG4/cj09PWw9PSEwOnM/bz09PWE9PSEwOi0xPT09aC5pbmRleE9mKCExKTt9ZnVuY3Rpb24gaSh0LGUpe2lmKHQ9dC5sZW5ndGg/dFswXTp0LHQ9PT13aW5kb3d8fHQ9PT1kb2N1bWVudCl0aHJvdyBuZXcgRXJyb3IoXFxcIkknbSBzb3JyeSwgRGF2ZS4gSSdtIGFmcmFpZCBJIGNhbid0IGRvIHRoYXQuXFxcIik7dmFyIGk9dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxuPXQucGFyZW50Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxzPWRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksbz13aW5kb3cucGFnZVlPZmZzZXQsYT13aW5kb3cucGFnZVhPZmZzZXQ7cmV0dXJue3dpZHRoOmkud2lkdGgsaGVpZ2h0OmkuaGVpZ2h0LG9mZnNldDp7dG9wOmkudG9wK28sbGVmdDppLmxlZnQrYX0scGFyZW50RGltczp7d2lkdGg6bi53aWR0aCxoZWlnaHQ6bi5oZWlnaHQsb2Zmc2V0Ont0b3A6bi50b3ArbyxsZWZ0Om4ubGVmdCthfX0sd2luZG93RGltczp7d2lkdGg6cy53aWR0aCxoZWlnaHQ6cy5oZWlnaHQsb2Zmc2V0Ont0b3A6byxsZWZ0OmF9fX07fWZ1bmN0aW9uIG4odCxlLG4scyxvLGEpe3ZhciByPWkodCksbD1lP2koZSk6bnVsbDtzd2l0Y2gobil7Y2FzZVxcXCJ0b3BcXFwiOnJldHVybntsZWZ0OkZvdW5kYXRpb24ucnRsKCk/bC5vZmZzZXQubGVmdC1yLndpZHRoK2wud2lkdGg6bC5vZmZzZXQubGVmdCx0b3A6bC5vZmZzZXQudG9wLShyLmhlaWdodCtzKX07Y2FzZVxcXCJsZWZ0XFxcIjpyZXR1cm57bGVmdDpsLm9mZnNldC5sZWZ0LShyLndpZHRoK28pLHRvcDpsLm9mZnNldC50b3B9O2Nhc2VcXFwicmlnaHRcXFwiOnJldHVybntsZWZ0Omwub2Zmc2V0LmxlZnQrbC53aWR0aCtvLHRvcDpsLm9mZnNldC50b3B9O2Nhc2VcXFwiY2VudGVyIHRvcFxcXCI6cmV0dXJue2xlZnQ6bC5vZmZzZXQubGVmdCtsLndpZHRoLzItci53aWR0aC8yLHRvcDpsLm9mZnNldC50b3AtKHIuaGVpZ2h0K3MpfTtjYXNlXFxcImNlbnRlciBib3R0b21cXFwiOnJldHVybntsZWZ0OmE/bzpsLm9mZnNldC5sZWZ0K2wud2lkdGgvMi1yLndpZHRoLzIsdG9wOmwub2Zmc2V0LnRvcCtsLmhlaWdodCtzfTtjYXNlXFxcImNlbnRlciBsZWZ0XFxcIjpyZXR1cm57bGVmdDpsLm9mZnNldC5sZWZ0LShyLndpZHRoK28pLHRvcDpsLm9mZnNldC50b3ArbC5oZWlnaHQvMi1yLmhlaWdodC8yfTtjYXNlXFxcImNlbnRlciByaWdodFxcXCI6cmV0dXJue2xlZnQ6bC5vZmZzZXQubGVmdCtsLndpZHRoK28rMSx0b3A6bC5vZmZzZXQudG9wK2wuaGVpZ2h0LzItci5oZWlnaHQvMn07Y2FzZVxcXCJjZW50ZXJcXFwiOnJldHVybntsZWZ0OnIud2luZG93RGltcy5vZmZzZXQubGVmdCtyLndpbmRvd0RpbXMud2lkdGgvMi1yLndpZHRoLzIsdG9wOnIud2luZG93RGltcy5vZmZzZXQudG9wK3Iud2luZG93RGltcy5oZWlnaHQvMi1yLmhlaWdodC8yfTtjYXNlXFxcInJldmVhbFxcXCI6cmV0dXJue2xlZnQ6KHIud2luZG93RGltcy53aWR0aC1yLndpZHRoKS8yLHRvcDpyLndpbmRvd0RpbXMub2Zmc2V0LnRvcCtzfTtjYXNlXFxcInJldmVhbCBmdWxsXFxcIjpyZXR1cm57bGVmdDpyLndpbmRvd0RpbXMub2Zmc2V0LmxlZnQsdG9wOnIud2luZG93RGltcy5vZmZzZXQudG9wfTtjYXNlXFxcImxlZnQgYm90dG9tXFxcIjpyZXR1cm57bGVmdDpsLm9mZnNldC5sZWZ0LShyLndpZHRoK28pLHRvcDpsLm9mZnNldC50b3ArbC5oZWlnaHR9O2Nhc2VcXFwicmlnaHQgYm90dG9tXFxcIjpyZXR1cm57bGVmdDpsLm9mZnNldC5sZWZ0K2wud2lkdGgrby1yLndpZHRoLHRvcDpsLm9mZnNldC50b3ArbC5oZWlnaHR9O2RlZmF1bHQ6cmV0dXJue2xlZnQ6Rm91bmRhdGlvbi5ydGwoKT9sLm9mZnNldC5sZWZ0LXIud2lkdGgrbC53aWR0aDpsLm9mZnNldC5sZWZ0LHRvcDpsLm9mZnNldC50b3ArbC5oZWlnaHQrc307fX1Gb3VuZGF0aW9uLkJveD17SW1Ob3RUb3VjaGluZ1lvdTplLEdldERpbWVuc2lvbnM6aSxHZXRPZmZzZXRzOm59O30oalF1ZXJ5KSwhZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0KXt2YXIgZT17fTtmb3IodmFyIGkgaW4gdCl7ZVt0W2ldXT10W2ldO31yZXR1cm4gZTt9dmFyIGk9ezk6XFxcIlRBQlxcXCIsMTM6XFxcIkVOVEVSXFxcIiwyNzpcXFwiRVNDQVBFXFxcIiwzMjpcXFwiU1BBQ0VcXFwiLDM3OlxcXCJBUlJPV19MRUZUXFxcIiwzODpcXFwiQVJST1dfVVBcXFwiLDM5OlxcXCJBUlJPV19SSUdIVFxcXCIsNDA6XFxcIkFSUk9XX0RPV05cXFwifSxuPXt9LHM9e2tleXM6ZShpKSxwYXJzZUtleTpmdW5jdGlvbiBwYXJzZUtleSh0KXt2YXIgZT1pW3Qud2hpY2h8fHQua2V5Q29kZV18fFN0cmluZy5mcm9tQ2hhckNvZGUodC53aGljaCkudG9VcHBlckNhc2UoKTtyZXR1cm4gdC5zaGlmdEtleSYmKGU9XFxcIlNISUZUX1xcXCIrZSksdC5jdHJsS2V5JiYoZT1cXFwiQ1RSTF9cXFwiK2UpLHQuYWx0S2V5JiYoZT1cXFwiQUxUX1xcXCIrZSksZTt9LGhhbmRsZUtleTpmdW5jdGlvbiBoYW5kbGVLZXkoZSxpLHMpe3ZhciBvLGEscixsPW5baV0sdT10aGlzLnBhcnNlS2V5KGUpO2lmKCFsKXJldHVybiBjb25zb2xlLndhcm4oXFxcIkNvbXBvbmVudCBub3QgZGVmaW5lZCFcXFwiKTtpZihvPVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgbC5sdHI/bDpGb3VuZGF0aW9uLnJ0bCgpP3QuZXh0ZW5kKHt9LGwubHRyLGwucnRsKTp0LmV4dGVuZCh7fSxsLnJ0bCxsLmx0ciksYT1vW3VdLHI9c1thXSxyJiZcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2Ygcil7dmFyIGQ9ci5hcHBseSgpOyhzLmhhbmRsZWR8fFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBzLmhhbmRsZWQpJiZzLmhhbmRsZWQoZCk7fWVsc2Uocy51bmhhbmRsZWR8fFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBzLnVuaGFuZGxlZCkmJnMudW5oYW5kbGVkKCk7fSxmaW5kRm9jdXNhYmxlOmZ1bmN0aW9uIGZpbmRGb2N1c2FibGUoZSl7cmV0dXJuIGUuZmluZChcXFwiYVtocmVmXSwgYXJlYVtocmVmXSwgaW5wdXQ6bm90KFtkaXNhYmxlZF0pLCBzZWxlY3Q6bm90KFtkaXNhYmxlZF0pLCB0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSksIGJ1dHRvbjpub3QoW2Rpc2FibGVkXSksIGlmcmFtZSwgb2JqZWN0LCBlbWJlZCwgKlt0YWJpbmRleF0sICpbY29udGVudGVkaXRhYmxlXVxcXCIpLmZpbHRlcihmdW5jdGlvbigpe3JldHVybiB0KHRoaXMpLmlzKFxcXCI6dmlzaWJsZVxcXCIpJiYhKHQodGhpcykuYXR0cihcXFwidGFiaW5kZXhcXFwiKTwwKTt9KTt9LHJlZ2lzdGVyOmZ1bmN0aW9uIHJlZ2lzdGVyKHQsZSl7blt0XT1lO319O0ZvdW5kYXRpb24uS2V5Ym9hcmQ9czt9KGpRdWVyeSksIWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7dmFyIGU9e307cmV0dXJuXFxcInN0cmluZ1xcXCIhPXR5cGVvZiB0P2U6KHQ9dC50cmltKCkuc2xpY2UoMSwtMSkpP2U9dC5zcGxpdChcXFwiJlxcXCIpLnJlZHVjZShmdW5jdGlvbih0LGUpe3ZhciBpPWUucmVwbGFjZSgvXFxcXCsvZyxcXFwiIFxcXCIpLnNwbGl0KFxcXCI9XFxcIiksbj1pWzBdLHM9aVsxXTtyZXR1cm4gbj1kZWNvZGVVUklDb21wb25lbnQobikscz12b2lkIDA9PT1zP251bGw6ZGVjb2RlVVJJQ29tcG9uZW50KHMpLHQuaGFzT3duUHJvcGVydHkobik/QXJyYXkuaXNBcnJheSh0W25dKT90W25dLnB1c2gocyk6dFtuXT1bdFtuXSxzXTp0W25dPXMsdDt9LHt9KTplO312YXIgaT17cXVlcmllczpbXSxjdXJyZW50OlxcXCJcXFwiLF9pbml0OmZ1bmN0aW9uIF9pbml0KCl7dmFyIGksbj10aGlzLHM9dChcXFwiLmZvdW5kYXRpb24tbXFcXFwiKS5jc3MoXFxcImZvbnQtZmFtaWx5XFxcIik7aT1lKHMpO2Zvcih2YXIgbyBpbiBpKXtpLmhhc093blByb3BlcnR5KG8pJiZuLnF1ZXJpZXMucHVzaCh7bmFtZTpvLHZhbHVlOlxcXCJvbmx5IHNjcmVlbiBhbmQgKG1pbi13aWR0aDogXFxcIitpW29dK1xcXCIpXFxcIn0pO310aGlzLmN1cnJlbnQ9dGhpcy5fZ2V0Q3VycmVudFNpemUoKSx0aGlzLl93YXRjaGVyKCk7fSxhdExlYXN0OmZ1bmN0aW9uIGF0TGVhc3QodCl7dmFyIGU9dGhpcy5nZXQodCk7cmV0dXJuIGU/d2luZG93Lm1hdGNoTWVkaWEoZSkubWF0Y2hlczohMTt9LGdldDpmdW5jdGlvbiBnZXQodCl7Zm9yKHZhciBlIGluIHRoaXMucXVlcmllcyl7aWYodGhpcy5xdWVyaWVzLmhhc093blByb3BlcnR5KGUpKXt2YXIgaT10aGlzLnF1ZXJpZXNbZV07aWYodD09PWkubmFtZSlyZXR1cm4gaS52YWx1ZTt9fXJldHVybiBudWxsO30sX2dldEN1cnJlbnRTaXplOmZ1bmN0aW9uIF9nZXRDdXJyZW50U2l6ZSgpe2Zvcih2YXIgdCxlPTA7ZTx0aGlzLnF1ZXJpZXMubGVuZ3RoO2UrKyl7dmFyIGk9dGhpcy5xdWVyaWVzW2VdO3dpbmRvdy5tYXRjaE1lZGlhKGkudmFsdWUpLm1hdGNoZXMmJih0PWkpO31yZXR1cm5cXFwib2JqZWN0XFxcIj09KHR5cGVvZiB0PT09XFxcInVuZGVmaW5lZFxcXCI/XFxcInVuZGVmaW5lZFxcXCI6X3R5cGVvZih0KSk/dC5uYW1lOnQ7fSxfd2F0Y2hlcjpmdW5jdGlvbiBfd2F0Y2hlcigpe3ZhciBlPXRoaXM7dCh3aW5kb3cpLm9uKFxcXCJyZXNpemUuemYubWVkaWFxdWVyeVxcXCIsZnVuY3Rpb24oKXt2YXIgaT1lLl9nZXRDdXJyZW50U2l6ZSgpLG49ZS5jdXJyZW50O2khPT1uJiYoZS5jdXJyZW50PWksdCh3aW5kb3cpLnRyaWdnZXIoXFxcImNoYW5nZWQuemYubWVkaWFxdWVyeVxcXCIsW2ksbl0pKTt9KTt9fTtGb3VuZGF0aW9uLk1lZGlhUXVlcnk9aSx3aW5kb3cubWF0Y2hNZWRpYXx8KHdpbmRvdy5tYXRjaE1lZGlhPWZ1bmN0aW9uKCl7XFxcInVzZSBzdHJpY3RcXFwiO3ZhciB0PXdpbmRvdy5zdHlsZU1lZGlhfHx3aW5kb3cubWVkaWE7aWYoIXQpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInN0eWxlXFxcIiksaT1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwic2NyaXB0XFxcIilbMF0sbj1udWxsO2UudHlwZT1cXFwidGV4dC9jc3NcXFwiLGUuaWQ9XFxcIm1hdGNobWVkaWFqcy10ZXN0XFxcIixpLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUsaSksbj1cXFwiZ2V0Q29tcHV0ZWRTdHlsZVxcXCJpbiB3aW5kb3cmJndpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGUsbnVsbCl8fGUuY3VycmVudFN0eWxlLHQ9e21hdGNoTWVkaXVtOmZ1bmN0aW9uIG1hdGNoTWVkaXVtKHQpe3ZhciBpPVxcXCJAbWVkaWEgXFxcIit0K1xcXCJ7ICNtYXRjaG1lZGlhanMtdGVzdCB7IHdpZHRoOiAxcHg7IH0gfVxcXCI7cmV0dXJuIGUuc3R5bGVTaGVldD9lLnN0eWxlU2hlZXQuY3NzVGV4dD1pOmUudGV4dENvbnRlbnQ9aSxcXFwiMXB4XFxcIj09PW4ud2lkdGg7fX07fXJldHVybiBmdW5jdGlvbihlKXtyZXR1cm57bWF0Y2hlczp0Lm1hdGNoTWVkaXVtKGV8fFxcXCJhbGxcXFwiKSxtZWRpYTplfHxcXFwiYWxsXFxcIn07fTt9KCkpLEZvdW5kYXRpb24uTWVkaWFRdWVyeT1pO30oalF1ZXJ5KSwhZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0LGUsaSl7ZnVuY3Rpb24gbihyKXthfHwoYT13aW5kb3cucGVyZm9ybWFuY2Uubm93KCkpLG89ci1hLGkuYXBwbHkoZSksdD5vP3M9d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShuLGUpOih3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUocyksZS50cmlnZ2VyKFxcXCJmaW5pc2hlZC56Zi5hbmltYXRlXFxcIixbZV0pLnRyaWdnZXJIYW5kbGVyKFxcXCJmaW5pc2hlZC56Zi5hbmltYXRlXFxcIixbZV0pKTt9dmFyIHMsbyxhPW51bGw7cz13aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG4pO31mdW5jdGlvbiBpKGUsaSxvLGEpe2Z1bmN0aW9uIHIoKXtlfHxpLmhpZGUoKSxsKCksYSYmYS5hcHBseShpKTt9ZnVuY3Rpb24gbCgpe2lbMF0uc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uPTAsaS5yZW1vdmVDbGFzcyh1K1xcXCIgXFxcIitkK1xcXCIgXFxcIitvKTt9aWYoaT10KGkpLmVxKDApLGkubGVuZ3RoKXt2YXIgdT1lP25bMF06blsxXSxkPWU/c1swXTpzWzFdO2woKSxpLmFkZENsYXNzKG8pLmNzcyhcXFwidHJhbnNpdGlvblxcXCIsXFxcIm5vbmVcXFwiKSxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtpLmFkZENsYXNzKHUpLGUmJmkuc2hvdygpO30pLHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe2lbMF0ub2Zmc2V0V2lkdGgsaS5jc3MoXFxcInRyYW5zaXRpb25cXFwiLFxcXCJcXFwiKS5hZGRDbGFzcyhkKTt9KSxpLm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQoaSkscik7fX12YXIgbj1bXFxcIm11aS1lbnRlclxcXCIsXFxcIm11aS1sZWF2ZVxcXCJdLHM9W1xcXCJtdWktZW50ZXItYWN0aXZlXFxcIixcXFwibXVpLWxlYXZlLWFjdGl2ZVxcXCJdLG89e2FuaW1hdGVJbjpmdW5jdGlvbiBhbmltYXRlSW4odCxlLG4pe2koITAsdCxlLG4pO30sYW5pbWF0ZU91dDpmdW5jdGlvbiBhbmltYXRlT3V0KHQsZSxuKXtpKCExLHQsZSxuKTt9fTtGb3VuZGF0aW9uLk1vdmU9ZSxGb3VuZGF0aW9uLk1vdGlvbj1vO30oalF1ZXJ5KSwhZnVuY3Rpb24odCl7dmFyIGU9e0ZlYXRoZXI6ZnVuY3Rpb24gRmVhdGhlcihlKXt2YXIgaT1hcmd1bWVudHMubGVuZ3RoPD0xfHx2b2lkIDA9PT1hcmd1bWVudHNbMV0/XFxcInpmXFxcIjphcmd1bWVudHNbMV07ZS5hdHRyKFxcXCJyb2xlXFxcIixcXFwibWVudWJhclxcXCIpO3ZhciBuPWUuZmluZChcXFwibGlcXFwiKS5hdHRyKHtyb2xlOlxcXCJtZW51aXRlbVxcXCJ9KSxzPVxcXCJpcy1cXFwiK2krXFxcIi1zdWJtZW51XFxcIixvPXMrXFxcIi1pdGVtXFxcIixhPVxcXCJpcy1cXFwiK2krXFxcIi1zdWJtZW51LXBhcmVudFxcXCI7ZS5maW5kKFxcXCJhOmZpcnN0XFxcIikuYXR0cihcXFwidGFiaW5kZXhcXFwiLDApLG4uZWFjaChmdW5jdGlvbigpe3ZhciBlPXQodGhpcyksaT1lLmNoaWxkcmVuKFxcXCJ1bFxcXCIpO2kubGVuZ3RoJiYoZS5hZGRDbGFzcyhhKS5hdHRyKHtcXFwiYXJpYS1oYXNwb3B1cFxcXCI6ITAsXFxcImFyaWEtZXhwYW5kZWRcXFwiOiExLFxcXCJhcmlhLWxhYmVsXFxcIjplLmNoaWxkcmVuKFxcXCJhOmZpcnN0XFxcIikudGV4dCgpfSksaS5hZGRDbGFzcyhcXFwic3VibWVudSBcXFwiK3MpLmF0dHIoe1xcXCJkYXRhLXN1Ym1lbnVcXFwiOlxcXCJcXFwiLFxcXCJhcmlhLWhpZGRlblxcXCI6ITAscm9sZTpcXFwibWVudVxcXCJ9KSksZS5wYXJlbnQoXFxcIltkYXRhLXN1Ym1lbnVdXFxcIikubGVuZ3RoJiZlLmFkZENsYXNzKFxcXCJpcy1zdWJtZW51LWl0ZW0gXFxcIitvKTt9KTt9LEJ1cm46ZnVuY3Rpb24gQnVybih0LGUpe3ZhciBpPSh0LmZpbmQoXFxcImxpXFxcIikucmVtb3ZlQXR0cihcXFwidGFiaW5kZXhcXFwiKSxcXFwiaXMtXFxcIitlK1xcXCItc3VibWVudVxcXCIpLG49aStcXFwiLWl0ZW1cXFwiLHM9XFxcImlzLVxcXCIrZStcXFwiLXN1Ym1lbnUtcGFyZW50XFxcIjt0LmZpbmQoXFxcIipcXFwiKS5yZW1vdmVDbGFzcyhpK1xcXCIgXFxcIituK1xcXCIgXFxcIitzK1xcXCIgaXMtc3VibWVudS1pdGVtIHN1Ym1lbnUgaXMtYWN0aXZlXFxcIikucmVtb3ZlQXR0cihcXFwiZGF0YS1zdWJtZW51XFxcIikuY3NzKFxcXCJkaXNwbGF5XFxcIixcXFwiXFxcIik7fX07Rm91bmRhdGlvbi5OZXN0PWU7fShqUXVlcnkpLCFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQsZSxpKXt2YXIgbixzLG89dGhpcyxhPWUuZHVyYXRpb24scj1PYmplY3Qua2V5cyh0LmRhdGEoKSlbMF18fFxcXCJ0aW1lclxcXCIsbD0tMTt0aGlzLmlzUGF1c2VkPSExLHRoaXMucmVzdGFydD1mdW5jdGlvbigpe2w9LTEsY2xlYXJUaW1lb3V0KHMpLHRoaXMuc3RhcnQoKTt9LHRoaXMuc3RhcnQ9ZnVuY3Rpb24oKXt0aGlzLmlzUGF1c2VkPSExLGNsZWFyVGltZW91dChzKSxsPTA+PWw/YTpsLHQuZGF0YShcXFwicGF1c2VkXFxcIiwhMSksbj1EYXRlLm5vdygpLHM9c2V0VGltZW91dChmdW5jdGlvbigpe2UuaW5maW5pdGUmJm8ucmVzdGFydCgpLGkoKTt9LGwpLHQudHJpZ2dlcihcXFwidGltZXJzdGFydC56Zi5cXFwiK3IpO30sdGhpcy5wYXVzZT1mdW5jdGlvbigpe3RoaXMuaXNQYXVzZWQ9ITAsY2xlYXJUaW1lb3V0KHMpLHQuZGF0YShcXFwicGF1c2VkXFxcIiwhMCk7dmFyIGU9RGF0ZS5ub3coKTtsLT1lLW4sdC50cmlnZ2VyKFxcXCJ0aW1lcnBhdXNlZC56Zi5cXFwiK3IpO307fWZ1bmN0aW9uIGkoZSxpKXtmdW5jdGlvbiBuKCl7cy0tLDA9PT1zJiZpKCk7fXZhciBzPWUubGVuZ3RoOzA9PT1zJiZpKCksZS5lYWNoKGZ1bmN0aW9uKCl7dGhpcy5jb21wbGV0ZT9uKCk6XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB0aGlzLm5hdHVyYWxXaWR0aCYmdGhpcy5uYXR1cmFsV2lkdGg+MD9uKCk6dCh0aGlzKS5vbmUoXFxcImxvYWRcXFwiLGZ1bmN0aW9uKCl7bigpO30pO30pO31Gb3VuZGF0aW9uLlRpbWVyPWUsRm91bmRhdGlvbi5vbkltYWdlc0xvYWRlZD1pO30oalF1ZXJ5KSxmdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7dGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJ0b3VjaG1vdmVcXFwiLGkpLHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcXFwidG91Y2hlbmRcXFwiLGUpLHU9ITE7fWZ1bmN0aW9uIGkoaSl7aWYodC5zcG90U3dpcGUucHJldmVudERlZmF1bHQmJmkucHJldmVudERlZmF1bHQoKSx1KXt2YXIgbixzPWkudG91Y2hlc1swXS5wYWdlWCxhPShpLnRvdWNoZXNbMF0ucGFnZVksby1zKTtsPW5ldyBEYXRlKCkuZ2V0VGltZSgpLXIsTWF0aC5hYnMoYSk+PXQuc3BvdFN3aXBlLm1vdmVUaHJlc2hvbGQmJmw8PXQuc3BvdFN3aXBlLnRpbWVUaHJlc2hvbGQmJihuPWE+MD9cXFwibGVmdFxcXCI6XFxcInJpZ2h0XFxcIiksbiYmKGkucHJldmVudERlZmF1bHQoKSxlLmNhbGwodGhpcyksdCh0aGlzKS50cmlnZ2VyKFxcXCJzd2lwZVxcXCIsbikudHJpZ2dlcihcXFwic3dpcGVcXFwiK24pKTt9fWZ1bmN0aW9uIG4odCl7MT09dC50b3VjaGVzLmxlbmd0aCYmKG89dC50b3VjaGVzWzBdLnBhZ2VYLGE9dC50b3VjaGVzWzBdLnBhZ2VZLHU9ITAscj1uZXcgRGF0ZSgpLmdldFRpbWUoKSx0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXFxcInRvdWNobW92ZVxcXCIsaSwhMSksdGhpcy5hZGRFdmVudExpc3RlbmVyKFxcXCJ0b3VjaGVuZFxcXCIsZSwhMSkpO31mdW5jdGlvbiBzKCl7dGhpcy5hZGRFdmVudExpc3RlbmVyJiZ0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXFxcInRvdWNoc3RhcnRcXFwiLG4sITEpO310LnNwb3RTd2lwZT17dmVyc2lvbjpcXFwiMS4wLjBcXFwiLGVuYWJsZWQ6XFxcIm9udG91Y2hzdGFydFxcXCJpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQscHJldmVudERlZmF1bHQ6ITEsbW92ZVRocmVzaG9sZDo3NSx0aW1lVGhyZXNob2xkOjIwMH07dmFyIG8sYSxyLGwsdT0hMTt0LmV2ZW50LnNwZWNpYWwuc3dpcGU9e3NldHVwOnN9LHQuZWFjaChbXFxcImxlZnRcXFwiLFxcXCJ1cFxcXCIsXFxcImRvd25cXFwiLFxcXCJyaWdodFxcXCJdLGZ1bmN0aW9uKCl7dC5ldmVudC5zcGVjaWFsW1xcXCJzd2lwZVxcXCIrdGhpc109e3NldHVwOmZ1bmN0aW9uIHNldHVwKCl7dCh0aGlzKS5vbihcXFwic3dpcGVcXFwiLHQubm9vcCk7fX07fSk7fShqUXVlcnkpLCFmdW5jdGlvbih0KXt0LmZuLmFkZFRvdWNoPWZ1bmN0aW9uKCl7dGhpcy5lYWNoKGZ1bmN0aW9uKGksbil7dChuKS5iaW5kKFxcXCJ0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbFxcXCIsZnVuY3Rpb24oKXtlKGV2ZW50KTt9KTt9KTt2YXIgZT1mdW5jdGlvbiBlKHQpe3ZhciBlLGk9dC5jaGFuZ2VkVG91Y2hlcyxuPWlbMF0scz17dG91Y2hzdGFydDpcXFwibW91c2Vkb3duXFxcIix0b3VjaG1vdmU6XFxcIm1vdXNlbW92ZVxcXCIsdG91Y2hlbmQ6XFxcIm1vdXNldXBcXFwifSxvPXNbdC50eXBlXTtcXFwiTW91c2VFdmVudFxcXCJpbiB3aW5kb3cmJlxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiB3aW5kb3cuTW91c2VFdmVudD9lPW5ldyB3aW5kb3cuTW91c2VFdmVudChvLHtidWJibGVzOiEwLGNhbmNlbGFibGU6ITAsc2NyZWVuWDpuLnNjcmVlblgsc2NyZWVuWTpuLnNjcmVlblksY2xpZW50WDpuLmNsaWVudFgsY2xpZW50WTpuLmNsaWVudFl9KTooZT1kb2N1bWVudC5jcmVhdGVFdmVudChcXFwiTW91c2VFdmVudFxcXCIpLGUuaW5pdE1vdXNlRXZlbnQobywhMCwhMCx3aW5kb3csMSxuLnNjcmVlblgsbi5zY3JlZW5ZLG4uY2xpZW50WCxuLmNsaWVudFksITEsITEsITEsITEsMCxudWxsKSksbi50YXJnZXQuZGlzcGF0Y2hFdmVudChlKTt9O307fShqUXVlcnkpLCFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7bygpLG4oKSxzKCksaSgpO31mdW5jdGlvbiBpKGUpe3ZhciBpPXQoXFxcIltkYXRhLXlldGktYm94XVxcXCIpLG49W1xcXCJkcm9wZG93blxcXCIsXFxcInRvb2x0aXBcXFwiLFxcXCJyZXZlYWxcXFwiXTtpZihlJiYoXFxcInN0cmluZ1xcXCI9PXR5cGVvZiBlP24ucHVzaChlKTpcXFwib2JqZWN0XFxcIj09KHR5cGVvZiBlPT09XFxcInVuZGVmaW5lZFxcXCI/XFxcInVuZGVmaW5lZFxcXCI6X3R5cGVvZihlKSkmJlxcXCJzdHJpbmdcXFwiPT10eXBlb2YgZVswXT9uLmNvbmNhdChlKTpjb25zb2xlLmVycm9yKFxcXCJQbHVnaW4gbmFtZXMgbXVzdCBiZSBzdHJpbmdzXFxcIikpLGkubGVuZ3RoKXt2YXIgcz1uLm1hcChmdW5jdGlvbih0KXtyZXR1cm5cXFwiY2xvc2VtZS56Zi5cXFwiK3Q7fSkuam9pbihcXFwiIFxcXCIpO3Qod2luZG93KS5vZmYocykub24ocyxmdW5jdGlvbihlLGkpe3ZhciBuPWUubmFtZXNwYWNlLnNwbGl0KFxcXCIuXFxcIilbMF0scz10KFxcXCJbZGF0YS1cXFwiK24rXFxcIl1cXFwiKS5ub3QoJ1tkYXRhLXlldGktYm94PVxcXCInK2krJ1xcXCJdJyk7cy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGU9dCh0aGlzKTtlLnRyaWdnZXJIYW5kbGVyKFxcXCJjbG9zZS56Zi50cmlnZ2VyXFxcIixbZV0pO30pO30pO319ZnVuY3Rpb24gbihlKXt2YXIgaT12b2lkIDAsbj10KFxcXCJbZGF0YS1yZXNpemVdXFxcIik7bi5sZW5ndGgmJnQod2luZG93KS5vZmYoXFxcInJlc2l6ZS56Zi50cmlnZ2VyXFxcIikub24oXFxcInJlc2l6ZS56Zi50cmlnZ2VyXFxcIixmdW5jdGlvbihzKXtpJiZjbGVhclRpbWVvdXQoaSksaT1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YXx8bi5lYWNoKGZ1bmN0aW9uKCl7dCh0aGlzKS50cmlnZ2VySGFuZGxlcihcXFwicmVzaXplbWUuemYudHJpZ2dlclxcXCIpO30pLG4uYXR0cihcXFwiZGF0YS1ldmVudHNcXFwiLFxcXCJyZXNpemVcXFwiKTt9LGV8fDEwKTt9KTt9ZnVuY3Rpb24gcyhlKXt2YXIgaT12b2lkIDAsbj10KFxcXCJbZGF0YS1zY3JvbGxdXFxcIik7bi5sZW5ndGgmJnQod2luZG93KS5vZmYoXFxcInNjcm9sbC56Zi50cmlnZ2VyXFxcIikub24oXFxcInNjcm9sbC56Zi50cmlnZ2VyXFxcIixmdW5jdGlvbihzKXtpJiZjbGVhclRpbWVvdXQoaSksaT1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YXx8bi5lYWNoKGZ1bmN0aW9uKCl7dCh0aGlzKS50cmlnZ2VySGFuZGxlcihcXFwic2Nyb2xsbWUuemYudHJpZ2dlclxcXCIpO30pLG4uYXR0cihcXFwiZGF0YS1ldmVudHNcXFwiLFxcXCJzY3JvbGxcXFwiKTt9LGV8fDEwKTt9KTt9ZnVuY3Rpb24gbygpe2lmKCFhKXJldHVybiExO3ZhciBlPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIltkYXRhLXJlc2l6ZV0sIFtkYXRhLXNjcm9sbF0sIFtkYXRhLW11dGF0ZV1cXFwiKSxpPWZ1bmN0aW9uIGkoZSl7dmFyIGk9dChlWzBdLnRhcmdldCk7c3dpdGNoKGkuYXR0cihcXFwiZGF0YS1ldmVudHNcXFwiKSl7Y2FzZVxcXCJyZXNpemVcXFwiOmkudHJpZ2dlckhhbmRsZXIoXFxcInJlc2l6ZW1lLnpmLnRyaWdnZXJcXFwiLFtpXSk7YnJlYWs7Y2FzZVxcXCJzY3JvbGxcXFwiOmkudHJpZ2dlckhhbmRsZXIoXFxcInNjcm9sbG1lLnpmLnRyaWdnZXJcXFwiLFtpLHdpbmRvdy5wYWdlWU9mZnNldF0pO2JyZWFrO2RlZmF1bHQ6cmV0dXJuITE7fX07aWYoZS5sZW5ndGgpZm9yKHZhciBuPTA7bjw9ZS5sZW5ndGgtMTtuKyspe3ZhciBzPW5ldyBhKGkpO3Mub2JzZXJ2ZShlW25dLHthdHRyaWJ1dGVzOiEwLGNoaWxkTGlzdDohMSxjaGFyYWN0ZXJEYXRhOiExLHN1YnRyZWU6ITEsYXR0cmlidXRlRmlsdGVyOltcXFwiZGF0YS1ldmVudHNcXFwiXX0pO319dmFyIGE9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9W1xcXCJXZWJLaXRcXFwiLFxcXCJNb3pcXFwiLFxcXCJPXFxcIixcXFwiTXNcXFwiLFxcXCJcXFwiXSxlPTA7ZTx0Lmxlbmd0aDtlKyspe2lmKHRbZV0rXFxcIk11dGF0aW9uT2JzZXJ2ZXJcXFwiaW4gd2luZG93KXJldHVybiB3aW5kb3dbdFtlXStcXFwiTXV0YXRpb25PYnNlcnZlclxcXCJdO31yZXR1cm4hMTt9KCkscj1mdW5jdGlvbiByKGUsaSl7ZS5kYXRhKGkpLnNwbGl0KFxcXCIgXFxcIikuZm9yRWFjaChmdW5jdGlvbihuKXt0KFxcXCIjXFxcIituKVtcXFwiY2xvc2VcXFwiPT09aT9cXFwidHJpZ2dlclxcXCI6XFxcInRyaWdnZXJIYW5kbGVyXFxcIl0oaStcXFwiLnpmLnRyaWdnZXJcXFwiLFtlXSk7fSk7fTt0KGRvY3VtZW50KS5vbihcXFwiY2xpY2suemYudHJpZ2dlclxcXCIsXFxcIltkYXRhLW9wZW5dXFxcIixmdW5jdGlvbigpe3IodCh0aGlzKSxcXFwib3BlblxcXCIpO30pLHQoZG9jdW1lbnQpLm9uKFxcXCJjbGljay56Zi50cmlnZ2VyXFxcIixcXFwiW2RhdGEtY2xvc2VdXFxcIixmdW5jdGlvbigpe3ZhciBlPXQodGhpcykuZGF0YShcXFwiY2xvc2VcXFwiKTtlP3IodCh0aGlzKSxcXFwiY2xvc2VcXFwiKTp0KHRoaXMpLnRyaWdnZXIoXFxcImNsb3NlLnpmLnRyaWdnZXJcXFwiKTt9KSx0KGRvY3VtZW50KS5vbihcXFwiY2xpY2suemYudHJpZ2dlclxcXCIsXFxcIltkYXRhLXRvZ2dsZV1cXFwiLGZ1bmN0aW9uKCl7cih0KHRoaXMpLFxcXCJ0b2dnbGVcXFwiKTt9KSx0KGRvY3VtZW50KS5vbihcXFwiY2xvc2UuemYudHJpZ2dlclxcXCIsXFxcIltkYXRhLWNsb3NhYmxlXVxcXCIsZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24oKTt2YXIgaT10KHRoaXMpLmRhdGEoXFxcImNsb3NhYmxlXFxcIik7XFxcIlxcXCIhPT1pP0ZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVPdXQodCh0aGlzKSxpLGZ1bmN0aW9uKCl7dCh0aGlzKS50cmlnZ2VyKFxcXCJjbG9zZWQuemZcXFwiKTt9KTp0KHRoaXMpLmZhZGVPdXQoKS50cmlnZ2VyKFxcXCJjbG9zZWQuemZcXFwiKTt9KSx0KGRvY3VtZW50KS5vbihcXFwiZm9jdXMuemYudHJpZ2dlciBibHVyLnpmLnRyaWdnZXJcXFwiLFxcXCJbZGF0YS10b2dnbGUtZm9jdXNdXFxcIixmdW5jdGlvbigpe3ZhciBlPXQodGhpcykuZGF0YShcXFwidG9nZ2xlLWZvY3VzXFxcIik7dChcXFwiI1xcXCIrZSkudHJpZ2dlckhhbmRsZXIoXFxcInRvZ2dsZS56Zi50cmlnZ2VyXFxcIixbdCh0aGlzKV0pO30pLHQod2luZG93KS5sb2FkKGZ1bmN0aW9uKCl7ZSgpO30pLEZvdW5kYXRpb24uSUhlYXJZb3U9ZTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGkpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg8PTF8fHZvaWQgMD09PWFyZ3VtZW50c1sxXT97fTphcmd1bWVudHNbMV07X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD1pLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG4pLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIkFiaWRlXFxcIik7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kaW5wdXRzPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiaW5wdXQsIHRleHRhcmVhLCBzZWxlY3RcXFwiKSx0aGlzLl9ldmVudHMoKTt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7dGhpcy4kZWxlbWVudC5vZmYoXFxcIi5hYmlkZVxcXCIpLm9uKFxcXCJyZXNldC56Zi5hYmlkZVxcXCIsZnVuY3Rpb24oKXtlLnJlc2V0Rm9ybSgpO30pLm9uKFxcXCJzdWJtaXQuemYuYWJpZGVcXFwiLGZ1bmN0aW9uKCl7cmV0dXJuIGUudmFsaWRhdGVGb3JtKCk7fSksXFxcImZpZWxkQ2hhbmdlXFxcIj09PXRoaXMub3B0aW9ucy52YWxpZGF0ZU9uJiZ0aGlzLiRpbnB1dHMub2ZmKFxcXCJjaGFuZ2UuemYuYWJpZGVcXFwiKS5vbihcXFwiY2hhbmdlLnpmLmFiaWRlXFxcIixmdW5jdGlvbihpKXtlLnZhbGlkYXRlSW5wdXQodChpLnRhcmdldCkpO30pLHRoaXMub3B0aW9ucy5saXZlVmFsaWRhdGUmJnRoaXMuJGlucHV0cy5vZmYoXFxcImlucHV0LnpmLmFiaWRlXFxcIikub24oXFxcImlucHV0LnpmLmFiaWRlXFxcIixmdW5jdGlvbihpKXtlLnZhbGlkYXRlSW5wdXQodChpLnRhcmdldCkpO30pO319LHtrZXk6XFxcIl9yZWZsb3dcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy5faW5pdCgpO319LHtrZXk6XFxcInJlcXVpcmVkQ2hlY2tcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe2lmKCF0LmF0dHIoXFxcInJlcXVpcmVkXFxcIikpcmV0dXJuITA7dmFyIGU9ITA7c3dpdGNoKHRbMF0udHlwZSl7Y2FzZVxcXCJjaGVja2JveFxcXCI6ZT10WzBdLmNoZWNrZWQ7YnJlYWs7Y2FzZVxcXCJzZWxlY3RcXFwiOmNhc2VcXFwic2VsZWN0LW9uZVxcXCI6Y2FzZVxcXCJzZWxlY3QtbXVsdGlwbGVcXFwiOnZhciBpPXQuZmluZChcXFwib3B0aW9uOnNlbGVjdGVkXFxcIik7aS5sZW5ndGgmJmkudmFsKCl8fChlPSExKTticmVhaztkZWZhdWx0OnQudmFsKCkmJnQudmFsKCkubGVuZ3RofHwoZT0hMSk7fXJldHVybiBlO319LHtrZXk6XFxcImZpbmRGb3JtRXJyb3JcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3ZhciBlPXQuc2libGluZ3ModGhpcy5vcHRpb25zLmZvcm1FcnJvclNlbGVjdG9yKTtyZXR1cm4gZS5sZW5ndGh8fChlPXQucGFyZW50KCkuZmluZCh0aGlzLm9wdGlvbnMuZm9ybUVycm9yU2VsZWN0b3IpKSxlO319LHtrZXk6XFxcImZpbmRMYWJlbFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGU9dFswXS5pZCxpPXRoaXMuJGVsZW1lbnQuZmluZCgnbGFiZWxbZm9yPVxcXCInK2UrJ1xcXCJdJyk7cmV0dXJuIGkubGVuZ3RoP2k6dC5jbG9zZXN0KFxcXCJsYWJlbFxcXCIpO319LHtrZXk6XFxcImZpbmRSYWRpb0xhYmVsc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7dmFyIGk9dGhpcyxuPWUubWFwKGZ1bmN0aW9uKGUsbil7dmFyIHM9bi5pZCxvPWkuJGVsZW1lbnQuZmluZCgnbGFiZWxbZm9yPVxcXCInK3MrJ1xcXCJdJyk7cmV0dXJuIG8ubGVuZ3RofHwobz10KG4pLmNsb3Nlc3QoXFxcImxhYmVsXFxcIikpLG9bMF07fSk7cmV0dXJuIHQobik7fX0se2tleTpcXFwiYWRkRXJyb3JDbGFzc2VzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt2YXIgZT10aGlzLmZpbmRMYWJlbCh0KSxpPXRoaXMuZmluZEZvcm1FcnJvcih0KTtlLmxlbmd0aCYmZS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMubGFiZWxFcnJvckNsYXNzKSxpLmxlbmd0aCYmaS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuZm9ybUVycm9yQ2xhc3MpLHQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmlucHV0RXJyb3JDbGFzcykuYXR0cihcXFwiZGF0YS1pbnZhbGlkXFxcIixcXFwiXFxcIik7fX0se2tleTpcXFwicmVtb3ZlUmFkaW9FcnJvckNsYXNzZXNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3ZhciBlPXRoaXMuJGVsZW1lbnQuZmluZCgnOnJhZGlvW25hbWU9XFxcIicrdCsnXFxcIl0nKSxpPXRoaXMuZmluZFJhZGlvTGFiZWxzKGUpLG49dGhpcy5maW5kRm9ybUVycm9yKGUpO2kubGVuZ3RoJiZpLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5sYWJlbEVycm9yQ2xhc3MpLG4ubGVuZ3RoJiZuLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JDbGFzcyksZS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuaW5wdXRFcnJvckNsYXNzKS5yZW1vdmVBdHRyKFxcXCJkYXRhLWludmFsaWRcXFwiKTt9fSx7a2V5OlxcXCJyZW1vdmVFcnJvckNsYXNzZXNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe2lmKFxcXCJyYWRpb1xcXCI9PXRbMF0udHlwZSlyZXR1cm4gdGhpcy5yZW1vdmVSYWRpb0Vycm9yQ2xhc3Nlcyh0LmF0dHIoXFxcIm5hbWVcXFwiKSk7dmFyIGU9dGhpcy5maW5kTGFiZWwodCksaT10aGlzLmZpbmRGb3JtRXJyb3IodCk7ZS5sZW5ndGgmJmUucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmxhYmVsRXJyb3JDbGFzcyksaS5sZW5ndGgmJmkucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmZvcm1FcnJvckNsYXNzKSx0LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5pbnB1dEVycm9yQ2xhc3MpLnJlbW92ZUF0dHIoXFxcImRhdGEtaW52YWxpZFxcXCIpO319LHtrZXk6XFxcInZhbGlkYXRlSW5wdXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3ZhciBlPXRoaXMucmVxdWlyZWRDaGVjayh0KSxpPSExLG49ITAscz10LmF0dHIoXFxcImRhdGEtdmFsaWRhdG9yXFxcIiksbz0hMDtpZih0LmlzKFxcXCJbZGF0YS1hYmlkZS1pZ25vcmVdXFxcIil8fHQuaXMoJ1t0eXBlPVxcXCJoaWRkZW5cXFwiXScpKXJldHVybiEwO3N3aXRjaCh0WzBdLnR5cGUpe2Nhc2VcXFwicmFkaW9cXFwiOmk9dGhpcy52YWxpZGF0ZVJhZGlvKHQuYXR0cihcXFwibmFtZVxcXCIpKTticmVhaztjYXNlXFxcImNoZWNrYm94XFxcIjppPWU7YnJlYWs7Y2FzZVxcXCJzZWxlY3RcXFwiOmNhc2VcXFwic2VsZWN0LW9uZVxcXCI6Y2FzZVxcXCJzZWxlY3QtbXVsdGlwbGVcXFwiOmk9ZTticmVhaztkZWZhdWx0Omk9dGhpcy52YWxpZGF0ZVRleHQodCk7fXMmJihuPXRoaXMubWF0Y2hWYWxpZGF0aW9uKHQscyx0LmF0dHIoXFxcInJlcXVpcmVkXFxcIikpKSx0LmF0dHIoXFxcImRhdGEtZXF1YWx0b1xcXCIpJiYobz10aGlzLm9wdGlvbnMudmFsaWRhdG9ycy5lcXVhbFRvKHQpKTt2YXIgYT0tMT09PVtlLGksbixvXS5pbmRleE9mKCExKSxyPShhP1xcXCJ2YWxpZFxcXCI6XFxcImludmFsaWRcXFwiKStcXFwiLnpmLmFiaWRlXFxcIjtyZXR1cm4gdGhpc1thP1xcXCJyZW1vdmVFcnJvckNsYXNzZXNcXFwiOlxcXCJhZGRFcnJvckNsYXNzZXNcXFwiXSh0KSx0LnRyaWdnZXIocixbdF0pLGE7fX0se2tleTpcXFwidmFsaWRhdGVGb3JtXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPVtdLGk9dGhpczt0aGlzLiRpbnB1dHMuZWFjaChmdW5jdGlvbigpe2UucHVzaChpLnZhbGlkYXRlSW5wdXQodCh0aGlzKSkpO30pO3ZhciBuPS0xPT09ZS5pbmRleE9mKCExKTtyZXR1cm4gdGhpcy4kZWxlbWVudC5maW5kKFxcXCJbZGF0YS1hYmlkZS1lcnJvcl1cXFwiKS5jc3MoXFxcImRpc3BsYXlcXFwiLG4/XFxcIm5vbmVcXFwiOlxcXCJibG9ja1xcXCIpLHRoaXMuJGVsZW1lbnQudHJpZ2dlcigobj9cXFwiZm9ybXZhbGlkXFxcIjpcXFwiZm9ybWludmFsaWRcXFwiKStcXFwiLnpmLmFiaWRlXFxcIixbdGhpcy4kZWxlbWVudF0pLG47fX0se2tleTpcXFwidmFsaWRhdGVUZXh0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0LGUpe2U9ZXx8dC5hdHRyKFxcXCJwYXR0ZXJuXFxcIil8fHQuYXR0cihcXFwidHlwZVxcXCIpO3ZhciBpPXQudmFsKCksbj0hMTtyZXR1cm4gaS5sZW5ndGg/bj10aGlzLm9wdGlvbnMucGF0dGVybnMuaGFzT3duUHJvcGVydHkoZSk/dGhpcy5vcHRpb25zLnBhdHRlcm5zW2VdLnRlc3QoaSk6ZSE9PXQuYXR0cihcXFwidHlwZVxcXCIpP25ldyBSZWdFeHAoZSkudGVzdChpKTohMDp0LnByb3AoXFxcInJlcXVpcmVkXFxcIil8fChuPSEwKSxuO319LHtrZXk6XFxcInZhbGlkYXRlUmFkaW9cXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe3ZhciBpPXRoaXMuJGVsZW1lbnQuZmluZCgnOnJhZGlvW25hbWU9XFxcIicrZSsnXFxcIl0nKSxuPSExLHM9ITE7cmV0dXJuIGkuZWFjaChmdW5jdGlvbihlLGkpe3QoaSkuYXR0cihcXFwicmVxdWlyZWRcXFwiKSYmKHM9ITApO30pLHN8fChuPSEwKSxufHxpLmVhY2goZnVuY3Rpb24oZSxpKXt0KGkpLnByb3AoXFxcImNoZWNrZWRcXFwiKSYmKG49ITApO30pLG47fX0se2tleTpcXFwibWF0Y2hWYWxpZGF0aW9uXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0LGUsaSl7dmFyIG49dGhpcztpPSEhaTt2YXIgcz1lLnNwbGl0KFxcXCIgXFxcIikubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBuLm9wdGlvbnMudmFsaWRhdG9yc1tlXSh0LGksdC5wYXJlbnQoKSk7fSk7cmV0dXJuLTE9PT1zLmluZGV4T2YoITEpO319LHtrZXk6XFxcInJlc2V0Rm9ybVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzLiRlbGVtZW50LGk9dGhpcy5vcHRpb25zO3QoXFxcIi5cXFwiK2kubGFiZWxFcnJvckNsYXNzLGUpLm5vdChcXFwic21hbGxcXFwiKS5yZW1vdmVDbGFzcyhpLmxhYmVsRXJyb3JDbGFzcyksdChcXFwiLlxcXCIraS5pbnB1dEVycm9yQ2xhc3MsZSkubm90KFxcXCJzbWFsbFxcXCIpLnJlbW92ZUNsYXNzKGkuaW5wdXRFcnJvckNsYXNzKSx0KGkuZm9ybUVycm9yU2VsZWN0b3IrXFxcIi5cXFwiK2kuZm9ybUVycm9yQ2xhc3MpLnJlbW92ZUNsYXNzKGkuZm9ybUVycm9yQ2xhc3MpLGUuZmluZChcXFwiW2RhdGEtYWJpZGUtZXJyb3JdXFxcIikuY3NzKFxcXCJkaXNwbGF5XFxcIixcXFwibm9uZVxcXCIpLHQoXFxcIjppbnB1dFxcXCIsZSkubm90KFxcXCI6YnV0dG9uLCA6c3VibWl0LCA6cmVzZXQsIDpoaWRkZW4sIDpyYWRpbywgOmNoZWNrYm94LCBbZGF0YS1hYmlkZS1pZ25vcmVdXFxcIikudmFsKFxcXCJcXFwiKS5yZW1vdmVBdHRyKFxcXCJkYXRhLWludmFsaWRcXFwiKSx0KFxcXCI6aW5wdXQ6cmFkaW9cXFwiLGUpLm5vdChcXFwiW2RhdGEtYWJpZGUtaWdub3JlXVxcXCIpLnByb3AoXFxcImNoZWNrZWRcXFwiLCExKS5yZW1vdmVBdHRyKFxcXCJkYXRhLWludmFsaWRcXFwiKSx0KFxcXCI6aW5wdXQ6Y2hlY2tib3hcXFwiLGUpLm5vdChcXFwiW2RhdGEtYWJpZGUtaWdub3JlXVxcXCIpLnByb3AoXFxcImNoZWNrZWRcXFwiLCExKS5yZW1vdmVBdHRyKFxcXCJkYXRhLWludmFsaWRcXFwiKSxlLnRyaWdnZXIoXFxcImZvcm1yZXNldC56Zi5hYmlkZVxcXCIsW2VdKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7dGhpcy4kZWxlbWVudC5vZmYoXFxcIi5hYmlkZVxcXCIpLmZpbmQoXFxcIltkYXRhLWFiaWRlLWVycm9yXVxcXCIpLmNzcyhcXFwiZGlzcGxheVxcXCIsXFxcIm5vbmVcXFwiKSx0aGlzLiRpbnB1dHMub2ZmKFxcXCIuYWJpZGVcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7ZS5yZW1vdmVFcnJvckNsYXNzZXModCh0aGlzKSk7fSksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7ZS5kZWZhdWx0cz17dmFsaWRhdGVPbjpcXFwiZmllbGRDaGFuZ2VcXFwiLGxhYmVsRXJyb3JDbGFzczpcXFwiaXMtaW52YWxpZC1sYWJlbFxcXCIsaW5wdXRFcnJvckNsYXNzOlxcXCJpcy1pbnZhbGlkLWlucHV0XFxcIixmb3JtRXJyb3JTZWxlY3RvcjpcXFwiLmZvcm0tZXJyb3JcXFwiLGZvcm1FcnJvckNsYXNzOlxcXCJpcy12aXNpYmxlXFxcIixsaXZlVmFsaWRhdGU6ITEscGF0dGVybnM6e2FscGhhOi9eW2EtekEtWl0rJC8sYWxwaGFfbnVtZXJpYzovXlthLXpBLVowLTldKyQvLGludGVnZXI6L15bLStdP1xcXFxkKyQvLG51bWJlcjovXlstK10/XFxcXGQqKD86W1xcXFwuXFxcXCxdXFxcXGQrKT8kLyxjYXJkOi9eKD86NFswLTldezEyfSg/OlswLTldezN9KT98NVsxLTVdWzAtOV17MTR9fDYoPzowMTF8NVswLTldWzAtOV0pWzAtOV17MTJ9fDNbNDddWzAtOV17MTN9fDMoPzowWzAtNV18WzY4XVswLTldKVswLTldezExfXwoPzoyMTMxfDE4MDB8MzVcXFxcZHszfSlcXFxcZHsxMX0pJC8sY3Z2Oi9eKFswLTldKXszLDR9JC8sZW1haWw6L15bYS16QS1aMC05LiEjJCUmJyorXFxcXC89P15fYHt8fX4tXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFxcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKyQvLHVybDovXihodHRwcz98ZnRwfGZpbGV8c3NoKTpcXFxcL1xcXFwvKCgoKFthLXpBLVpdfFxcXFxkfC18XFxcXC58X3x+fFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKXwoJVtcXFxcZGEtZl17Mn0pfFshXFxcXCQmJ1xcXFwoXFxcXClcXFxcKlxcXFwrLDs9XXw6KSpAKT8oKChcXFxcZHxbMS05XVxcXFxkfDFcXFxcZFxcXFxkfDJbMC00XVxcXFxkfDI1WzAtNV0pXFxcXC4oXFxcXGR8WzEtOV1cXFxcZHwxXFxcXGRcXFxcZHwyWzAtNF1cXFxcZHwyNVswLTVdKVxcXFwuKFxcXFxkfFsxLTldXFxcXGR8MVxcXFxkXFxcXGR8MlswLTRdXFxcXGR8MjVbMC01XSlcXFxcLihcXFxcZHxbMS05XVxcXFxkfDFcXFxcZFxcXFxkfDJbMC00XVxcXFxkfDI1WzAtNV0pKXwoKChbYS16QS1aXXxcXFxcZHxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSl8KChbYS16QS1aXXxcXFxcZHxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSkoW2EtekEtWl18XFxcXGR8LXxcXFxcLnxffH58W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pKihbYS16QS1aXXxcXFxcZHxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSkpKVxcXFwuKSsoKFthLXpBLVpdfFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKXwoKFthLXpBLVpdfFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKShbYS16QS1aXXxcXFxcZHwtfFxcXFwufF98fnxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSkqKFthLXpBLVpdfFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKSkpXFxcXC4/KSg6XFxcXGQqKT8pKFxcXFwvKCgoW2EtekEtWl18XFxcXGR8LXxcXFxcLnxffH58W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pfCglW1xcXFxkYS1mXXsyfSl8WyFcXFxcJCYnXFxcXChcXFxcKVxcXFwqXFxcXCssOz1dfDp8QCkrKFxcXFwvKChbYS16QS1aXXxcXFxcZHwtfFxcXFwufF98fnxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSl8KCVbXFxcXGRhLWZdezJ9KXxbIVxcXFwkJidcXFxcKFxcXFwpXFxcXCpcXFxcKyw7PV18OnxAKSopKik/KT8oXFxcXD8oKChbYS16QS1aXXxcXFxcZHwtfFxcXFwufF98fnxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSl8KCVbXFxcXGRhLWZdezJ9KXxbIVxcXFwkJidcXFxcKFxcXFwpXFxcXCpcXFxcKyw7PV18OnxAKXxbXFxcXHVFMDAwLVxcXFx1RjhGRl18XFxcXC98XFxcXD8pKik/KFxcXFwjKCgoW2EtekEtWl18XFxcXGR8LXxcXFxcLnxffH58W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pfCglW1xcXFxkYS1mXXsyfSl8WyFcXFxcJCYnXFxcXChcXFxcKVxcXFwqXFxcXCssOz1dfDp8QCl8XFxcXC98XFxcXD8pKik/JC8sZG9tYWluOi9eKFthLXpBLVowLTldKFthLXpBLVowLTlcXFxcLV17MCw2MX1bYS16QS1aMC05XSk/XFxcXC4pK1thLXpBLVpdezIsOH0kLyxkYXRldGltZTovXihbMC0yXVswLTldezN9KVxcXFwtKFswLTFdWzAtOV0pXFxcXC0oWzAtM11bMC05XSlUKFswLTVdWzAtOV0pXFxcXDooWzAtNV1bMC05XSlcXFxcOihbMC01XVswLTldKShafChbXFxcXC1cXFxcK10oWzAtMV1bMC05XSlcXFxcOjAwKSkkLyxkYXRlOi8oPzoxOXwyMClbMC05XXsyfS0oPzooPzowWzEtOV18MVswLTJdKS0oPzowWzEtOV18MVswLTldfDJbMC05XSl8KD86KD8hMDIpKD86MFsxLTldfDFbMC0yXSktKD86MzApKXwoPzooPzowWzEzNTc4XXwxWzAyXSktMzEpKSQvLHRpbWU6L14oMFswLTldfDFbMC05XXwyWzAtM10pKDpbMC01XVswLTldKXsyfSQvLGRhdGVJU086L15cXFxcZHs0fVtcXFxcL1xcXFwtXVxcXFxkezEsMn1bXFxcXC9cXFxcLV1cXFxcZHsxLDJ9JC8sbW9udGhfZGF5X3llYXI6L14oMFsxLTldfDFbMDEyXSlbLSBcXFxcLy5dKDBbMS05XXxbMTJdWzAtOV18M1swMV0pWy0gXFxcXC8uXVxcXFxkezR9JC8sZGF5X21vbnRoX3llYXI6L14oMFsxLTldfFsxMl1bMC05XXwzWzAxXSlbLSBcXFxcLy5dKDBbMS05XXwxWzAxMl0pWy0gXFxcXC8uXVxcXFxkezR9JC8sY29sb3I6L14jPyhbYS1mQS1GMC05XXs2fXxbYS1mQS1GMC05XXszfSkkL30sdmFsaWRhdG9yczp7ZXF1YWxUbzpmdW5jdGlvbiBlcXVhbFRvKGUsaSxuKXtyZXR1cm4gdChcXFwiI1xcXCIrZS5hdHRyKFxcXCJkYXRhLWVxdWFsdG9cXFwiKSkudmFsKCk9PT1lLnZhbCgpO319fSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJBYmlkZVxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiQWNjb3JkaW9uXFxcIiksRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcihcXFwiQWNjb3JkaW9uXFxcIix7RU5URVI6XFxcInRvZ2dsZVxcXCIsU1BBQ0U6XFxcInRvZ2dsZVxcXCIsQVJST1dfRE9XTjpcXFwibmV4dFxcXCIsQVJST1dfVVA6XFxcInByZXZpb3VzXFxcIn0pO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuJGVsZW1lbnQuYXR0cihcXFwicm9sZVxcXCIsXFxcInRhYmxpc3RcXFwiKSx0aGlzLiR0YWJzPXRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oXFxcImxpLCBbZGF0YS1hY2NvcmRpb24taXRlbV1cXFwiKSx0aGlzLiR0YWJzLmVhY2goZnVuY3Rpb24oZSxpKXt2YXIgbj10KGkpLHM9bi5jaGlsZHJlbihcXFwiW2RhdGEtdGFiLWNvbnRlbnRdXFxcIiksbz1zWzBdLmlkfHxGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsXFxcImFjY29yZGlvblxcXCIpLGE9aS5pZHx8bytcXFwiLWxhYmVsXFxcIjtuLmZpbmQoXFxcImE6Zmlyc3RcXFwiKS5hdHRyKHtcXFwiYXJpYS1jb250cm9sc1xcXCI6byxyb2xlOlxcXCJ0YWJcXFwiLGlkOmEsXFxcImFyaWEtZXhwYW5kZWRcXFwiOiExLFxcXCJhcmlhLXNlbGVjdGVkXFxcIjohMX0pLHMuYXR0cih7cm9sZTpcXFwidGFicGFuZWxcXFwiLFxcXCJhcmlhLWxhYmVsbGVkYnlcXFwiOmEsXFxcImFyaWEtaGlkZGVuXFxcIjohMCxpZDpvfSk7fSk7dmFyIGU9dGhpcy4kZWxlbWVudC5maW5kKFxcXCIuaXMtYWN0aXZlXFxcIikuY2hpbGRyZW4oXFxcIltkYXRhLXRhYi1jb250ZW50XVxcXCIpO2UubGVuZ3RoJiZ0aGlzLmRvd24oZSwhMCksdGhpcy5fZXZlbnRzKCk7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzO3RoaXMuJHRhYnMuZWFjaChmdW5jdGlvbigpe3ZhciBpPXQodGhpcyksbj1pLmNoaWxkcmVuKFxcXCJbZGF0YS10YWItY29udGVudF1cXFwiKTtuLmxlbmd0aCYmaS5jaGlsZHJlbihcXFwiYVxcXCIpLm9mZihcXFwiY2xpY2suemYuYWNjb3JkaW9uIGtleWRvd24uemYuYWNjb3JkaW9uXFxcIikub24oXFxcImNsaWNrLnpmLmFjY29yZGlvblxcXCIsZnVuY3Rpb24odCl7dC5wcmV2ZW50RGVmYXVsdCgpLGkuaGFzQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpPyhlLm9wdGlvbnMuYWxsb3dBbGxDbG9zZWR8fGkuc2libGluZ3MoKS5oYXNDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIikpJiZlLnVwKG4pOmUuZG93bihuKTt9KS5vbihcXFwia2V5ZG93bi56Zi5hY2NvcmRpb25cXFwiLGZ1bmN0aW9uKHQpe0ZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KHQsXFxcIkFjY29yZGlvblxcXCIse3RvZ2dsZTpmdW5jdGlvbiB0b2dnbGUoKXtlLnRvZ2dsZShuKTt9LG5leHQ6ZnVuY3Rpb24gbmV4dCgpe3ZhciB0PWkubmV4dCgpLmZpbmQoXFxcImFcXFwiKS5mb2N1cygpO2Uub3B0aW9ucy5tdWx0aUV4cGFuZHx8dC50cmlnZ2VyKFxcXCJjbGljay56Zi5hY2NvcmRpb25cXFwiKTt9LHByZXZpb3VzOmZ1bmN0aW9uIHByZXZpb3VzKCl7dmFyIHQ9aS5wcmV2KCkuZmluZChcXFwiYVxcXCIpLmZvY3VzKCk7ZS5vcHRpb25zLm11bHRpRXhwYW5kfHx0LnRyaWdnZXIoXFxcImNsaWNrLnpmLmFjY29yZGlvblxcXCIpO30saGFuZGxlZDpmdW5jdGlvbiBoYW5kbGVkKCl7dC5wcmV2ZW50RGVmYXVsdCgpLHQuc3RvcFByb3BhZ2F0aW9uKCk7fX0pO30pO30pO319LHtrZXk6XFxcInRvZ2dsZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7aWYodC5wYXJlbnQoKS5oYXNDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIikpe2lmKCF0aGlzLm9wdGlvbnMuYWxsb3dBbGxDbG9zZWQmJiF0LnBhcmVudCgpLnNpYmxpbmdzKCkuaGFzQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpKXJldHVybjt0aGlzLnVwKHQpO31lbHNlIHRoaXMuZG93bih0KTt9fSx7a2V5OlxcXCJkb3duXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlLGkpe3ZhciBuPXRoaXM7aWYoIXRoaXMub3B0aW9ucy5tdWx0aUV4cGFuZCYmIWkpe3ZhciBzPXRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oXFxcIi5pcy1hY3RpdmVcXFwiKS5jaGlsZHJlbihcXFwiW2RhdGEtdGFiLWNvbnRlbnRdXFxcIik7cy5sZW5ndGgmJnRoaXMudXAocyk7fWUuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLCExKS5wYXJlbnQoXFxcIltkYXRhLXRhYi1jb250ZW50XVxcXCIpLmFkZEJhY2soKS5wYXJlbnQoKS5hZGRDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIiksZS5zbGlkZURvd24odGhpcy5vcHRpb25zLnNsaWRlU3BlZWQsZnVuY3Rpb24oKXtuLiRlbGVtZW50LnRyaWdnZXIoXFxcImRvd24uemYuYWNjb3JkaW9uXFxcIixbZV0pO30pLHQoXFxcIiNcXFwiK2UuYXR0cihcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIikpLmF0dHIoe1xcXCJhcmlhLWV4cGFuZGVkXFxcIjohMCxcXFwiYXJpYS1zZWxlY3RlZFxcXCI6ITB9KTt9fSx7a2V5OlxcXCJ1cFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7dmFyIGk9ZS5wYXJlbnQoKS5zaWJsaW5ncygpLG49dGhpcyxzPXRoaXMub3B0aW9ucy5tdWx0aUV4cGFuZD9pLmhhc0NsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKTplLnBhcmVudCgpLmhhc0NsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKTsodGhpcy5vcHRpb25zLmFsbG93QWxsQ2xvc2VkfHxzKSYmKGUuc2xpZGVVcChuLm9wdGlvbnMuc2xpZGVTcGVlZCxmdW5jdGlvbigpe24uJGVsZW1lbnQudHJpZ2dlcihcXFwidXAuemYuYWNjb3JkaW9uXFxcIixbZV0pO30pLGUuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLCEwKS5wYXJlbnQoKS5yZW1vdmVDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIiksdChcXFwiI1xcXCIrZS5hdHRyKFxcXCJhcmlhLWxhYmVsbGVkYnlcXFwiKSkuYXR0cih7XFxcImFyaWEtZXhwYW5kZWRcXFwiOiExLFxcXCJhcmlhLXNlbGVjdGVkXFxcIjohMX0pKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuJGVsZW1lbnQuZmluZChcXFwiW2RhdGEtdGFiLWNvbnRlbnRdXFxcIikuc3RvcCghMCkuc2xpZGVVcCgwKS5jc3MoXFxcImRpc3BsYXlcXFwiLFxcXCJcXFwiKSx0aGlzLiRlbGVtZW50LmZpbmQoXFxcImFcXFwiKS5vZmYoXFxcIi56Zi5hY2NvcmRpb25cXFwiKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXtzbGlkZVNwZWVkOjI1MCxtdWx0aUV4cGFuZDohMSxhbGxvd0FsbENsb3NlZDohMX0sRm91bmRhdGlvbi5wbHVnaW4oZSxcXFwiQWNjb3JkaW9uXFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9aSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxuKSxGb3VuZGF0aW9uLk5lc3QuRmVhdGhlcih0aGlzLiRlbGVtZW50LFxcXCJhY2NvcmRpb25cXFwiKSx0aGlzLl9pbml0KCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFxcXCJBY2NvcmRpb25NZW51XFxcIiksRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcihcXFwiQWNjb3JkaW9uTWVudVxcXCIse0VOVEVSOlxcXCJ0b2dnbGVcXFwiLFNQQUNFOlxcXCJ0b2dnbGVcXFwiLEFSUk9XX1JJR0hUOlxcXCJvcGVuXFxcIixBUlJPV19VUDpcXFwidXBcXFwiLEFSUk9XX0RPV046XFxcImRvd25cXFwiLEFSUk9XX0xFRlQ6XFxcImNsb3NlXFxcIixFU0NBUEU6XFxcImNsb3NlQWxsXFxcIixUQUI6XFxcImRvd25cXFwiLFNISUZUX1RBQjpcXFwidXBcXFwifSk7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kZWxlbWVudC5maW5kKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpLm5vdChcXFwiLmlzLWFjdGl2ZVxcXCIpLnNsaWRlVXAoMCksdGhpcy4kZWxlbWVudC5hdHRyKHtyb2xlOlxcXCJ0YWJsaXN0XFxcIixcXFwiYXJpYS1tdWx0aXNlbGVjdGFibGVcXFwiOnRoaXMub3B0aW9ucy5tdWx0aU9wZW59KSx0aGlzLiRtZW51TGlua3M9dGhpcy4kZWxlbWVudC5maW5kKFxcXCIuaXMtYWNjb3JkaW9uLXN1Ym1lbnUtcGFyZW50XFxcIiksdGhpcy4kbWVudUxpbmtzLmVhY2goZnVuY3Rpb24oKXt2YXIgZT10aGlzLmlkfHxGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsXFxcImFjYy1tZW51LWxpbmtcXFwiKSxpPXQodGhpcyksbj1pLmNoaWxkcmVuKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpLHM9blswXS5pZHx8Rm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LFxcXCJhY2MtbWVudVxcXCIpLG89bi5oYXNDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIik7aS5hdHRyKHtcXFwiYXJpYS1jb250cm9sc1xcXCI6cyxcXFwiYXJpYS1leHBhbmRlZFxcXCI6byxyb2xlOlxcXCJ0YWJcXFwiLGlkOmV9KSxuLmF0dHIoe1xcXCJhcmlhLWxhYmVsbGVkYnlcXFwiOmUsXFxcImFyaWEtaGlkZGVuXFxcIjohbyxyb2xlOlxcXCJ0YWJwYW5lbFxcXCIsaWQ6c30pO30pO3ZhciBlPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLmlzLWFjdGl2ZVxcXCIpO2lmKGUubGVuZ3RoKXt2YXIgaT10aGlzO2UuZWFjaChmdW5jdGlvbigpe2kuZG93bih0KHRoaXMpKTt9KTt9dGhpcy5fZXZlbnRzKCk7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzO3RoaXMuJGVsZW1lbnQuZmluZChcXFwibGlcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIGk9dCh0aGlzKS5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV1cXFwiKTtpLmxlbmd0aCYmdCh0aGlzKS5jaGlsZHJlbihcXFwiYVxcXCIpLm9mZihcXFwiY2xpY2suemYuYWNjb3JkaW9uTWVudVxcXCIpLm9uKFxcXCJjbGljay56Zi5hY2NvcmRpb25NZW51XFxcIixmdW5jdGlvbih0KXt0LnByZXZlbnREZWZhdWx0KCksZS50b2dnbGUoaSk7fSk7fSkub24oXFxcImtleWRvd24uemYuYWNjb3JkaW9ubWVudVxcXCIsZnVuY3Rpb24oaSl7dmFyIG4scyxvPXQodGhpcyksYT1vLnBhcmVudChcXFwidWxcXFwiKS5jaGlsZHJlbihcXFwibGlcXFwiKSxyPW8uY2hpbGRyZW4oXFxcIltkYXRhLXN1Ym1lbnVdXFxcIik7YS5lYWNoKGZ1bmN0aW9uKGUpe3JldHVybiB0KHRoaXMpLmlzKG8pPyhuPWEuZXEoTWF0aC5tYXgoMCxlLTEpKS5maW5kKFxcXCJhXFxcIikuZmlyc3QoKSxzPWEuZXEoTWF0aC5taW4oZSsxLGEubGVuZ3RoLTEpKS5maW5kKFxcXCJhXFxcIikuZmlyc3QoKSx0KHRoaXMpLmNoaWxkcmVuKFxcXCJbZGF0YS1zdWJtZW51XTp2aXNpYmxlXFxcIikubGVuZ3RoJiYocz1vLmZpbmQoXFxcImxpOmZpcnN0LWNoaWxkXFxcIikuZmluZChcXFwiYVxcXCIpLmZpcnN0KCkpLHQodGhpcykuaXMoXFxcIjpmaXJzdC1jaGlsZFxcXCIpP249by5wYXJlbnRzKFxcXCJsaVxcXCIpLmZpcnN0KCkuZmluZChcXFwiYVxcXCIpLmZpcnN0KCk6bi5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV06dmlzaWJsZVxcXCIpLmxlbmd0aCYmKG49bi5maW5kKFxcXCJsaTpsYXN0LWNoaWxkXFxcIikuZmluZChcXFwiYVxcXCIpLmZpcnN0KCkpLHZvaWQodCh0aGlzKS5pcyhcXFwiOmxhc3QtY2hpbGRcXFwiKSYmKHM9by5wYXJlbnRzKFxcXCJsaVxcXCIpLmZpcnN0KCkubmV4dChcXFwibGlcXFwiKS5maW5kKFxcXCJhXFxcIikuZmlyc3QoKSkpKTp2b2lkIDA7fSksRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoaSxcXFwiQWNjb3JkaW9uTWVudVxcXCIse29wZW46ZnVuY3Rpb24gb3Blbigpe3IuaXMoXFxcIjpoaWRkZW5cXFwiKSYmKGUuZG93bihyKSxyLmZpbmQoXFxcImxpXFxcIikuZmlyc3QoKS5maW5kKFxcXCJhXFxcIikuZmlyc3QoKS5mb2N1cygpKTt9LGNsb3NlOmZ1bmN0aW9uIGNsb3NlKCl7ci5sZW5ndGgmJiFyLmlzKFxcXCI6aGlkZGVuXFxcIik/ZS51cChyKTpvLnBhcmVudChcXFwiW2RhdGEtc3VibWVudV1cXFwiKS5sZW5ndGgmJihlLnVwKG8ucGFyZW50KFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpKSxvLnBhcmVudHMoXFxcImxpXFxcIikuZmlyc3QoKS5maW5kKFxcXCJhXFxcIikuZmlyc3QoKS5mb2N1cygpKTt9LHVwOmZ1bmN0aW9uIHVwKCl7cmV0dXJuIG4uYXR0cihcXFwidGFiaW5kZXhcXFwiLC0xKS5mb2N1cygpLCEwO30sZG93bjpmdW5jdGlvbiBkb3duKCl7cmV0dXJuIHMuYXR0cihcXFwidGFiaW5kZXhcXFwiLC0xKS5mb2N1cygpLCEwO30sdG9nZ2xlOmZ1bmN0aW9uIHRvZ2dsZSgpe28uY2hpbGRyZW4oXFxcIltkYXRhLXN1Ym1lbnVdXFxcIikubGVuZ3RoJiZlLnRvZ2dsZShvLmNoaWxkcmVuKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpKTt9LGNsb3NlQWxsOmZ1bmN0aW9uIGNsb3NlQWxsKCl7ZS5oaWRlQWxsKCk7fSxoYW5kbGVkOmZ1bmN0aW9uIGhhbmRsZWQodCl7dCYmaS5wcmV2ZW50RGVmYXVsdCgpLGkuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7fX0pO30pO319LHtrZXk6XFxcImhpZGVBbGxcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kZWxlbWVudC5maW5kKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpLnNsaWRlVXAodGhpcy5vcHRpb25zLnNsaWRlU3BlZWQpO319LHtrZXk6XFxcInRvZ2dsZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dC5pcyhcXFwiOmFuaW1hdGVkXFxcIil8fCh0LmlzKFxcXCI6aGlkZGVuXFxcIik/dGhpcy5kb3duKHQpOnRoaXMudXAodCkpO319LHtrZXk6XFxcImRvd25cXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3ZhciBlPXRoaXM7dGhpcy5vcHRpb25zLm11bHRpT3Blbnx8dGhpcy51cCh0aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5pcy1hY3RpdmVcXFwiKS5ub3QodC5wYXJlbnRzVW50aWwodGhpcy4kZWxlbWVudCkuYWRkKHQpKSksdC5hZGRDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIikuYXR0cih7XFxcImFyaWEtaGlkZGVuXFxcIjohMX0pLnBhcmVudChcXFwiLmlzLWFjY29yZGlvbi1zdWJtZW51LXBhcmVudFxcXCIpLmF0dHIoe1xcXCJhcmlhLWV4cGFuZGVkXFxcIjohMH0pLHQuc2xpZGVEb3duKGUub3B0aW9ucy5zbGlkZVNwZWVkLGZ1bmN0aW9uKCl7ZS4kZWxlbWVudC50cmlnZ2VyKFxcXCJkb3duLnpmLmFjY29yZGlvbk1lbnVcXFwiLFt0XSk7fSk7fX0se2tleTpcXFwidXBcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3ZhciBlPXRoaXM7dC5zbGlkZVVwKGUub3B0aW9ucy5zbGlkZVNwZWVkLGZ1bmN0aW9uKCl7ZS4kZWxlbWVudC50cmlnZ2VyKFxcXCJ1cC56Zi5hY2NvcmRpb25NZW51XFxcIixbdF0pO30pO3ZhciBpPXQuZmluZChcXFwiW2RhdGEtc3VibWVudV1cXFwiKS5zbGlkZVVwKDApLmFkZEJhY2soKS5hdHRyKFxcXCJhcmlhLWhpZGRlblxcXCIsITApO2kucGFyZW50KFxcXCIuaXMtYWNjb3JkaW9uLXN1Ym1lbnUtcGFyZW50XFxcIikuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsITEpO319LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kZWxlbWVudC5maW5kKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpLnNsaWRlRG93bigwKS5jc3MoXFxcImRpc3BsYXlcXFwiLFxcXCJcXFwiKSx0aGlzLiRlbGVtZW50LmZpbmQoXFxcImFcXFwiKS5vZmYoXFxcImNsaWNrLnpmLmFjY29yZGlvbk1lbnVcXFwiKSxGb3VuZGF0aW9uLk5lc3QuQnVybih0aGlzLiRlbGVtZW50LFxcXCJhY2NvcmRpb25cXFwiKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXtzbGlkZVNwZWVkOjI1MCxtdWx0aU9wZW46ITB9LEZvdW5kYXRpb24ucGx1Z2luKGUsXFxcIkFjY29yZGlvbk1lbnVcXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD1pLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG4pLEZvdW5kYXRpb24uTmVzdC5GZWF0aGVyKHRoaXMuJGVsZW1lbnQsXFxcImRyaWxsZG93blxcXCIpLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIkRyaWxsZG93blxcXCIpLEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoXFxcIkRyaWxsZG93blxcXCIse0VOVEVSOlxcXCJvcGVuXFxcIixTUEFDRTpcXFwib3BlblxcXCIsQVJST1dfUklHSFQ6XFxcIm5leHRcXFwiLEFSUk9XX1VQOlxcXCJ1cFxcXCIsQVJST1dfRE9XTjpcXFwiZG93blxcXCIsQVJST1dfTEVGVDpcXFwicHJldmlvdXNcXFwiLEVTQ0FQRTpcXFwiY2xvc2VcXFwiLFRBQjpcXFwiZG93blxcXCIsU0hJRlRfVEFCOlxcXCJ1cFxcXCJ9KTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRzdWJtZW51QW5jaG9ycz10aGlzLiRlbGVtZW50LmZpbmQoXFxcImxpLmlzLWRyaWxsZG93bi1zdWJtZW51LXBhcmVudFxcXCIpLmNoaWxkcmVuKFxcXCJhXFxcIiksdGhpcy4kc3VibWVudXM9dGhpcy4kc3VibWVudUFuY2hvcnMucGFyZW50KFxcXCJsaVxcXCIpLmNoaWxkcmVuKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpLHRoaXMuJG1lbnVJdGVtcz10aGlzLiRlbGVtZW50LmZpbmQoXFxcImxpXFxcIikubm90KFxcXCIuanMtZHJpbGxkb3duLWJhY2tcXFwiKS5hdHRyKFxcXCJyb2xlXFxcIixcXFwibWVudWl0ZW1cXFwiKS5maW5kKFxcXCJhXFxcIiksdGhpcy5fcHJlcGFyZU1lbnUoKSx0aGlzLl9rZXlib2FyZEV2ZW50cygpO319LHtrZXk6XFxcIl9wcmVwYXJlTWVudVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzO3RoaXMuJHN1Ym1lbnVBbmNob3JzLmVhY2goZnVuY3Rpb24oKXt2YXIgaT10KHRoaXMpLG49aS5wYXJlbnQoKTtlLm9wdGlvbnMucGFyZW50TGluayYmaS5jbG9uZSgpLnByZXBlbmRUbyhuLmNoaWxkcmVuKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpKS53cmFwKCc8bGkgY2xhc3M9XFxcImlzLXN1Ym1lbnUtcGFyZW50LWl0ZW0gaXMtc3VibWVudS1pdGVtIGlzLWRyaWxsZG93bi1zdWJtZW51LWl0ZW1cXFwiIHJvbGU9XFxcIm1lbnUtaXRlbVxcXCI+PC9saT4nKSxpLmRhdGEoXFxcInNhdmVkSHJlZlxcXCIsaS5hdHRyKFxcXCJocmVmXFxcIikpLnJlbW92ZUF0dHIoXFxcImhyZWZcXFwiKSxpLmNoaWxkcmVuKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpLmF0dHIoe1xcXCJhcmlhLWhpZGRlblxcXCI6ITAsdGFiaW5kZXg6MCxyb2xlOlxcXCJtZW51XFxcIn0pLGUuX2V2ZW50cyhpKTt9KSx0aGlzLiRzdWJtZW51cy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGk9dCh0aGlzKSxuPWkuZmluZChcXFwiLmpzLWRyaWxsZG93bi1iYWNrXFxcIik7bi5sZW5ndGh8fGkucHJlcGVuZChlLm9wdGlvbnMuYmFja0J1dHRvbiksZS5fYmFjayhpKTt9KSx0aGlzLiRlbGVtZW50LnBhcmVudCgpLmhhc0NsYXNzKFxcXCJpcy1kcmlsbGRvd25cXFwiKXx8KHRoaXMuJHdyYXBwZXI9dCh0aGlzLm9wdGlvbnMud3JhcHBlcikuYWRkQ2xhc3MoXFxcImlzLWRyaWxsZG93blxcXCIpLHRoaXMuJHdyYXBwZXI9dGhpcy4kZWxlbWVudC53cmFwKHRoaXMuJHdyYXBwZXIpLnBhcmVudCgpLmNzcyh0aGlzLl9nZXRNYXhEaW1zKCkpKTt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXt2YXIgaT10aGlzO2Uub2ZmKFxcXCJjbGljay56Zi5kcmlsbGRvd25cXFwiKS5vbihcXFwiY2xpY2suemYuZHJpbGxkb3duXFxcIixmdW5jdGlvbihuKXtpZih0KG4udGFyZ2V0KS5wYXJlbnRzVW50aWwoXFxcInVsXFxcIixcXFwibGlcXFwiKS5oYXNDbGFzcyhcXFwiaXMtZHJpbGxkb3duLXN1Ym1lbnUtcGFyZW50XFxcIikmJihuLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLG4ucHJldmVudERlZmF1bHQoKSksaS5fc2hvdyhlLnBhcmVudChcXFwibGlcXFwiKSksaS5vcHRpb25zLmNsb3NlT25DbGljayl7dmFyIHM9dChcXFwiYm9keVxcXCIpO3Mub2ZmKFxcXCIuemYuZHJpbGxkb3duXFxcIikub24oXFxcImNsaWNrLnpmLmRyaWxsZG93blxcXCIsZnVuY3Rpb24oZSl7ZS50YXJnZXQ9PT1pLiRlbGVtZW50WzBdfHx0LmNvbnRhaW5zKGkuJGVsZW1lbnRbMF0sZS50YXJnZXQpfHwoZS5wcmV2ZW50RGVmYXVsdCgpLGkuX2hpZGVBbGwoKSxzLm9mZihcXFwiLnpmLmRyaWxsZG93blxcXCIpKTt9KTt9fSk7fX0se2tleTpcXFwiX2tleWJvYXJkRXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7dGhpcy4kbWVudUl0ZW1zLmFkZCh0aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5qcy1kcmlsbGRvd24tYmFjayA+IGFcXFwiKSkub24oXFxcImtleWRvd24uemYuZHJpbGxkb3duXFxcIixmdW5jdGlvbihpKXt2YXIgbixzLG89dCh0aGlzKSxhPW8ucGFyZW50KFxcXCJsaVxcXCIpLnBhcmVudChcXFwidWxcXFwiKS5jaGlsZHJlbihcXFwibGlcXFwiKS5jaGlsZHJlbihcXFwiYVxcXCIpO2EuZWFjaChmdW5jdGlvbihlKXtyZXR1cm4gdCh0aGlzKS5pcyhvKT8obj1hLmVxKE1hdGgubWF4KDAsZS0xKSksdm9pZChzPWEuZXEoTWF0aC5taW4oZSsxLGEubGVuZ3RoLTEpKSkpOnZvaWQgMDt9KSxGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShpLFxcXCJEcmlsbGRvd25cXFwiLHtuZXh0OmZ1bmN0aW9uIG5leHQoKXtyZXR1cm4gby5pcyhlLiRzdWJtZW51QW5jaG9ycyk/KGUuX3Nob3coby5wYXJlbnQoXFxcImxpXFxcIikpLG8ucGFyZW50KFxcXCJsaVxcXCIpLm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQobyksZnVuY3Rpb24oKXtvLnBhcmVudChcXFwibGlcXFwiKS5maW5kKFxcXCJ1bCBsaSBhXFxcIikuZmlsdGVyKGUuJG1lbnVJdGVtcykuZmlyc3QoKS5mb2N1cygpO30pLCEwKTp2b2lkIDA7fSxwcmV2aW91czpmdW5jdGlvbiBwcmV2aW91cygpe3JldHVybiBlLl9oaWRlKG8ucGFyZW50KFxcXCJsaVxcXCIpLnBhcmVudChcXFwidWxcXFwiKSksby5wYXJlbnQoXFxcImxpXFxcIikucGFyZW50KFxcXCJ1bFxcXCIpLm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQobyksZnVuY3Rpb24oKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7by5wYXJlbnQoXFxcImxpXFxcIikucGFyZW50KFxcXCJ1bFxcXCIpLnBhcmVudChcXFwibGlcXFwiKS5jaGlsZHJlbihcXFwiYVxcXCIpLmZpcnN0KCkuZm9jdXMoKTt9LDEpO30pLCEwO30sdXA6ZnVuY3Rpb24gdXAoKXtyZXR1cm4gbi5mb2N1cygpLCEwO30sZG93bjpmdW5jdGlvbiBkb3duKCl7cmV0dXJuIHMuZm9jdXMoKSwhMDt9LGNsb3NlOmZ1bmN0aW9uIGNsb3NlKCl7ZS5fYmFjaygpO30sb3BlbjpmdW5jdGlvbiBvcGVuKCl7cmV0dXJuIG8uaXMoZS4kbWVudUl0ZW1zKT9vLmlzKGUuJHN1Ym1lbnVBbmNob3JzKSYmKGUuX3Nob3coby5wYXJlbnQoXFxcImxpXFxcIikpLG8ucGFyZW50KFxcXCJsaVxcXCIpLm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQobyksZnVuY3Rpb24oKXtvLnBhcmVudChcXFwibGlcXFwiKS5maW5kKFxcXCJ1bCBsaSBhXFxcIikuZmlsdGVyKGUuJG1lbnVJdGVtcykuZmlyc3QoKS5mb2N1cygpO30pKTooZS5faGlkZShvLnBhcmVudChcXFwibGlcXFwiKS5wYXJlbnQoXFxcInVsXFxcIikpLG8ucGFyZW50KFxcXCJsaVxcXCIpLnBhcmVudChcXFwidWxcXFwiKS5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKG8pLGZ1bmN0aW9uKCl7c2V0VGltZW91dChmdW5jdGlvbigpe28ucGFyZW50KFxcXCJsaVxcXCIpLnBhcmVudChcXFwidWxcXFwiKS5wYXJlbnQoXFxcImxpXFxcIikuY2hpbGRyZW4oXFxcImFcXFwiKS5maXJzdCgpLmZvY3VzKCk7fSwxKTt9KSksITA7fSxoYW5kbGVkOmZ1bmN0aW9uIGhhbmRsZWQodCl7dCYmaS5wcmV2ZW50RGVmYXVsdCgpLGkuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7fX0pO30pO319LHtrZXk6XFxcIl9oaWRlQWxsXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciB0PXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLmlzLWRyaWxsZG93bi1zdWJtZW51LmlzLWFjdGl2ZVxcXCIpLmFkZENsYXNzKFxcXCJpcy1jbG9zaW5nXFxcIik7dC5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKHQpLGZ1bmN0aW9uKGUpe3QucmVtb3ZlQ2xhc3MoXFxcImlzLWFjdGl2ZSBpcy1jbG9zaW5nXFxcIik7fSksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJjbG9zZWQuemYuZHJpbGxkb3duXFxcIik7fX0se2tleTpcXFwiX2JhY2tcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3ZhciBlPXRoaXM7dC5vZmYoXFxcImNsaWNrLnpmLmRyaWxsZG93blxcXCIpLHQuY2hpbGRyZW4oXFxcIi5qcy1kcmlsbGRvd24tYmFja1xcXCIpLm9uKFxcXCJjbGljay56Zi5kcmlsbGRvd25cXFwiLGZ1bmN0aW9uKGkpe2kuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksZS5faGlkZSh0KTt9KTt9fSx7a2V5OlxcXCJfbWVudUxpbmtFdmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIHQ9dGhpczt0aGlzLiRtZW51SXRlbXMubm90KFxcXCIuaXMtZHJpbGxkb3duLXN1Ym1lbnUtcGFyZW50XFxcIikub2ZmKFxcXCJjbGljay56Zi5kcmlsbGRvd25cXFwiKS5vbihcXFwiY2xpY2suemYuZHJpbGxkb3duXFxcIixmdW5jdGlvbihlKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dC5faGlkZUFsbCgpO30sMCk7fSk7fX0se2tleTpcXFwiX3Nob3dcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3QuY2hpbGRyZW4oXFxcIltkYXRhLXN1Ym1lbnVdXFxcIikuYWRkQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwib3Blbi56Zi5kcmlsbGRvd25cXFwiLFt0XSk7fX0se2tleTpcXFwiX2hpZGVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3QuYWRkQ2xhc3MoXFxcImlzLWNsb3NpbmdcXFwiKS5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKHQpLGZ1bmN0aW9uKCl7dC5yZW1vdmVDbGFzcyhcXFwiaXMtYWN0aXZlIGlzLWNsb3NpbmdcXFwiKSx0LmJsdXIoKTt9KSx0LnRyaWdnZXIoXFxcImhpZGUuemYuZHJpbGxkb3duXFxcIixbdF0pO319LHtrZXk6XFxcIl9nZXRNYXhEaW1zXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPTAsaT17fTtyZXR1cm4gdGhpcy4kc3VibWVudXMuYWRkKHRoaXMuJGVsZW1lbnQpLmVhY2goZnVuY3Rpb24oKXt2YXIgaT10KHRoaXMpLmNoaWxkcmVuKFxcXCJsaVxcXCIpLmxlbmd0aDtlPWk+ZT9pOmU7fSksaVtcXFwibWluLWhlaWdodFxcXCJdPWUqdGhpcy4kbWVudUl0ZW1zWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCtcXFwicHhcXFwiLGlbXFxcIm1heC13aWR0aFxcXCJdPXRoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgrXFxcInB4XFxcIixpO319LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy5faGlkZUFsbCgpLEZvdW5kYXRpb24uTmVzdC5CdXJuKHRoaXMuJGVsZW1lbnQsXFxcImRyaWxsZG93blxcXCIpLHRoaXMuJGVsZW1lbnQudW53cmFwKCkuZmluZChcXFwiLmpzLWRyaWxsZG93bi1iYWNrLCAuaXMtc3VibWVudS1wYXJlbnQtaXRlbVxcXCIpLnJlbW92ZSgpLmVuZCgpLmZpbmQoXFxcIi5pcy1hY3RpdmUsIC5pcy1jbG9zaW5nLCAuaXMtZHJpbGxkb3duLXN1Ym1lbnVcXFwiKS5yZW1vdmVDbGFzcyhcXFwiaXMtYWN0aXZlIGlzLWNsb3NpbmcgaXMtZHJpbGxkb3duLXN1Ym1lbnVcXFwiKS5lbmQoKS5maW5kKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpLnJlbW92ZUF0dHIoXFxcImFyaWEtaGlkZGVuIHRhYmluZGV4IHJvbGVcXFwiKSx0aGlzLiRzdWJtZW51QW5jaG9ycy5lYWNoKGZ1bmN0aW9uKCl7dCh0aGlzKS5vZmYoXFxcIi56Zi5kcmlsbGRvd25cXFwiKTt9KSx0aGlzLiRlbGVtZW50LmZpbmQoXFxcImFcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIGU9dCh0aGlzKTtlLmRhdGEoXFxcInNhdmVkSHJlZlxcXCIpJiZlLmF0dHIoXFxcImhyZWZcXFwiLGUuZGF0YShcXFwic2F2ZWRIcmVmXFxcIikpLnJlbW92ZURhdGEoXFxcInNhdmVkSHJlZlxcXCIpO30pLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pLGU7fSgpO2UuZGVmYXVsdHM9e2JhY2tCdXR0b246JzxsaSBjbGFzcz1cXFwianMtZHJpbGxkb3duLWJhY2tcXFwiPjxhIHRhYmluZGV4PVxcXCIwXFxcIj5CYWNrPC9hPjwvbGk+Jyx3cmFwcGVyOlxcXCI8ZGl2PjwvZGl2PlxcXCIscGFyZW50TGluazohMSxjbG9zZU9uQ2xpY2s6ITF9LEZvdW5kYXRpb24ucGx1Z2luKGUsXFxcIkRyaWxsZG93blxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiRHJvcGRvd25cXFwiKSxGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKFxcXCJEcm9wZG93blxcXCIse0VOVEVSOlxcXCJvcGVuXFxcIixTUEFDRTpcXFwib3BlblxcXCIsRVNDQVBFOlxcXCJjbG9zZVxcXCIsVEFCOlxcXCJ0YWJfZm9yd2FyZFxcXCIsU0hJRlRfVEFCOlxcXCJ0YWJfYmFja3dhcmRcXFwifSk7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcy4kZWxlbWVudC5hdHRyKFxcXCJpZFxcXCIpO3RoaXMuJGFuY2hvcj10KCdbZGF0YS10b2dnbGU9XFxcIicrZSsnXFxcIl0nKXx8dCgnW2RhdGEtb3Blbj1cXFwiJytlKydcXFwiXScpLHRoaXMuJGFuY2hvci5hdHRyKHtcXFwiYXJpYS1jb250cm9sc1xcXCI6ZSxcXFwiZGF0YS1pcy1mb2N1c1xcXCI6ITEsXFxcImRhdGEteWV0aS1ib3hcXFwiOmUsXFxcImFyaWEtaGFzcG9wdXBcXFwiOiEwLFxcXCJhcmlhLWV4cGFuZGVkXFxcIjohMX0pLHRoaXMub3B0aW9ucy5wb3NpdGlvbkNsYXNzPXRoaXMuZ2V0UG9zaXRpb25DbGFzcygpLHRoaXMuY291bnRlcj00LHRoaXMudXNlZFBvc2l0aW9ucz1bXSx0aGlzLiRlbGVtZW50LmF0dHIoe1xcXCJhcmlhLWhpZGRlblxcXCI6XFxcInRydWVcXFwiLFxcXCJkYXRhLXlldGktYm94XFxcIjplLFxcXCJkYXRhLXJlc2l6ZVxcXCI6ZSxcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIjp0aGlzLiRhbmNob3JbMF0uaWR8fEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNixcXFwiZGQtYW5jaG9yXFxcIil9KSx0aGlzLl9ldmVudHMoKTt9fSx7a2V5OlxcXCJnZXRQb3NpdGlvbkNsYXNzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciB0PXRoaXMuJGVsZW1lbnRbMF0uY2xhc3NOYW1lLm1hdGNoKC8odG9wfGxlZnR8cmlnaHR8Ym90dG9tKS9nKTt0PXQ/dFswXTpcXFwiXFxcIjt2YXIgZT0vZmxvYXQtKFxcXFxTKylcXFxccy8uZXhlYyh0aGlzLiRhbmNob3JbMF0uY2xhc3NOYW1lKTtlPWU/ZVsxXTpcXFwiXFxcIjt2YXIgaT1lP2UrXFxcIiBcXFwiK3Q6dDtyZXR1cm4gaTt9fSx7a2V5OlxcXCJfcmVwb3NpdGlvblxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dGhpcy51c2VkUG9zaXRpb25zLnB1c2godD90OlxcXCJib3R0b21cXFwiKSwhdCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcInRvcFxcXCIpPDA/dGhpcy4kZWxlbWVudC5hZGRDbGFzcyhcXFwidG9wXFxcIik6XFxcInRvcFxcXCI9PT10JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwiYm90dG9tXFxcIik8MD90aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHQpOlxcXCJsZWZ0XFxcIj09PXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJyaWdodFxcXCIpPDA/dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0KS5hZGRDbGFzcyhcXFwicmlnaHRcXFwiKTpcXFwicmlnaHRcXFwiPT09dCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImxlZnRcXFwiKTwwP3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModCkuYWRkQ2xhc3MoXFxcImxlZnRcXFwiKTohdCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcInRvcFxcXCIpPi0xJiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwibGVmdFxcXCIpPDA/dGhpcy4kZWxlbWVudC5hZGRDbGFzcyhcXFwibGVmdFxcXCIpOlxcXCJ0b3BcXFwiPT09dCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImJvdHRvbVxcXCIpPi0xJiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwibGVmdFxcXCIpPDA/dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0KS5hZGRDbGFzcyhcXFwibGVmdFxcXCIpOlxcXCJsZWZ0XFxcIj09PXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJyaWdodFxcXCIpPi0xJiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwiYm90dG9tXFxcIik8MD90aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHQpOlxcXCJyaWdodFxcXCI9PT10JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwibGVmdFxcXCIpPi0xJiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwiYm90dG9tXFxcIik8MD90aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHQpOnRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModCksdGhpcy5jbGFzc0NoYW5nZWQ9ITAsdGhpcy5jb3VudGVyLS07fX0se2tleTpcXFwiX3NldFBvc2l0aW9uXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe2lmKFxcXCJmYWxzZVxcXCI9PT10aGlzLiRhbmNob3IuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIpKXJldHVybiExO3ZhciB0PXRoaXMuZ2V0UG9zaXRpb25DbGFzcygpLGU9Rm91bmRhdGlvbi5Cb3guR2V0RGltZW5zaW9ucyh0aGlzLiRlbGVtZW50KSxpPShGb3VuZGF0aW9uLkJveC5HZXREaW1lbnNpb25zKHRoaXMuJGFuY2hvciksXFxcImxlZnRcXFwiPT09dD9cXFwibGVmdFxcXCI6XFxcInJpZ2h0XFxcIj09PXQ/XFxcImxlZnRcXFwiOlxcXCJ0b3BcXFwiKSxuPVxcXCJ0b3BcXFwiPT09aT9cXFwiaGVpZ2h0XFxcIjpcXFwid2lkdGhcXFwiO1xcXCJoZWlnaHRcXFwiPT09bj90aGlzLm9wdGlvbnMudk9mZnNldDp0aGlzLm9wdGlvbnMuaE9mZnNldDtpZihlLndpZHRoPj1lLndpbmRvd0RpbXMud2lkdGh8fCF0aGlzLmNvdW50ZXImJiFGb3VuZGF0aW9uLkJveC5JbU5vdFRvdWNoaW5nWW91KHRoaXMuJGVsZW1lbnQpKXJldHVybiB0aGlzLiRlbGVtZW50Lm9mZnNldChGb3VuZGF0aW9uLkJveC5HZXRPZmZzZXRzKHRoaXMuJGVsZW1lbnQsdGhpcy4kYW5jaG9yLFxcXCJjZW50ZXIgYm90dG9tXFxcIix0aGlzLm9wdGlvbnMudk9mZnNldCx0aGlzLm9wdGlvbnMuaE9mZnNldCwhMCkpLmNzcyh7d2lkdGg6ZS53aW5kb3dEaW1zLndpZHRoLTIqdGhpcy5vcHRpb25zLmhPZmZzZXQsaGVpZ2h0OlxcXCJhdXRvXFxcIn0pLHRoaXMuY2xhc3NDaGFuZ2VkPSEwLCExO2Zvcih0aGlzLiRlbGVtZW50Lm9mZnNldChGb3VuZGF0aW9uLkJveC5HZXRPZmZzZXRzKHRoaXMuJGVsZW1lbnQsdGhpcy4kYW5jaG9yLHQsdGhpcy5vcHRpb25zLnZPZmZzZXQsdGhpcy5vcHRpb25zLmhPZmZzZXQpKTshRm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdSh0aGlzLiRlbGVtZW50LCExLCEwKSYmdGhpcy5jb3VudGVyOyl7dGhpcy5fcmVwb3NpdGlvbih0KSx0aGlzLl9zZXRQb3NpdGlvbigpO319fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7dGhpcy4kZWxlbWVudC5vbih7XFxcIm9wZW4uemYudHJpZ2dlclxcXCI6dGhpcy5vcGVuLmJpbmQodGhpcyksXFxcImNsb3NlLnpmLnRyaWdnZXJcXFwiOnRoaXMuY2xvc2UuYmluZCh0aGlzKSxcXFwidG9nZ2xlLnpmLnRyaWdnZXJcXFwiOnRoaXMudG9nZ2xlLmJpbmQodGhpcyksXFxcInJlc2l6ZW1lLnpmLnRyaWdnZXJcXFwiOnRoaXMuX3NldFBvc2l0aW9uLmJpbmQodGhpcyl9KSx0aGlzLm9wdGlvbnMuaG92ZXImJih0aGlzLiRhbmNob3Iub2ZmKFxcXCJtb3VzZWVudGVyLnpmLmRyb3Bkb3duIG1vdXNlbGVhdmUuemYuZHJvcGRvd25cXFwiKS5vbihcXFwibW91c2VlbnRlci56Zi5kcm9wZG93blxcXCIsZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQoZS50aW1lb3V0KSxlLnRpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe2Uub3BlbigpLGUuJGFuY2hvci5kYXRhKFxcXCJob3ZlclxcXCIsITApO30sZS5vcHRpb25zLmhvdmVyRGVsYXkpO30pLm9uKFxcXCJtb3VzZWxlYXZlLnpmLmRyb3Bkb3duXFxcIixmdW5jdGlvbigpe2NsZWFyVGltZW91dChlLnRpbWVvdXQpLGUudGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5jbG9zZSgpLGUuJGFuY2hvci5kYXRhKFxcXCJob3ZlclxcXCIsITEpO30sZS5vcHRpb25zLmhvdmVyRGVsYXkpO30pLHRoaXMub3B0aW9ucy5ob3ZlclBhbmUmJnRoaXMuJGVsZW1lbnQub2ZmKFxcXCJtb3VzZWVudGVyLnpmLmRyb3Bkb3duIG1vdXNlbGVhdmUuemYuZHJvcGRvd25cXFwiKS5vbihcXFwibW91c2VlbnRlci56Zi5kcm9wZG93blxcXCIsZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQoZS50aW1lb3V0KTt9KS5vbihcXFwibW91c2VsZWF2ZS56Zi5kcm9wZG93blxcXCIsZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQoZS50aW1lb3V0KSxlLnRpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe2UuY2xvc2UoKSxlLiRhbmNob3IuZGF0YShcXFwiaG92ZXJcXFwiLCExKTt9LGUub3B0aW9ucy5ob3ZlckRlbGF5KTt9KSksdGhpcy4kYW5jaG9yLmFkZCh0aGlzLiRlbGVtZW50KS5vbihcXFwia2V5ZG93bi56Zi5kcm9wZG93blxcXCIsZnVuY3Rpb24oaSl7dmFyIG49dCh0aGlzKSxzPUZvdW5kYXRpb24uS2V5Ym9hcmQuZmluZEZvY3VzYWJsZShlLiRlbGVtZW50KTtGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShpLFxcXCJEcm9wZG93blxcXCIse3RhYl9mb3J3YXJkOmZ1bmN0aW9uIHRhYl9mb3J3YXJkKCl7ZS4kZWxlbWVudC5maW5kKFxcXCI6Zm9jdXNcXFwiKS5pcyhzLmVxKC0xKSkmJihlLm9wdGlvbnMudHJhcEZvY3VzPyhzLmVxKDApLmZvY3VzKCksaS5wcmV2ZW50RGVmYXVsdCgpKTplLmNsb3NlKCkpO30sdGFiX2JhY2t3YXJkOmZ1bmN0aW9uIHRhYl9iYWNrd2FyZCgpeyhlLiRlbGVtZW50LmZpbmQoXFxcIjpmb2N1c1xcXCIpLmlzKHMuZXEoMCkpfHxlLiRlbGVtZW50LmlzKFxcXCI6Zm9jdXNcXFwiKSkmJihlLm9wdGlvbnMudHJhcEZvY3VzPyhzLmVxKC0xKS5mb2N1cygpLGkucHJldmVudERlZmF1bHQoKSk6ZS5jbG9zZSgpKTt9LG9wZW46ZnVuY3Rpb24gb3Blbigpe24uaXMoZS4kYW5jaG9yKSYmKGUub3BlbigpLGUuJGVsZW1lbnQuYXR0cihcXFwidGFiaW5kZXhcXFwiLC0xKS5mb2N1cygpLGkucHJldmVudERlZmF1bHQoKSk7fSxjbG9zZTpmdW5jdGlvbiBjbG9zZSgpe2UuY2xvc2UoKSxlLiRhbmNob3IuZm9jdXMoKTt9fSk7fSk7fX0se2tleTpcXFwiX2FkZEJvZHlIYW5kbGVyXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXQoZG9jdW1lbnQuYm9keSkubm90KHRoaXMuJGVsZW1lbnQpLGk9dGhpcztlLm9mZihcXFwiY2xpY2suemYuZHJvcGRvd25cXFwiKS5vbihcXFwiY2xpY2suemYuZHJvcGRvd25cXFwiLGZ1bmN0aW9uKHQpe2kuJGFuY2hvci5pcyh0LnRhcmdldCl8fGkuJGFuY2hvci5maW5kKHQudGFyZ2V0KS5sZW5ndGh8fGkuJGVsZW1lbnQuZmluZCh0LnRhcmdldCkubGVuZ3RofHwoaS5jbG9zZSgpLGUub2ZmKFxcXCJjbGljay56Zi5kcm9wZG93blxcXCIpKTt9KTt9fSx7a2V5OlxcXCJvcGVuXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe2lmKHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwiY2xvc2VtZS56Zi5kcm9wZG93blxcXCIsdGhpcy4kZWxlbWVudC5hdHRyKFxcXCJpZFxcXCIpKSx0aGlzLiRhbmNob3IuYWRkQ2xhc3MoXFxcImhvdmVyXFxcIikuYXR0cih7XFxcImFyaWEtZXhwYW5kZWRcXFwiOiEwfSksdGhpcy5fc2V0UG9zaXRpb24oKSx0aGlzLiRlbGVtZW50LmFkZENsYXNzKFxcXCJpcy1vcGVuXFxcIikuYXR0cih7XFxcImFyaWEtaGlkZGVuXFxcIjohMX0pLHRoaXMub3B0aW9ucy5hdXRvRm9jdXMpe3ZhciB0PUZvdW5kYXRpb24uS2V5Ym9hcmQuZmluZEZvY3VzYWJsZSh0aGlzLiRlbGVtZW50KTt0Lmxlbmd0aCYmdC5lcSgwKS5mb2N1cygpO310aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrJiZ0aGlzLl9hZGRCb2R5SGFuZGxlcigpLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwic2hvdy56Zi5kcm9wZG93blxcXCIsW3RoaXMuJGVsZW1lbnRdKTt9fSx7a2V5OlxcXCJjbG9zZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXtpZighdGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcXFwiaXMtb3BlblxcXCIpKXJldHVybiExO2lmKHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcImlzLW9wZW5cXFwiKS5hdHRyKHtcXFwiYXJpYS1oaWRkZW5cXFwiOiEwfSksdGhpcy4kYW5jaG9yLnJlbW92ZUNsYXNzKFxcXCJob3ZlclxcXCIpLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCExKSx0aGlzLmNsYXNzQ2hhbmdlZCl7dmFyIHQ9dGhpcy5nZXRQb3NpdGlvbkNsYXNzKCk7dCYmdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0KSx0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5wb3NpdGlvbkNsYXNzKS5jc3Moe2hlaWdodDpcXFwiXFxcIix3aWR0aDpcXFwiXFxcIn0pLHRoaXMuY2xhc3NDaGFuZ2VkPSExLHRoaXMuY291bnRlcj00LHRoaXMudXNlZFBvc2l0aW9ucy5sZW5ndGg9MDt9dGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJoaWRlLnpmLmRyb3Bkb3duXFxcIixbdGhpcy4kZWxlbWVudF0pO319LHtrZXk6XFxcInRvZ2dsZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXtpZih0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFxcXCJpcy1vcGVuXFxcIikpe2lmKHRoaXMuJGFuY2hvci5kYXRhKFxcXCJob3ZlclxcXCIpKXJldHVybjt0aGlzLmNsb3NlKCk7fWVsc2UgdGhpcy5vcGVuKCk7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRlbGVtZW50Lm9mZihcXFwiLnpmLnRyaWdnZXJcXFwiKS5oaWRlKCksdGhpcy4kYW5jaG9yLm9mZihcXFwiLnpmLmRyb3Bkb3duXFxcIiksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7ZS5kZWZhdWx0cz17aG92ZXJEZWxheToyNTAsaG92ZXI6ITEsaG92ZXJQYW5lOiExLHZPZmZzZXQ6MSxoT2Zmc2V0OjEscG9zaXRpb25DbGFzczpcXFwiXFxcIix0cmFwRm9jdXM6ITEsYXV0b0ZvY3VzOiExLGNsb3NlT25DbGljazohMX0sRm91bmRhdGlvbi5wbHVnaW4oZSxcXFwiRHJvcGRvd25cXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD1pLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG4pLEZvdW5kYXRpb24uTmVzdC5GZWF0aGVyKHRoaXMuJGVsZW1lbnQsXFxcImRyb3Bkb3duXFxcIiksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiRHJvcGRvd25NZW51XFxcIiksRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcihcXFwiRHJvcGRvd25NZW51XFxcIix7RU5URVI6XFxcIm9wZW5cXFwiLFNQQUNFOlxcXCJvcGVuXFxcIixBUlJPV19SSUdIVDpcXFwibmV4dFxcXCIsQVJST1dfVVA6XFxcInVwXFxcIixBUlJPV19ET1dOOlxcXCJkb3duXFxcIixBUlJPV19MRUZUOlxcXCJwcmV2aW91c1xcXCIsRVNDQVBFOlxcXCJjbG9zZVxcXCJ9KTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgdD10aGlzLiRlbGVtZW50LmZpbmQoXFxcImxpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50XFxcIik7dGhpcy4kZWxlbWVudC5jaGlsZHJlbihcXFwiLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50XFxcIikuY2hpbGRyZW4oXFxcIi5pcy1kcm9wZG93bi1zdWJtZW51XFxcIikuYWRkQ2xhc3MoXFxcImZpcnN0LXN1YlxcXCIpLHRoaXMuJG1lbnVJdGVtcz10aGlzLiRlbGVtZW50LmZpbmQoJ1tyb2xlPVxcXCJtZW51aXRlbVxcXCJdJyksdGhpcy4kdGFicz10aGlzLiRlbGVtZW50LmNoaWxkcmVuKCdbcm9sZT1cXFwibWVudWl0ZW1cXFwiXScpLHRoaXMuJHRhYnMuZmluZChcXFwidWwuaXMtZHJvcGRvd24tc3VibWVudVxcXCIpLmFkZENsYXNzKHRoaXMub3B0aW9ucy52ZXJ0aWNhbENsYXNzKSx0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMub3B0aW9ucy5yaWdodENsYXNzKXx8XFxcInJpZ2h0XFxcIj09PXRoaXMub3B0aW9ucy5hbGlnbm1lbnR8fEZvdW5kYXRpb24ucnRsKCl8fHRoaXMuJGVsZW1lbnQucGFyZW50cyhcXFwiLnRvcC1iYXItcmlnaHRcXFwiKS5pcyhcXFwiKlxcXCIpPyh0aGlzLm9wdGlvbnMuYWxpZ25tZW50PVxcXCJyaWdodFxcXCIsdC5hZGRDbGFzcyhcXFwib3BlbnMtbGVmdFxcXCIpKTp0LmFkZENsYXNzKFxcXCJvcGVucy1yaWdodFxcXCIpLHRoaXMuY2hhbmdlZD0hMSx0aGlzLl9ldmVudHMoKTt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXMsaT1cXFwib250b3VjaHN0YXJ0XFxcImluIHdpbmRvd3x8XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB3aW5kb3cub250b3VjaHN0YXJ0LG49XFxcImlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50XFxcIixzPWZ1bmN0aW9uIHMoX3Mpe3ZhciBvPXQoX3MudGFyZ2V0KS5wYXJlbnRzVW50aWwoXFxcInVsXFxcIixcXFwiLlxcXCIrbiksYT1vLmhhc0NsYXNzKG4pLHI9XFxcInRydWVcXFwiPT09by5hdHRyKFxcXCJkYXRhLWlzLWNsaWNrXFxcIik7by5jaGlsZHJlbihcXFwiLmlzLWRyb3Bkb3duLXN1Ym1lbnVcXFwiKTtpZihhKWlmKHIpe2lmKCFlLm9wdGlvbnMuY2xvc2VPbkNsaWNrfHwhZS5vcHRpb25zLmNsaWNrT3BlbiYmIWl8fGUub3B0aW9ucy5mb3JjZUZvbGxvdyYmaSlyZXR1cm47X3Muc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksX3MucHJldmVudERlZmF1bHQoKSxlLl9oaWRlKG8pO31lbHNlIF9zLnByZXZlbnREZWZhdWx0KCksX3Muc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksZS5fc2hvdyhvLmNoaWxkcmVuKFxcXCIuaXMtZHJvcGRvd24tc3VibWVudVxcXCIpKSxvLmFkZChvLnBhcmVudHNVbnRpbChlLiRlbGVtZW50LFxcXCIuXFxcIituKSkuYXR0cihcXFwiZGF0YS1pcy1jbGlja1xcXCIsITApO307KHRoaXMub3B0aW9ucy5jbGlja09wZW58fGkpJiZ0aGlzLiRtZW51SXRlbXMub24oXFxcImNsaWNrLnpmLmRyb3Bkb3dubWVudSB0b3VjaHN0YXJ0LnpmLmRyb3Bkb3dubWVudVxcXCIscyksdGhpcy5vcHRpb25zLmRpc2FibGVIb3Zlcnx8dGhpcy4kbWVudUl0ZW1zLm9uKFxcXCJtb3VzZWVudGVyLnpmLmRyb3Bkb3dubWVudVxcXCIsZnVuY3Rpb24oaSl7dmFyIHM9dCh0aGlzKSxvPXMuaGFzQ2xhc3Mobik7byYmKGNsZWFyVGltZW91dChlLmRlbGF5KSxlLmRlbGF5PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLl9zaG93KHMuY2hpbGRyZW4oXFxcIi5pcy1kcm9wZG93bi1zdWJtZW51XFxcIikpO30sZS5vcHRpb25zLmhvdmVyRGVsYXkpKTt9KS5vbihcXFwibW91c2VsZWF2ZS56Zi5kcm9wZG93bm1lbnVcXFwiLGZ1bmN0aW9uKGkpe3ZhciBzPXQodGhpcyksbz1zLmhhc0NsYXNzKG4pO2lmKG8mJmUub3B0aW9ucy5hdXRvY2xvc2Upe2lmKFxcXCJ0cnVlXFxcIj09PXMuYXR0cihcXFwiZGF0YS1pcy1jbGlja1xcXCIpJiZlLm9wdGlvbnMuY2xpY2tPcGVuKXJldHVybiExO2NsZWFyVGltZW91dChlLmRlbGF5KSxlLmRlbGF5PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLl9oaWRlKHMpO30sZS5vcHRpb25zLmNsb3NpbmdUaW1lKTt9fSksdGhpcy4kbWVudUl0ZW1zLm9uKFxcXCJrZXlkb3duLnpmLmRyb3Bkb3dubWVudVxcXCIsZnVuY3Rpb24oaSl7dmFyIG4scyxvPXQoaS50YXJnZXQpLnBhcmVudHNVbnRpbChcXFwidWxcXFwiLCdbcm9sZT1cXFwibWVudWl0ZW1cXFwiXScpLGE9ZS4kdGFicy5pbmRleChvKT4tMSxyPWE/ZS4kdGFiczpvLnNpYmxpbmdzKFxcXCJsaVxcXCIpLmFkZChvKTtyLmVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHQodGhpcykuaXMobyk/KG49ci5lcShlLTEpLHZvaWQocz1yLmVxKGUrMSkpKTp2b2lkIDA7fSk7dmFyIGw9ZnVuY3Rpb24gbCgpe28uaXMoXFxcIjpsYXN0LWNoaWxkXFxcIil8fChzLmNoaWxkcmVuKFxcXCJhOmZpcnN0XFxcIikuZm9jdXMoKSxpLnByZXZlbnREZWZhdWx0KCkpO30sdT1mdW5jdGlvbiB1KCl7bi5jaGlsZHJlbihcXFwiYTpmaXJzdFxcXCIpLmZvY3VzKCksaS5wcmV2ZW50RGVmYXVsdCgpO30sZD1mdW5jdGlvbiBkKCl7dmFyIHQ9by5jaGlsZHJlbihcXFwidWwuaXMtZHJvcGRvd24tc3VibWVudVxcXCIpO3QubGVuZ3RoJiYoZS5fc2hvdyh0KSxvLmZpbmQoXFxcImxpID4gYTpmaXJzdFxcXCIpLmZvY3VzKCksaS5wcmV2ZW50RGVmYXVsdCgpKTt9LGg9ZnVuY3Rpb24gaCgpe3ZhciB0PW8ucGFyZW50KFxcXCJ1bFxcXCIpLnBhcmVudChcXFwibGlcXFwiKTt0LmNoaWxkcmVuKFxcXCJhOmZpcnN0XFxcIikuZm9jdXMoKSxlLl9oaWRlKHQpLGkucHJldmVudERlZmF1bHQoKTt9LGM9e29wZW46ZCxjbG9zZTpmdW5jdGlvbiBjbG9zZSgpe2UuX2hpZGUoZS4kZWxlbWVudCksZS4kbWVudUl0ZW1zLmZpbmQoXFxcImE6Zmlyc3RcXFwiKS5mb2N1cygpLGkucHJldmVudERlZmF1bHQoKTt9LGhhbmRsZWQ6ZnVuY3Rpb24gaGFuZGxlZCgpe2kuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7fX07YT9lLiRlbGVtZW50Lmhhc0NsYXNzKGUub3B0aW9ucy52ZXJ0aWNhbENsYXNzKT9cXFwibGVmdFxcXCI9PT1lLm9wdGlvbnMuYWxpZ25tZW50P3QuZXh0ZW5kKGMse2Rvd246bCx1cDp1LG5leHQ6ZCxwcmV2aW91czpofSk6dC5leHRlbmQoYyx7ZG93bjpsLHVwOnUsbmV4dDpoLHByZXZpb3VzOmR9KTp0LmV4dGVuZChjLHtuZXh0OmwscHJldmlvdXM6dSxkb3duOmQsdXA6aH0pOlxcXCJsZWZ0XFxcIj09PWUub3B0aW9ucy5hbGlnbm1lbnQ/dC5leHRlbmQoYyx7bmV4dDpkLHByZXZpb3VzOmgsZG93bjpsLHVwOnV9KTp0LmV4dGVuZChjLHtuZXh0OmgscHJldmlvdXM6ZCxkb3duOmwsdXA6dX0pLEZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGksXFxcIkRyb3Bkb3duTWVudVxcXCIsYyk7fSk7fX0se2tleTpcXFwiX2FkZEJvZHlIYW5kbGVyXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXQoZG9jdW1lbnQuYm9keSksaT10aGlzO2Uub2ZmKFxcXCJtb3VzZXVwLnpmLmRyb3Bkb3dubWVudSB0b3VjaGVuZC56Zi5kcm9wZG93bm1lbnVcXFwiKS5vbihcXFwibW91c2V1cC56Zi5kcm9wZG93bm1lbnUgdG91Y2hlbmQuemYuZHJvcGRvd25tZW51XFxcIixmdW5jdGlvbih0KXt2YXIgbj1pLiRlbGVtZW50LmZpbmQodC50YXJnZXQpO24ubGVuZ3RofHwoaS5faGlkZSgpLGUub2ZmKFxcXCJtb3VzZXVwLnpmLmRyb3Bkb3dubWVudSB0b3VjaGVuZC56Zi5kcm9wZG93bm1lbnVcXFwiKSk7fSk7fX0se2tleTpcXFwiX3Nob3dcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe3ZhciBpPXRoaXMuJHRhYnMuaW5kZXgodGhpcy4kdGFicy5maWx0ZXIoZnVuY3Rpb24oaSxuKXtyZXR1cm4gdChuKS5maW5kKGUpLmxlbmd0aD4wO30pKSxuPWUucGFyZW50KFxcXCJsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudFxcXCIpLnNpYmxpbmdzKFxcXCJsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudFxcXCIpO3RoaXMuX2hpZGUobixpKSxlLmNzcyhcXFwidmlzaWJpbGl0eVxcXCIsXFxcImhpZGRlblxcXCIpLmFkZENsYXNzKFxcXCJqcy1kcm9wZG93bi1hY3RpdmVcXFwiKS5hdHRyKHtcXFwiYXJpYS1oaWRkZW5cXFwiOiExfSkucGFyZW50KFxcXCJsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudFxcXCIpLmFkZENsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKS5hdHRyKHtcXFwiYXJpYS1leHBhbmRlZFxcXCI6ITB9KTt2YXIgcz1Gb3VuZGF0aW9uLkJveC5JbU5vdFRvdWNoaW5nWW91KGUsbnVsbCwhMCk7aWYoIXMpe3ZhciBvPVxcXCJsZWZ0XFxcIj09PXRoaXMub3B0aW9ucy5hbGlnbm1lbnQ/XFxcIi1yaWdodFxcXCI6XFxcIi1sZWZ0XFxcIixhPWUucGFyZW50KFxcXCIuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnRcXFwiKTthLnJlbW92ZUNsYXNzKFxcXCJvcGVuc1xcXCIrbykuYWRkQ2xhc3MoXFxcIm9wZW5zLVxcXCIrdGhpcy5vcHRpb25zLmFsaWdubWVudCkscz1Gb3VuZGF0aW9uLkJveC5JbU5vdFRvdWNoaW5nWW91KGUsbnVsbCwhMCksc3x8YS5yZW1vdmVDbGFzcyhcXFwib3BlbnMtXFxcIit0aGlzLm9wdGlvbnMuYWxpZ25tZW50KS5hZGRDbGFzcyhcXFwib3BlbnMtaW5uZXJcXFwiKSx0aGlzLmNoYW5nZWQ9ITA7fWUuY3NzKFxcXCJ2aXNpYmlsaXR5XFxcIixcXFwiXFxcIiksdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayYmdGhpcy5fYWRkQm9keUhhbmRsZXIoKSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcInNob3cuemYuZHJvcGRvd25tZW51XFxcIixbZV0pO319LHtrZXk6XFxcIl9oaWRlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0LGUpe3ZhciBpO2k9dCYmdC5sZW5ndGg/dDp2b2lkIDAhPT1lP3RoaXMuJHRhYnMubm90KGZ1bmN0aW9uKHQsaSl7cmV0dXJuIHQ9PT1lO30pOnRoaXMuJGVsZW1lbnQ7dmFyIG49aS5oYXNDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIil8fGkuZmluZChcXFwiLmlzLWFjdGl2ZVxcXCIpLmxlbmd0aD4wO2lmKG4pe2lmKGkuZmluZChcXFwibGkuaXMtYWN0aXZlXFxcIikuYWRkKGkpLmF0dHIoe1xcXCJhcmlhLWV4cGFuZGVkXFxcIjohMSxcXFwiZGF0YS1pcy1jbGlja1xcXCI6ITF9KS5yZW1vdmVDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIiksaS5maW5kKFxcXCJ1bC5qcy1kcm9wZG93bi1hY3RpdmVcXFwiKS5hdHRyKHtcXFwiYXJpYS1oaWRkZW5cXFwiOiEwfSkucmVtb3ZlQ2xhc3MoXFxcImpzLWRyb3Bkb3duLWFjdGl2ZVxcXCIpLHRoaXMuY2hhbmdlZHx8aS5maW5kKFxcXCJvcGVucy1pbm5lclxcXCIpLmxlbmd0aCl7dmFyIHM9XFxcImxlZnRcXFwiPT09dGhpcy5vcHRpb25zLmFsaWdubWVudD9cXFwicmlnaHRcXFwiOlxcXCJsZWZ0XFxcIjtpLmZpbmQoXFxcImxpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50XFxcIikuYWRkKGkpLnJlbW92ZUNsYXNzKFxcXCJvcGVucy1pbm5lciBvcGVucy1cXFwiK3RoaXMub3B0aW9ucy5hbGlnbm1lbnQpLmFkZENsYXNzKFxcXCJvcGVucy1cXFwiK3MpLHRoaXMuY2hhbmdlZD0hMTt9dGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJoaWRlLnpmLmRyb3Bkb3dubWVudVxcXCIsW2ldKTt9fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRtZW51SXRlbXMub2ZmKFxcXCIuemYuZHJvcGRvd25tZW51XFxcIikucmVtb3ZlQXR0cihcXFwiZGF0YS1pcy1jbGlja1xcXCIpLnJlbW92ZUNsYXNzKFxcXCJpcy1yaWdodC1hcnJvdyBpcy1sZWZ0LWFycm93IGlzLWRvd24tYXJyb3cgb3BlbnMtcmlnaHQgb3BlbnMtbGVmdCBvcGVucy1pbm5lclxcXCIpLHQoZG9jdW1lbnQuYm9keSkub2ZmKFxcXCIuemYuZHJvcGRvd25tZW51XFxcIiksRm91bmRhdGlvbi5OZXN0LkJ1cm4odGhpcy4kZWxlbWVudCxcXFwiZHJvcGRvd25cXFwiKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXtkaXNhYmxlSG92ZXI6ITEsYXV0b2Nsb3NlOiEwLGhvdmVyRGVsYXk6NTAsY2xpY2tPcGVuOiExLGNsb3NpbmdUaW1lOjUwMCxhbGlnbm1lbnQ6XFxcImxlZnRcXFwiLGNsb3NlT25DbGljazohMCx2ZXJ0aWNhbENsYXNzOlxcXCJ2ZXJ0aWNhbFxcXCIscmlnaHRDbGFzczpcXFwiYWxpZ24tcmlnaHRcXFwiLGZvcmNlRm9sbG93OiEwfSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJEcm9wZG93bk1lbnVcXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD1pLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG4pLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIkVxdWFsaXplclxcXCIpO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXMuJGVsZW1lbnQuYXR0cihcXFwiZGF0YS1lcXVhbGl6ZXJcXFwiKXx8XFxcIlxcXCIsaT10aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLWVxdWFsaXplci13YXRjaD1cXFwiJytlKydcXFwiXScpO3RoaXMuJHdhdGNoZWQ9aS5sZW5ndGg/aTp0aGlzLiRlbGVtZW50LmZpbmQoXFxcIltkYXRhLWVxdWFsaXplci13YXRjaF1cXFwiKSx0aGlzLiRlbGVtZW50LmF0dHIoXFxcImRhdGEtcmVzaXplXFxcIixlfHxGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsXFxcImVxXFxcIikpLHRoaXMuaGFzTmVzdGVkPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiW2RhdGEtZXF1YWxpemVyXVxcXCIpLmxlbmd0aD4wLHRoaXMuaXNOZXN0ZWQ9dGhpcy4kZWxlbWVudC5wYXJlbnRzVW50aWwoZG9jdW1lbnQuYm9keSxcXFwiW2RhdGEtZXF1YWxpemVyXVxcXCIpLmxlbmd0aD4wLHRoaXMuaXNPbj0hMSx0aGlzLl9iaW5kSGFuZGxlcj17b25SZXNpemVNZUJvdW5kOnRoaXMuX29uUmVzaXplTWUuYmluZCh0aGlzKSxvblBvc3RFcXVhbGl6ZWRCb3VuZDp0aGlzLl9vblBvc3RFcXVhbGl6ZWQuYmluZCh0aGlzKX07dmFyIG4scz10aGlzLiRlbGVtZW50LmZpbmQoXFxcImltZ1xcXCIpO3RoaXMub3B0aW9ucy5lcXVhbGl6ZU9uPyhuPXRoaXMuX2NoZWNrTVEoKSx0KHdpbmRvdykub24oXFxcImNoYW5nZWQuemYubWVkaWFxdWVyeVxcXCIsdGhpcy5fY2hlY2tNUS5iaW5kKHRoaXMpKSk6dGhpcy5fZXZlbnRzKCksKHZvaWQgMCE9PW4mJm49PT0hMXx8dm9pZCAwPT09bikmJihzLmxlbmd0aD9Gb3VuZGF0aW9uLm9uSW1hZ2VzTG9hZGVkKHMsdGhpcy5fcmVmbG93LmJpbmQodGhpcykpOnRoaXMuX3JlZmxvdygpKTt9fSx7a2V5OlxcXCJfcGF1c2VFdmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy5pc09uPSExLHRoaXMuJGVsZW1lbnQub2ZmKHtcXFwiLnpmLmVxdWFsaXplclxcXCI6dGhpcy5fYmluZEhhbmRsZXIub25Qb3N0RXF1YWxpemVkQm91bmQsXFxcInJlc2l6ZW1lLnpmLnRyaWdnZXJcXFwiOnRoaXMuX2JpbmRIYW5kbGVyLm9uUmVzaXplTWVCb3VuZH0pO319LHtrZXk6XFxcIl9vblJlc2l6ZU1lXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt0aGlzLl9yZWZsb3coKTt9fSx7a2V5OlxcXCJfb25Qb3N0RXF1YWxpemVkXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt0LnRhcmdldCE9PXRoaXMuJGVsZW1lbnRbMF0mJnRoaXMuX3JlZmxvdygpO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy5fcGF1c2VFdmVudHMoKSx0aGlzLmhhc05lc3RlZD90aGlzLiRlbGVtZW50Lm9uKFxcXCJwb3N0ZXF1YWxpemVkLnpmLmVxdWFsaXplclxcXCIsdGhpcy5fYmluZEhhbmRsZXIub25Qb3N0RXF1YWxpemVkQm91bmQpOnRoaXMuJGVsZW1lbnQub24oXFxcInJlc2l6ZW1lLnpmLnRyaWdnZXJcXFwiLHRoaXMuX2JpbmRIYW5kbGVyLm9uUmVzaXplTWVCb3VuZCksdGhpcy5pc09uPSEwO319LHtrZXk6XFxcIl9jaGVja01RXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciB0PSFGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdCh0aGlzLm9wdGlvbnMuZXF1YWxpemVPbik7cmV0dXJuIHQ/dGhpcy5pc09uJiYodGhpcy5fcGF1c2VFdmVudHMoKSx0aGlzLiR3YXRjaGVkLmNzcyhcXFwiaGVpZ2h0XFxcIixcXFwiYXV0b1xcXCIpKTp0aGlzLmlzT258fHRoaXMuX2V2ZW50cygpLHQ7fX0se2tleTpcXFwiX2tpbGxzd2l0Y2hcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7fX0se2tleTpcXFwiX3JlZmxvd1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXtyZXR1cm4hdGhpcy5vcHRpb25zLmVxdWFsaXplT25TdGFjayYmdGhpcy5faXNTdGFja2VkKCk/KHRoaXMuJHdhdGNoZWQuY3NzKFxcXCJoZWlnaHRcXFwiLFxcXCJhdXRvXFxcIiksITEpOnZvaWQodGhpcy5vcHRpb25zLmVxdWFsaXplQnlSb3c/dGhpcy5nZXRIZWlnaHRzQnlSb3codGhpcy5hcHBseUhlaWdodEJ5Um93LmJpbmQodGhpcykpOnRoaXMuZ2V0SGVpZ2h0cyh0aGlzLmFwcGx5SGVpZ2h0LmJpbmQodGhpcykpKTt9fSx7a2V5OlxcXCJfaXNTdGFja2VkXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3JldHVybiB0aGlzLiR3YXRjaGVkWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCE9PXRoaXMuJHdhdGNoZWRbMV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO319LHtrZXk6XFxcImdldEhlaWdodHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe2Zvcih2YXIgZT1bXSxpPTAsbj10aGlzLiR3YXRjaGVkLmxlbmd0aDtuPmk7aSsrKXt0aGlzLiR3YXRjaGVkW2ldLnN0eWxlLmhlaWdodD1cXFwiYXV0b1xcXCIsZS5wdXNoKHRoaXMuJHdhdGNoZWRbaV0ub2Zmc2V0SGVpZ2h0KTt9dChlKTt9fSx7a2V5OlxcXCJnZXRIZWlnaHRzQnlSb3dcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe3ZhciBpPXRoaXMuJHdhdGNoZWQubGVuZ3RoP3RoaXMuJHdhdGNoZWQuZmlyc3QoKS5vZmZzZXQoKS50b3A6MCxuPVtdLHM9MDtuW3NdPVtdO2Zvcih2YXIgbz0wLGE9dGhpcy4kd2F0Y2hlZC5sZW5ndGg7YT5vO28rKyl7dGhpcy4kd2F0Y2hlZFtvXS5zdHlsZS5oZWlnaHQ9XFxcImF1dG9cXFwiO3ZhciByPXQodGhpcy4kd2F0Y2hlZFtvXSkub2Zmc2V0KCkudG9wO3IhPWkmJihzKyssbltzXT1bXSxpPXIpLG5bc10ucHVzaChbdGhpcy4kd2F0Y2hlZFtvXSx0aGlzLiR3YXRjaGVkW29dLm9mZnNldEhlaWdodF0pO31mb3IodmFyIGw9MCx1PW4ubGVuZ3RoO3U+bDtsKyspe3ZhciBkPXQobltsXSkubWFwKGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbMV07fSkuZ2V0KCksaD1NYXRoLm1heC5hcHBseShudWxsLGQpO25bbF0ucHVzaChoKTt9ZShuKTt9fSx7a2V5OlxcXCJhcHBseUhlaWdodFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGU9TWF0aC5tYXguYXBwbHkobnVsbCx0KTt0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcInByZWVxdWFsaXplZC56Zi5lcXVhbGl6ZXJcXFwiKSx0aGlzLiR3YXRjaGVkLmNzcyhcXFwiaGVpZ2h0XFxcIixlKSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcInBvc3RlcXVhbGl6ZWQuemYuZXF1YWxpemVyXFxcIik7fX0se2tleTpcXFwiYXBwbHlIZWlnaHRCeVJvd1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7dGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJwcmVlcXVhbGl6ZWQuemYuZXF1YWxpemVyXFxcIik7Zm9yKHZhciBpPTAsbj1lLmxlbmd0aDtuPmk7aSsrKXt2YXIgcz1lW2ldLmxlbmd0aCxvPWVbaV1bcy0xXTtpZigyPj1zKXQoZVtpXVswXVswXSkuY3NzKHtoZWlnaHQ6XFxcImF1dG9cXFwifSk7ZWxzZXt0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcInByZWVxdWFsaXplZHJvdy56Zi5lcXVhbGl6ZXJcXFwiKTtmb3IodmFyIGE9MCxyPXMtMTtyPmE7YSsrKXt0KGVbaV1bYV1bMF0pLmNzcyh7aGVpZ2h0Om99KTt9dGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJwb3N0ZXF1YWxpemVkcm93LnpmLmVxdWFsaXplclxcXCIpO319dGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJwb3N0ZXF1YWxpemVkLnpmLmVxdWFsaXplclxcXCIpO319LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy5fcGF1c2VFdmVudHMoKSx0aGlzLiR3YXRjaGVkLmNzcyhcXFwiaGVpZ2h0XFxcIixcXFwiYXV0b1xcXCIpLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pLGU7fSgpO2UuZGVmYXVsdHM9e2VxdWFsaXplT25TdGFjazohMCxlcXVhbGl6ZUJ5Um93OiExLGVxdWFsaXplT246XFxcIlxcXCJ9LEZvdW5kYXRpb24ucGx1Z2luKGUsXFxcIkVxdWFsaXplclxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsbiksdGhpcy5ydWxlcz1bXSx0aGlzLmN1cnJlbnRQYXRoPVxcXCJcXFwiLHRoaXMuX2luaXQoKSx0aGlzLl9ldmVudHMoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIkludGVyY2hhbmdlXFxcIik7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy5fYWRkQnJlYWtwb2ludHMoKSx0aGlzLl9nZW5lcmF0ZVJ1bGVzKCksdGhpcy5fcmVmbG93KCk7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0KHdpbmRvdykub24oXFxcInJlc2l6ZS56Zi5pbnRlcmNoYW5nZVxcXCIsRm91bmRhdGlvbi51dGlsLnRocm90dGxlKHRoaXMuX3JlZmxvdy5iaW5kKHRoaXMpLDUwKSk7fX0se2tleTpcXFwiX3JlZmxvd1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgdDtmb3IodmFyIGUgaW4gdGhpcy5ydWxlcyl7aWYodGhpcy5ydWxlcy5oYXNPd25Qcm9wZXJ0eShlKSl7dmFyIGk9dGhpcy5ydWxlc1tlXTt3aW5kb3cubWF0Y2hNZWRpYShpLnF1ZXJ5KS5tYXRjaGVzJiYodD1pKTt9fXQmJnRoaXMucmVwbGFjZSh0LnBhdGgpO319LHtrZXk6XFxcIl9hZGRCcmVha3BvaW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXtmb3IodmFyIHQgaW4gRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LnF1ZXJpZXMpe2lmKEZvdW5kYXRpb24uTWVkaWFRdWVyeS5xdWVyaWVzLmhhc093blByb3BlcnR5KHQpKXt2YXIgaT1Gb3VuZGF0aW9uLk1lZGlhUXVlcnkucXVlcmllc1t0XTtlLlNQRUNJQUxfUVVFUklFU1tpLm5hbWVdPWkudmFsdWU7fX19fSx7a2V5OlxcXCJfZ2VuZXJhdGVSdWxlc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGksbj1bXTtpPXRoaXMub3B0aW9ucy5ydWxlcz90aGlzLm9wdGlvbnMucnVsZXM6dGhpcy4kZWxlbWVudC5kYXRhKFxcXCJpbnRlcmNoYW5nZVxcXCIpLm1hdGNoKC9cXFxcWy4qP1xcXFxdL2cpO2Zvcih2YXIgcyBpbiBpKXtpZihpLmhhc093blByb3BlcnR5KHMpKXt2YXIgbz1pW3NdLnNsaWNlKDEsLTEpLnNwbGl0KFxcXCIsIFxcXCIpLGE9by5zbGljZSgwLC0xKS5qb2luKFxcXCJcXFwiKSxyPW9bby5sZW5ndGgtMV07ZS5TUEVDSUFMX1FVRVJJRVNbcl0mJihyPWUuU1BFQ0lBTF9RVUVSSUVTW3JdKSxuLnB1c2goe3BhdGg6YSxxdWVyeTpyfSk7fX10aGlzLnJ1bGVzPW47fX0se2tleTpcXFwicmVwbGFjZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7aWYodGhpcy5jdXJyZW50UGF0aCE9PWUpe3ZhciBpPXRoaXMsbj1cXFwicmVwbGFjZWQuemYuaW50ZXJjaGFuZ2VcXFwiO1xcXCJJTUdcXFwiPT09dGhpcy4kZWxlbWVudFswXS5ub2RlTmFtZT90aGlzLiRlbGVtZW50LmF0dHIoXFxcInNyY1xcXCIsZSkubG9hZChmdW5jdGlvbigpe2kuY3VycmVudFBhdGg9ZTt9KS50cmlnZ2VyKG4pOmUubWF0Y2goL1xcXFwuKGdpZnxqcGd8anBlZ3xwbmd8c3ZnfHRpZmYpKFs/I10uKik/L2kpP3RoaXMuJGVsZW1lbnQuY3NzKHtcXFwiYmFja2dyb3VuZC1pbWFnZVxcXCI6XFxcInVybChcXFwiK2UrXFxcIilcXFwifSkudHJpZ2dlcihuKTp0LmdldChlLGZ1bmN0aW9uKHMpe2kuJGVsZW1lbnQuaHRtbChzKS50cmlnZ2VyKG4pLHQocykuZm91bmRhdGlvbigpLGkuY3VycmVudFBhdGg9ZTt9KTt9fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt9fV0pLGU7fSgpO2UuZGVmYXVsdHM9e3J1bGVzOm51bGx9LGUuU1BFQ0lBTF9RVUVSSUVTPXtsYW5kc2NhcGU6XFxcInNjcmVlbiBhbmQgKG9yaWVudGF0aW9uOiBsYW5kc2NhcGUpXFxcIixwb3J0cmFpdDpcXFwic2NyZWVuIGFuZCAob3JpZW50YXRpb246IHBvcnRyYWl0KVxcXCIscmV0aW5hOlxcXCJvbmx5IHNjcmVlbiBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbzogMiksIG9ubHkgc2NyZWVuIGFuZCAobWluLS1tb3otZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwgb25seSBzY3JlZW4gYW5kICgtby1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyLzEpLCBvbmx5IHNjcmVlbiBhbmQgKG1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCBvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAxOTJkcGkpLCBvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAyZHBweClcXFwifSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJJbnRlcmNoYW5nZVxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiTWFnZWxsYW5cXFwiKTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzLiRlbGVtZW50WzBdLmlkfHxGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsXFxcIm1hZ2VsbGFuXFxcIik7dGhpcy4kdGFyZ2V0cz10KFxcXCJbZGF0YS1tYWdlbGxhbi10YXJnZXRdXFxcIiksdGhpcy4kbGlua3M9dGhpcy4kZWxlbWVudC5maW5kKFxcXCJhXFxcIiksdGhpcy4kZWxlbWVudC5hdHRyKHtcXFwiZGF0YS1yZXNpemVcXFwiOmUsXFxcImRhdGEtc2Nyb2xsXFxcIjplLGlkOmV9KSx0aGlzLiRhY3RpdmU9dCgpLHRoaXMuc2Nyb2xsUG9zPXBhcnNlSW50KHdpbmRvdy5wYWdlWU9mZnNldCwxMCksdGhpcy5fZXZlbnRzKCk7fX0se2tleTpcXFwiY2FsY1BvaW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzLGk9ZG9jdW1lbnQuYm9keSxuPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudDt0aGlzLnBvaW50cz1bXSx0aGlzLndpbkhlaWdodD1NYXRoLnJvdW5kKE1hdGgubWF4KHdpbmRvdy5pbm5lckhlaWdodCxuLmNsaWVudEhlaWdodCkpLHRoaXMuZG9jSGVpZ2h0PU1hdGgucm91bmQoTWF0aC5tYXgoaS5zY3JvbGxIZWlnaHQsaS5vZmZzZXRIZWlnaHQsbi5jbGllbnRIZWlnaHQsbi5zY3JvbGxIZWlnaHQsbi5vZmZzZXRIZWlnaHQpKSx0aGlzLiR0YXJnZXRzLmVhY2goZnVuY3Rpb24oKXt2YXIgaT10KHRoaXMpLG49TWF0aC5yb3VuZChpLm9mZnNldCgpLnRvcC1lLm9wdGlvbnMudGhyZXNob2xkKTtpLnRhcmdldFBvaW50PW4sZS5wb2ludHMucHVzaChuKTt9KTt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7dChcXFwiaHRtbCwgYm9keVxcXCIpLHtkdXJhdGlvbjplLm9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sZWFzaW5nOmUub3B0aW9ucy5hbmltYXRpb25FYXNpbmd9O3Qod2luZG93KS5vbmUoXFxcImxvYWRcXFwiLGZ1bmN0aW9uKCl7ZS5vcHRpb25zLmRlZXBMaW5raW5nJiZsb2NhdGlvbi5oYXNoJiZlLnNjcm9sbFRvTG9jKGxvY2F0aW9uLmhhc2gpLGUuY2FsY1BvaW50cygpLGUuX3VwZGF0ZUFjdGl2ZSgpO30pLHRoaXMuJGVsZW1lbnQub24oe1xcXCJyZXNpemVtZS56Zi50cmlnZ2VyXFxcIjp0aGlzLnJlZmxvdy5iaW5kKHRoaXMpLFxcXCJzY3JvbGxtZS56Zi50cmlnZ2VyXFxcIjp0aGlzLl91cGRhdGVBY3RpdmUuYmluZCh0aGlzKX0pLm9uKFxcXCJjbGljay56Zi5tYWdlbGxhblxcXCIsJ2FbaHJlZl49XFxcIiNcXFwiXScsZnVuY3Rpb24odCl7dC5wcmV2ZW50RGVmYXVsdCgpO3ZhciBpPXRoaXMuZ2V0QXR0cmlidXRlKFxcXCJocmVmXFxcIik7ZS5zY3JvbGxUb0xvYyhpKTt9KTt9fSx7a2V5OlxcXCJzY3JvbGxUb0xvY1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7dmFyIGk9TWF0aC5yb3VuZCh0KGUpLm9mZnNldCgpLnRvcC10aGlzLm9wdGlvbnMudGhyZXNob2xkLzItdGhpcy5vcHRpb25zLmJhck9mZnNldCk7dChcXFwiaHRtbCwgYm9keVxcXCIpLnN0b3AoITApLmFuaW1hdGUoe3Njcm9sbFRvcDppfSx0aGlzLm9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sdGhpcy5vcHRpb25zLmFuaW1hdGlvbkVhc2luZyk7fX0se2tleTpcXFwicmVmbG93XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuY2FsY1BvaW50cygpLHRoaXMuX3VwZGF0ZUFjdGl2ZSgpO319LHtrZXk6XFxcIl91cGRhdGVBY3RpdmVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIHQsZT1wYXJzZUludCh3aW5kb3cucGFnZVlPZmZzZXQsMTApO2lmKGUrdGhpcy53aW5IZWlnaHQ9PT10aGlzLmRvY0hlaWdodCl0PXRoaXMucG9pbnRzLmxlbmd0aC0xO2Vsc2UgaWYoZTx0aGlzLnBvaW50c1swXSl0PTA7ZWxzZXt2YXIgaT10aGlzLnNjcm9sbFBvczxlLG49dGhpcyxzPXRoaXMucG9pbnRzLmZpbHRlcihmdW5jdGlvbih0LHMpe3JldHVybiBpP3Qtbi5vcHRpb25zLmJhck9mZnNldDw9ZTp0LW4ub3B0aW9ucy5iYXJPZmZzZXQtbi5vcHRpb25zLnRocmVzaG9sZDw9ZTt9KTt0PXMubGVuZ3RoP3MubGVuZ3RoLTE6MDt9aWYodGhpcy4kYWN0aXZlLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyksdGhpcy4kYWN0aXZlPXRoaXMuJGxpbmtzLmVxKHQpLmFkZENsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyksdGhpcy5vcHRpb25zLmRlZXBMaW5raW5nKXt2YXIgbz10aGlzLiRhY3RpdmVbMF0uZ2V0QXR0cmlidXRlKFxcXCJocmVmXFxcIik7d2luZG93Lmhpc3RvcnkucHVzaFN0YXRlP3dpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShudWxsLG51bGwsbyk6d2luZG93LmxvY2F0aW9uLmhhc2g9bzt9dGhpcy5zY3JvbGxQb3M9ZSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcInVwZGF0ZS56Zi5tYWdlbGxhblxcXCIsW3RoaXMuJGFjdGl2ZV0pO319LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7aWYodGhpcy4kZWxlbWVudC5vZmYoXFxcIi56Zi50cmlnZ2VyIC56Zi5tYWdlbGxhblxcXCIpLmZpbmQoXFxcIi5cXFwiK3RoaXMub3B0aW9ucy5hY3RpdmVDbGFzcykucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKSx0aGlzLm9wdGlvbnMuZGVlcExpbmtpbmcpe3ZhciB0PXRoaXMuJGFjdGl2ZVswXS5nZXRBdHRyaWJ1dGUoXFxcImhyZWZcXFwiKTt3aW5kb3cubG9jYXRpb24uaGFzaC5yZXBsYWNlKHQsXFxcIlxcXCIpO31Gb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXthbmltYXRpb25EdXJhdGlvbjo1MDAsYW5pbWF0aW9uRWFzaW5nOlxcXCJsaW5lYXJcXFwiLHRocmVzaG9sZDo1MCxhY3RpdmVDbGFzczpcXFwiYWN0aXZlXFxcIixkZWVwTGlua2luZzohMSxiYXJPZmZzZXQ6MH0sRm91bmRhdGlvbi5wbHVnaW4oZSxcXFwiTWFnZWxsYW5cXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD1pLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG4pLHRoaXMuJGxhc3RUcmlnZ2VyPXQoKSx0aGlzLiR0cmlnZ2Vycz10KCksdGhpcy5faW5pdCgpLHRoaXMuX2V2ZW50cygpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiT2ZmQ2FudmFzXFxcIik7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcy4kZWxlbWVudC5hdHRyKFxcXCJpZFxcXCIpO2lmKHRoaXMuJGVsZW1lbnQuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLFxcXCJ0cnVlXFxcIiksdGhpcy4kdHJpZ2dlcnM9dChkb2N1bWVudCkuZmluZCgnW2RhdGEtb3Blbj1cXFwiJytlKydcXFwiXSwgW2RhdGEtY2xvc2U9XFxcIicrZSsnXFxcIl0sIFtkYXRhLXRvZ2dsZT1cXFwiJytlKydcXFwiXScpLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLFxcXCJmYWxzZVxcXCIpLmF0dHIoXFxcImFyaWEtY29udHJvbHNcXFwiLGUpLHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spaWYodChcXFwiLmpzLW9mZi1jYW52YXMtZXhpdFxcXCIpLmxlbmd0aCl0aGlzLiRleGl0ZXI9dChcXFwiLmpzLW9mZi1jYW52YXMtZXhpdFxcXCIpO2Vsc2V7dmFyIGk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7aS5zZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIixcXFwianMtb2ZmLWNhbnZhcy1leGl0XFxcIiksdChcXFwiW2RhdGEtb2ZmLWNhbnZhcy1jb250ZW50XVxcXCIpLmFwcGVuZChpKSx0aGlzLiRleGl0ZXI9dChpKTt9dGhpcy5vcHRpb25zLmlzUmV2ZWFsZWQ9dGhpcy5vcHRpb25zLmlzUmV2ZWFsZWR8fG5ldyBSZWdFeHAodGhpcy5vcHRpb25zLnJldmVhbENsYXNzLFxcXCJnXFxcIikudGVzdCh0aGlzLiRlbGVtZW50WzBdLmNsYXNzTmFtZSksdGhpcy5vcHRpb25zLmlzUmV2ZWFsZWQmJih0aGlzLm9wdGlvbnMucmV2ZWFsT249dGhpcy5vcHRpb25zLnJldmVhbE9ufHx0aGlzLiRlbGVtZW50WzBdLmNsYXNzTmFtZS5tYXRjaCgvKHJldmVhbC1mb3ItbWVkaXVtfHJldmVhbC1mb3ItbGFyZ2UpL2cpWzBdLnNwbGl0KFxcXCItXFxcIilbMl0sdGhpcy5fc2V0TVFDaGVja2VyKCkpLHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVGltZXx8KHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVGltZT0xZTMqcGFyc2VGbG9hdCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0KFxcXCJbZGF0YS1vZmYtY2FudmFzLXdyYXBwZXJdXFxcIilbMF0pLnRyYW5zaXRpb25EdXJhdGlvbikpO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kZWxlbWVudC5vZmYoXFxcIi56Zi50cmlnZ2VyIC56Zi5vZmZjYW52YXNcXFwiKS5vbih7XFxcIm9wZW4uemYudHJpZ2dlclxcXCI6dGhpcy5vcGVuLmJpbmQodGhpcyksXFxcImNsb3NlLnpmLnRyaWdnZXJcXFwiOnRoaXMuY2xvc2UuYmluZCh0aGlzKSxcXFwidG9nZ2xlLnpmLnRyaWdnZXJcXFwiOnRoaXMudG9nZ2xlLmJpbmQodGhpcyksXFxcImtleWRvd24uemYub2ZmY2FudmFzXFxcIjp0aGlzLl9oYW5kbGVLZXlib2FyZC5iaW5kKHRoaXMpfSksdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayYmdGhpcy4kZXhpdGVyLmxlbmd0aCYmdGhpcy4kZXhpdGVyLm9uKHtcXFwiY2xpY2suemYub2ZmY2FudmFzXFxcIjp0aGlzLmNsb3NlLmJpbmQodGhpcyl9KTt9fSx7a2V5OlxcXCJfc2V0TVFDaGVja2VyXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7dCh3aW5kb3cpLm9uKFxcXCJjaGFuZ2VkLnpmLm1lZGlhcXVlcnlcXFwiLGZ1bmN0aW9uKCl7Rm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QoZS5vcHRpb25zLnJldmVhbE9uKT9lLnJldmVhbCghMCk6ZS5yZXZlYWwoITEpO30pLm9uZShcXFwibG9hZC56Zi5vZmZjYW52YXNcXFwiLGZ1bmN0aW9uKCl7Rm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QoZS5vcHRpb25zLnJldmVhbE9uKSYmZS5yZXZlYWwoITApO30pO319LHtrZXk6XFxcInJldmVhbFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGU9dGhpcy4kZWxlbWVudC5maW5kKFxcXCJbZGF0YS1jbG9zZV1cXFwiKTt0Pyh0aGlzLmNsb3NlKCksdGhpcy5pc1JldmVhbGVkPSEwLHRoaXMuJGVsZW1lbnQub2ZmKFxcXCJvcGVuLnpmLnRyaWdnZXIgdG9nZ2xlLnpmLnRyaWdnZXJcXFwiKSxlLmxlbmd0aCYmZS5oaWRlKCkpOih0aGlzLmlzUmV2ZWFsZWQ9ITEsdGhpcy4kZWxlbWVudC5vbih7XFxcIm9wZW4uemYudHJpZ2dlclxcXCI6dGhpcy5vcGVuLmJpbmQodGhpcyksXFxcInRvZ2dsZS56Zi50cmlnZ2VyXFxcIjp0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpfSksZS5sZW5ndGgmJmUuc2hvdygpKTt9fSx7a2V5OlxcXCJvcGVuXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlLGkpe2lmKCF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFxcXCJpcy1vcGVuXFxcIikmJiF0aGlzLmlzUmV2ZWFsZWQpe3ZhciBuPXRoaXM7dChkb2N1bWVudC5ib2R5KTt0aGlzLm9wdGlvbnMuZm9yY2VUb3AmJnQoXFxcImJvZHlcXFwiKS5zY3JvbGxUb3AoMCksRm91bmRhdGlvbi5Nb3ZlKHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVGltZSx0aGlzLiRlbGVtZW50LGZ1bmN0aW9uKCl7dChcXFwiW2RhdGEtb2ZmLWNhbnZhcy13cmFwcGVyXVxcXCIpLmFkZENsYXNzKFxcXCJpcy1vZmYtY2FudmFzLW9wZW4gaXMtb3Blbi1cXFwiK24ub3B0aW9ucy5wb3NpdGlvbiksbi4kZWxlbWVudC5hZGRDbGFzcyhcXFwiaXMtb3BlblxcXCIpO30pLHRoaXMuJHRyaWdnZXJzLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLFxcXCJ0cnVlXFxcIiksdGhpcy4kZWxlbWVudC5hdHRyKFxcXCJhcmlhLWhpZGRlblxcXCIsXFxcImZhbHNlXFxcIikudHJpZ2dlcihcXFwib3BlbmVkLnpmLm9mZmNhbnZhc1xcXCIpLHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2smJnRoaXMuJGV4aXRlci5hZGRDbGFzcyhcXFwiaXMtdmlzaWJsZVxcXCIpLGkmJih0aGlzLiRsYXN0VHJpZ2dlcj1pKSx0aGlzLm9wdGlvbnMuYXV0b0ZvY3VzJiZ0aGlzLiRlbGVtZW50Lm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQodGhpcy4kZWxlbWVudCksZnVuY3Rpb24oKXtuLiRlbGVtZW50LmZpbmQoXFxcImEsIGJ1dHRvblxcXCIpLmVxKDApLmZvY3VzKCk7fSksdGhpcy5vcHRpb25zLnRyYXBGb2N1cyYmKHQoXFxcIltkYXRhLW9mZi1jYW52YXMtY29udGVudF1cXFwiKS5hdHRyKFxcXCJ0YWJpbmRleFxcXCIsXFxcIi0xXFxcIiksdGhpcy5fdHJhcEZvY3VzKCkpO319fSx7a2V5OlxcXCJfdHJhcEZvY3VzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciB0PUZvdW5kYXRpb24uS2V5Ym9hcmQuZmluZEZvY3VzYWJsZSh0aGlzLiRlbGVtZW50KSxlPXQuZXEoMCksaT10LmVxKC0xKTt0Lm9mZihcXFwiLnpmLm9mZmNhbnZhc1xcXCIpLm9uKFxcXCJrZXlkb3duLnpmLm9mZmNhbnZhc1xcXCIsZnVuY3Rpb24odCl7OSE9PXQud2hpY2gmJjkhPT10LmtleWNvZGV8fCh0LnRhcmdldCE9PWlbMF18fHQuc2hpZnRLZXl8fCh0LnByZXZlbnREZWZhdWx0KCksZS5mb2N1cygpKSx0LnRhcmdldD09PWVbMF0mJnQuc2hpZnRLZXkmJih0LnByZXZlbnREZWZhdWx0KCksaS5mb2N1cygpKSk7fSk7fX0se2tleTpcXFwiY2xvc2VcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe2lmKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXFxcImlzLW9wZW5cXFwiKSYmIXRoaXMuaXNSZXZlYWxlZCl7dmFyIGk9dGhpczt0KFxcXCJbZGF0YS1vZmYtY2FudmFzLXdyYXBwZXJdXFxcIikucmVtb3ZlQ2xhc3MoXFxcImlzLW9mZi1jYW52YXMtb3BlbiBpcy1vcGVuLVxcXCIraS5vcHRpb25zLnBvc2l0aW9uKSxpLiRlbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJpcy1vcGVuXFxcIiksdGhpcy4kZWxlbWVudC5hdHRyKFxcXCJhcmlhLWhpZGRlblxcXCIsXFxcInRydWVcXFwiKS50cmlnZ2VyKFxcXCJjbG9zZWQuemYub2ZmY2FudmFzXFxcIiksdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayYmdGhpcy4kZXhpdGVyLnJlbW92ZUNsYXNzKFxcXCJpcy12aXNpYmxlXFxcIiksdGhpcy4kdHJpZ2dlcnMuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsXFxcImZhbHNlXFxcIiksdGhpcy5vcHRpb25zLnRyYXBGb2N1cyYmdChcXFwiW2RhdGEtb2ZmLWNhbnZhcy1jb250ZW50XVxcXCIpLnJlbW92ZUF0dHIoXFxcInRhYmluZGV4XFxcIik7fX19LHtrZXk6XFxcInRvZ2dsZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCxlKXt0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFxcXCJpcy1vcGVuXFxcIik/dGhpcy5jbG9zZSh0LGUpOnRoaXMub3Blbih0LGUpO319LHtrZXk6XFxcIl9oYW5kbGVLZXlib2FyZFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7Mjc9PT10LndoaWNoJiYodC5zdG9wUHJvcGFnYXRpb24oKSx0LnByZXZlbnREZWZhdWx0KCksdGhpcy5jbG9zZSgpLHRoaXMuJGxhc3RUcmlnZ2VyLmZvY3VzKCkpO319LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy5jbG9zZSgpLHRoaXMuJGVsZW1lbnQub2ZmKFxcXCIuemYudHJpZ2dlciAuemYub2ZmY2FudmFzXFxcIiksdGhpcy4kZXhpdGVyLm9mZihcXFwiLnpmLm9mZmNhbnZhc1xcXCIpLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pLGU7fSgpO2UuZGVmYXVsdHM9e2Nsb3NlT25DbGljazohMCx0cmFuc2l0aW9uVGltZTowLHBvc2l0aW9uOlxcXCJsZWZ0XFxcIixmb3JjZVRvcDohMCxpc1JldmVhbGVkOiExLHJldmVhbE9uOm51bGwsYXV0b0ZvY3VzOiEwLHJldmVhbENsYXNzOlxcXCJyZXZlYWwtZm9yLVxcXCIsdHJhcEZvY3VzOiExfSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJPZmZDYW52YXNcXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD1pLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG4pLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIk9yYml0XFxcIiksRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcihcXFwiT3JiaXRcXFwiLHtsdHI6e0FSUk9XX1JJR0hUOlxcXCJuZXh0XFxcIixBUlJPV19MRUZUOlxcXCJwcmV2aW91c1xcXCJ9LHJ0bDp7QVJST1dfTEVGVDpcXFwibmV4dFxcXCIsQVJST1dfUklHSFQ6XFxcInByZXZpb3VzXFxcIn19KTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiR3cmFwcGVyPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLmNvbnRhaW5lckNsYXNzKSx0aGlzLiRzbGlkZXM9dGhpcy4kZWxlbWVudC5maW5kKFxcXCIuXFxcIit0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcyk7dmFyIHQ9dGhpcy4kZWxlbWVudC5maW5kKFxcXCJpbWdcXFwiKSxlPXRoaXMuJHNsaWRlcy5maWx0ZXIoXFxcIi5pcy1hY3RpdmVcXFwiKTtlLmxlbmd0aHx8dGhpcy4kc2xpZGVzLmVxKDApLmFkZENsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKSx0aGlzLm9wdGlvbnMudXNlTVVJfHx0aGlzLiRzbGlkZXMuYWRkQ2xhc3MoXFxcIm5vLW1vdGlvbnVpXFxcIiksdC5sZW5ndGg/Rm91bmRhdGlvbi5vbkltYWdlc0xvYWRlZCh0LHRoaXMuX3ByZXBhcmVGb3JPcmJpdC5iaW5kKHRoaXMpKTp0aGlzLl9wcmVwYXJlRm9yT3JiaXQoKSx0aGlzLm9wdGlvbnMuYnVsbGV0cyYmdGhpcy5fbG9hZEJ1bGxldHMoKSx0aGlzLl9ldmVudHMoKSx0aGlzLm9wdGlvbnMuYXV0b1BsYXkmJnRoaXMuJHNsaWRlcy5sZW5ndGg+MSYmdGhpcy5nZW9TeW5jKCksdGhpcy5vcHRpb25zLmFjY2Vzc2libGUmJnRoaXMuJHdyYXBwZXIuYXR0cihcXFwidGFiaW5kZXhcXFwiLDApO319LHtrZXk6XFxcIl9sb2FkQnVsbGV0c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRidWxsZXRzPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLmJveE9mQnVsbGV0cykuZmluZChcXFwiYnV0dG9uXFxcIik7fX0se2tleTpcXFwiZ2VvU3luY1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgdD10aGlzO3RoaXMudGltZXI9bmV3IEZvdW5kYXRpb24uVGltZXIodGhpcy4kZWxlbWVudCx7ZHVyYXRpb246dGhpcy5vcHRpb25zLnRpbWVyRGVsYXksaW5maW5pdGU6ITF9LGZ1bmN0aW9uKCl7dC5jaGFuZ2VTbGlkZSghMCk7fSksdGhpcy50aW1lci5zdGFydCgpO319LHtrZXk6XFxcIl9wcmVwYXJlRm9yT3JiaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIHQ9dGhpczt0aGlzLl9zZXRXcmFwcGVySGVpZ2h0KGZ1bmN0aW9uKGUpe3QuX3NldFNsaWRlSGVpZ2h0KGUpO30pO319LHtrZXk6XFxcIl9zZXRXcmFwcGVySGVpZ2h0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXt2YXIgaSxuPTAscz0wO3RoaXMuJHNsaWRlcy5lYWNoKGZ1bmN0aW9uKCl7aT10aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCx0KHRoaXMpLmF0dHIoXFxcImRhdGEtc2xpZGVcXFwiLHMpLHMmJnQodGhpcykuY3NzKHtwb3NpdGlvbjpcXFwicmVsYXRpdmVcXFwiLGRpc3BsYXk6XFxcIm5vbmVcXFwifSksbj1pPm4/aTpuLHMrKzt9KSxzPT09dGhpcy4kc2xpZGVzLmxlbmd0aCYmKHRoaXMuJHdyYXBwZXIuY3NzKHtoZWlnaHQ6bn0pLGUobikpO319LHtrZXk6XFxcIl9zZXRTbGlkZUhlaWdodFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7dGhpcy4kc2xpZGVzLmVhY2goZnVuY3Rpb24oKXt0KHRoaXMpLmNzcyhcXFwibWF4LWhlaWdodFxcXCIsZSk7fSk7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzO2lmKHRoaXMuJHNsaWRlcy5sZW5ndGg+MSl7aWYodGhpcy5vcHRpb25zLnN3aXBlJiZ0aGlzLiRzbGlkZXMub2ZmKFxcXCJzd2lwZWxlZnQuemYub3JiaXQgc3dpcGVyaWdodC56Zi5vcmJpdFxcXCIpLm9uKFxcXCJzd2lwZWxlZnQuemYub3JiaXRcXFwiLGZ1bmN0aW9uKHQpe3QucHJldmVudERlZmF1bHQoKSxlLmNoYW5nZVNsaWRlKCEwKTt9KS5vbihcXFwic3dpcGVyaWdodC56Zi5vcmJpdFxcXCIsZnVuY3Rpb24odCl7dC5wcmV2ZW50RGVmYXVsdCgpLGUuY2hhbmdlU2xpZGUoITEpO30pLHRoaXMub3B0aW9ucy5hdXRvUGxheSYmKHRoaXMuJHNsaWRlcy5vbihcXFwiY2xpY2suemYub3JiaXRcXFwiLGZ1bmN0aW9uKCl7ZS4kZWxlbWVudC5kYXRhKFxcXCJjbGlja2VkT25cXFwiLCFlLiRlbGVtZW50LmRhdGEoXFxcImNsaWNrZWRPblxcXCIpKSxlLnRpbWVyW2UuJGVsZW1lbnQuZGF0YShcXFwiY2xpY2tlZE9uXFxcIik/XFxcInBhdXNlXFxcIjpcXFwic3RhcnRcXFwiXSgpO30pLHRoaXMub3B0aW9ucy5wYXVzZU9uSG92ZXImJnRoaXMuJGVsZW1lbnQub24oXFxcIm1vdXNlZW50ZXIuemYub3JiaXRcXFwiLGZ1bmN0aW9uKCl7ZS50aW1lci5wYXVzZSgpO30pLm9uKFxcXCJtb3VzZWxlYXZlLnpmLm9yYml0XFxcIixmdW5jdGlvbigpe2UuJGVsZW1lbnQuZGF0YShcXFwiY2xpY2tlZE9uXFxcIil8fGUudGltZXIuc3RhcnQoKTt9KSksdGhpcy5vcHRpb25zLm5hdkJ1dHRvbnMpe3ZhciBpPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLm5leHRDbGFzcytcXFwiLCAuXFxcIit0aGlzLm9wdGlvbnMucHJldkNsYXNzKTtpLmF0dHIoXFxcInRhYmluZGV4XFxcIiwwKS5vbihcXFwiY2xpY2suemYub3JiaXQgdG91Y2hlbmQuemYub3JiaXRcXFwiLGZ1bmN0aW9uKGkpe2kucHJldmVudERlZmF1bHQoKSxlLmNoYW5nZVNsaWRlKHQodGhpcykuaGFzQ2xhc3MoZS5vcHRpb25zLm5leHRDbGFzcykpO30pO310aGlzLm9wdGlvbnMuYnVsbGV0cyYmdGhpcy4kYnVsbGV0cy5vbihcXFwiY2xpY2suemYub3JiaXQgdG91Y2hlbmQuemYub3JiaXRcXFwiLGZ1bmN0aW9uKCl7aWYoL2lzLWFjdGl2ZS9nLnRlc3QodGhpcy5jbGFzc05hbWUpKXJldHVybiExO3ZhciBpPXQodGhpcykuZGF0YShcXFwic2xpZGVcXFwiKSxuPWk+ZS4kc2xpZGVzLmZpbHRlcihcXFwiLmlzLWFjdGl2ZVxcXCIpLmRhdGEoXFxcInNsaWRlXFxcIikscz1lLiRzbGlkZXMuZXEoaSk7ZS5jaGFuZ2VTbGlkZShuLHMsaSk7fSksdGhpcy4kd3JhcHBlci5hZGQodGhpcy4kYnVsbGV0cykub24oXFxcImtleWRvd24uemYub3JiaXRcXFwiLGZ1bmN0aW9uKGkpe0ZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGksXFxcIk9yYml0XFxcIix7bmV4dDpmdW5jdGlvbiBuZXh0KCl7ZS5jaGFuZ2VTbGlkZSghMCk7fSxwcmV2aW91czpmdW5jdGlvbiBwcmV2aW91cygpe2UuY2hhbmdlU2xpZGUoITEpO30saGFuZGxlZDpmdW5jdGlvbiBoYW5kbGVkKCl7dChpLnRhcmdldCkuaXMoZS4kYnVsbGV0cykmJmUuJGJ1bGxldHMuZmlsdGVyKFxcXCIuaXMtYWN0aXZlXFxcIikuZm9jdXMoKTt9fSk7fSk7fX19LHtrZXk6XFxcImNoYW5nZVNsaWRlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0LGUsaSl7dmFyIG49dGhpcy4kc2xpZGVzLmZpbHRlcihcXFwiLmlzLWFjdGl2ZVxcXCIpLmVxKDApO2lmKC9tdWkvZy50ZXN0KG5bMF0uY2xhc3NOYW1lKSlyZXR1cm4hMTt2YXIgcyxvPXRoaXMuJHNsaWRlcy5maXJzdCgpLGE9dGhpcy4kc2xpZGVzLmxhc3QoKSxyPXQ/XFxcIlJpZ2h0XFxcIjpcXFwiTGVmdFxcXCIsbD10P1xcXCJMZWZ0XFxcIjpcXFwiUmlnaHRcXFwiLHU9dGhpcztzPWU/ZTp0P3RoaXMub3B0aW9ucy5pbmZpbml0ZVdyYXA/bi5uZXh0KFxcXCIuXFxcIit0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykubGVuZ3RoP24ubmV4dChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpOm86bi5uZXh0KFxcXCIuXFxcIit0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcyk6dGhpcy5vcHRpb25zLmluZmluaXRlV3JhcD9uLnByZXYoXFxcIi5cXFwiK3RoaXMub3B0aW9ucy5zbGlkZUNsYXNzKS5sZW5ndGg/bi5wcmV2KFxcXCIuXFxcIit0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcyk6YTpuLnByZXYoXFxcIi5cXFwiK3RoaXMub3B0aW9ucy5zbGlkZUNsYXNzKSxzLmxlbmd0aCYmKHRoaXMub3B0aW9ucy5idWxsZXRzJiYoaT1pfHx0aGlzLiRzbGlkZXMuaW5kZXgocyksdGhpcy5fdXBkYXRlQnVsbGV0cyhpKSksdGhpcy5vcHRpb25zLnVzZU1VST8oRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZUluKHMuYWRkQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLmNzcyh7cG9zaXRpb246XFxcImFic29sdXRlXFxcIix0b3A6MH0pLHRoaXMub3B0aW9uc1tcXFwiYW5pbUluRnJvbVxcXCIrcl0sZnVuY3Rpb24oKXtzLmNzcyh7cG9zaXRpb246XFxcInJlbGF0aXZlXFxcIixkaXNwbGF5OlxcXCJibG9ja1xcXCJ9KS5hdHRyKFxcXCJhcmlhLWxpdmVcXFwiLFxcXCJwb2xpdGVcXFwiKTt9KSxGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlT3V0KG4ucmVtb3ZlQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLHRoaXMub3B0aW9uc1tcXFwiYW5pbU91dFRvXFxcIitsXSxmdW5jdGlvbigpe24ucmVtb3ZlQXR0cihcXFwiYXJpYS1saXZlXFxcIiksdS5vcHRpb25zLmF1dG9QbGF5JiYhdS50aW1lci5pc1BhdXNlZCYmdS50aW1lci5yZXN0YXJ0KCk7fSkpOihuLnJlbW92ZUNsYXNzKFxcXCJpcy1hY3RpdmUgaXMtaW5cXFwiKS5yZW1vdmVBdHRyKFxcXCJhcmlhLWxpdmVcXFwiKS5oaWRlKCkscy5hZGRDbGFzcyhcXFwiaXMtYWN0aXZlIGlzLWluXFxcIikuYXR0cihcXFwiYXJpYS1saXZlXFxcIixcXFwicG9saXRlXFxcIikuc2hvdygpLHRoaXMub3B0aW9ucy5hdXRvUGxheSYmIXRoaXMudGltZXIuaXNQYXVzZWQmJnRoaXMudGltZXIucmVzdGFydCgpKSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcInNsaWRlY2hhbmdlLnpmLm9yYml0XFxcIixbc10pKTt9fSx7a2V5OlxcXCJfdXBkYXRlQnVsbGV0c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGU9dGhpcy4kZWxlbWVudC5maW5kKFxcXCIuXFxcIit0aGlzLm9wdGlvbnMuYm94T2ZCdWxsZXRzKS5maW5kKFxcXCIuaXMtYWN0aXZlXFxcIikucmVtb3ZlQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLmJsdXIoKSxpPWUuZmluZChcXFwic3BhbjpsYXN0XFxcIikuZGV0YWNoKCk7dGhpcy4kYnVsbGV0cy5lcSh0KS5hZGRDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIikuYXBwZW5kKGkpO319LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kZWxlbWVudC5vZmYoXFxcIi56Zi5vcmJpdFxcXCIpLmZpbmQoXFxcIipcXFwiKS5vZmYoXFxcIi56Zi5vcmJpdFxcXCIpLmVuZCgpLmhpZGUoKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXtidWxsZXRzOiEwLG5hdkJ1dHRvbnM6ITAsYW5pbUluRnJvbVJpZ2h0OlxcXCJzbGlkZS1pbi1yaWdodFxcXCIsYW5pbU91dFRvUmlnaHQ6XFxcInNsaWRlLW91dC1yaWdodFxcXCIsYW5pbUluRnJvbUxlZnQ6XFxcInNsaWRlLWluLWxlZnRcXFwiLGFuaW1PdXRUb0xlZnQ6XFxcInNsaWRlLW91dC1sZWZ0XFxcIixhdXRvUGxheTohMCx0aW1lckRlbGF5OjVlMyxpbmZpbml0ZVdyYXA6ITAsc3dpcGU6ITAscGF1c2VPbkhvdmVyOiEwLGFjY2Vzc2libGU6ITAsY29udGFpbmVyQ2xhc3M6XFxcIm9yYml0LWNvbnRhaW5lclxcXCIsc2xpZGVDbGFzczpcXFwib3JiaXQtc2xpZGVcXFwiLGJveE9mQnVsbGV0czpcXFwib3JiaXQtYnVsbGV0c1xcXCIsbmV4dENsYXNzOlxcXCJvcmJpdC1uZXh0XFxcIixwcmV2Q2xhc3M6XFxcIm9yYml0LXByZXZpb3VzXFxcIix1c2VNVUk6ITB9LEZvdW5kYXRpb24ucGx1Z2luKGUsXFxcIk9yYml0XFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9dChpKSx0aGlzLnJ1bGVzPXRoaXMuJGVsZW1lbnQuZGF0YShcXFwicmVzcG9uc2l2ZS1tZW51XFxcIiksdGhpcy5jdXJyZW50TXE9bnVsbCx0aGlzLmN1cnJlbnRQbHVnaW49bnVsbCx0aGlzLl9pbml0KCksdGhpcy5fZXZlbnRzKCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFxcXCJSZXNwb25zaXZlTWVudVxcXCIpO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe2lmKFxcXCJzdHJpbmdcXFwiPT10eXBlb2YgdGhpcy5ydWxlcyl7Zm9yKHZhciBlPXt9LG49dGhpcy5ydWxlcy5zcGxpdChcXFwiIFxcXCIpLHM9MDtzPG4ubGVuZ3RoO3MrKyl7dmFyIG89bltzXS5zcGxpdChcXFwiLVxcXCIpLGE9by5sZW5ndGg+MT9vWzBdOlxcXCJzbWFsbFxcXCIscj1vLmxlbmd0aD4xP29bMV06b1swXTtudWxsIT09aVtyXSYmKGVbYV09aVtyXSk7fXRoaXMucnVsZXM9ZTt9dC5pc0VtcHR5T2JqZWN0KHRoaXMucnVsZXMpfHx0aGlzLl9jaGVja01lZGlhUXVlcmllcygpO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpczt0KHdpbmRvdykub24oXFxcImNoYW5nZWQuemYubWVkaWFxdWVyeVxcXCIsZnVuY3Rpb24oKXtlLl9jaGVja01lZGlhUXVlcmllcygpO30pO319LHtrZXk6XFxcIl9jaGVja01lZGlhUXVlcmllc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZSxuPXRoaXM7dC5lYWNoKHRoaXMucnVsZXMsZnVuY3Rpb24odCl7Rm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QodCkmJihlPXQpO30pLGUmJih0aGlzLmN1cnJlbnRQbHVnaW4gaW5zdGFuY2VvZiB0aGlzLnJ1bGVzW2VdLnBsdWdpbnx8KHQuZWFjaChpLGZ1bmN0aW9uKHQsZSl7bi4kZWxlbWVudC5yZW1vdmVDbGFzcyhlLmNzc0NsYXNzKTt9KSx0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMucnVsZXNbZV0uY3NzQ2xhc3MpLHRoaXMuY3VycmVudFBsdWdpbiYmdGhpcy5jdXJyZW50UGx1Z2luLmRlc3Ryb3koKSx0aGlzLmN1cnJlbnRQbHVnaW49bmV3IHRoaXMucnVsZXNbZV0ucGx1Z2luKHRoaXMuJGVsZW1lbnQse30pKSk7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLmN1cnJlbnRQbHVnaW4uZGVzdHJveSgpLHQod2luZG93KS5vZmYoXFxcIi56Zi5SZXNwb25zaXZlTWVudVxcXCIpLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pLGU7fSgpO2UuZGVmYXVsdHM9e307dmFyIGk9e2Ryb3Bkb3duOntjc3NDbGFzczpcXFwiZHJvcGRvd25cXFwiLHBsdWdpbjpGb3VuZGF0aW9uLl9wbHVnaW5zW1xcXCJkcm9wZG93bi1tZW51XFxcIl18fG51bGx9LGRyaWxsZG93bjp7Y3NzQ2xhc3M6XFxcImRyaWxsZG93blxcXCIscGx1Z2luOkZvdW5kYXRpb24uX3BsdWdpbnMuZHJpbGxkb3dufHxudWxsfSxhY2NvcmRpb246e2Nzc0NsYXNzOlxcXCJhY2NvcmRpb24tbWVudVxcXCIscGx1Z2luOkZvdW5kYXRpb24uX3BsdWdpbnNbXFxcImFjY29yZGlvbi1tZW51XFxcIl18fG51bGx9fTtGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJSZXNwb25zaXZlTWVudVxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PXQoaSksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy5faW5pdCgpLHRoaXMuX2V2ZW50cygpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiUmVzcG9uc2l2ZVRvZ2dsZVxcXCIpO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXMuJGVsZW1lbnQuZGF0YShcXFwicmVzcG9uc2l2ZS10b2dnbGVcXFwiKTtlfHxjb25zb2xlLmVycm9yKFxcXCJZb3VyIHRhYiBiYXIgbmVlZHMgYW4gSUQgb2YgYSBNZW51IGFzIHRoZSB2YWx1ZSBvZiBkYXRhLXRhYi1iYXIuXFxcIiksdGhpcy4kdGFyZ2V0TWVudT10KFxcXCIjXFxcIitlKSx0aGlzLiR0b2dnbGVyPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiW2RhdGEtdG9nZ2xlXVxcXCIpLHRoaXMuX3VwZGF0ZSgpO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy5fdXBkYXRlTXFIYW5kbGVyPXRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMpLHQod2luZG93KS5vbihcXFwiY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5XFxcIix0aGlzLl91cGRhdGVNcUhhbmRsZXIpLHRoaXMuJHRvZ2dsZXIub24oXFxcImNsaWNrLnpmLnJlc3BvbnNpdmVUb2dnbGVcXFwiLHRoaXMudG9nZ2xlTWVudS5iaW5kKHRoaXMpKTt9fSx7a2V5OlxcXCJfdXBkYXRlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe0ZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KHRoaXMub3B0aW9ucy5oaWRlRm9yKT8odGhpcy4kZWxlbWVudC5oaWRlKCksdGhpcy4kdGFyZ2V0TWVudS5zaG93KCkpOih0aGlzLiRlbGVtZW50LnNob3coKSx0aGlzLiR0YXJnZXRNZW51LmhpZGUoKSk7fX0se2tleTpcXFwidG9nZ2xlTWVudVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXtGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdCh0aGlzLm9wdGlvbnMuaGlkZUZvcil8fCh0aGlzLiR0YXJnZXRNZW51LnRvZ2dsZSgwKSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcInRvZ2dsZWQuemYucmVzcG9uc2l2ZVRvZ2dsZVxcXCIpKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuJGVsZW1lbnQub2ZmKFxcXCIuemYucmVzcG9uc2l2ZVRvZ2dsZVxcXCIpLHRoaXMuJHRvZ2dsZXIub2ZmKFxcXCIuemYucmVzcG9uc2l2ZVRvZ2dsZVxcXCIpLHQod2luZG93KS5vZmYoXFxcImNoYW5nZWQuemYubWVkaWFxdWVyeVxcXCIsdGhpcy5fdXBkYXRlTXFIYW5kbGVyKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxlO30oKTtlLmRlZmF1bHRzPXtoaWRlRm9yOlxcXCJtZWRpdW1cXFwifSxGb3VuZGF0aW9uLnBsdWdpbihlLFxcXCJSZXNwb25zaXZlVG9nZ2xlXFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gL2lQKGFkfGhvbmV8b2QpLipPUy8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7fWZ1bmN0aW9uIGkoKXtyZXR1cm4gL0FuZHJvaWQvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO31mdW5jdGlvbiBuKCl7cmV0dXJuIGUoKXx8aSgpO312YXIgcz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksbiksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiUmV2ZWFsXFxcIiksRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcihcXFwiUmV2ZWFsXFxcIix7RU5URVI6XFxcIm9wZW5cXFwiLFNQQUNFOlxcXCJvcGVuXFxcIixFU0NBUEU6XFxcImNsb3NlXFxcIixUQUI6XFxcInRhYl9mb3J3YXJkXFxcIixTSElGVF9UQUI6XFxcInRhYl9iYWNrd2FyZFxcXCJ9KTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLmlkPXRoaXMuJGVsZW1lbnQuYXR0cihcXFwiaWRcXFwiKSx0aGlzLmlzQWN0aXZlPSExLHRoaXMuY2FjaGVkPXttcTpGb3VuZGF0aW9uLk1lZGlhUXVlcnkuY3VycmVudH0sdGhpcy5pc01vYmlsZT1uKCksdGhpcy4kYW5jaG9yPXQodCgnW2RhdGEtb3Blbj1cXFwiJyt0aGlzLmlkKydcXFwiXScpLmxlbmd0aD8nW2RhdGEtb3Blbj1cXFwiJyt0aGlzLmlkKydcXFwiXSc6J1tkYXRhLXRvZ2dsZT1cXFwiJyt0aGlzLmlkKydcXFwiXScpLHRoaXMuJGFuY2hvci5hdHRyKHtcXFwiYXJpYS1jb250cm9sc1xcXCI6dGhpcy5pZCxcXFwiYXJpYS1oYXNwb3B1cFxcXCI6ITAsdGFiaW5kZXg6MH0pLCh0aGlzLm9wdGlvbnMuZnVsbFNjcmVlbnx8dGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcXFwiZnVsbFxcXCIpKSYmKHRoaXMub3B0aW9ucy5mdWxsU2NyZWVuPSEwLHRoaXMub3B0aW9ucy5vdmVybGF5PSExKSx0aGlzLm9wdGlvbnMub3ZlcmxheSYmIXRoaXMuJG92ZXJsYXkmJih0aGlzLiRvdmVybGF5PXRoaXMuX21ha2VPdmVybGF5KHRoaXMuaWQpKSx0aGlzLiRlbGVtZW50LmF0dHIoe3JvbGU6XFxcImRpYWxvZ1xcXCIsXFxcImFyaWEtaGlkZGVuXFxcIjohMCxcXFwiZGF0YS15ZXRpLWJveFxcXCI6dGhpcy5pZCxcXFwiZGF0YS1yZXNpemVcXFwiOnRoaXMuaWR9KSx0aGlzLiRvdmVybGF5P3RoaXMuJGVsZW1lbnQuZGV0YWNoKCkuYXBwZW5kVG8odGhpcy4kb3ZlcmxheSk6KHRoaXMuJGVsZW1lbnQuZGV0YWNoKCkuYXBwZW5kVG8odChcXFwiYm9keVxcXCIpKSx0aGlzLiRlbGVtZW50LmFkZENsYXNzKFxcXCJ3aXRob3V0LW92ZXJsYXlcXFwiKSksdGhpcy5fZXZlbnRzKCksdGhpcy5vcHRpb25zLmRlZXBMaW5rJiZ3aW5kb3cubG9jYXRpb24uaGFzaD09PVxcXCIjXFxcIit0aGlzLmlkJiZ0KHdpbmRvdykub25lKFxcXCJsb2FkLnpmLnJldmVhbFxcXCIsdGhpcy5vcGVuLmJpbmQodGhpcykpO319LHtrZXk6XFxcIl9tYWtlT3ZlcmxheVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7dmFyIGk9dChcXFwiPGRpdj48L2Rpdj5cXFwiKS5hZGRDbGFzcyhcXFwicmV2ZWFsLW92ZXJsYXlcXFwiKS5hcHBlbmRUbyhcXFwiYm9keVxcXCIpO3JldHVybiBpO319LHtrZXk6XFxcIl91cGRhdGVQb3NpdGlvblxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZSxpLG49dGhpcy4kZWxlbWVudC5vdXRlcldpZHRoKCkscz10KHdpbmRvdykud2lkdGgoKSxvPXRoaXMuJGVsZW1lbnQub3V0ZXJIZWlnaHQoKSxhPXQod2luZG93KS5oZWlnaHQoKTtlPVxcXCJhdXRvXFxcIj09PXRoaXMub3B0aW9ucy5oT2Zmc2V0P3BhcnNlSW50KChzLW4pLzIsMTApOnBhcnNlSW50KHRoaXMub3B0aW9ucy5oT2Zmc2V0LDEwKSxpPVxcXCJhdXRvXFxcIj09PXRoaXMub3B0aW9ucy52T2Zmc2V0P28+YT9wYXJzZUludChNYXRoLm1pbigxMDAsYS8xMCksMTApOnBhcnNlSW50KChhLW8pLzQsMTApOnBhcnNlSW50KHRoaXMub3B0aW9ucy52T2Zmc2V0LDEwKSx0aGlzLiRlbGVtZW50LmNzcyh7dG9wOmkrXFxcInB4XFxcIn0pLHRoaXMuJG92ZXJsYXkmJlxcXCJhdXRvXFxcIj09PXRoaXMub3B0aW9ucy5oT2Zmc2V0fHwodGhpcy4kZWxlbWVudC5jc3Moe2xlZnQ6ZStcXFwicHhcXFwifSksdGhpcy4kZWxlbWVudC5jc3Moe21hcmdpbjpcXFwiMHB4XFxcIn0pKTt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXMsaT10aGlzO3RoaXMuJGVsZW1lbnQub24oe1xcXCJvcGVuLnpmLnRyaWdnZXJcXFwiOnRoaXMub3Blbi5iaW5kKHRoaXMpLFxcXCJjbG9zZS56Zi50cmlnZ2VyXFxcIjpmdW5jdGlvbiBjbG9zZVpmVHJpZ2dlcihuLHMpe3JldHVybiBuLnRhcmdldD09PWkuJGVsZW1lbnRbMF18fHQobi50YXJnZXQpLnBhcmVudHMoXFxcIltkYXRhLWNsb3NhYmxlXVxcXCIpWzBdPT09cz9lLmNsb3NlLmFwcGx5KGUpOnZvaWQgMDt9LFxcXCJ0b2dnbGUuemYudHJpZ2dlclxcXCI6dGhpcy50b2dnbGUuYmluZCh0aGlzKSxcXFwicmVzaXplbWUuemYudHJpZ2dlclxcXCI6ZnVuY3Rpb24gcmVzaXplbWVaZlRyaWdnZXIoKXtpLl91cGRhdGVQb3NpdGlvbigpO319KSx0aGlzLiRhbmNob3IubGVuZ3RoJiZ0aGlzLiRhbmNob3Iub24oXFxcImtleWRvd24uemYucmV2ZWFsXFxcIixmdW5jdGlvbih0KXsxMyE9PXQud2hpY2gmJjMyIT09dC53aGljaHx8KHQuc3RvcFByb3BhZ2F0aW9uKCksdC5wcmV2ZW50RGVmYXVsdCgpLGkub3BlbigpKTt9KSx0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrJiZ0aGlzLm9wdGlvbnMub3ZlcmxheSYmdGhpcy4kb3ZlcmxheS5vZmYoXFxcIi56Zi5yZXZlYWxcXFwiKS5vbihcXFwiY2xpY2suemYucmV2ZWFsXFxcIixmdW5jdGlvbihlKXtlLnRhcmdldD09PWkuJGVsZW1lbnRbMF18fHQuY29udGFpbnMoaS4kZWxlbWVudFswXSxlLnRhcmdldCl8fGkuY2xvc2UoKTt9KSx0aGlzLm9wdGlvbnMuZGVlcExpbmsmJnQod2luZG93KS5vbihcXFwicG9wc3RhdGUuemYucmV2ZWFsOlxcXCIrdGhpcy5pZCx0aGlzLl9oYW5kbGVTdGF0ZS5iaW5kKHRoaXMpKTt9fSx7a2V5OlxcXCJfaGFuZGxlU3RhdGVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3dpbmRvdy5sb2NhdGlvbi5oYXNoIT09XFxcIiNcXFwiK3RoaXMuaWR8fHRoaXMuaXNBY3RpdmU/dGhpcy5jbG9zZSgpOnRoaXMub3BlbigpO319LHtrZXk6XFxcIm9wZW5cXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcztpZih0aGlzLm9wdGlvbnMuZGVlcExpbmspe3ZhciBpPVxcXCIjXFxcIit0aGlzLmlkO3dpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZT93aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUobnVsbCxudWxsLGkpOndpbmRvdy5sb2NhdGlvbi5oYXNoPWk7fWlmKHRoaXMuaXNBY3RpdmU9ITAsdGhpcy4kZWxlbWVudC5jc3Moe3Zpc2liaWxpdHk6XFxcImhpZGRlblxcXCJ9KS5zaG93KCkuc2Nyb2xsVG9wKDApLHRoaXMub3B0aW9ucy5vdmVybGF5JiZ0aGlzLiRvdmVybGF5LmNzcyh7dmlzaWJpbGl0eTpcXFwiaGlkZGVuXFxcIn0pLnNob3coKSx0aGlzLl91cGRhdGVQb3NpdGlvbigpLHRoaXMuJGVsZW1lbnQuaGlkZSgpLmNzcyh7dmlzaWJpbGl0eTpcXFwiXFxcIn0pLHRoaXMuJG92ZXJsYXkmJih0aGlzLiRvdmVybGF5LmNzcyh7dmlzaWJpbGl0eTpcXFwiXFxcIn0pLmhpZGUoKSx0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFxcXCJmYXN0XFxcIik/dGhpcy4kb3ZlcmxheS5hZGRDbGFzcyhcXFwiZmFzdFxcXCIpOnRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXFxcInNsb3dcXFwiKSYmdGhpcy4kb3ZlcmxheS5hZGRDbGFzcyhcXFwic2xvd1xcXCIpKSx0aGlzLm9wdGlvbnMubXVsdGlwbGVPcGVuZWR8fHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwiY2xvc2VtZS56Zi5yZXZlYWxcXFwiLHRoaXMuaWQpLHRoaXMub3B0aW9ucy5hbmltYXRpb25Jbil7dmFyIG47IWZ1bmN0aW9uKCl7dmFyIHQ9ZnVuY3Rpb24gdCgpe24uJGVsZW1lbnQuYXR0cih7XFxcImFyaWEtaGlkZGVuXFxcIjohMSx0YWJpbmRleDotMX0pLmZvY3VzKCksY29uc29sZS5sb2coXFxcImZvY3VzXFxcIik7fTtuPWUsZS5vcHRpb25zLm92ZXJsYXkmJkZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVJbihlLiRvdmVybGF5LFxcXCJmYWRlLWluXFxcIiksRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZUluKGUuJGVsZW1lbnQsZS5vcHRpb25zLmFuaW1hdGlvbkluLGZ1bmN0aW9uKCl7ZS5mb2N1c2FibGVFbGVtZW50cz1Gb3VuZGF0aW9uLktleWJvYXJkLmZpbmRGb2N1c2FibGUoZS4kZWxlbWVudCksdCgpO30pO30oKTt9ZWxzZSB0aGlzLm9wdGlvbnMub3ZlcmxheSYmdGhpcy4kb3ZlcmxheS5zaG93KDApLHRoaXMuJGVsZW1lbnQuc2hvdyh0aGlzLm9wdGlvbnMuc2hvd0RlbGF5KTt0aGlzLiRlbGVtZW50LmF0dHIoe1xcXCJhcmlhLWhpZGRlblxcXCI6ITEsdGFiaW5kZXg6LTF9KS5mb2N1cygpLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwib3Blbi56Zi5yZXZlYWxcXFwiKSx0aGlzLmlzTW9iaWxlPyh0aGlzLm9yaWdpbmFsU2Nyb2xsUG9zPXdpbmRvdy5wYWdlWU9mZnNldCx0KFxcXCJodG1sLCBib2R5XFxcIikuYWRkQ2xhc3MoXFxcImlzLXJldmVhbC1vcGVuXFxcIikpOnQoXFxcImJvZHlcXFwiKS5hZGRDbGFzcyhcXFwiaXMtcmV2ZWFsLW9wZW5cXFwiKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5fZXh0cmFIYW5kbGVycygpO30sMCk7fX0se2tleTpcXFwiX2V4dHJhSGFuZGxlcnNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpczt0aGlzLmZvY3VzYWJsZUVsZW1lbnRzPUZvdW5kYXRpb24uS2V5Ym9hcmQuZmluZEZvY3VzYWJsZSh0aGlzLiRlbGVtZW50KSx0aGlzLm9wdGlvbnMub3ZlcmxheXx8IXRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2t8fHRoaXMub3B0aW9ucy5mdWxsU2NyZWVufHx0KFxcXCJib2R5XFxcIikub24oXFxcImNsaWNrLnpmLnJldmVhbFxcXCIsZnVuY3Rpb24oaSl7aS50YXJnZXQ9PT1lLiRlbGVtZW50WzBdfHx0LmNvbnRhaW5zKGUuJGVsZW1lbnRbMF0saS50YXJnZXQpfHxlLmNsb3NlKCk7fSksdGhpcy5vcHRpb25zLmNsb3NlT25Fc2MmJnQod2luZG93KS5vbihcXFwia2V5ZG93bi56Zi5yZXZlYWxcXFwiLGZ1bmN0aW9uKHQpe0ZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KHQsXFxcIlJldmVhbFxcXCIse2Nsb3NlOmZ1bmN0aW9uIGNsb3NlKCl7ZS5vcHRpb25zLmNsb3NlT25Fc2MmJihlLmNsb3NlKCksZS4kYW5jaG9yLmZvY3VzKCkpO319KTt9KSx0aGlzLiRlbGVtZW50Lm9uKFxcXCJrZXlkb3duLnpmLnJldmVhbFxcXCIsZnVuY3Rpb24oaSl7dmFyIG49dCh0aGlzKTtGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShpLFxcXCJSZXZlYWxcXFwiLHt0YWJfZm9yd2FyZDpmdW5jdGlvbiB0YWJfZm9yd2FyZCgpe3JldHVybiBlLiRlbGVtZW50LmZpbmQoXFxcIjpmb2N1c1xcXCIpLmlzKGUuZm9jdXNhYmxlRWxlbWVudHMuZXEoLTEpKT8oZS5mb2N1c2FibGVFbGVtZW50cy5lcSgwKS5mb2N1cygpLCEwKTowPT09ZS5mb2N1c2FibGVFbGVtZW50cy5sZW5ndGg/ITA6dm9pZCAwO30sdGFiX2JhY2t3YXJkOmZ1bmN0aW9uIHRhYl9iYWNrd2FyZCgpe3JldHVybiBlLiRlbGVtZW50LmZpbmQoXFxcIjpmb2N1c1xcXCIpLmlzKGUuZm9jdXNhYmxlRWxlbWVudHMuZXEoMCkpfHxlLiRlbGVtZW50LmlzKFxcXCI6Zm9jdXNcXFwiKT8oZS5mb2N1c2FibGVFbGVtZW50cy5lcSgtMSkuZm9jdXMoKSwhMCk6MD09PWUuZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoPyEwOnZvaWQgMDt9LG9wZW46ZnVuY3Rpb24gb3Blbigpe2UuJGVsZW1lbnQuZmluZChcXFwiOmZvY3VzXFxcIikuaXMoZS4kZWxlbWVudC5maW5kKFxcXCJbZGF0YS1jbG9zZV1cXFwiKSk/c2V0VGltZW91dChmdW5jdGlvbigpe2UuJGFuY2hvci5mb2N1cygpO30sMSk6bi5pcyhlLmZvY3VzYWJsZUVsZW1lbnRzKSYmZS5vcGVuKCk7fSxjbG9zZTpmdW5jdGlvbiBjbG9zZSgpe2Uub3B0aW9ucy5jbG9zZU9uRXNjJiYoZS5jbG9zZSgpLGUuJGFuY2hvci5mb2N1cygpKTt9LGhhbmRsZWQ6ZnVuY3Rpb24gaGFuZGxlZCh0KXt0JiZpLnByZXZlbnREZWZhdWx0KCk7fX0pO30pO319LHtrZXk6XFxcImNsb3NlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe2Z1bmN0aW9uIGUoKXtpLmlzTW9iaWxlPyh0KFxcXCJodG1sLCBib2R5XFxcIikucmVtb3ZlQ2xhc3MoXFxcImlzLXJldmVhbC1vcGVuXFxcIiksaS5vcmlnaW5hbFNjcm9sbFBvcyYmKHQoXFxcImJvZHlcXFwiKS5zY3JvbGxUb3AoaS5vcmlnaW5hbFNjcm9sbFBvcyksaS5vcmlnaW5hbFNjcm9sbFBvcz1udWxsKSk6dChcXFwiYm9keVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJpcy1yZXZlYWwtb3BlblxcXCIpLGkuJGVsZW1lbnQuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLCEwKSxpLiRlbGVtZW50LnRyaWdnZXIoXFxcImNsb3NlZC56Zi5yZXZlYWxcXFwiKTt9aWYoIXRoaXMuaXNBY3RpdmV8fCF0aGlzLiRlbGVtZW50LmlzKFxcXCI6dmlzaWJsZVxcXCIpKXJldHVybiExO3ZhciBpPXRoaXM7dGhpcy5vcHRpb25zLmFuaW1hdGlvbk91dD8odGhpcy5vcHRpb25zLm92ZXJsYXk/Rm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZU91dCh0aGlzLiRvdmVybGF5LFxcXCJmYWRlLW91dFxcXCIsZSk6ZSgpLEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVPdXQodGhpcy4kZWxlbWVudCx0aGlzLm9wdGlvbnMuYW5pbWF0aW9uT3V0KSk6KHRoaXMub3B0aW9ucy5vdmVybGF5P3RoaXMuJG92ZXJsYXkuaGlkZSgwLGUpOmUoKSx0aGlzLiRlbGVtZW50LmhpZGUodGhpcy5vcHRpb25zLmhpZGVEZWxheSkpLHRoaXMub3B0aW9ucy5jbG9zZU9uRXNjJiZ0KHdpbmRvdykub2ZmKFxcXCJrZXlkb3duLnpmLnJldmVhbFxcXCIpLCF0aGlzLm9wdGlvbnMub3ZlcmxheSYmdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayYmdChcXFwiYm9keVxcXCIpLm9mZihcXFwiY2xpY2suemYucmV2ZWFsXFxcIiksdGhpcy4kZWxlbWVudC5vZmYoXFxcImtleWRvd24uemYucmV2ZWFsXFxcIiksdGhpcy5vcHRpb25zLnJlc2V0T25DbG9zZSYmdGhpcy4kZWxlbWVudC5odG1sKHRoaXMuJGVsZW1lbnQuaHRtbCgpKSx0aGlzLmlzQWN0aXZlPSExLGkub3B0aW9ucy5kZWVwTGluayYmKHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZT93aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoXFxcIlxcXCIsZG9jdW1lbnQudGl0bGUsd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lKTp3aW5kb3cubG9jYXRpb24uaGFzaD1cXFwiXFxcIik7fX0se2tleTpcXFwidG9nZ2xlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuaXNBY3RpdmU/dGhpcy5jbG9zZSgpOnRoaXMub3BlbigpO319LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy5vcHRpb25zLm92ZXJsYXkmJih0aGlzLiRlbGVtZW50LmFwcGVuZFRvKHQoXFxcImJvZHlcXFwiKSksdGhpcy4kb3ZlcmxheS5oaWRlKCkub2ZmKCkucmVtb3ZlKCkpLHRoaXMuJGVsZW1lbnQuaGlkZSgpLm9mZigpLHRoaXMuJGFuY2hvci5vZmYoXFxcIi56ZlxcXCIpLHQod2luZG93KS5vZmYoXFxcIi56Zi5yZXZlYWw6XFxcIit0aGlzLmlkKSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxlO30oKTtzLmRlZmF1bHRzPXthbmltYXRpb25JbjpcXFwiXFxcIixhbmltYXRpb25PdXQ6XFxcIlxcXCIsc2hvd0RlbGF5OjAsaGlkZURlbGF5OjAsY2xvc2VPbkNsaWNrOiEwLGNsb3NlT25Fc2M6ITAsbXVsdGlwbGVPcGVuZWQ6ITEsdk9mZnNldDpcXFwiYXV0b1xcXCIsaE9mZnNldDpcXFwiYXV0b1xcXCIsZnVsbFNjcmVlbjohMSxidG1PZmZzZXRQY3Q6MTAsb3ZlcmxheTohMCxyZXNldE9uQ2xvc2U6ITEsZGVlcExpbms6ITF9LEZvdW5kYXRpb24ucGx1Z2luKHMsXFxcIlJldmVhbFxcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQsZSl7cmV0dXJuIHQvZTt9ZnVuY3Rpb24gaSh0LGUsaSxuKXtyZXR1cm4gTWF0aC5hYnModC5wb3NpdGlvbigpW2VdK3Rbbl0oKS8yLWkpO312YXIgbj1mdW5jdGlvbigpe2Z1bmN0aW9uIG4oZSxpKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxuKSx0aGlzLiRlbGVtZW50PWUsdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LG4uZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksaSksdGhpcy5faW5pdCgpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiU2xpZGVyXFxcIiksRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcihcXFwiU2xpZGVyXFxcIix7bHRyOntBUlJPV19SSUdIVDpcXFwiaW5jcmVhc2VcXFwiLEFSUk9XX1VQOlxcXCJpbmNyZWFzZVxcXCIsQVJST1dfRE9XTjpcXFwiZGVjcmVhc2VcXFwiLEFSUk9XX0xFRlQ6XFxcImRlY3JlYXNlXFxcIixTSElGVF9BUlJPV19SSUdIVDpcXFwiaW5jcmVhc2VfZmFzdFxcXCIsU0hJRlRfQVJST1dfVVA6XFxcImluY3JlYXNlX2Zhc3RcXFwiLFNISUZUX0FSUk9XX0RPV046XFxcImRlY3JlYXNlX2Zhc3RcXFwiLFNISUZUX0FSUk9XX0xFRlQ6XFxcImRlY3JlYXNlX2Zhc3RcXFwifSxydGw6e0FSUk9XX0xFRlQ6XFxcImluY3JlYXNlXFxcIixBUlJPV19SSUdIVDpcXFwiZGVjcmVhc2VcXFwiLFNISUZUX0FSUk9XX0xFRlQ6XFxcImluY3JlYXNlX2Zhc3RcXFwiLFNISUZUX0FSUk9XX1JJR0hUOlxcXCJkZWNyZWFzZV9mYXN0XFxcIn19KTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhuLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLmlucHV0cz10aGlzLiRlbGVtZW50LmZpbmQoXFxcImlucHV0XFxcIiksdGhpcy5oYW5kbGVzPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiW2RhdGEtc2xpZGVyLWhhbmRsZV1cXFwiKSx0aGlzLiRoYW5kbGU9dGhpcy5oYW5kbGVzLmVxKDApLHRoaXMuJGlucHV0PXRoaXMuaW5wdXRzLmxlbmd0aD90aGlzLmlucHV0cy5lcSgwKTp0KFxcXCIjXFxcIit0aGlzLiRoYW5kbGUuYXR0cihcXFwiYXJpYS1jb250cm9sc1xcXCIpKSx0aGlzLiRmaWxsPXRoaXMuJGVsZW1lbnQuZmluZChcXFwiW2RhdGEtc2xpZGVyLWZpbGxdXFxcIikuY3NzKHRoaXMub3B0aW9ucy52ZXJ0aWNhbD9cXFwiaGVpZ2h0XFxcIjpcXFwid2lkdGhcXFwiLDApO3ZhciBlPSExLGk9dGhpczsodGhpcy5vcHRpb25zLmRpc2FibGVkfHx0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMub3B0aW9ucy5kaXNhYmxlZENsYXNzKSkmJih0aGlzLm9wdGlvbnMuZGlzYWJsZWQ9ITAsdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuZGlzYWJsZWRDbGFzcykpLHRoaXMuaW5wdXRzLmxlbmd0aHx8KHRoaXMuaW5wdXRzPXQoKS5hZGQodGhpcy4kaW5wdXQpLHRoaXMub3B0aW9ucy5iaW5kaW5nPSEwKSx0aGlzLl9zZXRJbml0QXR0cigwKSx0aGlzLl9ldmVudHModGhpcy4kaGFuZGxlKSx0aGlzLmhhbmRsZXNbMV0mJih0aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQ9ITAsdGhpcy4kaGFuZGxlMj10aGlzLmhhbmRsZXMuZXEoMSksdGhpcy4kaW5wdXQyPXRoaXMuaW5wdXRzLmxlbmd0aD4xP3RoaXMuaW5wdXRzLmVxKDEpOnQoXFxcIiNcXFwiK3RoaXMuJGhhbmRsZTIuYXR0cihcXFwiYXJpYS1jb250cm9sc1xcXCIpKSx0aGlzLmlucHV0c1sxXXx8KHRoaXMuaW5wdXRzPXRoaXMuaW5wdXRzLmFkZCh0aGlzLiRpbnB1dDIpKSxlPSEwLHRoaXMuX3NldEhhbmRsZVBvcyh0aGlzLiRoYW5kbGUsdGhpcy5vcHRpb25zLmluaXRpYWxTdGFydCwhMCxmdW5jdGlvbigpe2kuX3NldEhhbmRsZVBvcyhpLiRoYW5kbGUyLGkub3B0aW9ucy5pbml0aWFsRW5kLCEwKTt9KSx0aGlzLl9zZXRJbml0QXR0cigxKSx0aGlzLl9ldmVudHModGhpcy4kaGFuZGxlMikpLGV8fHRoaXMuX3NldEhhbmRsZVBvcyh0aGlzLiRoYW5kbGUsdGhpcy5vcHRpb25zLmluaXRpYWxTdGFydCwhMCk7fX0se2tleTpcXFwiX3NldEhhbmRsZVBvc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCxpLG4scyl7aWYoIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3ModGhpcy5vcHRpb25zLmRpc2FibGVkQ2xhc3MpKXtpPXBhcnNlRmxvYXQoaSksaTx0aGlzLm9wdGlvbnMuc3RhcnQ/aT10aGlzLm9wdGlvbnMuc3RhcnQ6aT50aGlzLm9wdGlvbnMuZW5kJiYoaT10aGlzLm9wdGlvbnMuZW5kKTt2YXIgbz10aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQ7aWYobylpZigwPT09dGhpcy5oYW5kbGVzLmluZGV4KHQpKXt2YXIgYT1wYXJzZUZsb2F0KHRoaXMuJGhhbmRsZTIuYXR0cihcXFwiYXJpYS12YWx1ZW5vd1xcXCIpKTtpPWk+PWE/YS10aGlzLm9wdGlvbnMuc3RlcDppO31lbHNle3ZhciByPXBhcnNlRmxvYXQodGhpcy4kaGFuZGxlLmF0dHIoXFxcImFyaWEtdmFsdWVub3dcXFwiKSk7aT1yPj1pP3IrdGhpcy5vcHRpb25zLnN0ZXA6aTt9dGhpcy5vcHRpb25zLnZlcnRpY2FsJiYhbiYmKGk9dGhpcy5vcHRpb25zLmVuZC1pKTt2YXIgbD10aGlzLHU9dGhpcy5vcHRpb25zLnZlcnRpY2FsLGQ9dT9cXFwiaGVpZ2h0XFxcIjpcXFwid2lkdGhcXFwiLGg9dT9cXFwidG9wXFxcIjpcXFwibGVmdFxcXCIsYz10WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2RdLGY9dGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtkXSxwPWUoaS10aGlzLm9wdGlvbnMuc3RhcnQsdGhpcy5vcHRpb25zLmVuZC10aGlzLm9wdGlvbnMuc3RhcnQpLnRvRml4ZWQoMiksbT0oZi1jKSpwLHY9KDEwMCplKG0sZikpLnRvRml4ZWQodGhpcy5vcHRpb25zLmRlY2ltYWwpO2k9cGFyc2VGbG9hdChpLnRvRml4ZWQodGhpcy5vcHRpb25zLmRlY2ltYWwpKTt2YXIgZz17fTtpZih0aGlzLl9zZXRWYWx1ZXModCxpKSxvKXt2YXIgdyx5PTA9PT10aGlzLmhhbmRsZXMuaW5kZXgodCksYj1+figxMDAqZShjLGYpKTtpZih5KWdbaF09ditcXFwiJVxcXCIsdz1wYXJzZUZsb2F0KHRoaXMuJGhhbmRsZTJbMF0uc3R5bGVbaF0pLXYrYixzJiZcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgcyYmcygpO2Vsc2V7dmFyICQ9cGFyc2VGbG9hdCh0aGlzLiRoYW5kbGVbMF0uc3R5bGVbaF0pO3c9di0oaXNOYU4oJCk/dGhpcy5vcHRpb25zLmluaXRpYWxTdGFydC8oKHRoaXMub3B0aW9ucy5lbmQtdGhpcy5vcHRpb25zLnN0YXJ0KS8xMDApOiQpK2I7fWdbXFxcIm1pbi1cXFwiK2RdPXcrXFxcIiVcXFwiO310aGlzLiRlbGVtZW50Lm9uZShcXFwiZmluaXNoZWQuemYuYW5pbWF0ZVxcXCIsZnVuY3Rpb24oKXtsLiRlbGVtZW50LnRyaWdnZXIoXFxcIm1vdmVkLnpmLnNsaWRlclxcXCIsW3RdKTt9KTt2YXIgQz10aGlzLiRlbGVtZW50LmRhdGEoXFxcImRyYWdnaW5nXFxcIik/MWUzLzYwOnRoaXMub3B0aW9ucy5tb3ZlVGltZTtGb3VuZGF0aW9uLk1vdmUoQyx0LGZ1bmN0aW9uKCl7dC5jc3MoaCx2K1xcXCIlXFxcIiksbC5vcHRpb25zLmRvdWJsZVNpZGVkP2wuJGZpbGwuY3NzKGcpOmwuJGZpbGwuY3NzKGQsMTAwKnArXFxcIiVcXFwiKTt9KSxjbGVhclRpbWVvdXQobC50aW1lb3V0KSxsLnRpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe2wuJGVsZW1lbnQudHJpZ2dlcihcXFwiY2hhbmdlZC56Zi5zbGlkZXJcXFwiLFt0XSk7fSxsLm9wdGlvbnMuY2hhbmdlZERlbGF5KTt9fX0se2tleTpcXFwiX3NldEluaXRBdHRyXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt2YXIgZT10aGlzLmlucHV0cy5lcSh0KS5hdHRyKFxcXCJpZFxcXCIpfHxGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsXFxcInNsaWRlclxcXCIpO3RoaXMuaW5wdXRzLmVxKHQpLmF0dHIoe2lkOmUsbWF4OnRoaXMub3B0aW9ucy5lbmQsbWluOnRoaXMub3B0aW9ucy5zdGFydCxzdGVwOnRoaXMub3B0aW9ucy5zdGVwfSksdGhpcy5oYW5kbGVzLmVxKHQpLmF0dHIoe3JvbGU6XFxcInNsaWRlclxcXCIsXFxcImFyaWEtY29udHJvbHNcXFwiOmUsXFxcImFyaWEtdmFsdWVtYXhcXFwiOnRoaXMub3B0aW9ucy5lbmQsXFxcImFyaWEtdmFsdWVtaW5cXFwiOnRoaXMub3B0aW9ucy5zdGFydCxcXFwiYXJpYS12YWx1ZW5vd1xcXCI6MD09PXQ/dGhpcy5vcHRpb25zLmluaXRpYWxTdGFydDp0aGlzLm9wdGlvbnMuaW5pdGlhbEVuZCxcXFwiYXJpYS1vcmllbnRhdGlvblxcXCI6dGhpcy5vcHRpb25zLnZlcnRpY2FsP1xcXCJ2ZXJ0aWNhbFxcXCI6XFxcImhvcml6b250YWxcXFwiLHRhYmluZGV4OjB9KTt9fSx7a2V5OlxcXCJfc2V0VmFsdWVzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0LGUpe3ZhciBpPXRoaXMub3B0aW9ucy5kb3VibGVTaWRlZD90aGlzLmhhbmRsZXMuaW5kZXgodCk6MDt0aGlzLmlucHV0cy5lcShpKS52YWwoZSksdC5hdHRyKFxcXCJhcmlhLXZhbHVlbm93XFxcIixlKTt9fSx7a2V5OlxcXCJfaGFuZGxlRXZlbnRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKG4scyxvKXt2YXIgYSxyO2lmKG8pYT10aGlzLl9hZGp1c3RWYWx1ZShudWxsLG8pLHI9ITA7ZWxzZXtuLnByZXZlbnREZWZhdWx0KCk7dmFyIGw9dGhpcyx1PXRoaXMub3B0aW9ucy52ZXJ0aWNhbCxkPXU/XFxcImhlaWdodFxcXCI6XFxcIndpZHRoXFxcIixoPXU/XFxcInRvcFxcXCI6XFxcImxlZnRcXFwiLGM9dT9uLnBhZ2VZOm4ucGFnZVgsZj0odGhpcy4kaGFuZGxlWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2RdLzIsdGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtkXSkscD11P3Qod2luZG93KS5zY3JvbGxUb3AoKTp0KHdpbmRvdykuc2Nyb2xsTGVmdCgpLG09dGhpcy4kZWxlbWVudC5vZmZzZXQoKVtoXTtuLmNsaWVudFk9PT1uLnBhZ2VZJiYoYys9cCk7dmFyIHYsZz1jLW07aWYodj0wPmc/MDpnPmY/ZjpnLG9mZnNldFBjdD1lKHYsZiksYT0odGhpcy5vcHRpb25zLmVuZC10aGlzLm9wdGlvbnMuc3RhcnQpKm9mZnNldFBjdCt0aGlzLm9wdGlvbnMuc3RhcnQsRm91bmRhdGlvbi5ydGwoKSYmIXRoaXMub3B0aW9ucy52ZXJ0aWNhbCYmKGE9dGhpcy5vcHRpb25zLmVuZC1hKSxhPWwuX2FkanVzdFZhbHVlKG51bGwsYSkscj0hMSwhcyl7dmFyIHc9aSh0aGlzLiRoYW5kbGUsaCx2LGQpLHk9aSh0aGlzLiRoYW5kbGUyLGgsdixkKTtzPXk+PXc/dGhpcy4kaGFuZGxlOnRoaXMuJGhhbmRsZTI7fX10aGlzLl9zZXRIYW5kbGVQb3MocyxhLHIpO319LHtrZXk6XFxcIl9hZGp1c3RWYWx1ZVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCxlKXt2YXIgaSxuLHMsbyxhPXRoaXMub3B0aW9ucy5zdGVwLHI9cGFyc2VGbG9hdChhLzIpO3JldHVybiBpPXQ/cGFyc2VGbG9hdCh0LmF0dHIoXFxcImFyaWEtdmFsdWVub3dcXFwiKSk6ZSxuPWklYSxzPWktbixvPXMrYSwwPT09bj9pOmk9aT49cytyP286czt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXt2YXIgaSxuPXRoaXM7aWYodGhpcy5pbnB1dHMub2ZmKFxcXCJjaGFuZ2UuemYuc2xpZGVyXFxcIikub24oXFxcImNoYW5nZS56Zi5zbGlkZXJcXFwiLGZ1bmN0aW9uKGUpe3ZhciBpPW4uaW5wdXRzLmluZGV4KHQodGhpcykpO24uX2hhbmRsZUV2ZW50KGUsbi5oYW5kbGVzLmVxKGkpLHQodGhpcykudmFsKCkpO30pLHRoaXMub3B0aW9ucy5jbGlja1NlbGVjdCYmdGhpcy4kZWxlbWVudC5vZmYoXFxcImNsaWNrLnpmLnNsaWRlclxcXCIpLm9uKFxcXCJjbGljay56Zi5zbGlkZXJcXFwiLGZ1bmN0aW9uKGUpe3JldHVybiBuLiRlbGVtZW50LmRhdGEoXFxcImRyYWdnaW5nXFxcIik/ITE6dm9pZCh0KGUudGFyZ2V0KS5pcyhcXFwiW2RhdGEtc2xpZGVyLWhhbmRsZV1cXFwiKXx8KG4ub3B0aW9ucy5kb3VibGVTaWRlZD9uLl9oYW5kbGVFdmVudChlKTpuLl9oYW5kbGVFdmVudChlLG4uJGhhbmRsZSkpKTt9KSx0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlKXt0aGlzLmhhbmRsZXMuYWRkVG91Y2goKTt2YXIgcz10KFxcXCJib2R5XFxcIik7ZS5vZmYoXFxcIm1vdXNlZG93bi56Zi5zbGlkZXJcXFwiKS5vbihcXFwibW91c2Vkb3duLnpmLnNsaWRlclxcXCIsZnVuY3Rpb24obyl7ZS5hZGRDbGFzcyhcXFwiaXMtZHJhZ2dpbmdcXFwiKSxuLiRmaWxsLmFkZENsYXNzKFxcXCJpcy1kcmFnZ2luZ1xcXCIpLG4uJGVsZW1lbnQuZGF0YShcXFwiZHJhZ2dpbmdcXFwiLCEwKSxpPXQoby5jdXJyZW50VGFyZ2V0KSxzLm9uKFxcXCJtb3VzZW1vdmUuemYuc2xpZGVyXFxcIixmdW5jdGlvbih0KXt0LnByZXZlbnREZWZhdWx0KCksbi5faGFuZGxlRXZlbnQodCxpKTt9KS5vbihcXFwibW91c2V1cC56Zi5zbGlkZXJcXFwiLGZ1bmN0aW9uKHQpe24uX2hhbmRsZUV2ZW50KHQsaSksZS5yZW1vdmVDbGFzcyhcXFwiaXMtZHJhZ2dpbmdcXFwiKSxuLiRmaWxsLnJlbW92ZUNsYXNzKFxcXCJpcy1kcmFnZ2luZ1xcXCIpLG4uJGVsZW1lbnQuZGF0YShcXFwiZHJhZ2dpbmdcXFwiLCExKSxzLm9mZihcXFwibW91c2Vtb3ZlLnpmLnNsaWRlciBtb3VzZXVwLnpmLnNsaWRlclxcXCIpO30pO30pLm9uKFxcXCJzZWxlY3RzdGFydC56Zi5zbGlkZXIgdG91Y2htb3ZlLnpmLnNsaWRlclxcXCIsZnVuY3Rpb24odCl7dC5wcmV2ZW50RGVmYXVsdCgpO30pO31lLm9mZihcXFwia2V5ZG93bi56Zi5zbGlkZXJcXFwiKS5vbihcXFwia2V5ZG93bi56Zi5zbGlkZXJcXFwiLGZ1bmN0aW9uKGUpe3ZhciBpLHM9dCh0aGlzKSxvPW4ub3B0aW9ucy5kb3VibGVTaWRlZD9uLmhhbmRsZXMuaW5kZXgocyk6MCxhPXBhcnNlRmxvYXQobi5pbnB1dHMuZXEobykudmFsKCkpO0ZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGUsXFxcIlNsaWRlclxcXCIse2RlY3JlYXNlOmZ1bmN0aW9uIGRlY3JlYXNlKCl7aT1hLW4ub3B0aW9ucy5zdGVwO30saW5jcmVhc2U6ZnVuY3Rpb24gaW5jcmVhc2UoKXtpPWErbi5vcHRpb25zLnN0ZXA7fSxkZWNyZWFzZV9mYXN0OmZ1bmN0aW9uIGRlY3JlYXNlX2Zhc3QoKXtpPWEtMTAqbi5vcHRpb25zLnN0ZXA7fSxpbmNyZWFzZV9mYXN0OmZ1bmN0aW9uIGluY3JlYXNlX2Zhc3QoKXtpPWErMTAqbi5vcHRpb25zLnN0ZXA7fSxoYW5kbGVkOmZ1bmN0aW9uIGhhbmRsZWQoKXtlLnByZXZlbnREZWZhdWx0KCksbi5fc2V0SGFuZGxlUG9zKHMsaSwhMCk7fX0pO30pO319LHtrZXk6XFxcImRlc3Ryb3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy5oYW5kbGVzLm9mZihcXFwiLnpmLnNsaWRlclxcXCIpLHRoaXMuaW5wdXRzLm9mZihcXFwiLnpmLnNsaWRlclxcXCIpLHRoaXMuJGVsZW1lbnQub2ZmKFxcXCIuemYuc2xpZGVyXFxcIiksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksbjt9KCk7bi5kZWZhdWx0cz17c3RhcnQ6MCxlbmQ6MTAwLHN0ZXA6MSxpbml0aWFsU3RhcnQ6MCxpbml0aWFsRW5kOjEwMCxiaW5kaW5nOiExLGNsaWNrU2VsZWN0OiEwLHZlcnRpY2FsOiExLGRyYWdnYWJsZTohMCxkaXNhYmxlZDohMSxkb3VibGVTaWRlZDohMSxkZWNpbWFsOjIsbW92ZVRpbWU6MjAwLGRpc2FibGVkQ2xhc3M6XFxcImRpc2FibGVkXFxcIixpbnZlcnRWZXJ0aWNhbDohMSxjaGFuZ2VkRGVsYXk6NTAwfSxGb3VuZGF0aW9uLnBsdWdpbihuLFxcXCJTbGlkZXJcXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0KXtyZXR1cm4gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSxudWxsKS5mb250U2l6ZSwxMCkqdDt9dmFyIGk9ZnVuY3Rpb24oKXtmdW5jdGlvbiBpKGUsbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsaSksdGhpcy4kZWxlbWVudD1lLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxpLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG4pLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIlN0aWNreVxcXCIpO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGksW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXMuJGVsZW1lbnQucGFyZW50KFxcXCJbZGF0YS1zdGlja3ktY29udGFpbmVyXVxcXCIpLGk9dGhpcy4kZWxlbWVudFswXS5pZHx8Rm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LFxcXCJzdGlja3lcXFwiKSxuPXRoaXM7ZS5sZW5ndGh8fCh0aGlzLndhc1dyYXBwZWQ9ITApLHRoaXMuJGNvbnRhaW5lcj1lLmxlbmd0aD9lOnQodGhpcy5vcHRpb25zLmNvbnRhaW5lcikud3JhcElubmVyKHRoaXMuJGVsZW1lbnQpLHRoaXMuJGNvbnRhaW5lci5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuY29udGFpbmVyQ2xhc3MpLHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnN0aWNreUNsYXNzKS5hdHRyKHtcXFwiZGF0YS1yZXNpemVcXFwiOml9KSx0aGlzLnNjcm9sbENvdW50PXRoaXMub3B0aW9ucy5jaGVja0V2ZXJ5LHRoaXMuaXNTdHVjaz0hMSx0KHdpbmRvdykub25lKFxcXCJsb2FkLnpmLnN0aWNreVxcXCIsZnVuY3Rpb24oKXtcXFwiXFxcIiE9PW4ub3B0aW9ucy5hbmNob3I/bi4kYW5jaG9yPXQoXFxcIiNcXFwiK24ub3B0aW9ucy5hbmNob3IpOm4uX3BhcnNlUG9pbnRzKCksbi5fc2V0U2l6ZXMoZnVuY3Rpb24oKXtuLl9jYWxjKCExKTt9KSxuLl9ldmVudHMoaS5zcGxpdChcXFwiLVxcXCIpLnJldmVyc2UoKS5qb2luKFxcXCItXFxcIikpO30pO319LHtrZXk6XFxcIl9wYXJzZVBvaW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXtmb3IodmFyIGU9XFxcIlxcXCI9PXRoaXMub3B0aW9ucy50b3BBbmNob3I/MTp0aGlzLm9wdGlvbnMudG9wQW5jaG9yLGk9XFxcIlxcXCI9PXRoaXMub3B0aW9ucy5idG1BbmNob3I/ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodDp0aGlzLm9wdGlvbnMuYnRtQW5jaG9yLG49W2UsaV0scz17fSxvPTAsYT1uLmxlbmd0aDthPm8mJm5bb107bysrKXt2YXIgcjtpZihcXFwibnVtYmVyXFxcIj09dHlwZW9mIG5bb10pcj1uW29dO2Vsc2V7dmFyIGw9bltvXS5zcGxpdChcXFwiOlxcXCIpLHU9dChcXFwiI1xcXCIrbFswXSk7cj11Lm9mZnNldCgpLnRvcCxsWzFdJiZcXFwiYm90dG9tXFxcIj09PWxbMV0udG9Mb3dlckNhc2UoKSYmKHIrPXVbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0KTt9c1tvXT1yO310aGlzLnBvaW50cz1zO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKGUpe3ZhciBpPXRoaXMsbj10aGlzLnNjcm9sbExpc3RlbmVyPVxcXCJzY3JvbGwuemYuXFxcIitlO3RoaXMuaXNPbnx8KHRoaXMuY2FuU3RpY2smJih0aGlzLmlzT249ITAsdCh3aW5kb3cpLm9mZihuKS5vbihuLGZ1bmN0aW9uKHQpezA9PT1pLnNjcm9sbENvdW50PyhpLnNjcm9sbENvdW50PWkub3B0aW9ucy5jaGVja0V2ZXJ5LGkuX3NldFNpemVzKGZ1bmN0aW9uKCl7aS5fY2FsYyghMSx3aW5kb3cucGFnZVlPZmZzZXQpO30pKTooaS5zY3JvbGxDb3VudC0tLGkuX2NhbGMoITEsd2luZG93LnBhZ2VZT2Zmc2V0KSk7fSkpLHRoaXMuJGVsZW1lbnQub2ZmKFxcXCJyZXNpemVtZS56Zi50cmlnZ2VyXFxcIikub24oXFxcInJlc2l6ZW1lLnpmLnRyaWdnZXJcXFwiLGZ1bmN0aW9uKHQscyl7aS5fc2V0U2l6ZXMoZnVuY3Rpb24oKXtpLl9jYWxjKCExKSxpLmNhblN0aWNrP2kuaXNPbnx8aS5fZXZlbnRzKGUpOmkuaXNPbiYmaS5fcGF1c2VMaXN0ZW5lcnMobik7fSk7fSkpO319LHtrZXk6XFxcIl9wYXVzZUxpc3RlbmVyc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoZSl7dGhpcy5pc09uPSExLHQod2luZG93KS5vZmYoZSksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJwYXVzZS56Zi5zdGlja3lcXFwiKTt9fSx7a2V5OlxcXCJfY2FsY1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCxlKXtyZXR1cm4gdCYmdGhpcy5fc2V0U2l6ZXMoKSx0aGlzLmNhblN0aWNrPyhlfHwoZT13aW5kb3cucGFnZVlPZmZzZXQpLHZvaWQoZT49dGhpcy50b3BQb2ludD9lPD10aGlzLmJvdHRvbVBvaW50P3RoaXMuaXNTdHVja3x8dGhpcy5fc2V0U3RpY2t5KCk6dGhpcy5pc1N0dWNrJiZ0aGlzLl9yZW1vdmVTdGlja3koITEpOnRoaXMuaXNTdHVjayYmdGhpcy5fcmVtb3ZlU3RpY2t5KCEwKSkpOih0aGlzLmlzU3R1Y2smJnRoaXMuX3JlbW92ZVN0aWNreSghMCksITEpO319LHtrZXk6XFxcIl9zZXRTdGlja3lcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIHQ9dGhpcyxlPXRoaXMub3B0aW9ucy5zdGlja1RvLGk9XFxcInRvcFxcXCI9PT1lP1xcXCJtYXJnaW5Ub3BcXFwiOlxcXCJtYXJnaW5Cb3R0b21cXFwiLG49XFxcInRvcFxcXCI9PT1lP1xcXCJib3R0b21cXFwiOlxcXCJ0b3BcXFwiLHM9e307c1tpXT10aGlzLm9wdGlvbnNbaV0rXFxcImVtXFxcIixzW2VdPTAsc1tuXT1cXFwiYXV0b1xcXCIscy5sZWZ0PXRoaXMuJGNvbnRhaW5lci5vZmZzZXQoKS5sZWZ0K3BhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuJGNvbnRhaW5lclswXSlbXFxcInBhZGRpbmctbGVmdFxcXCJdLDEwKSx0aGlzLmlzU3R1Y2s9ITAsdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwiaXMtYW5jaG9yZWQgaXMtYXQtXFxcIituKS5hZGRDbGFzcyhcXFwiaXMtc3R1Y2sgaXMtYXQtXFxcIitlKS5jc3MocykudHJpZ2dlcihcXFwic3RpY2t5LnpmLnN0dWNrdG86XFxcIitlKSx0aGlzLiRlbGVtZW50Lm9uKFxcXCJ0cmFuc2l0aW9uZW5kIHdlYmtpdFRyYW5zaXRpb25FbmQgb1RyYW5zaXRpb25FbmQgb3RyYW5zaXRpb25lbmQgTVNUcmFuc2l0aW9uRW5kXFxcIixmdW5jdGlvbigpe3QuX3NldFNpemVzKCk7fSk7fX0se2tleTpcXFwiX3JlbW92ZVN0aWNreVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dmFyIGU9dGhpcy5vcHRpb25zLnN0aWNrVG8saT1cXFwidG9wXFxcIj09PWUsbj17fSxzPSh0aGlzLnBvaW50cz90aGlzLnBvaW50c1sxXS10aGlzLnBvaW50c1swXTp0aGlzLmFuY2hvckhlaWdodCktdGhpcy5lbGVtSGVpZ2h0LG89aT9cXFwibWFyZ2luVG9wXFxcIjpcXFwibWFyZ2luQm90dG9tXFxcIixhPXQ/XFxcInRvcFxcXCI6XFxcImJvdHRvbVxcXCI7bltvXT0wLG4uYm90dG9tPVxcXCJhdXRvXFxcIix0P24udG9wPTA6bi50b3A9cyxuLmxlZnQ9XFxcIlxcXCIsdGhpcy5pc1N0dWNrPSExLHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcImlzLXN0dWNrIGlzLWF0LVxcXCIrZSkuYWRkQ2xhc3MoXFxcImlzLWFuY2hvcmVkIGlzLWF0LVxcXCIrYSkuY3NzKG4pLnRyaWdnZXIoXFxcInN0aWNreS56Zi51bnN0dWNrZnJvbTpcXFwiK2EpO319LHtrZXk6XFxcIl9zZXRTaXplc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUodCl7dGhpcy5jYW5TdGljaz1Gb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdCh0aGlzLm9wdGlvbnMuc3RpY2t5T24pLHRoaXMuY2FuU3RpY2t8fHQoKTt2YXIgZT10aGlzLiRjb250YWluZXJbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgsaT13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRjb250YWluZXJbMF0pLG49cGFyc2VJbnQoaVtcXFwicGFkZGluZy1yaWdodFxcXCJdLDEwKTt0aGlzLiRhbmNob3ImJnRoaXMuJGFuY2hvci5sZW5ndGg/dGhpcy5hbmNob3JIZWlnaHQ9dGhpcy4kYW5jaG9yWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDp0aGlzLl9wYXJzZVBvaW50cygpLHRoaXMuJGVsZW1lbnQuY3NzKHtcXFwibWF4LXdpZHRoXFxcIjplLW4rXFxcInB4XFxcIn0pO3ZhciBzPXRoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0fHx0aGlzLmNvbnRhaW5lckhlaWdodDtcXFwibm9uZVxcXCI9PXRoaXMuJGVsZW1lbnQuY3NzKFxcXCJkaXNwbGF5XFxcIikmJihzPTApLHRoaXMuY29udGFpbmVySGVpZ2h0PXMsdGhpcy4kY29udGFpbmVyLmNzcyh7aGVpZ2h0OnN9KSx0aGlzLmVsZW1IZWlnaHQ9cyx0aGlzLmlzU3R1Y2smJnRoaXMuJGVsZW1lbnQuY3NzKHtsZWZ0OnRoaXMuJGNvbnRhaW5lci5vZmZzZXQoKS5sZWZ0K3BhcnNlSW50KGlbXFxcInBhZGRpbmctbGVmdFxcXCJdLDEwKX0pLHRoaXMuX3NldEJyZWFrUG9pbnRzKHMsZnVuY3Rpb24oKXt0JiZ0KCk7fSk7fX0se2tleTpcXFwiX3NldEJyZWFrUG9pbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0LGkpe2lmKCF0aGlzLmNhblN0aWNrKXtpZighaSlyZXR1cm4hMTtpKCk7fXZhciBuPWUodGhpcy5vcHRpb25zLm1hcmdpblRvcCkscz1lKHRoaXMub3B0aW9ucy5tYXJnaW5Cb3R0b20pLG89dGhpcy5wb2ludHM/dGhpcy5wb2ludHNbMF06dGhpcy4kYW5jaG9yLm9mZnNldCgpLnRvcCxhPXRoaXMucG9pbnRzP3RoaXMucG9pbnRzWzFdOm8rdGhpcy5hbmNob3JIZWlnaHQscj13aW5kb3cuaW5uZXJIZWlnaHQ7XFxcInRvcFxcXCI9PT10aGlzLm9wdGlvbnMuc3RpY2tUbz8oby09bixhLT10K24pOlxcXCJib3R0b21cXFwiPT09dGhpcy5vcHRpb25zLnN0aWNrVG8mJihvLT1yLSh0K3MpLGEtPXItcyksdGhpcy50b3BQb2ludD1vLHRoaXMuYm90dG9tUG9pbnQ9YSxpJiZpKCk7fX0se2tleTpcXFwiZGVzdHJveVxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLl9yZW1vdmVTdGlja3koITApLHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLnN0aWNreUNsYXNzK1xcXCIgaXMtYW5jaG9yZWQgaXMtYXQtdG9wXFxcIikuY3NzKHtoZWlnaHQ6XFxcIlxcXCIsdG9wOlxcXCJcXFwiLGJvdHRvbTpcXFwiXFxcIixcXFwibWF4LXdpZHRoXFxcIjpcXFwiXFxcIn0pLm9mZihcXFwicmVzaXplbWUuemYudHJpZ2dlclxcXCIpLHRoaXMuJGFuY2hvciYmdGhpcy4kYW5jaG9yLmxlbmd0aCYmdGhpcy4kYW5jaG9yLm9mZihcXFwiY2hhbmdlLnpmLnN0aWNreVxcXCIpLHQod2luZG93KS5vZmYodGhpcy5zY3JvbGxMaXN0ZW5lciksdGhpcy53YXNXcmFwcGVkP3RoaXMuJGVsZW1lbnQudW53cmFwKCk6dGhpcy4kY29udGFpbmVyLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5jb250YWluZXJDbGFzcykuY3NzKHtoZWlnaHQ6XFxcIlxcXCJ9KSxGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKSxpO30oKTtpLmRlZmF1bHRzPXtjb250YWluZXI6XFxcIjxkaXYgZGF0YS1zdGlja3ktY29udGFpbmVyPjwvZGl2PlxcXCIsc3RpY2tUbzpcXFwidG9wXFxcIixhbmNob3I6XFxcIlxcXCIsdG9wQW5jaG9yOlxcXCJcXFwiLGJ0bUFuY2hvcjpcXFwiXFxcIixtYXJnaW5Ub3A6MSxtYXJnaW5Cb3R0b206MSxzdGlja3lPbjpcXFwibWVkaXVtXFxcIixzdGlja3lDbGFzczpcXFwic3RpY2t5XFxcIixjb250YWluZXJDbGFzczpcXFwic3RpY2t5LWNvbnRhaW5lclxcXCIsY2hlY2tFdmVyeTotMX0sRm91bmRhdGlvbi5wbHVnaW4oaSxcXFwiU3RpY2t5XFxcIik7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBpPTA7aTxlLmxlbmd0aDtpKyspe3ZhciBuPWVbaV07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXFxcInZhbHVlXFxcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLmtleSxuKTt9fXJldHVybiBmdW5jdGlvbihlLGksbil7cmV0dXJuIGkmJnQoZS5wcm90b3R5cGUsaSksbiYmdChlLG4pLGU7fTt9KCk7IWZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShpLG4pe19jbGFzc0NhbGxDaGVjayh0aGlzLGUpLHRoaXMuJGVsZW1lbnQ9aSx0aGlzLm9wdGlvbnM9dC5leHRlbmQoe30sZS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxuKSx0aGlzLl9pbml0KCksRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLFxcXCJUYWJzXFxcIiksRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcihcXFwiVGFic1xcXCIse0VOVEVSOlxcXCJvcGVuXFxcIixTUEFDRTpcXFwib3BlblxcXCIsQVJST1dfUklHSFQ6XFxcIm5leHRcXFwiLEFSUk9XX1VQOlxcXCJwcmV2aW91c1xcXCIsQVJST1dfRE9XTjpcXFwibmV4dFxcXCIsQVJST1dfTEVGVDpcXFwicHJldmlvdXNcXFwifSk7fXJldHVybiBfY3JlYXRlQ2xhc3MoZSxbe2tleTpcXFwiX2luaXRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpcztpZih0aGlzLiR0YWJUaXRsZXM9dGhpcy4kZWxlbWVudC5maW5kKFxcXCIuXFxcIit0aGlzLm9wdGlvbnMubGlua0NsYXNzKSx0aGlzLiR0YWJDb250ZW50PXQoJ1tkYXRhLXRhYnMtY29udGVudD1cXFwiJyt0aGlzLiRlbGVtZW50WzBdLmlkKydcXFwiXScpLHRoaXMuJHRhYlRpdGxlcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGk9dCh0aGlzKSxuPWkuZmluZChcXFwiYVxcXCIpLHM9aS5oYXNDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIiksbz1uWzBdLmhhc2guc2xpY2UoMSksYT1uWzBdLmlkP25bMF0uaWQ6bytcXFwiLWxhYmVsXFxcIixyPXQoXFxcIiNcXFwiK28pO2kuYXR0cih7cm9sZTpcXFwicHJlc2VudGF0aW9uXFxcIn0pLG4uYXR0cih7cm9sZTpcXFwidGFiXFxcIixcXFwiYXJpYS1jb250cm9sc1xcXCI6byxcXFwiYXJpYS1zZWxlY3RlZFxcXCI6cyxpZDphfSksci5hdHRyKHtyb2xlOlxcXCJ0YWJwYW5lbFxcXCIsXFxcImFyaWEtaGlkZGVuXFxcIjohcyxcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIjphfSkscyYmZS5vcHRpb25zLmF1dG9Gb2N1cyYmbi5mb2N1cygpO30pLHRoaXMub3B0aW9ucy5tYXRjaEhlaWdodCl7dmFyIGk9dGhpcy4kdGFiQ29udGVudC5maW5kKFxcXCJpbWdcXFwiKTtpLmxlbmd0aD9Gb3VuZGF0aW9uLm9uSW1hZ2VzTG9hZGVkKGksdGhpcy5fc2V0SGVpZ2h0LmJpbmQodGhpcykpOnRoaXMuX3NldEhlaWdodCgpO310aGlzLl9ldmVudHMoKTt9fSx7a2V5OlxcXCJfZXZlbnRzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuX2FkZEtleUhhbmRsZXIoKSx0aGlzLl9hZGRDbGlja0hhbmRsZXIoKSx0aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXI9bnVsbCx0aGlzLm9wdGlvbnMubWF0Y2hIZWlnaHQmJih0aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXI9dGhpcy5fc2V0SGVpZ2h0LmJpbmQodGhpcyksdCh3aW5kb3cpLm9uKFxcXCJjaGFuZ2VkLnpmLm1lZGlhcXVlcnlcXFwiLHRoaXMuX3NldEhlaWdodE1xSGFuZGxlcikpO319LHtrZXk6XFxcIl9hZGRDbGlja0hhbmRsZXJcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9dGhpczt0aGlzLiRlbGVtZW50Lm9mZihcXFwiY2xpY2suemYudGFic1xcXCIpLm9uKFxcXCJjbGljay56Zi50YWJzXFxcIixcXFwiLlxcXCIrdGhpcy5vcHRpb25zLmxpbmtDbGFzcyxmdW5jdGlvbihpKXtpLnByZXZlbnREZWZhdWx0KCksaS5zdG9wUHJvcGFnYXRpb24oKSx0KHRoaXMpLmhhc0NsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKXx8ZS5faGFuZGxlVGFiQ2hhbmdlKHQodGhpcykpO30pO319LHtrZXk6XFxcIl9hZGRLZXlIYW5kbGVyXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlPXRoaXM7ZS4kZWxlbWVudC5maW5kKFxcXCJsaTpmaXJzdC1vZi10eXBlXFxcIiksZS4kZWxlbWVudC5maW5kKFxcXCJsaTpsYXN0LW9mLXR5cGVcXFwiKTt0aGlzLiR0YWJUaXRsZXMub2ZmKFxcXCJrZXlkb3duLnpmLnRhYnNcXFwiKS5vbihcXFwia2V5ZG93bi56Zi50YWJzXFxcIixmdW5jdGlvbihpKXtpZig5IT09aS53aGljaCl7dmFyIG4scyxvPXQodGhpcyksYT1vLnBhcmVudChcXFwidWxcXFwiKS5jaGlsZHJlbihcXFwibGlcXFwiKTthLmVhY2goZnVuY3Rpb24oaSl7cmV0dXJuIHQodGhpcykuaXMobyk/dm9pZChlLm9wdGlvbnMud3JhcE9uS2V5cz8obj0wPT09aT9hLmxhc3QoKTphLmVxKGktMSkscz1pPT09YS5sZW5ndGgtMT9hLmZpcnN0KCk6YS5lcShpKzEpKToobj1hLmVxKE1hdGgubWF4KDAsaS0xKSkscz1hLmVxKE1hdGgubWluKGkrMSxhLmxlbmd0aC0xKSkpKTp2b2lkIDA7fSksRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoaSxcXFwiVGFic1xcXCIse29wZW46ZnVuY3Rpb24gb3Blbigpe28uZmluZCgnW3JvbGU9XFxcInRhYlxcXCJdJykuZm9jdXMoKSxlLl9oYW5kbGVUYWJDaGFuZ2Uobyk7fSxwcmV2aW91czpmdW5jdGlvbiBwcmV2aW91cygpe24uZmluZCgnW3JvbGU9XFxcInRhYlxcXCJdJykuZm9jdXMoKSxlLl9oYW5kbGVUYWJDaGFuZ2Uobik7fSxuZXh0OmZ1bmN0aW9uIG5leHQoKXtzLmZpbmQoJ1tyb2xlPVxcXCJ0YWJcXFwiXScpLmZvY3VzKCksZS5faGFuZGxlVGFiQ2hhbmdlKHMpO30saGFuZGxlZDpmdW5jdGlvbiBoYW5kbGVkKCl7aS5zdG9wUHJvcGFnYXRpb24oKSxpLnByZXZlbnREZWZhdWx0KCk7fX0pO319KTt9fSx7a2V5OlxcXCJfaGFuZGxlVGFiQ2hhbmdlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXt2YXIgaT1lLmZpbmQoJ1tyb2xlPVxcXCJ0YWJcXFwiXScpLG49aVswXS5oYXNoLHM9dGhpcy4kdGFiQ29udGVudC5maW5kKG4pLG89dGhpcy4kZWxlbWVudC5maW5kKFxcXCIuXFxcIit0aGlzLm9wdGlvbnMubGlua0NsYXNzK1xcXCIuaXMtYWN0aXZlXFxcIikucmVtb3ZlQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLmZpbmQoJ1tyb2xlPVxcXCJ0YWJcXFwiXScpLmF0dHIoe1xcXCJhcmlhLXNlbGVjdGVkXFxcIjpcXFwiZmFsc2VcXFwifSk7dChcXFwiI1xcXCIrby5hdHRyKFxcXCJhcmlhLWNvbnRyb2xzXFxcIikpLnJlbW92ZUNsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKS5hdHRyKHtcXFwiYXJpYS1oaWRkZW5cXFwiOlxcXCJ0cnVlXFxcIn0pLGUuYWRkQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLGkuYXR0cih7XFxcImFyaWEtc2VsZWN0ZWRcXFwiOlxcXCJ0cnVlXFxcIn0pLHMuYWRkQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLmF0dHIoe1xcXCJhcmlhLWhpZGRlblxcXCI6XFxcImZhbHNlXFxcIn0pLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwiY2hhbmdlLnpmLnRhYnNcXFwiLFtlXSk7fX0se2tleTpcXFwic2VsZWN0VGFiXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXt2YXIgZTtlPVxcXCJvYmplY3RcXFwiPT0odHlwZW9mIHQ9PT1cXFwidW5kZWZpbmVkXFxcIj9cXFwidW5kZWZpbmVkXFxcIjpfdHlwZW9mKHQpKT90WzBdLmlkOnQsZS5pbmRleE9mKFxcXCIjXFxcIik8MCYmKGU9XFxcIiNcXFwiK2UpO3ZhciBpPXRoaXMuJHRhYlRpdGxlcy5maW5kKCdbaHJlZj1cXFwiJytlKydcXFwiXScpLnBhcmVudChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLmxpbmtDbGFzcyk7dGhpcy5faGFuZGxlVGFiQ2hhbmdlKGkpO319LHtrZXk6XFxcIl9zZXRIZWlnaHRcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dmFyIGU9MDt0aGlzLiR0YWJDb250ZW50LmZpbmQoXFxcIi5cXFwiK3RoaXMub3B0aW9ucy5wYW5lbENsYXNzKS5jc3MoXFxcImhlaWdodFxcXCIsXFxcIlxcXCIpLmVhY2goZnVuY3Rpb24oKXt2YXIgaT10KHRoaXMpLG49aS5oYXNDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIik7bnx8aS5jc3Moe3Zpc2liaWxpdHk6XFxcImhpZGRlblxcXCIsZGlzcGxheTpcXFwiYmxvY2tcXFwifSk7dmFyIHM9dGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7bnx8aS5jc3Moe3Zpc2liaWxpdHk6XFxcIlxcXCIsZGlzcGxheTpcXFwiXFxcIn0pLGU9cz5lP3M6ZTt9KS5jc3MoXFxcImhlaWdodFxcXCIsZStcXFwicHhcXFwiKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuJGVsZW1lbnQuZmluZChcXFwiLlxcXCIrdGhpcy5vcHRpb25zLmxpbmtDbGFzcykub2ZmKFxcXCIuemYudGFic1xcXCIpLmhpZGUoKS5lbmQoKS5maW5kKFxcXCIuXFxcIit0aGlzLm9wdGlvbnMucGFuZWxDbGFzcykuaGlkZSgpLHRoaXMub3B0aW9ucy5tYXRjaEhlaWdodCYmbnVsbCE9dGhpcy5fc2V0SGVpZ2h0TXFIYW5kbGVyJiZ0KHdpbmRvdykub2ZmKFxcXCJjaGFuZ2VkLnpmLm1lZGlhcXVlcnlcXFwiLHRoaXMuX3NldEhlaWdodE1xSGFuZGxlciksRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSksZTt9KCk7ZS5kZWZhdWx0cz17YXV0b0ZvY3VzOiExLHdyYXBPbktleXM6ITAsbWF0Y2hIZWlnaHQ6ITEsbGlua0NsYXNzOlxcXCJ0YWJzLXRpdGxlXFxcIixwYW5lbENsYXNzOlxcXCJ0YWJzLXBhbmVsXFxcIn0sRm91bmRhdGlvbi5wbHVnaW4oZSxcXFwiVGFic1xcXCIpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgbj1lW2ldO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFxcXCJ2YWx1ZVxcXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbi5rZXksbik7fX1yZXR1cm4gZnVuY3Rpb24oZSxpLG4pe3JldHVybiBpJiZ0KGUucHJvdG90eXBlLGkpLG4mJnQoZSxuKSxlO307fSgpOyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoaSxuKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxlKSx0aGlzLiRlbGVtZW50PWksdGhpcy5vcHRpb25zPXQuZXh0ZW5kKHt9LGUuZGVmYXVsdHMsaS5kYXRhKCksbiksdGhpcy5jbGFzc05hbWU9XFxcIlxcXCIsdGhpcy5faW5pdCgpLHRoaXMuX2V2ZW50cygpLEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcyxcXFwiVG9nZ2xlclxcXCIpO31yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsW3trZXk6XFxcIl9pbml0XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciBlO3RoaXMub3B0aW9ucy5hbmltYXRlPyhlPXRoaXMub3B0aW9ucy5hbmltYXRlLnNwbGl0KFxcXCIgXFxcIiksdGhpcy5hbmltYXRpb25Jbj1lWzBdLHRoaXMuYW5pbWF0aW9uT3V0PWVbMV18fG51bGwpOihlPXRoaXMuJGVsZW1lbnQuZGF0YShcXFwidG9nZ2xlclxcXCIpLHRoaXMuY2xhc3NOYW1lPVxcXCIuXFxcIj09PWVbMF0/ZS5zbGljZSgxKTplKTt2YXIgaT10aGlzLiRlbGVtZW50WzBdLmlkO3QoJ1tkYXRhLW9wZW49XFxcIicraSsnXFxcIl0sIFtkYXRhLWNsb3NlPVxcXCInK2krJ1xcXCJdLCBbZGF0YS10b2dnbGU9XFxcIicraSsnXFxcIl0nKS5hdHRyKFxcXCJhcmlhLWNvbnRyb2xzXFxcIixpKSx0aGlzLiRlbGVtZW50LmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCF0aGlzLiRlbGVtZW50LmlzKFxcXCI6aGlkZGVuXFxcIikpO319LHtrZXk6XFxcIl9ldmVudHNcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy4kZWxlbWVudC5vZmYoXFxcInRvZ2dsZS56Zi50cmlnZ2VyXFxcIikub24oXFxcInRvZ2dsZS56Zi50cmlnZ2VyXFxcIix0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpKTt9fSx7a2V5OlxcXCJ0b2dnbGVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpc1t0aGlzLm9wdGlvbnMuYW5pbWF0ZT9cXFwiX3RvZ2dsZUFuaW1hdGVcXFwiOlxcXCJfdG9nZ2xlQ2xhc3NcXFwiXSgpO319LHtrZXk6XFxcIl90b2dnbGVDbGFzc1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt0aGlzLiRlbGVtZW50LnRvZ2dsZUNsYXNzKHRoaXMuY2xhc3NOYW1lKTt2YXIgdD10aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMuY2xhc3NOYW1lKTt0P3RoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwib24uemYudG9nZ2xlclxcXCIpOnRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwib2ZmLnpmLnRvZ2dsZXJcXFwiKSx0aGlzLl91cGRhdGVBUklBKHQpO319LHtrZXk6XFxcIl90b2dnbGVBbmltYXRlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciB0PXRoaXM7dGhpcy4kZWxlbWVudC5pcyhcXFwiOmhpZGRlblxcXCIpP0ZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVJbih0aGlzLiRlbGVtZW50LHRoaXMuYW5pbWF0aW9uSW4sZnVuY3Rpb24oKXt0Ll91cGRhdGVBUklBKCEwKSx0aGlzLnRyaWdnZXIoXFxcIm9uLnpmLnRvZ2dsZXJcXFwiKTt9KTpGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlT3V0KHRoaXMuJGVsZW1lbnQsdGhpcy5hbmltYXRpb25PdXQsZnVuY3Rpb24oKXt0Ll91cGRhdGVBUklBKCExKSx0aGlzLnRyaWdnZXIoXFxcIm9mZi56Zi50b2dnbGVyXFxcIik7fSk7fX0se2tleTpcXFwiX3VwZGF0ZUFSSUFcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3RoaXMuJGVsZW1lbnQuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsISF0KTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuJGVsZW1lbnQub2ZmKFxcXCIuemYudG9nZ2xlclxcXCIpLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pLGU7fSgpO2UuZGVmYXVsdHM9e2FuaW1hdGU6ITF9LEZvdW5kYXRpb24ucGx1Z2luKGUsXFxcIlRvZ2dsZXJcXFwiKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyl7dmFyIG49ZVtpXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcXFwidmFsdWVcXFwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pO319cmV0dXJuIGZ1bmN0aW9uKGUsaSxuKXtyZXR1cm4gaSYmdChlLnByb3RvdHlwZSxpKSxuJiZ0KGUsbiksZTt9O30oKTshZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGksbil7X2NsYXNzQ2FsbENoZWNrKHRoaXMsZSksdGhpcy4kZWxlbWVudD1pLHRoaXMub3B0aW9ucz10LmV4dGVuZCh7fSxlLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG4pLHRoaXMuaXNBY3RpdmU9ITEsdGhpcy5pc0NsaWNrPSExLHRoaXMuX2luaXQoKSxGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsXFxcIlRvb2x0aXBcXFwiKTt9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLFt7a2V5OlxcXCJfaW5pdFxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgZT10aGlzLiRlbGVtZW50LmF0dHIoXFxcImFyaWEtZGVzY3JpYmVkYnlcXFwiKXx8Rm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LFxcXCJ0b29sdGlwXFxcIik7dGhpcy5vcHRpb25zLnBvc2l0aW9uQ2xhc3M9dGhpcy5vcHRpb25zLnBvc2l0aW9uQ2xhc3N8fHRoaXMuX2dldFBvc2l0aW9uQ2xhc3ModGhpcy4kZWxlbWVudCksdGhpcy5vcHRpb25zLnRpcFRleHQ9dGhpcy5vcHRpb25zLnRpcFRleHR8fHRoaXMuJGVsZW1lbnQuYXR0cihcXFwidGl0bGVcXFwiKSx0aGlzLnRlbXBsYXRlPXRoaXMub3B0aW9ucy50ZW1wbGF0ZT90KHRoaXMub3B0aW9ucy50ZW1wbGF0ZSk6dGhpcy5fYnVpbGRUZW1wbGF0ZShlKSx0aGlzLnRlbXBsYXRlLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpLnRleHQodGhpcy5vcHRpb25zLnRpcFRleHQpLmhpZGUoKSx0aGlzLiRlbGVtZW50LmF0dHIoe3RpdGxlOlxcXCJcXFwiLFxcXCJhcmlhLWRlc2NyaWJlZGJ5XFxcIjplLFxcXCJkYXRhLXlldGktYm94XFxcIjplLFxcXCJkYXRhLXRvZ2dsZVxcXCI6ZSxcXFwiZGF0YS1yZXNpemVcXFwiOmV9KS5hZGRDbGFzcyh0aGlzLnRyaWdnZXJDbGFzcyksdGhpcy51c2VkUG9zaXRpb25zPVtdLHRoaXMuY291bnRlcj00LHRoaXMuY2xhc3NDaGFuZ2VkPSExLHRoaXMuX2V2ZW50cygpO319LHtrZXk6XFxcIl9nZXRQb3NpdGlvbkNsYXNzXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSh0KXtpZighdClyZXR1cm5cXFwiXFxcIjt2YXIgZT10WzBdLmNsYXNzTmFtZS5tYXRjaCgvXFxcXGIodG9wfGxlZnR8cmlnaHQpXFxcXGIvZyk7cmV0dXJuIGU9ZT9lWzBdOlxcXCJcXFwiO319LHtrZXk6XFxcIl9idWlsZFRlbXBsYXRlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZShlKXt2YXIgaT0odGhpcy5vcHRpb25zLnRvb2x0aXBDbGFzcytcXFwiIFxcXCIrdGhpcy5vcHRpb25zLnBvc2l0aW9uQ2xhc3MrXFxcIiBcXFwiK3RoaXMub3B0aW9ucy50ZW1wbGF0ZUNsYXNzZXMpLnRyaW0oKSxuPXQoXFxcIjxkaXY+PC9kaXY+XFxcIikuYWRkQ2xhc3MoaSkuYXR0cih7cm9sZTpcXFwidG9vbHRpcFxcXCIsXFxcImFyaWEtaGlkZGVuXFxcIjohMCxcXFwiZGF0YS1pcy1hY3RpdmVcXFwiOiExLFxcXCJkYXRhLWlzLWZvY3VzXFxcIjohMSxpZDplfSk7cmV0dXJuIG47fX0se2tleTpcXFwiX3JlcG9zaXRpb25cXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKHQpe3RoaXMudXNlZFBvc2l0aW9ucy5wdXNoKHQ/dDpcXFwiYm90dG9tXFxcIiksIXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJ0b3BcXFwiKTwwP3RoaXMudGVtcGxhdGUuYWRkQ2xhc3MoXFxcInRvcFxcXCIpOlxcXCJ0b3BcXFwiPT09dCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImJvdHRvbVxcXCIpPDA/dGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyh0KTpcXFwibGVmdFxcXCI9PT10JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwicmlnaHRcXFwiKTwwP3RoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3ModCkuYWRkQ2xhc3MoXFxcInJpZ2h0XFxcIik6XFxcInJpZ2h0XFxcIj09PXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJsZWZ0XFxcIik8MD90aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHQpLmFkZENsYXNzKFxcXCJsZWZ0XFxcIik6IXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJ0b3BcXFwiKT4tMSYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImxlZnRcXFwiKTwwP3RoaXMudGVtcGxhdGUuYWRkQ2xhc3MoXFxcImxlZnRcXFwiKTpcXFwidG9wXFxcIj09PXQmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJib3R0b21cXFwiKT4tMSYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImxlZnRcXFwiKTwwP3RoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3ModCkuYWRkQ2xhc3MoXFxcImxlZnRcXFwiKTpcXFwibGVmdFxcXCI9PT10JiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwicmlnaHRcXFwiKT4tMSYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImJvdHRvbVxcXCIpPDA/dGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyh0KTpcXFwicmlnaHRcXFwiPT09dCYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImxlZnRcXFwiKT4tMSYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImJvdHRvbVxcXCIpPDA/dGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyh0KTp0aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHQpLHRoaXMuY2xhc3NDaGFuZ2VkPSEwLHRoaXMuY291bnRlci0tO319LHtrZXk6XFxcIl9zZXRQb3NpdGlvblxcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgdD10aGlzLl9nZXRQb3NpdGlvbkNsYXNzKHRoaXMudGVtcGxhdGUpLGU9Rm91bmRhdGlvbi5Cb3guR2V0RGltZW5zaW9ucyh0aGlzLnRlbXBsYXRlKSxpPUZvdW5kYXRpb24uQm94LkdldERpbWVuc2lvbnModGhpcy4kZWxlbWVudCksbj1cXFwibGVmdFxcXCI9PT10P1xcXCJsZWZ0XFxcIjpcXFwicmlnaHRcXFwiPT09dD9cXFwibGVmdFxcXCI6XFxcInRvcFxcXCIscz1cXFwidG9wXFxcIj09PW4/XFxcImhlaWdodFxcXCI6XFxcIndpZHRoXFxcIjtcXFwiaGVpZ2h0XFxcIj09PXM/dGhpcy5vcHRpb25zLnZPZmZzZXQ6dGhpcy5vcHRpb25zLmhPZmZzZXQ7aWYoZS53aWR0aD49ZS53aW5kb3dEaW1zLndpZHRofHwhdGhpcy5jb3VudGVyJiYhRm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdSh0aGlzLnRlbXBsYXRlKSlyZXR1cm4gdGhpcy50ZW1wbGF0ZS5vZmZzZXQoRm91bmRhdGlvbi5Cb3guR2V0T2Zmc2V0cyh0aGlzLnRlbXBsYXRlLHRoaXMuJGVsZW1lbnQsXFxcImNlbnRlciBib3R0b21cXFwiLHRoaXMub3B0aW9ucy52T2Zmc2V0LHRoaXMub3B0aW9ucy5oT2Zmc2V0LCEwKSkuY3NzKHt3aWR0aDppLndpbmRvd0RpbXMud2lkdGgtMip0aGlzLm9wdGlvbnMuaE9mZnNldCxoZWlnaHQ6XFxcImF1dG9cXFwifSksITE7Zm9yKHRoaXMudGVtcGxhdGUub2Zmc2V0KEZvdW5kYXRpb24uQm94LkdldE9mZnNldHModGhpcy50ZW1wbGF0ZSx0aGlzLiRlbGVtZW50LFxcXCJjZW50ZXIgXFxcIisodHx8XFxcImJvdHRvbVxcXCIpLHRoaXMub3B0aW9ucy52T2Zmc2V0LHRoaXMub3B0aW9ucy5oT2Zmc2V0KSk7IUZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UodGhpcy50ZW1wbGF0ZSkmJnRoaXMuY291bnRlcjspe3RoaXMuX3JlcG9zaXRpb24odCksdGhpcy5fc2V0UG9zaXRpb24oKTt9fX0se2tleTpcXFwic2hvd1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXtpZihcXFwiYWxsXFxcIiE9PXRoaXMub3B0aW9ucy5zaG93T24mJiFGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdCh0aGlzLm9wdGlvbnMuc2hvd09uKSlyZXR1cm4hMTt2YXIgdD10aGlzO3RoaXMudGVtcGxhdGUuY3NzKFxcXCJ2aXNpYmlsaXR5XFxcIixcXFwiaGlkZGVuXFxcIikuc2hvdygpLHRoaXMuX3NldFBvc2l0aW9uKCksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJjbG9zZW1lLnpmLnRvb2x0aXBcXFwiLHRoaXMudGVtcGxhdGUuYXR0cihcXFwiaWRcXFwiKSksdGhpcy50ZW1wbGF0ZS5hdHRyKHtcXFwiZGF0YS1pcy1hY3RpdmVcXFwiOiEwLFxcXCJhcmlhLWhpZGRlblxcXCI6ITF9KSx0LmlzQWN0aXZlPSEwLHRoaXMudGVtcGxhdGUuc3RvcCgpLmhpZGUoKS5jc3MoXFxcInZpc2liaWxpdHlcXFwiLFxcXCJcXFwiKS5mYWRlSW4odGhpcy5vcHRpb25zLmZhZGVJbkR1cmF0aW9uLGZ1bmN0aW9uKCl7fSksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJzaG93LnpmLnRvb2x0aXBcXFwiKTt9fSx7a2V5OlxcXCJoaWRlXFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3ZhciB0PXRoaXM7dGhpcy50ZW1wbGF0ZS5zdG9wKCkuYXR0cih7XFxcImFyaWEtaGlkZGVuXFxcIjohMCxcXFwiZGF0YS1pcy1hY3RpdmVcXFwiOiExfSkuZmFkZU91dCh0aGlzLm9wdGlvbnMuZmFkZU91dER1cmF0aW9uLGZ1bmN0aW9uKCl7dC5pc0FjdGl2ZT0hMSx0LmlzQ2xpY2s9ITEsdC5jbGFzc0NoYW5nZWQmJih0LnRlbXBsYXRlLnJlbW92ZUNsYXNzKHQuX2dldFBvc2l0aW9uQ2xhc3ModC50ZW1wbGF0ZSkpLmFkZENsYXNzKHQub3B0aW9ucy5wb3NpdGlvbkNsYXNzKSx0LnVzZWRQb3NpdGlvbnM9W10sdC5jb3VudGVyPTQsdC5jbGFzc0NoYW5nZWQ9ITEpO30pLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwiaGlkZS56Zi50b29sdGlwXFxcIik7fX0se2tleTpcXFwiX2V2ZW50c1xcXCIsdmFsdWU6ZnVuY3Rpb24gdmFsdWUoKXt2YXIgdD10aGlzLGU9KHRoaXMudGVtcGxhdGUsITEpO3RoaXMub3B0aW9ucy5kaXNhYmxlSG92ZXJ8fHRoaXMuJGVsZW1lbnQub24oXFxcIm1vdXNlZW50ZXIuemYudG9vbHRpcFxcXCIsZnVuY3Rpb24oZSl7dC5pc0FjdGl2ZXx8KHQudGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dC5zaG93KCk7fSx0Lm9wdGlvbnMuaG92ZXJEZWxheSkpO30pLm9uKFxcXCJtb3VzZWxlYXZlLnpmLnRvb2x0aXBcXFwiLGZ1bmN0aW9uKGkpe2NsZWFyVGltZW91dCh0LnRpbWVvdXQpLCghZXx8dC5pc0NsaWNrJiYhdC5vcHRpb25zLmNsaWNrT3BlbikmJnQuaGlkZSgpO30pLHRoaXMub3B0aW9ucy5jbGlja09wZW4/dGhpcy4kZWxlbWVudC5vbihcXFwibW91c2Vkb3duLnpmLnRvb2x0aXBcXFwiLGZ1bmN0aW9uKGUpe2Uuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksdC5pc0NsaWNrfHwodC5pc0NsaWNrPSEwLCF0Lm9wdGlvbnMuZGlzYWJsZUhvdmVyJiZ0LiRlbGVtZW50LmF0dHIoXFxcInRhYmluZGV4XFxcIil8fHQuaXNBY3RpdmV8fHQuc2hvdygpKTt9KTp0aGlzLiRlbGVtZW50Lm9uKFxcXCJtb3VzZWRvd24uemYudG9vbHRpcFxcXCIsZnVuY3Rpb24oZSl7ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSx0LmlzQ2xpY2s9ITA7fSksdGhpcy5vcHRpb25zLmRpc2FibGVGb3JUb3VjaHx8dGhpcy4kZWxlbWVudC5vbihcXFwidGFwLnpmLnRvb2x0aXAgdG91Y2hlbmQuemYudG9vbHRpcFxcXCIsZnVuY3Rpb24oZSl7dC5pc0FjdGl2ZT90LmhpZGUoKTp0LnNob3coKTt9KSx0aGlzLiRlbGVtZW50Lm9uKHtcXFwiY2xvc2UuemYudHJpZ2dlclxcXCI6dGhpcy5oaWRlLmJpbmQodGhpcyl9KSx0aGlzLiRlbGVtZW50Lm9uKFxcXCJmb2N1cy56Zi50b29sdGlwXFxcIixmdW5jdGlvbihpKXtyZXR1cm4gZT0hMCx0LmlzQ2xpY2s/KHQub3B0aW9ucy5jbGlja09wZW58fChlPSExKSwhMSk6dm9pZCB0LnNob3coKTt9KS5vbihcXFwiZm9jdXNvdXQuemYudG9vbHRpcFxcXCIsZnVuY3Rpb24oaSl7ZT0hMSx0LmlzQ2xpY2s9ITEsdC5oaWRlKCk7fSkub24oXFxcInJlc2l6ZW1lLnpmLnRyaWdnZXJcXFwiLGZ1bmN0aW9uKCl7dC5pc0FjdGl2ZSYmdC5fc2V0UG9zaXRpb24oKTt9KTt9fSx7a2V5OlxcXCJ0b2dnbGVcXFwiLHZhbHVlOmZ1bmN0aW9uIHZhbHVlKCl7dGhpcy5pc0FjdGl2ZT90aGlzLmhpZGUoKTp0aGlzLnNob3coKTt9fSx7a2V5OlxcXCJkZXN0cm95XFxcIix2YWx1ZTpmdW5jdGlvbiB2YWx1ZSgpe3RoaXMuJGVsZW1lbnQuYXR0cihcXFwidGl0bGVcXFwiLHRoaXMudGVtcGxhdGUudGV4dCgpKS5vZmYoXFxcIi56Zi50cmlnZ2VyIC56Zi50b290aXBcXFwiKS5yZW1vdmVBdHRyKFxcXCJhcmlhLWRlc2NyaWJlZGJ5XFxcIikucmVtb3ZlQXR0cihcXFwiZGF0YS15ZXRpLWJveFxcXCIpLnJlbW92ZUF0dHIoXFxcImRhdGEtdG9nZ2xlXFxcIikucmVtb3ZlQXR0cihcXFwiZGF0YS1yZXNpemVcXFwiKSx0aGlzLnRlbXBsYXRlLnJlbW92ZSgpLEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pLGU7fSgpO2UuZGVmYXVsdHM9e2Rpc2FibGVGb3JUb3VjaDohMSxob3ZlckRlbGF5OjIwMCxmYWRlSW5EdXJhdGlvbjoxNTAsZmFkZU91dER1cmF0aW9uOjE1MCxkaXNhYmxlSG92ZXI6ITEsdGVtcGxhdGVDbGFzc2VzOlxcXCJcXFwiLHRvb2x0aXBDbGFzczpcXFwidG9vbHRpcFxcXCIsdHJpZ2dlckNsYXNzOlxcXCJoYXMtdGlwXFxcIixzaG93T246XFxcInNtYWxsXFxcIix0ZW1wbGF0ZTpcXFwiXFxcIix0aXBUZXh0OlxcXCJcXFwiLHRvdWNoQ2xvc2VUZXh0OlxcXCJUYXAgdG8gY2xvc2UuXFxcIixjbGlja09wZW46ITAscG9zaXRpb25DbGFzczpcXFwiXFxcIix2T2Zmc2V0OjEwLGhPZmZzZXQ6MTJ9LEZvdW5kYXRpb24ucGx1Z2luKGUsXFxcIlRvb2x0aXBcXFwiKTt9KGpRdWVyeSk7XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yYXctbG9hZGVyIS4vfi9iYWJlbC1sb2FkZXI/e1wicHJlc2V0c1wiOltcInJlYWN0XCIsXCJlczIwMTVcIixcInN0YWdlLTBcIl19IS4vfi9mb3VuZGF0aW9uLXNpdGVzL2Rpc3QvZm91bmRhdGlvbi5taW4uanNcbiAqKiBtb2R1bGUgaWQgPSA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG52YXIge1JvdXRlLCBSb3V0ZXIsIEluZGV4Um91dGUsIGhhc2hIaXN0b3J5fSA9IHJlcXVpcmUoJ3JlYWN0LXJvdXRlcicpO1xuXG52YXIgVG9kb0FwcCA9IHJlcXVpcmUoJ1RvZG9BcHAnKTtcblxuLy9sb2FkIGZvdW5kYXRpb25cbiQoZG9jdW1lbnQpLmZvdW5kYXRpb24oKTtcblxuLy8gQXBwIGNzc1xucmVxdWlyZSgnc3R5bGUhY3NzIXNhc3MhYXBwbGljYXRpb25TdHlsZXMnKTtcblxuXG5cblJlYWN0RE9NLnJlbmRlcihcbiAgPFRvZG9BcHAvPixcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJhcHBcIilcbik7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9hcHAuanN4XG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBqUXVlcnk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBleHRlcm5hbCBcImpRdWVyeVwiXG4gKiogbW9kdWxlIGlkID0gN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL1JlYWN0Jyk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvcmVhY3QuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJy4vUmVhY3RET00nKTtcbnZhciBSZWFjdERPTVNlcnZlciA9IHJlcXVpcmUoJy4vUmVhY3RET01TZXJ2ZXInKTtcbnZhciBSZWFjdElzb21vcnBoaWMgPSByZXF1aXJlKCcuL1JlYWN0SXNvbW9ycGhpYycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZGVwcmVjYXRlZCA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlZCcpO1xuXG4vLyBgdmVyc2lvbmAgd2lsbCBiZSBhZGRlZCBoZXJlIGJ5IFJlYWN0SXNvbW9ycGhpYy5cbnZhciBSZWFjdCA9IHt9O1xuXG5hc3NpZ24oUmVhY3QsIFJlYWN0SXNvbW9ycGhpYyk7XG5cbmFzc2lnbihSZWFjdCwge1xuICAvLyBSZWFjdERPTVxuICBmaW5kRE9NTm9kZTogZGVwcmVjYXRlZCgnZmluZERPTU5vZGUnLCAnUmVhY3RET00nLCAncmVhY3QtZG9tJywgUmVhY3RET00sIFJlYWN0RE9NLmZpbmRET01Ob2RlKSxcbiAgcmVuZGVyOiBkZXByZWNhdGVkKCdyZW5kZXInLCAnUmVhY3RET00nLCAncmVhY3QtZG9tJywgUmVhY3RET00sIFJlYWN0RE9NLnJlbmRlciksXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IGRlcHJlY2F0ZWQoJ3VubW91bnRDb21wb25lbnRBdE5vZGUnLCAnUmVhY3RET00nLCAncmVhY3QtZG9tJywgUmVhY3RET00sIFJlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUpLFxuXG4gIC8vIFJlYWN0RE9NU2VydmVyXG4gIHJlbmRlclRvU3RyaW5nOiBkZXByZWNhdGVkKCdyZW5kZXJUb1N0cmluZycsICdSZWFjdERPTVNlcnZlcicsICdyZWFjdC1kb20vc2VydmVyJywgUmVhY3RET01TZXJ2ZXIsIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RyaW5nKSxcbiAgcmVuZGVyVG9TdGF0aWNNYXJrdXA6IGRlcHJlY2F0ZWQoJ3JlbmRlclRvU3RhdGljTWFya3VwJywgJ1JlYWN0RE9NU2VydmVyJywgJ3JlYWN0LWRvbS9zZXJ2ZXInLCBSZWFjdERPTVNlcnZlciwgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdGF0aWNNYXJrdXApXG59KTtcblxuUmVhY3QuX19TRUNSRVRfRE9NX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSBSZWFjdERPTTtcblJlYWN0Ll9fU0VDUkVUX0RPTV9TRVJWRVJfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IFJlYWN0RE9NU2VydmVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3QuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01cbiAqL1xuXG4vKiBnbG9iYWxzIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RE9NVGV4dENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RET01UZXh0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3REZWZhdWx0SW5qZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdERlZmF1bHRJbmplY3Rpb24nKTtcbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZUhhbmRsZXMnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZSgnLi9SZWFjdFBlcmYnKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG52YXIgUmVhY3RWZXJzaW9uID0gcmVxdWlyZSgnLi9SZWFjdFZlcnNpb24nKTtcblxudmFyIGZpbmRET01Ob2RlID0gcmVxdWlyZSgnLi9maW5kRE9NTm9kZScpO1xudmFyIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyID0gcmVxdWlyZSgnLi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cblJlYWN0RGVmYXVsdEluamVjdGlvbi5pbmplY3QoKTtcblxudmFyIHJlbmRlciA9IFJlYWN0UGVyZi5tZWFzdXJlKCdSZWFjdCcsICdyZW5kZXInLCBSZWFjdE1vdW50LnJlbmRlcik7XG5cbnZhciBSZWFjdCA9IHtcbiAgZmluZERPTU5vZGU6IGZpbmRET01Ob2RlLFxuICByZW5kZXI6IHJlbmRlcixcbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogUmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG5cbiAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMsXG4gIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lclxufTtcblxuLy8gSW5qZWN0IHRoZSBydW50aW1lIGludG8gYSBkZXZ0b29scyBnbG9iYWwgaG9vayByZWdhcmRsZXNzIG9mIGJyb3dzZXIuXG4vLyBBbGxvd3MgZm9yIGRlYnVnZ2luZyB3aGVuIHRoZSBob29rIGlzIGluamVjdGVkIG9uIHRoZSBwYWdlLlxuLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cbmlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmluamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uaW5qZWN0KHtcbiAgICBDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICAgIEluc3RhbmNlSGFuZGxlczogUmVhY3RJbnN0YW5jZUhhbmRsZXMsXG4gICAgTW91bnQ6IFJlYWN0TW91bnQsXG4gICAgUmVjb25jaWxlcjogUmVhY3RSZWNvbmNpbGVyLFxuICAgIFRleHRDb21wb25lbnQ6IFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICB9KTtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbiAgaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB3aW5kb3cudG9wID09PSB3aW5kb3cuc2VsZikge1xuXG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgZGV2dG9vbHMgaXMgbm90IGluc3RhbGxlZFxuICAgIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gSWYgd2UncmUgaW4gQ2hyb21lIG9yIEZpcmVmb3gsIHByb3ZpZGUgYSBkb3dubG9hZCBsaW5rIGlmIG5vdCBpbnN0YWxsZWQuXG4gICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA+IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpID09PSAtMSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+IC0xKSB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ0Rvd25sb2FkIHRoZSBSZWFjdCBEZXZUb29scyBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UncmUgaW4gSUU4LCBjaGVjayB0byBzZWUgaWYgd2UgYXJlIGluIGNvbXBhdGliaWxpdHkgbW9kZSBhbmQgcHJvdmlkZVxuICAgIC8vIGluZm9ybWF0aW9uIG9uIHByZXZlbnRpbmcgY29tcGF0aWJpbGl0eSBtb2RlXG4gICAgdmFyIGllQ29tcGF0aWJpbGl0eU1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDwgODtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpZUNvbXBhdGliaWxpdHlNb2RlLCAnSW50ZXJuZXQgRXhwbG9yZXIgaXMgcnVubmluZyBpbiBjb21wYXRpYmlsaXR5IG1vZGU7IHBsZWFzZSBhZGQgdGhlICcgKyAnZm9sbG93aW5nIHRhZyB0byB5b3VyIEhUTUwgdG8gcHJldmVudCB0aGlzIGZyb20gaGFwcGVuaW5nOiAnICsgJzxtZXRhIGh0dHAtZXF1aXY9XCJYLVVBLUNvbXBhdGlibGVcIiBjb250ZW50PVwiSUU9ZWRnZVwiIC8+JykgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgZXhwZWN0ZWRGZWF0dXJlcyA9IFtcbiAgICAvLyBzaGltc1xuICAgIEFycmF5LmlzQXJyYXksIEFycmF5LnByb3RvdHlwZS5ldmVyeSwgQXJyYXkucHJvdG90eXBlLmZvckVhY2gsIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLCBBcnJheS5wcm90b3R5cGUubWFwLCBEYXRlLm5vdywgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQsIE9iamVjdC5rZXlzLCBTdHJpbmcucHJvdG90eXBlLnNwbGl0LCBTdHJpbmcucHJvdG90eXBlLnRyaW0sXG5cbiAgICAvLyBzaGFtc1xuICAgIE9iamVjdC5jcmVhdGUsIE9iamVjdC5mcmVlemVdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZEZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWV4cGVjdGVkRmVhdHVyZXNbaV0pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignT25lIG9yIG1vcmUgRVM1IHNoaW0vc2hhbXMgZXhwZWN0ZWQgYnkgUmVhY3QgYXJlIG5vdCBhdmFpbGFibGU6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLXBvbHlmaWxscycpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NLmpzXG4gKiovIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9wcm9jZXNzL2Jyb3dzZXIuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDdXJyZW50T3duZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgb3duZXIuXG4gKlxuICogVGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIGNvbXBvbmVudCB3aG8gc2hvdWxkIG93biBhbnkgY29tcG9uZW50cyB0aGF0IGFyZVxuICogY3VycmVudGx5IGJlaW5nIGNvbnN0cnVjdGVkLlxuICovXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSB7XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDdXJyZW50T3duZXI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVRleHRDb21wb25lbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01DaGlsZHJlbk9wZXJhdGlvbnMnKTtcbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG52YXIgc2V0VGV4dENvbnRlbnQgPSByZXF1aXJlKCcuL3NldFRleHRDb250ZW50Jyk7XG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gcmVxdWlyZSgnLi92YWxpZGF0ZURPTU5lc3RpbmcnKTtcblxuLyoqXG4gKiBUZXh0IG5vZGVzIHZpb2xhdGUgYSBjb3VwbGUgYXNzdW1wdGlvbnMgdGhhdCBSZWFjdCBtYWtlcyBhYm91dCBjb21wb25lbnRzOlxuICpcbiAqICAtIFdoZW4gbW91bnRpbmcgdGV4dCBpbnRvIHRoZSBET00sIGFkamFjZW50IHRleHQgbm9kZXMgYXJlIG1lcmdlZC5cbiAqICAtIFRleHQgbm9kZXMgY2Fubm90IGJlIGFzc2lnbmVkIGEgUmVhY3Qgcm9vdCBJRC5cbiAqXG4gKiBUaGlzIGNvbXBvbmVudCBpcyB1c2VkIHRvIHdyYXAgc3RyaW5ncyBpbiBlbGVtZW50cyBzbyB0aGF0IHRoZXkgY2FuIHVuZGVyZ29cbiAqIHRoZSBzYW1lIHJlY29uY2lsaWF0aW9uIHRoYXQgaXMgYXBwbGllZCB0byBlbGVtZW50cy5cbiAqXG4gKiBUT0RPOiBJbnZlc3RpZ2F0ZSByZXByZXNlbnRpbmcgUmVhY3QgY29tcG9uZW50cyBpbiB0aGUgRE9NIHdpdGggdGV4dCBub2Rlcy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBAZXh0ZW5kcyBSZWFjdENvbXBvbmVudFxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdERPTVRleHRDb21wb25lbnQgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgLy8gVGhpcyBjb25zdHJ1Y3RvciBhbmQgaXRzIGFyZ3VtZW50IGlzIGN1cnJlbnRseSB1c2VkIGJ5IG1vY2tzLlxufTtcblxuYXNzaWduKFJlYWN0RE9NVGV4dENvbXBvbmVudC5wcm90b3R5cGUsIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtSZWFjdFRleHR9IHRleHRcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgLy8gVE9ETzogVGhpcyBpcyByZWFsbHkgYSBSZWFjdFRleHQgKFJlYWN0Tm9kZSksIG5vdCBhIFJlYWN0RWxlbWVudFxuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gdGV4dDtcbiAgICB0aGlzLl9zdHJpbmdUZXh0ID0gJycgKyB0ZXh0O1xuXG4gICAgLy8gUHJvcGVydGllc1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSBudWxsO1xuICAgIHRoaXMuX21vdW50SW5kZXggPSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBtYXJrdXAgZm9yIHRoaXMgdGV4dCBub2RlLiBUaGlzIG5vZGUgaXMgbm90IGludGVuZGVkIHRvIGhhdmVcbiAgICogYW55IGZlYXR1cmVzIGJlc2lkZXMgY29udGFpbmluZyB0ZXh0IGNvbnRlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgRE9NIElEIG9mIHRoZSByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBmb3IgdGhpcyB0ZXh0IG5vZGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChyb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjb250ZXh0W3ZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5XSkge1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmcoJ3NwYW4nLCBudWxsLCBjb250ZXh0W3ZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IHJvb3RJRDtcbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBjb250ZXh0W1JlYWN0TW91bnQub3duZXJEb2N1bWVudENvbnRleHRLZXldO1xuICAgICAgdmFyIGVsID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0QXR0cmlidXRlRm9ySUQoZWwsIHJvb3RJRCk7XG4gICAgICAvLyBQb3B1bGF0ZSBub2RlIGNhY2hlXG4gICAgICBSZWFjdE1vdW50LmdldElEKGVsKTtcbiAgICAgIHNldFRleHRDb250ZW50KGVsLCB0aGlzLl9zdHJpbmdUZXh0KTtcbiAgICAgIHJldHVybiBlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVzY2FwZWRUZXh0ID0gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRoaXMuX3N0cmluZ1RleHQpO1xuXG4gICAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgICAgICAgLy8gTm9ybWFsbHkgd2UnZCB3cmFwIHRoaXMgaW4gYSBgc3BhbmAgZm9yIHRoZSByZWFzb25zIHN0YXRlZCBhYm92ZSwgYnV0XG4gICAgICAgIC8vIHNpbmNlIHRoaXMgaXMgYSBzaXR1YXRpb24gd2hlcmUgUmVhY3Qgd29uJ3QgdGFrZSBvdmVyIChzdGF0aWMgcGFnZXMpLFxuICAgICAgICAvLyB3ZSBjYW4gc2ltcGx5IHJldHVybiB0aGUgdGV4dCBhcyBpdCBpcy5cbiAgICAgICAgcmV0dXJuIGVzY2FwZWRUZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJzxzcGFuICcgKyBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9ySUQocm9vdElEKSArICc+JyArIGVzY2FwZWRUZXh0ICsgJzwvc3Bhbj4nO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGNvbXBvbmVudCBieSB1cGRhdGluZyB0aGUgdGV4dCBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0VGV4dH0gbmV4dFRleHQgVGhlIG5leHQgdGV4dCBjb250ZW50XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dFRleHQsIHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKG5leHRUZXh0ICE9PSB0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0VGV4dDtcbiAgICAgIHZhciBuZXh0U3RyaW5nVGV4dCA9ICcnICsgbmV4dFRleHQ7XG4gICAgICBpZiAobmV4dFN0cmluZ1RleHQgIT09IHRoaXMuX3N0cmluZ1RleHQpIHtcbiAgICAgICAgLy8gVE9ETzogU2F2ZSB0aGlzIGFzIHBlbmRpbmcgcHJvcHMgYW5kIHVzZSBwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnlcbiAgICAgICAgLy8gYW5kL29yIHVwZGF0ZUNvbXBvbmVudCB0byBkbyB0aGUgYWN0dWFsIHVwZGF0ZSBmb3IgY29uc2lzdGVuY3kgd2l0aFxuICAgICAgICAvLyBvdGhlciBjb21wb25lbnQgdHlwZXM/XG4gICAgICAgIHRoaXMuX3N0cmluZ1RleHQgPSBuZXh0U3RyaW5nVGV4dDtcbiAgICAgICAgdmFyIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgICAgIERPTUNoaWxkcmVuT3BlcmF0aW9ucy51cGRhdGVUZXh0Q29udGVudChub2RlLCBuZXh0U3RyaW5nVGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudC51bm1vdW50SURGcm9tRW52aXJvbm1lbnQodGhpcy5fcm9vdE5vZGVJRCk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01UZXh0Q29tcG9uZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01UZXh0Q29tcG9uZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERPTUNoaWxkcmVuT3BlcmF0aW9uc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBEYW5nZXIgPSByZXF1aXJlKCcuL0RhbmdlcicpO1xudmFyIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcycpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG5cbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xudmFyIHNldFRleHRDb250ZW50ID0gcmVxdWlyZSgnLi9zZXRUZXh0Q29udGVudCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEluc2VydHMgYGNoaWxkTm9kZWAgYXMgYSBjaGlsZCBvZiBgcGFyZW50Tm9kZWAgYXQgdGhlIGBpbmRleGAuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBwYXJlbnROb2RlIFBhcmVudCBub2RlIGluIHdoaWNoIHRvIGluc2VydC5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY2hpbGROb2RlIENoaWxkIG5vZGUgdG8gaW5zZXJ0LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgY2hpbGQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaW5zZXJ0Q2hpbGRBdChwYXJlbnROb2RlLCBjaGlsZE5vZGUsIGluZGV4KSB7XG4gIC8vIEJ5IGV4cGxvaXRpbmcgYXJyYXlzIHJldHVybmluZyBgdW5kZWZpbmVkYCBmb3IgYW4gdW5kZWZpbmVkIGluZGV4LCB3ZSBjYW5cbiAgLy8gcmVseSBleGNsdXNpdmVseSBvbiBgaW5zZXJ0QmVmb3JlKG5vZGUsIG51bGwpYCBpbnN0ZWFkIG9mIGFsc28gdXNpbmdcbiAgLy8gYGFwcGVuZENoaWxkKG5vZGUpYC4gSG93ZXZlciwgdXNpbmcgYHVuZGVmaW5lZGAgaXMgbm90IGFsbG93ZWQgYnkgYWxsXG4gIC8vIGJyb3dzZXJzIHNvIHdlIG11c3QgcmVwbGFjZSBpdCB3aXRoIGBudWxsYC5cblxuICAvLyBmaXggcmVuZGVyIG9yZGVyIGVycm9yIGluIHNhZmFyaVxuICAvLyBJRTggd2lsbCB0aHJvdyBlcnJvciB3aGVuIGluZGV4IG91dCBvZiBsaXN0IHNpemUuXG4gIHZhciBiZWZvcmVDaGlsZCA9IGluZGV4ID49IHBhcmVudE5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPyBudWxsIDogcGFyZW50Tm9kZS5jaGlsZE5vZGVzLml0ZW0oaW5kZXgpO1xuXG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkTm9kZSwgYmVmb3JlQ2hpbGQpO1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIHVwZGF0aW5nIHdpdGggRE9NIGNoaWxkcmVuLlxuICovXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0ge1xuXG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwOiBEYW5nZXIuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAsXG5cbiAgdXBkYXRlVGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgY29tcG9uZW50J3MgY2hpbGRyZW4gYnkgcHJvY2Vzc2luZyBhIHNlcmllcyBvZiB1cGRhdGVzLiBUaGVcbiAgICogdXBkYXRlIGNvbmZpZ3VyYXRpb25zIGFyZSBlYWNoIGV4cGVjdGVkIHRvIGhhdmUgYSBgcGFyZW50Tm9kZWAgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXk8b2JqZWN0Pn0gdXBkYXRlcyBMaXN0IG9mIHVwZGF0ZSBjb25maWd1cmF0aW9ucy5cbiAgICogQHBhcmFtIHthcnJheTxzdHJpbmc+fSBtYXJrdXBMaXN0IExpc3Qgb2YgbWFya3VwIHN0cmluZ3MuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvY2Vzc1VwZGF0ZXM6IGZ1bmN0aW9uICh1cGRhdGVzLCBtYXJrdXBMaXN0KSB7XG4gICAgdmFyIHVwZGF0ZTtcbiAgICAvLyBNYXBwaW5nIGZyb20gcGFyZW50IElEcyB0byBpbml0aWFsIGNoaWxkIG9yZGVyaW5ncy5cbiAgICB2YXIgaW5pdGlhbENoaWxkcmVuID0gbnVsbDtcbiAgICAvLyBMaXN0IG9mIGNoaWxkcmVuIHRoYXQgd2lsbCBiZSBtb3ZlZCBvciByZW1vdmVkLlxuICAgIHZhciB1cGRhdGVkQ2hpbGRyZW4gPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB1cGRhdGUgPSB1cGRhdGVzW2ldO1xuICAgICAgaWYgKHVwZGF0ZS50eXBlID09PSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5NT1ZFX0VYSVNUSU5HIHx8IHVwZGF0ZS50eXBlID09PSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5SRU1PVkVfTk9ERSkge1xuICAgICAgICB2YXIgdXBkYXRlZEluZGV4ID0gdXBkYXRlLmZyb21JbmRleDtcbiAgICAgICAgdmFyIHVwZGF0ZWRDaGlsZCA9IHVwZGF0ZS5wYXJlbnROb2RlLmNoaWxkTm9kZXNbdXBkYXRlZEluZGV4XTtcbiAgICAgICAgdmFyIHBhcmVudElEID0gdXBkYXRlLnBhcmVudElEO1xuXG4gICAgICAgICF1cGRhdGVkQ2hpbGQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncHJvY2Vzc1VwZGF0ZXMoKTogVW5hYmxlIHRvIGZpbmQgY2hpbGQgJXMgb2YgZWxlbWVudC4gVGhpcyAnICsgJ3Byb2JhYmx5IG1lYW5zIHRoZSBET00gd2FzIHVuZXhwZWN0ZWRseSBtdXRhdGVkIChlLmcuLCBieSB0aGUgJyArICdicm93c2VyKSwgdXN1YWxseSBkdWUgdG8gZm9yZ2V0dGluZyBhIDx0Ym9keT4gd2hlbiB1c2luZyB0YWJsZXMsICcgKyAnbmVzdGluZyB0YWdzIGxpa2UgPGZvcm0+LCA8cD4sIG9yIDxhPiwgb3IgdXNpbmcgbm9uLVNWRyBlbGVtZW50cyAnICsgJ2luIGFuIDxzdmc+IHBhcmVudC4gVHJ5IGluc3BlY3RpbmcgdGhlIGNoaWxkIG5vZGVzIG9mIHRoZSBlbGVtZW50ICcgKyAnd2l0aCBSZWFjdCBJRCBgJXNgLicsIHVwZGF0ZWRJbmRleCwgcGFyZW50SUQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpbml0aWFsQ2hpbGRyZW4gPSBpbml0aWFsQ2hpbGRyZW4gfHwge307XG4gICAgICAgIGluaXRpYWxDaGlsZHJlbltwYXJlbnRJRF0gPSBpbml0aWFsQ2hpbGRyZW5bcGFyZW50SURdIHx8IFtdO1xuICAgICAgICBpbml0aWFsQ2hpbGRyZW5bcGFyZW50SURdW3VwZGF0ZWRJbmRleF0gPSB1cGRhdGVkQ2hpbGQ7XG5cbiAgICAgICAgdXBkYXRlZENoaWxkcmVuID0gdXBkYXRlZENoaWxkcmVuIHx8IFtdO1xuICAgICAgICB1cGRhdGVkQ2hpbGRyZW4ucHVzaCh1cGRhdGVkQ2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZW5kZXJlZE1hcmt1cDtcbiAgICAvLyBtYXJrdXBMaXN0IGlzIGVpdGhlciBhIGxpc3Qgb2YgbWFya3VwIG9yIGp1c3QgYSBsaXN0IG9mIGVsZW1lbnRzXG4gICAgaWYgKG1hcmt1cExpc3QubGVuZ3RoICYmIHR5cGVvZiBtYXJrdXBMaXN0WzBdID09PSAnc3RyaW5nJykge1xuICAgICAgcmVuZGVyZWRNYXJrdXAgPSBEYW5nZXIuZGFuZ2Vyb3VzbHlSZW5kZXJNYXJrdXAobWFya3VwTGlzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlcmVkTWFya3VwID0gbWFya3VwTGlzdDtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgdXBkYXRlZCBjaGlsZHJlbiBmaXJzdCBzbyB0aGF0IGB0b0luZGV4YCBpcyBjb25zaXN0ZW50LlxuICAgIGlmICh1cGRhdGVkQ2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdXBkYXRlZENoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHVwZGF0ZWRDaGlsZHJlbltqXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHVwZGF0ZWRDaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCB1cGRhdGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICB1cGRhdGUgPSB1cGRhdGVzW2tdO1xuICAgICAgc3dpdGNoICh1cGRhdGUudHlwZSkge1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLklOU0VSVF9NQVJLVVA6XG4gICAgICAgICAgaW5zZXJ0Q2hpbGRBdCh1cGRhdGUucGFyZW50Tm9kZSwgcmVuZGVyZWRNYXJrdXBbdXBkYXRlLm1hcmt1cEluZGV4XSwgdXBkYXRlLnRvSW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLk1PVkVfRVhJU1RJTkc6XG4gICAgICAgICAgaW5zZXJ0Q2hpbGRBdCh1cGRhdGUucGFyZW50Tm9kZSwgaW5pdGlhbENoaWxkcmVuW3VwZGF0ZS5wYXJlbnRJRF1bdXBkYXRlLmZyb21JbmRleF0sIHVwZGF0ZS50b0luZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5TRVRfTUFSS1VQOlxuICAgICAgICAgIHNldElubmVySFRNTCh1cGRhdGUucGFyZW50Tm9kZSwgdXBkYXRlLmNvbnRlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlRFWFRfQ09OVEVOVDpcbiAgICAgICAgICBzZXRUZXh0Q29udGVudCh1cGRhdGUucGFyZW50Tm9kZSwgdXBkYXRlLmNvbnRlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlJFTU9WRV9OT0RFOlxuICAgICAgICAgIC8vIEFscmVhZHkgcmVtb3ZlZCBieSB0aGUgZm9yLWxvb3AgYWJvdmUuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cblJlYWN0UGVyZi5tZWFzdXJlTWV0aG9kcyhET01DaGlsZHJlbk9wZXJhdGlvbnMsICdET01DaGlsZHJlbk9wZXJhdGlvbnMnLCB7XG4gIHVwZGF0ZVRleHRDb250ZW50OiAndXBkYXRlVGV4dENvbnRlbnQnXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01DaGlsZHJlbk9wZXJhdGlvbnM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9ET01DaGlsZHJlbk9wZXJhdGlvbnMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRGFuZ2VyXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cCA9IHJlcXVpcmUoJ2ZianMvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCcpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgZ2V0TWFya3VwV3JhcCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldE1hcmt1cFdyYXAnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIE9QRU5fVEFHX05BTUVfRVhQID0gL14oPFteIFxcLz5dKykvO1xudmFyIFJFU1VMVF9JTkRFWF9BVFRSID0gJ2RhdGEtZGFuZ2VyLWluZGV4JztcblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgYG5vZGVOYW1lYCBmcm9tIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAqXG4gKiBOT1RFOiBFeHRyYWN0aW5nIHRoZSBgbm9kZU5hbWVgIGRvZXMgbm90IHJlcXVpcmUgYSByZWd1bGFyIGV4cHJlc3Npb24gbWF0Y2hcbiAqIGJlY2F1c2Ugd2UgbWFrZSBhc3N1bXB0aW9ucyBhYm91dCBSZWFjdC1nZW5lcmF0ZWQgbWFya3VwIChpLmUuIHRoZXJlIGFyZSBub1xuICogc3BhY2VzIHN1cnJvdW5kaW5nIHRoZSBvcGVuaW5nIHRhZyBhbmQgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGF0dHJpYnV0ZSkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxuICogQHJldHVybiB7c3RyaW5nfSBOb2RlIG5hbWUgb2YgdGhlIHN1cHBsaWVkIG1hcmt1cC5cbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vZXh0cmFjdC1ub2RlbmFtZVxuICovXG5mdW5jdGlvbiBnZXROb2RlTmFtZShtYXJrdXApIHtcbiAgcmV0dXJuIG1hcmt1cC5zdWJzdHJpbmcoMSwgbWFya3VwLmluZGV4T2YoJyAnKSk7XG59XG5cbnZhciBEYW5nZXIgPSB7XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgbWFya3VwIGludG8gYW4gYXJyYXkgb2Ygbm9kZXMuIFRoZSBtYXJrdXAgaXMgZXhwZWN0ZWQgdG8gcmVuZGVyXG4gICAqIGludG8gYSBsaXN0IG9mIHJvb3Qgbm9kZXMuIEFsc28sIHRoZSBsZW5ndGggb2YgYHJlc3VsdExpc3RgIGFuZFxuICAgKiBgbWFya3VwTGlzdGAgc2hvdWxkIGJlIHRoZSBzYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PHN0cmluZz59IG1hcmt1cExpc3QgTGlzdCBvZiBtYXJrdXAgc3RyaW5ncyB0byByZW5kZXIuXG4gICAqIEByZXR1cm4ge2FycmF5PERPTUVsZW1lbnQ+fSBMaXN0IG9mIHJlbmRlcmVkIG5vZGVzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhbmdlcm91c2x5UmVuZGVyTWFya3VwOiBmdW5jdGlvbiAobWFya3VwTGlzdCkge1xuICAgICFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZW5kZXJNYXJrdXAoLi4uKTogQ2Fubm90IHJlbmRlciBtYXJrdXAgaW4gYSB3b3JrZXIgJyArICd0aHJlYWQuIE1ha2Ugc3VyZSBgd2luZG93YCBhbmQgYGRvY3VtZW50YCBhcmUgYXZhaWxhYmxlIGdsb2JhbGx5ICcgKyAnYmVmb3JlIHJlcXVpcmluZyBSZWFjdCB3aGVuIHVuaXQgdGVzdGluZyBvciB1c2UgJyArICdSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZyBmb3Igc2VydmVyIHJlbmRlcmluZy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIG5vZGVOYW1lO1xuICAgIHZhciBtYXJrdXBCeU5vZGVOYW1lID0ge307XG4gICAgLy8gR3JvdXAgbWFya3VwIGJ5IGBub2RlTmFtZWAgaWYgYSB3cmFwIGlzIG5lY2Vzc2FyeSwgZWxzZSBieSAnKicuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrdXBMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAhbWFya3VwTGlzdFtpXSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlbmRlck1hcmt1cCguLi4pOiBNaXNzaW5nIG1hcmt1cC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICBub2RlTmFtZSA9IGdldE5vZGVOYW1lKG1hcmt1cExpc3RbaV0pO1xuICAgICAgbm9kZU5hbWUgPSBnZXRNYXJrdXBXcmFwKG5vZGVOYW1lKSA/IG5vZGVOYW1lIDogJyonO1xuICAgICAgbWFya3VwQnlOb2RlTmFtZVtub2RlTmFtZV0gPSBtYXJrdXBCeU5vZGVOYW1lW25vZGVOYW1lXSB8fCBbXTtcbiAgICAgIG1hcmt1cEJ5Tm9kZU5hbWVbbm9kZU5hbWVdW2ldID0gbWFya3VwTGlzdFtpXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdExpc3QgPSBbXTtcbiAgICB2YXIgcmVzdWx0TGlzdEFzc2lnbm1lbnRDb3VudCA9IDA7XG4gICAgZm9yIChub2RlTmFtZSBpbiBtYXJrdXBCeU5vZGVOYW1lKSB7XG4gICAgICBpZiAoIW1hcmt1cEJ5Tm9kZU5hbWUuaGFzT3duUHJvcGVydHkobm9kZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIG1hcmt1cExpc3RCeU5vZGVOYW1lID0gbWFya3VwQnlOb2RlTmFtZVtub2RlTmFtZV07XG5cbiAgICAgIC8vIFRoaXMgZm9yLWluIGxvb3Agc2tpcHMgdGhlIGhvbGVzIG9mIHRoZSBzcGFyc2UgYXJyYXkuIFRoZSBvcmRlciBvZlxuICAgICAgLy8gaXRlcmF0aW9uIHNob3VsZCBmb2xsb3cgdGhlIG9yZGVyIG9mIGFzc2lnbm1lbnQsIHdoaWNoIGhhcHBlbnMgdG8gbWF0Y2hcbiAgICAgIC8vIG51bWVyaWNhbCBpbmRleCBvcmRlciwgYnV0IHdlIGRvbid0IHJlbHkgb24gdGhhdC5cbiAgICAgIHZhciByZXN1bHRJbmRleDtcbiAgICAgIGZvciAocmVzdWx0SW5kZXggaW4gbWFya3VwTGlzdEJ5Tm9kZU5hbWUpIHtcbiAgICAgICAgaWYgKG1hcmt1cExpc3RCeU5vZGVOYW1lLmhhc093blByb3BlcnR5KHJlc3VsdEluZGV4KSkge1xuICAgICAgICAgIHZhciBtYXJrdXAgPSBtYXJrdXBMaXN0QnlOb2RlTmFtZVtyZXN1bHRJbmRleF07XG5cbiAgICAgICAgICAvLyBQdXNoIHRoZSByZXF1ZXN0ZWQgbWFya3VwIHdpdGggYW4gYWRkaXRpb25hbCBSRVNVTFRfSU5ERVhfQVRUUlxuICAgICAgICAgIC8vIGF0dHJpYnV0ZS4gIElmIHRoZSBtYXJrdXAgZG9lcyBub3Qgc3RhcnQgd2l0aCBhIDwgY2hhcmFjdGVyLCBpdFxuICAgICAgICAgIC8vIHdpbGwgYmUgZGlzY2FyZGVkIGJlbG93ICh3aXRoIGFuIGFwcHJvcHJpYXRlIGNvbnNvbGUuZXJyb3IpLlxuICAgICAgICAgIG1hcmt1cExpc3RCeU5vZGVOYW1lW3Jlc3VsdEluZGV4XSA9IG1hcmt1cC5yZXBsYWNlKE9QRU5fVEFHX05BTUVfRVhQLFxuICAgICAgICAgIC8vIFRoaXMgaW5kZXggd2lsbCBiZSBwYXJzZWQgYmFjayBvdXQgYmVsb3cuXG4gICAgICAgICAgJyQxICcgKyBSRVNVTFRfSU5ERVhfQVRUUiArICc9XCInICsgcmVzdWx0SW5kZXggKyAnXCIgJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVuZGVyIGVhY2ggZ3JvdXAgb2YgbWFya3VwIHdpdGggc2ltaWxhciB3cmFwcGluZyBgbm9kZU5hbWVgLlxuICAgICAgdmFyIHJlbmRlck5vZGVzID0gY3JlYXRlTm9kZXNGcm9tTWFya3VwKG1hcmt1cExpc3RCeU5vZGVOYW1lLmpvaW4oJycpLCBlbXB0eUZ1bmN0aW9uIC8vIERvIG5vdGhpbmcgc3BlY2lhbCB3aXRoIDxzY3JpcHQ+IHRhZ3MuXG4gICAgICApO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlbmRlck5vZGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHZhciByZW5kZXJOb2RlID0gcmVuZGVyTm9kZXNbal07XG4gICAgICAgIGlmIChyZW5kZXJOb2RlLmhhc0F0dHJpYnV0ZSAmJiByZW5kZXJOb2RlLmhhc0F0dHJpYnV0ZShSRVNVTFRfSU5ERVhfQVRUUikpIHtcblxuICAgICAgICAgIHJlc3VsdEluZGV4ID0gK3JlbmRlck5vZGUuZ2V0QXR0cmlidXRlKFJFU1VMVF9JTkRFWF9BVFRSKTtcbiAgICAgICAgICByZW5kZXJOb2RlLnJlbW92ZUF0dHJpYnV0ZShSRVNVTFRfSU5ERVhfQVRUUik7XG5cbiAgICAgICAgICAhIXJlc3VsdExpc3QuaGFzT3duUHJvcGVydHkocmVzdWx0SW5kZXgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0RhbmdlcjogQXNzaWduaW5nIHRvIGFuIGFscmVhZHktb2NjdXBpZWQgcmVzdWx0IGluZGV4LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHJlc3VsdExpc3RbcmVzdWx0SW5kZXhdID0gcmVuZGVyTm9kZTtcblxuICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG1hdGNoIHJlc3VsdExpc3QubGVuZ3RoIGFuZCBtYXJrdXBMaXN0Lmxlbmd0aCB3aGVuXG4gICAgICAgICAgLy8gd2UncmUgZG9uZS5cbiAgICAgICAgICByZXN1bHRMaXN0QXNzaWdubWVudENvdW50ICs9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0RhbmdlcjogRGlzY2FyZGluZyB1bmV4cGVjdGVkIG5vZGU6JywgcmVuZGVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbHRob3VnaCByZXN1bHRMaXN0IHdhcyBwb3B1bGF0ZWQgb3V0IG9mIG9yZGVyLCBpdCBzaG91bGQgbm93IGJlIGEgZGVuc2VcbiAgICAvLyBhcnJheS5cbiAgICAhKHJlc3VsdExpc3RBc3NpZ25tZW50Q291bnQgPT09IHJlc3VsdExpc3QubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdEYW5nZXI6IERpZCBub3QgYXNzaWduIHRvIGV2ZXJ5IGluZGV4IG9mIHJlc3VsdExpc3QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgIShyZXN1bHRMaXN0Lmxlbmd0aCA9PT0gbWFya3VwTGlzdC5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0RhbmdlcjogRXhwZWN0ZWQgbWFya3VwIHRvIHJlbmRlciAlcyBub2RlcywgYnV0IHJlbmRlcmVkICVzLicsIG1hcmt1cExpc3QubGVuZ3RoLCByZXN1bHRMaXN0Lmxlbmd0aCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIHJlc3VsdExpc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGEgbm9kZSB3aXRoIGEgc3RyaW5nIG9mIG1hcmt1cCBhdCBpdHMgY3VycmVudCBwb3NpdGlvbiB3aXRoaW4gaXRzXG4gICAqIHBhcmVudC4gVGhlIG1hcmt1cCBtdXN0IHJlbmRlciBpbnRvIGEgc2luZ2xlIHJvb3Qgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBvbGRDaGlsZCBDaGlsZCBub2RlIHRvIHJlcGxhY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRvIHJlbmRlciBpbiBwbGFjZSBvZiB0aGUgY2hpbGQgbm9kZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDogZnVuY3Rpb24gKG9sZENoaWxkLCBtYXJrdXApIHtcbiAgICAhRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IENhbm5vdCByZW5kZXIgbWFya3VwIGluIGEgJyArICd3b3JrZXIgdGhyZWFkLiBNYWtlIHN1cmUgYHdpbmRvd2AgYW5kIGBkb2N1bWVudGAgYXJlIGF2YWlsYWJsZSAnICsgJ2dsb2JhbGx5IGJlZm9yZSByZXF1aXJpbmcgUmVhY3Qgd2hlbiB1bml0IHRlc3Rpbmcgb3IgdXNlICcgKyAnUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcoKSBmb3Igc2VydmVyIHJlbmRlcmluZy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgIW1hcmt1cCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBNaXNzaW5nIG1hcmt1cC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgIShvbGRDaGlsZC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdodG1sJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogQ2Fubm90IHJlcGxhY2UgbWFya3VwIG9mIHRoZSAnICsgJzxodG1sPiBub2RlLiBUaGlzIGlzIGJlY2F1c2UgYnJvd3NlciBxdWlya3MgbWFrZSB0aGlzIHVucmVsaWFibGUgJyArICdhbmQvb3Igc2xvdy4gSWYgeW91IHdhbnQgdG8gcmVuZGVyIHRvIHRoZSByb290IHlvdSBtdXN0IHVzZSAnICsgJ3NlcnZlciByZW5kZXJpbmcuIFNlZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBuZXdDaGlsZDtcbiAgICBpZiAodHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5ld0NoaWxkID0gY3JlYXRlTm9kZXNGcm9tTWFya3VwKG1hcmt1cCwgZW1wdHlGdW5jdGlvbilbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0NoaWxkID0gbWFya3VwO1xuICAgIH1cbiAgICBvbGRDaGlsZC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdDaGlsZCwgb2xkQ2hpbGQpO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGFuZ2VyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvRGFuZ2VyLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV4ZWN1dGlvbkVudmlyb25tZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxuLyoqXG4gKiBTaW1wbGUsIGxpZ2h0d2VpZ2h0IG1vZHVsZSBhc3Npc3Rpbmcgd2l0aCB0aGUgZGV0ZWN0aW9uIGFuZCBjb250ZXh0IG9mXG4gKiBXb3JrZXIuIEhlbHBzIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBhbmQgYWxsb3dzIGNvZGUgdG8gcmVhc29uIGFib3V0XG4gKiB3aGV0aGVyIG9yIG5vdCB0aGV5IGFyZSBpbiBhIFdvcmtlciwgZXZlbiBpZiB0aGV5IG5ldmVyIGluY2x1ZGUgdGhlIG1haW5cbiAqIGBSZWFjdFdvcmtlcmAgZGVwZW5kZW5jeS5cbiAqL1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0ge1xuXG4gIGNhblVzZURPTTogY2FuVXNlRE9NLFxuXG4gIGNhblVzZVdvcmtlcnM6IHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnLFxuXG4gIGNhblVzZUV2ZW50TGlzdGVuZXJzOiBjYW5Vc2VET00gJiYgISEod2luZG93LmFkZEV2ZW50TGlzdGVuZXIgfHwgd2luZG93LmF0dGFjaEV2ZW50KSxcblxuICBjYW5Vc2VWaWV3cG9ydDogY2FuVXNlRE9NICYmICEhd2luZG93LnNjcmVlbixcblxuICBpc0luV29ya2VyOiAhY2FuVXNlRE9NIC8vIEZvciBub3csIHRoaXMgaXMgdHJ1ZSAtIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXBcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSBmYi13d3cvdW5zYWZlLWh0bWwqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGNyZWF0ZUFycmF5RnJvbU1peGVkID0gcmVxdWlyZSgnLi9jcmVhdGVBcnJheUZyb21NaXhlZCcpO1xudmFyIGdldE1hcmt1cFdyYXAgPSByZXF1aXJlKCcuL2dldE1hcmt1cFdyYXAnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIER1bW15IGNvbnRhaW5lciB1c2VkIHRvIHJlbmRlciBhbGwgbWFya3VwLlxuICovXG52YXIgZHVtbXlOb2RlID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykgOiBudWxsO1xuXG4vKipcbiAqIFBhdHRlcm4gdXNlZCBieSBgZ2V0Tm9kZU5hbWVgLlxuICovXG52YXIgbm9kZU5hbWVQYXR0ZXJuID0gL15cXHMqPChcXHcrKS87XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIGBub2RlTmFtZWAgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gYSBzdHJpbmcgb2YgbWFya3VwLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgU3RyaW5nIG9mIG1hcmt1cC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IE5vZGUgbmFtZSBvZiB0aGUgc3VwcGxpZWQgbWFya3VwLlxuICovXG5mdW5jdGlvbiBnZXROb2RlTmFtZShtYXJrdXApIHtcbiAgdmFyIG5vZGVOYW1lTWF0Y2ggPSBtYXJrdXAubWF0Y2gobm9kZU5hbWVQYXR0ZXJuKTtcbiAgcmV0dXJuIG5vZGVOYW1lTWF0Y2ggJiYgbm9kZU5hbWVNYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbm9kZXMgcmVuZGVyZWQgZnJvbSB0aGUgc3VwcGxpZWQgbWFya3VwLiBUaGVcbiAqIG9wdGlvbmFsbHkgc3VwcGxpZWQgYGhhbmRsZVNjcmlwdGAgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIG9uY2UgZm9yIGVhY2hcbiAqIDxzY3JpcHQ+IGVsZW1lbnQgdGhhdCBpcyByZW5kZXJlZC4gSWYgbm8gYGhhbmRsZVNjcmlwdGAgZnVuY3Rpb24gaXMgc3VwcGxpZWQsXG4gKiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGlmIGFueSA8c2NyaXB0PiBlbGVtZW50cyBhcmUgcmVuZGVyZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBBIHN0cmluZyBvZiB2YWxpZCBIVE1MIG1hcmt1cC5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBoYW5kbGVTY3JpcHQgSW52b2tlZCBvbmNlIGZvciBlYWNoIHJlbmRlcmVkIDxzY3JpcHQ+LlxuICogQHJldHVybiB7YXJyYXk8RE9NRWxlbWVudHxET01UZXh0Tm9kZT59IEFuIGFycmF5IG9mIHJlbmRlcmVkIG5vZGVzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAobWFya3VwLCBoYW5kbGVTY3JpcHQpIHtcbiAgdmFyIG5vZGUgPSBkdW1teU5vZGU7XG4gICEhIWR1bW15Tm9kZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdjcmVhdGVOb2Rlc0Zyb21NYXJrdXAgZHVtbXkgbm90IGluaXRpYWxpemVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB2YXIgbm9kZU5hbWUgPSBnZXROb2RlTmFtZShtYXJrdXApO1xuXG4gIHZhciB3cmFwID0gbm9kZU5hbWUgJiYgZ2V0TWFya3VwV3JhcChub2RlTmFtZSk7XG4gIGlmICh3cmFwKSB7XG4gICAgbm9kZS5pbm5lckhUTUwgPSB3cmFwWzFdICsgbWFya3VwICsgd3JhcFsyXTtcblxuICAgIHZhciB3cmFwRGVwdGggPSB3cmFwWzBdO1xuICAgIHdoaWxlICh3cmFwRGVwdGgtLSkge1xuICAgICAgbm9kZSA9IG5vZGUubGFzdENoaWxkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlLmlubmVySFRNTCA9IG1hcmt1cDtcbiAgfVxuXG4gIHZhciBzY3JpcHRzID0gbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XG4gIGlmIChzY3JpcHRzLmxlbmd0aCkge1xuICAgICFoYW5kbGVTY3JpcHQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnY3JlYXRlTm9kZXNGcm9tTWFya3VwKC4uLik6IFVuZXhwZWN0ZWQgPHNjcmlwdD4gZWxlbWVudCByZW5kZXJlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgY3JlYXRlQXJyYXlGcm9tTWl4ZWQoc2NyaXB0cykuZm9yRWFjaChoYW5kbGVTY3JpcHQpO1xuICB9XG5cbiAgdmFyIG5vZGVzID0gY3JlYXRlQXJyYXlGcm9tTWl4ZWQobm9kZS5jaGlsZE5vZGVzKTtcbiAgd2hpbGUgKG5vZGUubGFzdENoaWxkKSB7XG4gICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmxhc3RDaGlsZCk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZU5vZGVzRnJvbU1hcmt1cDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvY3JlYXRlTm9kZXNGcm9tTWFya3VwLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNyZWF0ZUFycmF5RnJvbU1peGVkXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRvQXJyYXkgPSByZXF1aXJlKCcuL3RvQXJyYXknKTtcblxuLyoqXG4gKiBQZXJmb3JtIGEgaGV1cmlzdGljIHRlc3QgdG8gZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBcImFycmF5LWxpa2VcIi5cbiAqXG4gKiAgIEEgbW9uayBhc2tlZCBKb3NodSwgYSBaZW4gbWFzdGVyLCBcIkhhcyBhIGRvZyBCdWRkaGEgbmF0dXJlP1wiXG4gKiAgIEpvc2h1IHJlcGxpZWQ6IFwiTXUuXCJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRldGVybWluZXMgaWYgaXRzIGFyZ3VtZW50IGhhcyBcImFycmF5IG5hdHVyZVwiOiBpdCByZXR1cm5zXG4gKiB0cnVlIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBhY3R1YWwgYXJyYXksIGFuIGBhcmd1bWVudHMnIG9iamVjdCwgb3IgYW5cbiAqIEhUTUxDb2xsZWN0aW9uIChlLmcuIG5vZGUuY2hpbGROb2RlcyBvciBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCkpLlxuICpcbiAqIEl0IHdpbGwgcmV0dXJuIGZhbHNlIGZvciBvdGhlciBhcnJheS1saWtlIG9iamVjdHMgbGlrZSBGaWxlbGlzdC5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaGFzQXJyYXlOYXR1cmUob2JqKSB7XG4gIHJldHVybihcbiAgICAvLyBub3QgbnVsbC9mYWxzZVxuICAgICEhb2JqICYmIChcbiAgICAvLyBhcnJheXMgYXJlIG9iamVjdHMsIE5vZGVMaXN0cyBhcmUgZnVuY3Rpb25zIGluIFNhZmFyaVxuICAgIHR5cGVvZiBvYmogPT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nKSAmJlxuICAgIC8vIHF1YWNrcyBsaWtlIGFuIGFycmF5XG4gICAgJ2xlbmd0aCcgaW4gb2JqICYmXG4gICAgLy8gbm90IHdpbmRvd1xuICAgICEoJ3NldEludGVydmFsJyBpbiBvYmopICYmXG4gICAgLy8gbm8gRE9NIG5vZGUgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYW4gYXJyYXktbGlrZVxuICAgIC8vIGEgJ3NlbGVjdCcgZWxlbWVudCBoYXMgJ2xlbmd0aCcgYW5kICdpdGVtJyBwcm9wZXJ0aWVzIG9uIElFOFxuICAgIHR5cGVvZiBvYmoubm9kZVR5cGUgIT0gJ251bWJlcicgJiYgKFxuICAgIC8vIGEgcmVhbCBhcnJheVxuICAgIEFycmF5LmlzQXJyYXkob2JqKSB8fFxuICAgIC8vIGFyZ3VtZW50c1xuICAgICdjYWxsZWUnIGluIG9iaiB8fFxuICAgIC8vIEhUTUxDb2xsZWN0aW9uL05vZGVMaXN0XG4gICAgJ2l0ZW0nIGluIG9iailcbiAgKTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXkgYnkgd3JhcHBpbmcgaXQgaW4gYW4gYXJyYXkgaWYgaXQgaXMgbm90LlxuICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhlIGFyZ3VtZW50IGlmIGl0IGlzIGFscmVhZHkgYW4gYXJyYXkuXG4gKlxuICogVGhpcyBpcyBtb3N0bHkgdXNlZnVsIGlkaW9tYXRpY2FsbHk6XG4gKlxuICogICB2YXIgY3JlYXRlQXJyYXlGcm9tTWl4ZWQgPSByZXF1aXJlKCdjcmVhdGVBcnJheUZyb21NaXhlZCcpO1xuICpcbiAqICAgZnVuY3Rpb24gdGFrZXNPbmVPck1vcmVUaGluZ3ModGhpbmdzKSB7XG4gKiAgICAgdGhpbmdzID0gY3JlYXRlQXJyYXlGcm9tTWl4ZWQodGhpbmdzKTtcbiAqICAgICAuLi5cbiAqICAgfVxuICpcbiAqIFRoaXMgYWxsb3dzIHlvdSB0byB0cmVhdCBgdGhpbmdzJyBhcyBhbiBhcnJheSwgYnV0IGFjY2VwdCBzY2FsYXJzIGluIHRoZSBBUEkuXG4gKlxuICogSWYgeW91IG5lZWQgdG8gY29udmVydCBhbiBhcnJheS1saWtlIG9iamVjdCwgbGlrZSBgYXJndW1lbnRzYCwgaW50byBhbiBhcnJheVxuICogdXNlIHRvQXJyYXkgaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5RnJvbU1peGVkKG9iaikge1xuICBpZiAoIWhhc0FycmF5TmF0dXJlKG9iaikpIHtcbiAgICByZXR1cm4gW29ial07XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5zbGljZSgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0b0FycmF5KG9iaik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBcnJheUZyb21NaXhlZDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvY3JlYXRlQXJyYXlGcm9tTWl4ZWQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgdG9BcnJheVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIENvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIGFycmF5cy5cbiAqXG4gKiBUaGlzIEFQSSBhc3N1bWVzIHRoZSBjYWxsZXIga25vd3MgdGhlIGNvbnRlbnRzIG9mIHRoZSBkYXRhIHR5cGUuIEZvciBsZXNzXG4gKiB3ZWxsIGRlZmluZWQgaW5wdXRzIHVzZSBjcmVhdGVBcnJheUZyb21NaXhlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbnxmaWxlbGlzdH0gb2JqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgdmFyIGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cbiAgLy8gU29tZSBicm93c2UgYnVpbHRpbiBvYmplY3RzIGNhbiByZXBvcnQgdHlwZW9mICdmdW5jdGlvbicgKGUuZy4gTm9kZUxpc3QgaW5cbiAgLy8gb2xkIHZlcnNpb25zIG9mIFNhZmFyaSkuXG4gICEoIUFycmF5LmlzQXJyYXkob2JqKSAmJiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IEFycmF5LWxpa2Ugb2JqZWN0IGV4cGVjdGVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICEodHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IE9iamVjdCBuZWVkcyBhIGxlbmd0aCBwcm9wZXJ0eScpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAhKGxlbmd0aCA9PT0gMCB8fCBsZW5ndGggLSAxIGluIG9iaikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogT2JqZWN0IHNob3VsZCBoYXZlIGtleXMgZm9yIGluZGljZXMnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgLy8gT2xkIElFIGRvZXNuJ3QgZ2l2ZSBjb2xsZWN0aW9ucyBhY2Nlc3MgdG8gaGFzT3duUHJvcGVydHkuIEFzc3VtZSBpbnB1dHNcbiAgLy8gd2l0aG91dCBtZXRob2Qgd2lsbCB0aHJvdyBkdXJpbmcgdGhlIHNsaWNlIGNhbGwgYW5kIHNraXAgc3RyYWlnaHQgdG8gdGhlXG4gIC8vIGZhbGxiYWNrLlxuICBpZiAob2JqLmhhc093blByb3BlcnR5KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmopO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElFIDwgOSBkb2VzIG5vdCBzdXBwb3J0IEFycmF5I3NsaWNlIG9uIGNvbGxlY3Rpb25zIG9iamVjdHNcbiAgICB9XG4gIH1cblxuICAvLyBGYWxsIGJhY2sgdG8gY29weWluZyBrZXkgYnkga2V5LiBUaGlzIGFzc3VtZXMgYWxsIGtleXMgaGF2ZSBhIHZhbHVlLFxuICAvLyBzbyB3aWxsIG5vdCBwcmVzZXJ2ZSBzcGFyc2VseSBwb3B1bGF0ZWQgaW5wdXRzLlxuICB2YXIgcmV0ID0gQXJyYXkobGVuZ3RoKTtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGxlbmd0aDsgaWkrKykge1xuICAgIHJldFtpaV0gPSBvYmpbaWldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9BcnJheTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvdG9BcnJheS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpbnZhcmlhbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvaW52YXJpYW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldE1hcmt1cFdyYXBcbiAqL1xuXG4vKmVzbGludC1kaXNhYmxlIGZiLXd3dy91bnNhZmUtaHRtbCAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogRHVtbXkgY29udGFpbmVyIHVzZWQgdG8gZGV0ZWN0IHdoaWNoIHdyYXBzIGFyZSBuZWNlc3NhcnkuXG4gKi9cbnZhciBkdW1teU5vZGUgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSA6IG51bGw7XG5cbi8qKlxuICogU29tZSBicm93c2VycyBjYW5ub3QgdXNlIGBpbm5lckhUTUxgIHRvIHJlbmRlciBjZXJ0YWluIGVsZW1lbnRzIHN0YW5kYWxvbmUsXG4gKiBzbyB3ZSB3cmFwIHRoZW0sIHJlbmRlciB0aGUgd3JhcHBlZCBub2RlcywgdGhlbiBleHRyYWN0IHRoZSBkZXNpcmVkIG5vZGUuXG4gKlxuICogSW4gSUU4LCBjZXJ0YWluIGVsZW1lbnRzIGNhbm5vdCByZW5kZXIgYWxvbmUsIHNvIHdyYXAgYWxsIGVsZW1lbnRzICgnKicpLlxuICovXG5cbnZhciBzaG91bGRXcmFwID0ge307XG5cbnZhciBzZWxlY3RXcmFwID0gWzEsICc8c2VsZWN0IG11bHRpcGxlPVwidHJ1ZVwiPicsICc8L3NlbGVjdD4nXTtcbnZhciB0YWJsZVdyYXAgPSBbMSwgJzx0YWJsZT4nLCAnPC90YWJsZT4nXTtcbnZhciB0cldyYXAgPSBbMywgJzx0YWJsZT48dGJvZHk+PHRyPicsICc8L3RyPjwvdGJvZHk+PC90YWJsZT4nXTtcblxudmFyIHN2Z1dyYXAgPSBbMSwgJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPicsICc8L3N2Zz4nXTtcblxudmFyIG1hcmt1cFdyYXAgPSB7XG4gICcqJzogWzEsICc/PGRpdj4nLCAnPC9kaXY+J10sXG5cbiAgJ2FyZWEnOiBbMSwgJzxtYXA+JywgJzwvbWFwPiddLFxuICAnY29sJzogWzIsICc8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPicsICc8L2NvbGdyb3VwPjwvdGFibGU+J10sXG4gICdsZWdlbmQnOiBbMSwgJzxmaWVsZHNldD4nLCAnPC9maWVsZHNldD4nXSxcbiAgJ3BhcmFtJzogWzEsICc8b2JqZWN0PicsICc8L29iamVjdD4nXSxcbiAgJ3RyJzogWzIsICc8dGFibGU+PHRib2R5PicsICc8L3Rib2R5PjwvdGFibGU+J10sXG5cbiAgJ29wdGdyb3VwJzogc2VsZWN0V3JhcCxcbiAgJ29wdGlvbic6IHNlbGVjdFdyYXAsXG5cbiAgJ2NhcHRpb24nOiB0YWJsZVdyYXAsXG4gICdjb2xncm91cCc6IHRhYmxlV3JhcCxcbiAgJ3Rib2R5JzogdGFibGVXcmFwLFxuICAndGZvb3QnOiB0YWJsZVdyYXAsXG4gICd0aGVhZCc6IHRhYmxlV3JhcCxcblxuICAndGQnOiB0cldyYXAsXG4gICd0aCc6IHRyV3JhcFxufTtcblxuLy8gSW5pdGlhbGl6ZSB0aGUgU1ZHIGVsZW1lbnRzIHNpbmNlIHdlIGtub3cgdGhleSdsbCBhbHdheXMgbmVlZCB0byBiZSB3cmFwcGVkXG4vLyBjb25zaXN0ZW50bHkuIElmIHRoZXkgYXJlIGNyZWF0ZWQgaW5zaWRlIGEgPGRpdj4gdGhleSB3aWxsIGJlIGluaXRpYWxpemVkIGluXG4vLyB0aGUgd3JvbmcgbmFtZXNwYWNlIChhbmQgd2lsbCBub3QgZGlzcGxheSkuXG52YXIgc3ZnRWxlbWVudHMgPSBbJ2NpcmNsZScsICdjbGlwUGF0aCcsICdkZWZzJywgJ2VsbGlwc2UnLCAnZycsICdpbWFnZScsICdsaW5lJywgJ2xpbmVhckdyYWRpZW50JywgJ21hc2snLCAncGF0aCcsICdwYXR0ZXJuJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAncmFkaWFsR3JhZGllbnQnLCAncmVjdCcsICdzdG9wJywgJ3RleHQnLCAndHNwYW4nXTtcbnN2Z0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG5vZGVOYW1lKSB7XG4gIG1hcmt1cFdyYXBbbm9kZU5hbWVdID0gc3ZnV3JhcDtcbiAgc2hvdWxkV3JhcFtub2RlTmFtZV0gPSB0cnVlO1xufSk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFya3VwIHdyYXAgY29uZmlndXJhdGlvbiBmb3IgdGhlIHN1cHBsaWVkIGBub2RlTmFtZWAuXG4gKlxuICogTk9URTogVGhpcyBsYXppbHkgZGV0ZWN0cyB3aGljaCB3cmFwcyBhcmUgbmVjZXNzYXJ5IGZvciB0aGUgY3VycmVudCBicm93c2VyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBub2RlTmFtZSBMb3dlcmNhc2UgYG5vZGVOYW1lYC5cbiAqIEByZXR1cm4gez9hcnJheX0gTWFya3VwIHdyYXAgY29uZmlndXJhdGlvbiwgaWYgYXBwbGljYWJsZS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFya3VwV3JhcChub2RlTmFtZSkge1xuICAhISFkdW1teU5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTWFya3VwIHdyYXBwaW5nIG5vZGUgbm90IGluaXRpYWxpemVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBpZiAoIW1hcmt1cFdyYXAuaGFzT3duUHJvcGVydHkobm9kZU5hbWUpKSB7XG4gICAgbm9kZU5hbWUgPSAnKic7XG4gIH1cbiAgaWYgKCFzaG91bGRXcmFwLmhhc093blByb3BlcnR5KG5vZGVOYW1lKSkge1xuICAgIGlmIChub2RlTmFtZSA9PT0gJyonKSB7XG4gICAgICBkdW1teU5vZGUuaW5uZXJIVE1MID0gJzxsaW5rIC8+JztcbiAgICB9IGVsc2Uge1xuICAgICAgZHVtbXlOb2RlLmlubmVySFRNTCA9ICc8JyArIG5vZGVOYW1lICsgJz48LycgKyBub2RlTmFtZSArICc+JztcbiAgICB9XG4gICAgc2hvdWxkV3JhcFtub2RlTmFtZV0gPSAhZHVtbXlOb2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIHNob3VsZFdyYXBbbm9kZU5hbWVdID8gbWFya3VwV3JhcFtub2RlTmFtZV0gOiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcmt1cFdyYXA7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2dldE1hcmt1cFdyYXAuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZW1wdHlGdW5jdGlvblxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xuZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU1pcnJvcicpO1xuXG4vKipcbiAqIFdoZW4gYSBjb21wb25lbnQncyBjaGlsZHJlbiBhcmUgdXBkYXRlZCwgYSBzZXJpZXMgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdHMgYXJlIGNyZWF0ZWQgaW4gb3JkZXIgdG8gYmF0Y2ggYW5kIHNlcmlhbGl6ZSB0aGUgcmVxdWlyZWQgY2hhbmdlcy5cbiAqXG4gKiBFbnVtZXJhdGVzIGFsbCB0aGUgcG9zc2libGUgdHlwZXMgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMgPSBrZXlNaXJyb3Ioe1xuICBJTlNFUlRfTUFSS1VQOiBudWxsLFxuICBNT1ZFX0VYSVNUSU5HOiBudWxsLFxuICBSRU1PVkVfTk9ERTogbnVsbCxcbiAgU0VUX01BUktVUDogbnVsbCxcbiAgVEVYVF9DT05URU5UOiBudWxsXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGtleU1pcnJvclxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYW4gZW51bWVyYXRpb24gd2l0aCBrZXlzIGVxdWFsIHRvIHRoZWlyIHZhbHVlLlxuICpcbiAqIEZvciBleGFtcGxlOlxuICpcbiAqICAgdmFyIENPTE9SUyA9IGtleU1pcnJvcih7Ymx1ZTogbnVsbCwgcmVkOiBudWxsfSk7XG4gKiAgIHZhciBteUNvbG9yID0gQ09MT1JTLmJsdWU7XG4gKiAgIHZhciBpc0NvbG9yVmFsaWQgPSAhIUNPTE9SU1tteUNvbG9yXTtcbiAqXG4gKiBUaGUgbGFzdCBsaW5lIGNvdWxkIG5vdCBiZSBwZXJmb3JtZWQgaWYgdGhlIHZhbHVlcyBvZiB0aGUgZ2VuZXJhdGVkIGVudW0gd2VyZVxuICogbm90IGVxdWFsIHRvIHRoZWlyIGtleXMuXG4gKlxuICogICBJbnB1dDogIHtrZXkxOiB2YWwxLCBrZXkyOiB2YWwyfVxuICogICBPdXRwdXQ6IHtrZXkxOiBrZXkxLCBrZXkyOiBrZXkyfVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xudmFyIGtleU1pcnJvciA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJldCA9IHt9O1xuICB2YXIga2V5O1xuICAhKG9iaiBpbnN0YW5jZW9mIE9iamVjdCAmJiAhQXJyYXkuaXNBcnJheShvYmopKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdrZXlNaXJyb3IoLi4uKTogQXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0W2tleV0gPSBrZXk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5TWlycm9yO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9rZXlNaXJyb3IuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQZXJmXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZWFjdFBlcmYgaXMgYSBnZW5lcmFsIEFPUCBzeXN0ZW0gZGVzaWduZWQgdG8gbWVhc3VyZSBwZXJmb3JtYW5jZS4gVGhpc1xuICogbW9kdWxlIG9ubHkgaGFzIHRoZSBob29rczogc2VlIFJlYWN0RGVmYXVsdFBlcmYgZm9yIHRoZSBhbmFseXNpcyB0b29sLlxuICovXG52YXIgUmVhY3RQZXJmID0ge1xuICAvKipcbiAgICogQm9vbGVhbiB0byBlbmFibGUvZGlzYWJsZSBtZWFzdXJlbWVudC4gU2V0IHRvIGZhbHNlIGJ5IGRlZmF1bHQgdG8gcHJldmVudFxuICAgKiBhY2NpZGVudGFsIGxvZ2dpbmcgYW5kIHBlcmYgbG9zcy5cbiAgICovXG4gIGVuYWJsZU1lYXN1cmU6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBIb2xkcyBvbnRvIHRoZSBtZWFzdXJlIGZ1bmN0aW9uIGluIHVzZS4gQnkgZGVmYXVsdCwgZG9uJ3QgbWVhc3VyZVxuICAgKiBhbnl0aGluZywgYnV0IHdlJ2xsIG92ZXJyaWRlIHRoaXMgaWYgd2UgaW5qZWN0IGEgbWVhc3VyZSBmdW5jdGlvbi5cbiAgICovXG4gIHN0b3JlZE1lYXN1cmU6IF9ub01lYXN1cmUsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9iamVjdE5hbWVcbiAgICogQHBhcmFtIHtvYmplY3Q8c3RyaW5nPn0gbWV0aG9kTmFtZXNcbiAgICovXG4gIG1lYXN1cmVNZXRob2RzOiBmdW5jdGlvbiAob2JqZWN0LCBvYmplY3ROYW1lLCBtZXRob2ROYW1lcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kTmFtZXMpIHtcbiAgICAgICAgaWYgKCFtZXRob2ROYW1lcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0W2tleV0gPSBSZWFjdFBlcmYubWVhc3VyZShvYmplY3ROYW1lLCBtZXRob2ROYW1lc1trZXldLCBvYmplY3Rba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyB0byB3cmFwIG1ldGhvZHMgeW91IHdhbnQgdG8gbWVhc3VyZS4gWmVybyBvdmVyaGVhZCBpbiBwcm9kdWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2JqTmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm5OYW1lXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmNcbiAgICogQHJldHVybiB7ZnVuY3Rpb259XG4gICAqL1xuICBtZWFzdXJlOiBmdW5jdGlvbiAob2JqTmFtZSwgZm5OYW1lLCBmdW5jKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtZWFzdXJlZEZ1bmMgPSBudWxsO1xuICAgICAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChSZWFjdFBlcmYuZW5hYmxlTWVhc3VyZSkge1xuICAgICAgICAgIGlmICghbWVhc3VyZWRGdW5jKSB7XG4gICAgICAgICAgICBtZWFzdXJlZEZ1bmMgPSBSZWFjdFBlcmYuc3RvcmVkTWVhc3VyZShvYmpOYW1lLCBmbk5hbWUsIGZ1bmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVhc3VyZWRGdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICB3cmFwcGVyLmRpc3BsYXlOYW1lID0gb2JqTmFtZSArICdfJyArIGZuTmFtZTtcbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYztcbiAgfSxcblxuICBpbmplY3Rpb246IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZWFzdXJlXG4gICAgICovXG4gICAgaW5qZWN0TWVhc3VyZTogZnVuY3Rpb24gKG1lYXN1cmUpIHtcbiAgICAgIFJlYWN0UGVyZi5zdG9yZWRNZWFzdXJlID0gbWVhc3VyZTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogU2ltcGx5IHBhc3NlcyB0aHJvdWdoIHRoZSBtZWFzdXJlZCBmdW5jdGlvbiwgd2l0aG91dCBtZWFzdXJpbmcgaXQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG9iak5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBmbk5hbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmNcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBfbm9NZWFzdXJlKG9iak5hbWUsIGZuTmFtZSwgZnVuYykge1xuICByZXR1cm4gZnVuYztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFBlcmY7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFBlcmYuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgc2V0SW5uZXJIVE1MXG4gKi9cblxuLyogZ2xvYmFscyBNU0FwcCAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBXSElURVNQQUNFX1RFU1QgPSAvXlsgXFxyXFxuXFx0XFxmXS87XG52YXIgTk9OVklTSUJMRV9URVNUID0gLzwoIS0tfGxpbmt8bm9zY3JpcHR8bWV0YXxzY3JpcHR8c3R5bGUpWyBcXHJcXG5cXHRcXGZcXC8+XS87XG5cbi8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlLCBlbnN1cmluZyB0aGF0IHdoaXRlc3BhY2UgaXMgcHJlc2VydmVkXG4gKiBldmVuIGluIElFOC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHNldElubmVySFRNTCA9IGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbn07XG5cbi8vIFdpbjggYXBwczogQWxsb3cgYWxsIGh0bWwgdG8gYmUgaW5zZXJ0ZWRcbmlmICh0eXBlb2YgTVNBcHAgIT09ICd1bmRlZmluZWQnICYmIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKSB7XG4gIHNldElubmVySFRNTCA9IGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5pbm5lckhUTUwgPSBodG1sO1xuICAgIH0pO1xuICB9O1xufVxuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFODogV2hlbiB1cGRhdGluZyBhIGp1c3QgY3JlYXRlZCBub2RlIHdpdGggaW5uZXJIVE1MIG9ubHkgbGVhZGluZ1xuICAvLyB3aGl0ZXNwYWNlIGlzIHJlbW92ZWQuIFdoZW4gdXBkYXRpbmcgYW4gZXhpc3Rpbmcgbm9kZSB3aXRoIGlubmVySFRNTFxuICAvLyB3aGl0ZXNwYWNlIGluIHJvb3QgVGV4dE5vZGVzIGlzIGFsc28gY29sbGFwc2VkLlxuICAvLyBAc2VlIHF1aXJrc21vZGUub3JnL2J1Z3JlcG9ydHMvYXJjaGl2ZXMvMjAwNC8xMS9pbm5lcmh0bWxfYW5kX3QuaHRtbFxuXG4gIC8vIEZlYXR1cmUgZGV0ZWN0aW9uOyBvbmx5IElFOCBpcyBrbm93biB0byBiZWhhdmUgaW1wcm9wZXJseSBsaWtlIHRoaXMuXG4gIHZhciB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0ZXN0RWxlbWVudC5pbm5lckhUTUwgPSAnICc7XG4gIGlmICh0ZXN0RWxlbWVudC5pbm5lckhUTUwgPT09ICcnKSB7XG4gICAgc2V0SW5uZXJIVE1MID0gZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgICAgIC8vIE1hZ2ljIHRoZW9yeTogSUU4IHN1cHBvc2VkbHkgZGlmZmVyZW50aWF0ZXMgYmV0d2VlbiBhZGRlZCBhbmQgdXBkYXRlZFxuICAgICAgLy8gbm9kZXMgd2hlbiBwcm9jZXNzaW5nIGlubmVySFRNTCwgaW5uZXJIVE1MIG9uIHVwZGF0ZWQgbm9kZXMgc3VmZmVyc1xuICAgICAgLy8gZnJvbSB3b3JzZSB3aGl0ZXNwYWNlIGJlaGF2aW9yLiBSZS1hZGRpbmcgYSBub2RlIGxpa2UgdGhpcyB0cmlnZ2Vyc1xuICAgICAgLy8gdGhlIGluaXRpYWwgYW5kIG1vcmUgZmF2b3JhYmxlIHdoaXRlc3BhY2UgYmVoYXZpb3IuXG4gICAgICAvLyBUT0RPOiBXaGF0IHRvIGRvIG9uIGEgZGV0YWNoZWQgbm9kZT9cbiAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChub2RlLCBub2RlKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgYWxzbyBpbXBsZW1lbnQgYSB3b3JrYXJvdW5kIGZvciBub24tdmlzaWJsZSB0YWdzIGRpc2FwcGVhcmluZyBpbnRvXG4gICAgICAvLyB0aGluIGFpciBvbiBJRTgsIHRoaXMgb25seSBoYXBwZW5zIGlmIHRoZXJlIGlzIG5vIHZpc2libGUgdGV4dFxuICAgICAgLy8gaW4tZnJvbnQgb2YgdGhlIG5vbi12aXNpYmxlIHRhZ3MuIFBpZ2d5YmFjayBvbiB0aGUgd2hpdGVzcGFjZSBmaXhcbiAgICAgIC8vIGFuZCBzaW1wbHkgY2hlY2sgaWYgYW55IG5vbi12aXNpYmxlIHRhZ3MgYXBwZWFyIGluIHRoZSBzb3VyY2UuXG4gICAgICBpZiAoV0hJVEVTUEFDRV9URVNULnRlc3QoaHRtbCkgfHwgaHRtbFswXSA9PT0gJzwnICYmIE5PTlZJU0lCTEVfVEVTVC50ZXN0KGh0bWwpKSB7XG4gICAgICAgIC8vIFJlY292ZXIgbGVhZGluZyB3aGl0ZXNwYWNlIGJ5IHRlbXBvcmFyaWx5IHByZXBlbmRpbmcgYW55IGNoYXJhY3Rlci5cbiAgICAgICAgLy8gXFx1RkVGRiBoYXMgdGhlIHBvdGVudGlhbCBhZHZhbnRhZ2Ugb2YgYmVpbmcgemVyby13aWR0aC9pbnZpc2libGUuXG4gICAgICAgIC8vIFVnbGlmeUpTIGRyb3BzIFUrRkVGRiBjaGFycyB3aGVuIHBhcnNpbmcsIHNvIHVzZSBTdHJpbmcuZnJvbUNoYXJDb2RlXG4gICAgICAgIC8vIGluIGhvcGVzIHRoYXQgdGhpcyBpcyBwcmVzZXJ2ZWQgZXZlbiBpZiBcIlxcdUZFRkZcIiBpcyB0cmFuc2Zvcm1lZCB0b1xuICAgICAgICAvLyB0aGUgYWN0dWFsIFVuaWNvZGUgY2hhcmFjdGVyIChieSBCYWJlbCwgZm9yIGV4YW1wbGUpLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9ibG9iL3YyLjQuMjAvbGliL3BhcnNlLmpzI0wyMTZcbiAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkVGRikgKyBodG1sO1xuXG4gICAgICAgIC8vIGRlbGV0ZURhdGEgbGVhdmVzIGFuIGVtcHR5IGBUZXh0Tm9kZWAgd2hpY2ggb2Zmc2V0cyB0aGUgaW5kZXggb2YgYWxsXG4gICAgICAgIC8vIGNoaWxkcmVuLiBEZWZpbml0ZWx5IHdhbnQgdG8gYXZvaWQgdGhpcy5cbiAgICAgICAgdmFyIHRleHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZiAodGV4dE5vZGUuZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKHRleHROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0Tm9kZS5kZWxldGVEYXRhKDAsIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldElubmVySFRNTDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL3NldElubmVySFRNTC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBzZXRUZXh0Q29udGVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG5cbi8qKlxuICogU2V0IHRoZSB0ZXh0Q29udGVudCBwcm9wZXJ0eSBvZiBhIG5vZGUsIGVuc3VyaW5nIHRoYXQgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWRcbiAqIGV2ZW4gaW4gSUU4LiBpbm5lclRleHQgaXMgYSBwb29yIHN1YnN0aXR1dGUgZm9yIHRleHRDb250ZW50IGFuZCwgYW1vbmcgbWFueVxuICogaXNzdWVzLCBpbnNlcnRzIDxicj4gaW5zdGVhZCBvZiB0aGUgbGl0ZXJhbCBuZXdsaW5lIGNoYXJzLiBpbm5lckhUTUwgYmVoYXZlc1xuICogYXMgaXQgc2hvdWxkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn07XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgaWYgKCEoJ3RleHRDb250ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICAgICAgc2V0SW5uZXJIVE1MKG5vZGUsIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih0ZXh0KSk7XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRleHRDb250ZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvc2V0VGV4dENvbnRlbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVNDQVBFX0xPT0tVUCA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJzwnOiAnJmx0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICAnXFwnJzogJyYjeDI3Oydcbn07XG5cbnZhciBFU0NBUEVfUkVHRVggPSAvWyY+PFwiJ10vZztcblxuZnVuY3Rpb24gZXNjYXBlcihtYXRjaCkge1xuICByZXR1cm4gRVNDQVBFX0xPT0tVUFttYXRjaF07XG59XG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UoRVNDQVBFX1JFR0VYLCBlc2NhcGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRE9NUHJvcGVydHlPcGVyYXRpb25zXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG5cbnZhciBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXInKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vLyBTaW1wbGlmaWVkIHN1YnNldFxudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gL15bYS16QS1aX11bXFx3XFwuXFwtXSokLztcbnZhciBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG52YXIgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG5cbmZ1bmN0aW9uIGlzQXR0cmlidXRlTmFtZVNhZmUoYXR0cmlidXRlTmFtZSkge1xuICBpZiAodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcbiAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWU6IGAlc2AnLCBhdHRyaWJ1dGVOYW1lKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgJiYgIXZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNOdW1lcmljVmFsdWUgJiYgaXNOYU4odmFsdWUpIHx8IHByb3BlcnR5SW5mby5oYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSAmJiB2YWx1ZSA8IDEgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IGZhbHNlO1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcmVhY3RQcm9wcyA9IHtcbiAgICBjaGlsZHJlbjogdHJ1ZSxcbiAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogdHJ1ZSxcbiAgICBrZXk6IHRydWUsXG4gICAgcmVmOiB0cnVlXG4gIH07XG4gIHZhciB3YXJuZWRQcm9wZXJ0aWVzID0ge307XG5cbiAgdmFyIHdhcm5Vbmtub3duUHJvcGVydHkgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChyZWFjdFByb3BzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHJlYWN0UHJvcHNbbmFtZV0gfHwgd2FybmVkUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gZGF0YS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb25cbiAgICB2YXIgc3RhbmRhcmROYW1lID0gRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobG93ZXJDYXNlZE5hbWUpID8gbG93ZXJDYXNlZE5hbWUgOiBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZS5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuXG4gICAgLy8gRm9yIG5vdywgb25seSB3YXJuIHdoZW4gd2UgaGF2ZSBhIHN1Z2dlc3RlZCBjb3JyZWN0aW9uLiBUaGlzIHByZXZlbnRzXG4gICAgLy8gbG9nZ2luZyB0b28gbXVjaCB3aGVuIHVzaW5nIHRyYW5zZmVyUHJvcHNUby5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhzdGFuZGFyZE5hbWUgPT0gbnVsbCwgJ1Vua25vd24gRE9NIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgc3RhbmRhcmROYW1lKSA6IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggRE9NIHByb3BlcnRpZXMuXG4gKi9cbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgSUQgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBVbmVzY2FwZWQgSUQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZy5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvcklEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcihpZCk7XG4gIH0sXG5cbiAgc2V0QXR0cmlidXRlRm9ySUQ6IGZ1bmN0aW9uIChub2RlLCBpZCkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FLCBpZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciBhIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IE1hcmt1cCBzdHJpbmcsIG9yIG51bGwgaWYgdGhlIHByb3BlcnR5IHdhcyBpbnZhbGlkLlxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9XCJcIic7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm5Vbmtub3duUHJvcGVydHkobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgYSBjdXN0b20gcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgc3RyaW5nLCBvciBlbXB0eSBzdHJpbmcgaWYgdGhlIHByb3BlcnR5IHdhcyBpbnZhbGlkLlxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9yQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cbiAgc2V0VmFsdWVGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbiAgICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgICB2YXIgbXV0YXRpb25NZXRob2QgPSBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2Q7XG4gICAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSkge1xuICAgICAgICB0aGlzLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlQXR0cmlidXRlKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlO1xuICAgICAgICAvLyBgc2V0QXR0cmlidXRlYCB3aXRoIG9iamVjdHMgYmVjb21lcyBvbmx5IGBbb2JqZWN0XWAgaW4gSUU4LzksXG4gICAgICAgIC8vICgnJyArIHZhbHVlKSBtYWtlcyBpdCBvdXRwdXQgdGhlIGNvcnJlY3QgdG9TdHJpbmcoKS12YWx1ZS5cbiAgICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuICAgICAgICAvLyBNdXN0IGV4cGxpY2l0bHkgY2FzdCB2YWx1ZXMgZm9yIEhBU19TSURFX0VGRkVDVFMtcHJvcGVydGllcyB0byB0aGVcbiAgICAgICAgLy8gcHJvcGVydHkgdHlwZSBiZWZvcmUgY29tcGFyaW5nOyBvbmx5IGB2YWx1ZWAgZG9lcyBhbmQgaXMgc3RyaW5nLlxuICAgICAgICBpZiAoIXByb3BlcnR5SW5mby5oYXNTaWRlRWZmZWN0cyB8fCAnJyArIG5vZGVbcHJvcE5hbWVdICE9PSAnJyArIHZhbHVlKSB7XG4gICAgICAgICAgLy8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxuICAgICAgICAgIC8vIGB0b1N0cmluZ2BlZCBieSBJRTgvOS5cbiAgICAgICAgICBub2RlW3Byb3BOYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm5Vbmtub3duUHJvcGVydHkobmFtZSk7XG4gICAgfVxuICB9LFxuXG4gIHNldFZhbHVlRm9yQXR0cmlidXRlOiBmdW5jdGlvbiAobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCAnJyArIHZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqL1xuICBkZWxldGVWYWx1ZUZvclByb3BlcnR5OiBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgICAgaWYgKG11dGF0aW9uTWV0aG9kKSB7XG4gICAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHVuZGVmaW5lZCk7XG4gICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlQXR0cmlidXRlKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG4gICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBET01Qcm9wZXJ0eS5nZXREZWZhdWx0VmFsdWVGb3JQcm9wZXJ0eShub2RlLm5vZGVOYW1lLCBwcm9wTmFtZSk7XG4gICAgICAgIGlmICghcHJvcGVydHlJbmZvLmhhc1NpZGVFZmZlY3RzIHx8ICcnICsgbm9kZVtwcm9wTmFtZV0gIT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgIG5vZGVbcHJvcE5hbWVdID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuVW5rbm93blByb3BlcnR5KG5hbWUpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5SZWFjdFBlcmYubWVhc3VyZU1ldGhvZHMoRE9NUHJvcGVydHlPcGVyYXRpb25zLCAnRE9NUHJvcGVydHlPcGVyYXRpb25zJywge1xuICBzZXRWYWx1ZUZvclByb3BlcnR5OiAnc2V0VmFsdWVGb3JQcm9wZXJ0eScsXG4gIHNldFZhbHVlRm9yQXR0cmlidXRlOiAnc2V0VmFsdWVGb3JBdHRyaWJ1dGUnLFxuICBkZWxldGVWYWx1ZUZvclByb3BlcnR5OiAnZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eSdcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTVByb3BlcnR5T3BlcmF0aW9ucztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0RPTVByb3BlcnR5T3BlcmF0aW9ucy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBET01Qcm9wZXJ0eVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuZnVuY3Rpb24gY2hlY2tNYXNrKHZhbHVlLCBiaXRtYXNrKSB7XG4gIHJldHVybiAodmFsdWUgJiBiaXRtYXNrKSA9PT0gYml0bWFzaztcbn1cblxudmFyIERPTVByb3BlcnR5SW5qZWN0aW9uID0ge1xuICAvKipcbiAgICogTWFwcGluZyBmcm9tIG5vcm1hbGl6ZWQsIGNhbWVsY2FzZWQgcHJvcGVydHkgbmFtZXMgdG8gYSBjb25maWd1cmF0aW9uIHRoYXRcbiAgICogc3BlY2lmaWVzIGhvdyB0aGUgYXNzb2NpYXRlZCBET00gcHJvcGVydHkgc2hvdWxkIGJlIGFjY2Vzc2VkIG9yIHJlbmRlcmVkLlxuICAgKi9cbiAgTVVTVF9VU0VfQVRUUklCVVRFOiAweDEsXG4gIE1VU1RfVVNFX1BST1BFUlRZOiAweDIsXG4gIEhBU19TSURFX0VGRkVDVFM6IDB4NCxcbiAgSEFTX0JPT0xFQU5fVkFMVUU6IDB4OCxcbiAgSEFTX05VTUVSSUNfVkFMVUU6IDB4MTAsXG4gIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOiAweDIwIHwgMHgxMCxcbiAgSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTogMHg0MCxcblxuICAvKipcbiAgICogSW5qZWN0IHNvbWUgc3BlY2lhbGl6ZWQga25vd2xlZGdlIGFib3V0IHRoZSBET00uIFRoaXMgdGFrZXMgYSBjb25maWcgb2JqZWN0XG4gICAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiBpc0N1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gdGhhdCBnaXZlbiBhbiBhdHRyaWJ1dGUgbmFtZSB3aWxsIHJldHVybiB0cnVlXG4gICAqIGlmIGl0IGNhbiBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00gdmVyYmF0aW0uIFVzZWZ1bCBmb3IgZGF0YS0qIG9yIGFyaWEtKlxuICAgKiBhdHRyaWJ1dGVzIHdoZXJlIGl0J3MgaW1wb3NzaWJsZSB0byBlbnVtZXJhdGUgYWxsIG9mIHRoZSBwb3NzaWJsZVxuICAgKiBhdHRyaWJ1dGUgbmFtZXMsXG4gICAqXG4gICAqIFByb3BlcnRpZXM6IG9iamVjdCBtYXBwaW5nIERPTSBwcm9wZXJ0eSBuYW1lIHRvIG9uZSBvZiB0aGVcbiAgICogRE9NUHJvcGVydHlJbmplY3Rpb24gY29uc3RhbnRzIG9yIG51bGwuIElmIHlvdXIgYXR0cmlidXRlIGlzbid0IGluIGhlcmUsXG4gICAqIGl0IHdvbid0IGdldCB3cml0dGVuIHRvIHRoZSBET00uXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzOiBvYmplY3QgbWFwcGluZyBSZWFjdCBhdHRyaWJ1dGUgbmFtZSB0byB0aGUgRE9NXG4gICAqIGF0dHJpYnV0ZSBuYW1lLiBBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2UgdGhlICoqbG93ZXJjYXNlKipcbiAgICogbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01BdHRyaWJ1dGVOYW1lc3BhY2VzOiBvYmplY3QgbWFwcGluZyBSZWFjdCBhdHRyaWJ1dGUgbmFtZSB0byB0aGUgRE9NXG4gICAqIGF0dHJpYnV0ZSBuYW1lc3BhY2UgVVJMLiAoQXR0cmlidXRlIG5hbWVzIG5vdCBzcGVjaWZpZWQgdXNlIG5vIG5hbWVzcGFjZS4pXG4gICAqXG4gICAqIERPTVByb3BlcnR5TmFtZXM6IHNpbWlsYXIgdG8gRE9NQXR0cmlidXRlTmFtZXMgYnV0IGZvciBET00gcHJvcGVydGllcy5cbiAgICogUHJvcGVydHkgbmFtZXMgbm90IHNwZWNpZmllZCB1c2UgdGhlIG5vcm1hbGl6ZWQgbmFtZS5cbiAgICpcbiAgICogRE9NTXV0YXRpb25NZXRob2RzOiBQcm9wZXJ0aWVzIHRoYXQgcmVxdWlyZSBzcGVjaWFsIG11dGF0aW9uIG1ldGhvZHMuIElmXG4gICAqIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLCB0aGUgbXV0YXRpb24gbWV0aG9kIHNob3VsZCB1bnNldCB0aGUgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkb21Qcm9wZXJ0eUNvbmZpZyB0aGUgY29uZmlnIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAgICovXG4gIGluamVjdERPTVByb3BlcnR5Q29uZmlnOiBmdW5jdGlvbiAoZG9tUHJvcGVydHlDb25maWcpIHtcbiAgICB2YXIgSW5qZWN0aW9uID0gRE9NUHJvcGVydHlJbmplY3Rpb247XG4gICAgdmFyIFByb3BlcnRpZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5Qcm9wZXJ0aWVzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lc3BhY2VzID0gZG9tUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXNwYWNlcyB8fCB7fTtcbiAgICB2YXIgRE9NQXR0cmlidXRlTmFtZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lcyB8fCB7fTtcbiAgICB2YXIgRE9NUHJvcGVydHlOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTVByb3BlcnR5TmFtZXMgfHwge307XG4gICAgdmFyIERPTU11dGF0aW9uTWV0aG9kcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTU11dGF0aW9uTWV0aG9kcyB8fCB7fTtcblxuICAgIGlmIChkb21Qcm9wZXJ0eUNvbmZpZy5pc0N1c3RvbUF0dHJpYnV0ZSkge1xuICAgICAgRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zLnB1c2goZG9tUHJvcGVydHlDb25maWcuaXNDdXN0b21BdHRyaWJ1dGUpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIFByb3BlcnRpZXMpIHtcbiAgICAgICEhRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnaW5qZWN0RE9NUHJvcGVydHlDb25maWcoLi4uKTogWW91XFwncmUgdHJ5aW5nIHRvIGluamVjdCBET00gcHJvcGVydHkgJyArICdcXCclc1xcJyB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGluamVjdGVkLiBZb3UgbWF5IGJlIGFjY2lkZW50YWxseSAnICsgJ2luamVjdGluZyB0aGUgc2FtZSBET00gcHJvcGVydHkgY29uZmlnIHR3aWNlLCBvciB5b3UgbWF5IGJlICcgKyAnaW5qZWN0aW5nIHR3byBjb25maWdzIHRoYXQgaGF2ZSBjb25mbGljdGluZyBwcm9wZXJ0eSBuYW1lcy4nLCBwcm9wTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgICB2YXIgbG93ZXJDYXNlZCA9IHByb3BOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgcHJvcENvbmZpZyA9IFByb3BlcnRpZXNbcHJvcE5hbWVdO1xuXG4gICAgICB2YXIgcHJvcGVydHlJbmZvID0ge1xuICAgICAgICBhdHRyaWJ1dGVOYW1lOiBsb3dlckNhc2VkLFxuICAgICAgICBhdHRyaWJ1dGVOYW1lc3BhY2U6IG51bGwsXG4gICAgICAgIHByb3BlcnR5TmFtZTogcHJvcE5hbWUsXG4gICAgICAgIG11dGF0aW9uTWV0aG9kOiBudWxsLFxuXG4gICAgICAgIG11c3RVc2VBdHRyaWJ1dGU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uTVVTVF9VU0VfQVRUUklCVVRFKSxcbiAgICAgICAgbXVzdFVzZVByb3BlcnR5OiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZKSxcbiAgICAgICAgaGFzU2lkZUVmZmVjdHM6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX1NJREVfRUZGRUNUUyksXG4gICAgICAgIGhhc0Jvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRSksXG4gICAgICAgIGhhc051bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRSksXG4gICAgICAgIGhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFKSxcbiAgICAgICAgaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFKVxuICAgICAgfTtcblxuICAgICAgISghcHJvcGVydHlJbmZvLm11c3RVc2VBdHRyaWJ1dGUgfHwgIXByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0RPTVByb3BlcnR5OiBDYW5ub3QgcmVxdWlyZSB1c2luZyBib3RoIGF0dHJpYnV0ZSBhbmQgcHJvcGVydHk6ICVzJywgcHJvcE5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICEocHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSB8fCAhcHJvcGVydHlJbmZvLmhhc1NpZGVFZmZlY3RzKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdET01Qcm9wZXJ0eTogUHJvcGVydGllcyB0aGF0IGhhdmUgc2lkZSBlZmZlY3RzIG11c3QgdXNlIHByb3BlcnR5OiAlcycsIHByb3BOYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAhKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgKyBwcm9wZXJ0eUluZm8uaGFzTnVtZXJpY1ZhbHVlICsgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgPD0gMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRE9NUHJvcGVydHk6IFZhbHVlIGNhbiBiZSBvbmUgb2YgYm9vbGVhbiwgb3ZlcmxvYWRlZCBib29sZWFuLCBvciAnICsgJ251bWVyaWMgdmFsdWUsIGJ1dCBub3QgYSBjb21iaW5hdGlvbjogJXMnLCBwcm9wTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkXSA9IHByb3BOYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gRE9NQXR0cmlidXRlTmFtZXNbcHJvcE5hbWVdO1xuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbYXR0cmlidXRlTmFtZV0gPSBwcm9wTmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IERPTUF0dHJpYnV0ZU5hbWVzcGFjZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NUHJvcGVydHlOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZSA9IERPTVByb3BlcnR5TmFtZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NTXV0YXRpb25NZXRob2RzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2QgPSBET01NdXRhdGlvbk1ldGhvZHNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BOYW1lXSA9IHByb3BlcnR5SW5mbztcbiAgICB9XG4gIH1cbn07XG52YXIgZGVmYXVsdFZhbHVlQ2FjaGUgPSB7fTtcblxuLyoqXG4gKiBET01Qcm9wZXJ0eSBleHBvcnRzIGxvb2t1cCBvYmplY3RzIHRoYXQgY2FuIGJlIHVzZWQgbGlrZSBmdW5jdGlvbnM6XG4gKlxuICogICA+IERPTVByb3BlcnR5LmlzVmFsaWRbJ2lkJ11cbiAqICAgdHJ1ZVxuICogICA+IERPTVByb3BlcnR5LmlzVmFsaWRbJ2Zvb2JhciddXG4gKiAgIHVuZGVmaW5lZFxuICpcbiAqIEFsdGhvdWdoIHRoaXMgbWF5IGJlIGNvbmZ1c2luZywgaXQgcGVyZm9ybXMgYmV0dGVyIGluIGdlbmVyYWwuXG4gKlxuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9rZXktZXhpc3RzXG4gKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2tleS1taXNzaW5nXG4gKi9cbnZhciBET01Qcm9wZXJ0eSA9IHtcblxuICBJRF9BVFRSSUJVVEVfTkFNRTogJ2RhdGEtcmVhY3RpZCcsXG5cbiAgLyoqXG4gICAqIE1hcCBmcm9tIHByb3BlcnR5IFwic3RhbmRhcmQgbmFtZVwiIHRvIGFuIG9iamVjdCB3aXRoIGluZm8gYWJvdXQgaG93IHRvIHNldFxuICAgKiB0aGUgcHJvcGVydHkgaW4gdGhlIERPTS4gRWFjaCBvYmplY3QgY29udGFpbnM6XG4gICAqXG4gICAqIGF0dHJpYnV0ZU5hbWU6XG4gICAqICAgVXNlZCB3aGVuIHJlbmRlcmluZyBtYXJrdXAgb3Igd2l0aCBgKkF0dHJpYnV0ZSgpYC5cbiAgICogYXR0cmlidXRlTmFtZXNwYWNlXG4gICAqIHByb3BlcnR5TmFtZTpcbiAgICogICBVc2VkIG9uIERPTSBub2RlIGluc3RhbmNlcy4gKFRoaXMgaW5jbHVkZXMgcHJvcGVydGllcyB0aGF0IG11dGF0ZSBkdWUgdG9cbiAgICogICBleHRlcm5hbCBmYWN0b3JzLilcbiAgICogbXV0YXRpb25NZXRob2Q6XG4gICAqICAgSWYgbm9uLW51bGwsIHVzZWQgaW5zdGVhZCBvZiB0aGUgcHJvcGVydHkgb3IgYHNldEF0dHJpYnV0ZSgpYCBhZnRlclxuICAgKiAgIGluaXRpYWwgcmVuZGVyLlxuICAgKiBtdXN0VXNlQXR0cmlidXRlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgYWNjZXNzZWQgYW5kIG11dGF0ZWQgdXNpbmcgYCpBdHRyaWJ1dGUoKWAuXG4gICAqICAgKFRoaXMgaW5jbHVkZXMgYW55dGhpbmcgdGhhdCBmYWlscyBgPHByb3BOYW1lPiBpbiA8ZWxlbWVudD5gLilcbiAgICogbXVzdFVzZVByb3BlcnR5OlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgYWNjZXNzZWQgYW5kIG11dGF0ZWQgYXMgYW4gb2JqZWN0IHByb3BlcnR5LlxuICAgKiBoYXNTaWRlRWZmZWN0czpcbiAgICogICBXaGV0aGVyIG9yIG5vdCBzZXR0aW5nIGEgdmFsdWUgY2F1c2VzIHNpZGUgZWZmZWN0cyBzdWNoIGFzIHRyaWdnZXJpbmdcbiAgICogICByZXNvdXJjZXMgdG8gYmUgbG9hZGVkIG9yIHRleHQgc2VsZWN0aW9uIGNoYW5nZXMuIElmIHRydWUsIHdlIHJlYWQgZnJvbVxuICAgKiAgIHRoZSBET00gYmVmb3JlIHVwZGF0aW5nIHRvIGVuc3VyZSB0aGF0IHRoZSB2YWx1ZSBpcyBvbmx5IHNldCBpZiBpdCBoYXNcbiAgICogICBjaGFuZ2VkLlxuICAgKiBoYXNCb29sZWFuVmFsdWU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc051bWVyaWNWYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljIGFuZCBzaG91bGQgYmVcbiAgICogICByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIHBvc2l0aXZlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBwb3NpdGl2ZVxuICAgKiAgIG51bWVyaWMgYW5kIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IGNhbiBiZSB1c2VkIGFzIGEgZmxhZyBhcyB3ZWxsIGFzIHdpdGggYSB2YWx1ZS5cbiAgICogICBSZW1vdmVkIHdoZW4gc3RyaWN0bHkgZXF1YWwgdG8gZmFsc2U7IHByZXNlbnQgd2l0aG91dCBhIHZhbHVlIHdoZW5cbiAgICogICBzdHJpY3RseSBlcXVhbCB0byB0cnVlOyBwcmVzZW50IHdpdGggYSB2YWx1ZSBvdGhlcndpc2UuXG4gICAqL1xuICBwcm9wZXJ0aWVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lcyB0byB0aGUgcHJvcGVybHkgY2FzZWQgdmVyc2lvbiwgdXNlZFxuICAgKiB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgcHJvcGVydGllcy4gQXZhaWxhYmxlIG9ubHkgaW4gX19ERVZfXy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGdldFBvc3NpYmxlU3RhbmRhcmROYW1lOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8ge30gOiBudWxsLFxuXG4gIC8qKlxuICAgKiBBbGwgb2YgdGhlIGlzQ3VzdG9tQXR0cmlidXRlKCkgZnVuY3Rpb25zIHRoYXQgaGF2ZSBiZWVuIGluamVjdGVkLlxuICAgKi9cbiAgX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zOiBbXSxcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgYSBwcm9wZXJ0eSBuYW1lIGlzIGEgY3VzdG9tIGF0dHJpYnV0ZS5cbiAgICogQG1ldGhvZFxuICAgKi9cbiAgaXNDdXN0b21BdHRyaWJ1dGU6IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpc0N1c3RvbUF0dHJpYnV0ZUZuID0gRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zW2ldO1xuICAgICAgaWYgKGlzQ3VzdG9tQXR0cmlidXRlRm4oYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVmYXVsdCBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBET00gcHJvcGVydHkgKGkuZS4sIG5vdCBhblxuICAgKiBhdHRyaWJ1dGUpLiBNb3N0IGRlZmF1bHQgdmFsdWVzIGFyZSAnJyBvciBmYWxzZSwgYnV0IG5vdCBhbGwuIFdvcnNlIHlldCxcbiAgICogc29tZSAoaW4gcGFydGljdWxhciwgYHR5cGVgKSB2YXJ5IGRlcGVuZGluZyBvbiB0aGUgdHlwZSBvZiBlbGVtZW50LlxuICAgKlxuICAgKiBUT0RPOiBJcyBpdCBiZXR0ZXIgdG8gZ3JhYiBhbGwgdGhlIHBvc3NpYmxlIHByb3BlcnRpZXMgd2hlbiBjcmVhdGluZyBhblxuICAgKiBlbGVtZW50IHRvIGF2b2lkIGhhdmluZyB0byBjcmVhdGUgdGhlIHNhbWUgZWxlbWVudCB0d2ljZT9cbiAgICovXG4gIGdldERlZmF1bHRWYWx1ZUZvclByb3BlcnR5OiBmdW5jdGlvbiAobm9kZU5hbWUsIHByb3ApIHtcbiAgICB2YXIgbm9kZURlZmF1bHRzID0gZGVmYXVsdFZhbHVlQ2FjaGVbbm9kZU5hbWVdO1xuICAgIHZhciB0ZXN0RWxlbWVudDtcbiAgICBpZiAoIW5vZGVEZWZhdWx0cykge1xuICAgICAgZGVmYXVsdFZhbHVlQ2FjaGVbbm9kZU5hbWVdID0gbm9kZURlZmF1bHRzID0ge307XG4gICAgfVxuICAgIGlmICghKHByb3AgaW4gbm9kZURlZmF1bHRzKSkge1xuICAgICAgdGVzdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5vZGVOYW1lKTtcbiAgICAgIG5vZGVEZWZhdWx0c1twcm9wXSA9IHRlc3RFbGVtZW50W3Byb3BdO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZURlZmF1bHRzW3Byb3BdO1xuICB9LFxuXG4gIGluamVjdGlvbjogRE9NUHJvcGVydHlJbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NUHJvcGVydHk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9ET01Qcm9wZXJ0eS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG5cbi8qKlxuICogRXNjYXBlcyBhdHRyaWJ1dGUgdmFsdWUgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKSB7XG4gIHJldHVybiAnXCInICsgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHZhbHVlKSArICdcIic7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9xdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSB3YXJuaW5nXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGVtcHR5RnVuY3Rpb247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XG4gICAgICByZXR1cm47IC8vIElnbm9yZSBDb21wb3NpdGVDb21wb25lbnQgcHJvcHR5cGUgY2hlY2suXG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoICh4KSB7fVxuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi93YXJuaW5nLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0RE9NSURPcGVyYXRpb25zJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xuXG4vKipcbiAqIEFic3RyYWN0cyBhd2F5IGFsbCBmdW5jdGlvbmFsaXR5IG9mIHRoZSByZWNvbmNpbGVyIHRoYXQgcmVxdWlyZXMga25vd2xlZGdlIG9mXG4gKiB0aGUgYnJvd3NlciBjb250ZXh0LiBUT0RPOiBUaGVzZSBjYWxsZXJzIHNob3VsZCBiZSByZWZhY3RvcmVkIHRvIGF2b2lkIHRoZVxuICogbmVlZCBmb3IgdGhpcyBpbmplY3Rpb24uXG4gKi9cbnZhciBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCA9IHtcblxuICBwcm9jZXNzQ2hpbGRyZW5VcGRhdGVzOiBSZWFjdERPTUlET3BlcmF0aW9ucy5kYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXMsXG5cbiAgcmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRDogUmVhY3RET01JRE9wZXJhdGlvbnMuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlELFxuXG4gIC8qKlxuICAgKiBJZiBhIHBhcnRpY3VsYXIgZW52aXJvbm1lbnQgcmVxdWlyZXMgdGhhdCBzb21lIHJlc291cmNlcyBiZSBjbGVhbmVkIHVwLFxuICAgKiBzcGVjaWZ5IHRoaXMgaW4gdGhlIGluamVjdGVkIE1peGluLiBJbiB0aGUgRE9NLCB3ZSB3b3VsZCBsaWtlbHkgd2FudCB0b1xuICAgKiBwdXJnZSBhbnkgY2FjaGVkIG5vZGUgSUQgbG9va3Vwcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVubW91bnRJREZyb21FbnZpcm9ubWVudDogZnVuY3Rpb24gKHJvb3ROb2RlSUQpIHtcbiAgICBSZWFjdE1vdW50LnB1cmdlSUQocm9vdE5vZGVJRCk7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NSURPcGVyYXRpb25zXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NQ2hpbGRyZW5PcGVyYXRpb25zJyk7XG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZSgnLi9SZWFjdFBlcmYnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEVycm9ycyBmb3IgcHJvcGVydGllcyB0aGF0IHNob3VsZCBub3QgYmUgdXBkYXRlZCB3aXRoIGB1cGRhdGVQcm9wZXJ0eUJ5SUQoKWAuXG4gKlxuICogQHR5cGUge29iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBJTlZBTElEX1BST1BFUlRZX0VSUk9SUyA9IHtcbiAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6ICdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgc2V0IHVzaW5nIGB1cGRhdGVJbm5lckhUTUxCeUlEKClgLicsXG4gIHN0eWxlOiAnYHN0eWxlYCBtdXN0IGJlIHNldCB1c2luZyBgdXBkYXRlU3R5bGVzQnlJRCgpYC4nXG59O1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgdXNlZCB0byBwcm9jZXNzIHVwZGF0ZXMgdG8gRE9NIG5vZGVzLlxuICovXG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBET00gbm9kZSB3aXRoIG5ldyBwcm9wZXJ0eSB2YWx1ZXMuIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCB0b1xuICAgKiB1cGRhdGUgRE9NIHByb3BlcnRpZXMgaW4gYERPTVByb3BlcnR5YC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBub2RlIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQSB2YWxpZCBwcm9wZXJ0eSBuYW1lLCBzZWUgYERPTVByb3BlcnR5YC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBOZXcgdmFsdWUgb2YgdGhlIHByb3BlcnR5LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVwZGF0ZVByb3BlcnR5QnlJRDogZnVuY3Rpb24gKGlkLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKGlkKTtcbiAgICAhIUlOVkFMSURfUFJPUEVSVFlfRVJST1JTLmhhc093blByb3BlcnR5KG5hbWUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3VwZGF0ZVByb3BlcnR5QnlJRCguLi4pOiAlcycsIElOVkFMSURfUFJPUEVSVFlfRVJST1JTW25hbWVdKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBJZiB3ZSdyZSB1cGRhdGluZyB0byBudWxsIG9yIHVuZGVmaW5lZCwgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAgICAvLyBmcm9tIHRoZSBET00gbm9kZSBpbnN0ZWFkIG9mIGluYWR2ZXJ0YW50bHkgc2V0dGluZyB0byBhIHN0cmluZy4gVGhpc1xuICAgIC8vIGJyaW5ncyB1cyBpbiBsaW5lIHdpdGggdGhlIHNhbWUgYmVoYXZpb3Igd2UgaGF2ZSBvbiBpbml0aWFsIHJlbmRlci5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGEgRE9NIG5vZGUgdGhhdCBleGlzdHMgaW4gdGhlIGRvY3VtZW50IHdpdGggbWFya3VwLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgY2hpbGQgdG8gYmUgcmVwbGFjZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgRGFuZ2Vyb3VzIG1hcmt1cCB0byBpbmplY3QgaW4gcGxhY2Ugb2YgY2hpbGQuXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtEYW5nZXIuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXB9XG4gICAqL1xuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQ6IGZ1bmN0aW9uIChpZCwgbWFya3VwKSB7XG4gICAgdmFyIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUoaWQpO1xuICAgIERPTUNoaWxkcmVuT3BlcmF0aW9ucy5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cChub2RlLCBtYXJrdXApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgY29tcG9uZW50J3MgY2hpbGRyZW4gYnkgcHJvY2Vzc2luZyBhIHNlcmllcyBvZiB1cGRhdGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PG9iamVjdD59IHVwZGF0ZXMgTGlzdCBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXG4gICAqIEBwYXJhbSB7YXJyYXk8c3RyaW5nPn0gbWFya3VwIExpc3Qgb2YgbWFya3VwIHN0cmluZ3MuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzOiBmdW5jdGlvbiAodXBkYXRlcywgbWFya3VwKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB1cGRhdGVzW2ldLnBhcmVudE5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUodXBkYXRlc1tpXS5wYXJlbnRJRCk7XG4gICAgfVxuICAgIERPTUNoaWxkcmVuT3BlcmF0aW9ucy5wcm9jZXNzVXBkYXRlcyh1cGRhdGVzLCBtYXJrdXApO1xuICB9XG59O1xuXG5SZWFjdFBlcmYubWVhc3VyZU1ldGhvZHMoUmVhY3RET01JRE9wZXJhdGlvbnMsICdSZWFjdERPTUlET3BlcmF0aW9ucycsIHtcbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEOiAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEJyxcbiAgZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzOiAnZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzJ1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01JRE9wZXJhdGlvbnM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUlET3BlcmF0aW9ucy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE1vdW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdERPTUZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RET01GZWF0dXJlRmxhZ3MnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeSA9IHJlcXVpcmUoJy4vUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5Jyk7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VIYW5kbGVzJyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0TWFya3VwQ2hlY2tzdW0gPSByZXF1aXJlKCcuL1JlYWN0TWFya3VwQ2hlY2tzdW0nKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgY29udGFpbnNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvY29udGFpbnNOb2RlJyk7XG52YXIgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gcmVxdWlyZSgnLi92YWxpZGF0ZURPTU5lc3RpbmcnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgQVRUUl9OQU1FID0gRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUU7XG52YXIgbm9kZUNhY2hlID0ge307XG5cbnZhciBFTEVNRU5UX05PREVfVFlQRSA9IDE7XG52YXIgRE9DX05PREVfVFlQRSA9IDk7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFID0gMTE7XG5cbnZhciBvd25lckRvY3VtZW50Q29udGV4dEtleSA9ICdfX1JlYWN0TW91bnRfb3duZXJEb2N1bWVudCQnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG5cbi8qKiBNYXBwaW5nIGZyb20gcmVhY3RSb290SUQgdG8gUmVhY3QgY29tcG9uZW50IGluc3RhbmNlLiAqL1xudmFyIGluc3RhbmNlc0J5UmVhY3RSb290SUQgPSB7fTtcblxuLyoqIE1hcHBpbmcgZnJvbSByZWFjdFJvb3RJRCB0byBgY29udGFpbmVyYCBub2Rlcy4gKi9cbnZhciBjb250YWluZXJzQnlSZWFjdFJvb3RJRCA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvKiogX19ERVZfXy1vbmx5IG1hcHBpbmcgZnJvbSByZWFjdFJvb3RJRCB0byByb290IGVsZW1lbnRzLiAqL1xuICB2YXIgcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRCA9IHt9O1xufVxuXG4vLyBVc2VkIHRvIHN0b3JlIGJyZWFkdGgtZmlyc3Qgc2VhcmNoIHN0YXRlIGluIGZpbmRDb21wb25lbnRSb290LlxudmFyIGZpbmRDb21wb25lbnRSb290UmV1c2FibGVBcnJheSA9IFtdO1xuXG4vKipcbiAqIEZpbmRzIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyXG4gKiB0aGF0J3Mgbm90IGNvbW1vbiBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gc3RyaW5ncy5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgY2hhcmFjdGVyIHdoZXJlIHRoZSBzdHJpbmdzIGRpdmVyZ2VcbiAqL1xuZnVuY3Rpb24gZmlyc3REaWZmZXJlbmNlSW5kZXgoc3RyaW5nMSwgc3RyaW5nMikge1xuICB2YXIgbWluTGVuID0gTWF0aC5taW4oc3RyaW5nMS5sZW5ndGgsIHN0cmluZzIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5MZW47IGkrKykge1xuICAgIGlmIChzdHJpbmcxLmNoYXJBdChpKSAhPT0gc3RyaW5nMi5jaGFyQXQoaSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyaW5nMS5sZW5ndGggPT09IHN0cmluZzIubGVuZ3RoID8gLTEgOiBtaW5MZW47XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTURvY3VtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdGhhdCBtYXkgY29udGFpblxuICogYSBSZWFjdCBjb21wb25lbnRcbiAqIEByZXR1cm4gez8qfSBET00gZWxlbWVudCB0aGF0IG1heSBoYXZlIHRoZSByZWFjdFJvb3QgSUQsIG9yIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0aGF0IG1heSBjb250YWluIGEgUmVhY3QgY29tcG9uZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gQSBcInJlYWN0Um9vdFwiIElELCBpZiBhIFJlYWN0IGNvbXBvbmVudCBpcyByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVhY3RSb290SUQoY29udGFpbmVyKSB7XG4gIHZhciByb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICByZXR1cm4gcm9vdEVsZW1lbnQgJiYgUmVhY3RNb3VudC5nZXRJRChyb290RWxlbWVudCk7XG59XG5cbi8qKlxuICogQWNjZXNzaW5nIG5vZGVbQVRUUl9OQU1FXSBvciBjYWxsaW5nIGdldEF0dHJpYnV0ZShBVFRSX05BTUUpIG9uIGEgZm9ybVxuICogZWxlbWVudCBjYW4gcmV0dXJuIGl0cyBjb250cm9sIHdob3NlIG5hbWUgb3IgSUQgZXF1YWxzIEFUVFJfTkFNRS4gQWxsXG4gKiBET00gbm9kZXMgc3VwcG9ydCBgZ2V0QXR0cmlidXRlTm9kZWAgYnV0IHRoaXMgY2FuIGFsc28gZ2V0IGNhbGxlZCBvblxuICogb3RoZXIgb2JqZWN0cyBzbyBqdXN0IHJldHVybiAnJyBpZiB3ZSdyZSBnaXZlbiBzb21ldGhpbmcgb3RoZXIgdGhhbiBhXG4gKiBET00gbm9kZSAoc3VjaCBhcyB3aW5kb3cpLlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR8RE9NV2luZG93fERPTURvY3VtZW50fERPTVRleHROb2RlfSBub2RlIERPTSBub2RlLlxuICogQHJldHVybiB7c3RyaW5nfSBJRCBvZiB0aGUgc3VwcGxpZWQgYGRvbU5vZGVgLlxuICovXG5mdW5jdGlvbiBnZXRJRChub2RlKSB7XG4gIHZhciBpZCA9IGludGVybmFsR2V0SUQobm9kZSk7XG4gIGlmIChpZCkge1xuICAgIGlmIChub2RlQ2FjaGUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICB2YXIgY2FjaGVkID0gbm9kZUNhY2hlW2lkXTtcbiAgICAgIGlmIChjYWNoZWQgIT09IG5vZGUpIHtcbiAgICAgICAgISFpc1ZhbGlkKGNhY2hlZCwgaWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0TW91bnQ6IFR3byB2YWxpZCBidXQgdW5lcXVhbCBub2RlcyB3aXRoIHRoZSBzYW1lIGAlc2A6ICVzJywgQVRUUl9OQU1FLCBpZCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIG5vZGVDYWNoZVtpZF0gPSBub2RlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlQ2FjaGVbaWRdID0gbm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaWQ7XG59XG5cbmZ1bmN0aW9uIGludGVybmFsR2V0SUQobm9kZSkge1xuICAvLyBJZiBub2RlIGlzIHNvbWV0aGluZyBsaWtlIGEgd2luZG93LCBkb2N1bWVudCwgb3IgdGV4dCBub2RlLCBub25lIG9mXG4gIC8vIHdoaWNoIHN1cHBvcnQgYXR0cmlidXRlcyBvciBhIC5nZXRBdHRyaWJ1dGUgbWV0aG9kLCBncmFjZWZ1bGx5IHJldHVyblxuICAvLyB0aGUgZW1wdHkgc3RyaW5nLCBhcyBpZiB0aGUgYXR0cmlidXRlIHdlcmUgbWlzc2luZy5cbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoQVRUUl9OQU1FKSB8fCAnJztcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBSZWFjdC1zcGVjaWZpYyBJRCBvZiB0aGUgZ2l2ZW4gbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgVGhlIERPTSBub2RlIHdob3NlIElEIHdpbGwgYmUgc2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSB2YWx1ZSBvZiB0aGUgSUQgYXR0cmlidXRlLlxuICovXG5mdW5jdGlvbiBzZXRJRChub2RlLCBpZCkge1xuICB2YXIgb2xkSUQgPSBpbnRlcm5hbEdldElEKG5vZGUpO1xuICBpZiAob2xkSUQgIT09IGlkKSB7XG4gICAgZGVsZXRlIG5vZGVDYWNoZVtvbGRJRF07XG4gIH1cbiAgbm9kZS5zZXRBdHRyaWJ1dGUoQVRUUl9OQU1FLCBpZCk7XG4gIG5vZGVDYWNoZVtpZF0gPSBub2RlO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBub2RlIHdpdGggdGhlIHN1cHBsaWVkIFJlYWN0LWdlbmVyYXRlZCBET00gSUQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIEEgUmVhY3QtZ2VuZXJhdGVkIERPTSBJRC5cbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IERPTSBub2RlIHdpdGggdGhlIHN1cHBsZWQgYGlkYC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXROb2RlKGlkKSB7XG4gIGlmICghbm9kZUNhY2hlLmhhc093blByb3BlcnR5KGlkKSB8fCAhaXNWYWxpZChub2RlQ2FjaGVbaWRdLCBpZCkpIHtcbiAgICBub2RlQ2FjaGVbaWRdID0gUmVhY3RNb3VudC5maW5kUmVhY3ROb2RlQnlJRChpZCk7XG4gIH1cbiAgcmV0dXJuIG5vZGVDYWNoZVtpZF07XG59XG5cbi8qKlxuICogRmluZHMgdGhlIG5vZGUgd2l0aCB0aGUgc3VwcGxpZWQgcHVibGljIFJlYWN0IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7Kn0gaW5zdGFuY2UgQSBwdWJsaWMgUmVhY3QgaW5zdGFuY2UuXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudH0gRE9NIG5vZGUgd2l0aCB0aGUgc3VwcGxlZCBgaWRgLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgdmFyIGlkID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQoaW5zdGFuY2UpLl9yb290Tm9kZUlEO1xuICBpZiAoUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5LmlzTnVsbENvbXBvbmVudElEKGlkKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghbm9kZUNhY2hlLmhhc093blByb3BlcnR5KGlkKSB8fCAhaXNWYWxpZChub2RlQ2FjaGVbaWRdLCBpZCkpIHtcbiAgICBub2RlQ2FjaGVbaWRdID0gUmVhY3RNb3VudC5maW5kUmVhY3ROb2RlQnlJRChpZCk7XG4gIH1cbiAgcmV0dXJuIG5vZGVDYWNoZVtpZF07XG59XG5cbi8qKlxuICogQSBub2RlIGlzIFwidmFsaWRcIiBpZiBpdCBpcyBjb250YWluZWQgYnkgYSBjdXJyZW50bHkgbW91bnRlZCBjb250YWluZXIuXG4gKlxuICogVGhpcyBtZWFucyB0aGF0IHRoZSBub2RlIGRvZXMgbm90IGhhdmUgdG8gYmUgY29udGFpbmVkIGJ5IGEgZG9jdW1lbnQgaW5cbiAqIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgdmFsaWQuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBleHBlY3RlZCBJRCBvZiB0aGUgbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIG5vZGUgaXMgY29udGFpbmVkIGJ5IGEgbW91bnRlZCBjb250YWluZXIuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWQobm9kZSwgaWQpIHtcbiAgaWYgKG5vZGUpIHtcbiAgICAhKGludGVybmFsR2V0SUQobm9kZSkgPT09IGlkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdE1vdW50OiBVbmV4cGVjdGVkIG1vZGlmaWNhdGlvbiBvZiBgJXNgJywgQVRUUl9OQU1FKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgY29udGFpbmVyID0gUmVhY3RNb3VudC5maW5kUmVhY3RDb250YWluZXJGb3JJRChpZCk7XG4gICAgaWYgKGNvbnRhaW5lciAmJiBjb250YWluc05vZGUoY29udGFpbmVyLCBub2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENhdXNlcyB0aGUgY2FjaGUgdG8gZm9yZ2V0IGFib3V0IG9uZSBSZWFjdC1zcGVjaWZpYyBJRC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIElEIHRvIGZvcmdldC5cbiAqL1xuZnVuY3Rpb24gcHVyZ2VJRChpZCkge1xuICBkZWxldGUgbm9kZUNhY2hlW2lkXTtcbn1cblxudmFyIGRlZXBlc3ROb2RlU29GYXIgPSBudWxsO1xuZnVuY3Rpb24gZmluZERlZXBlc3RDYWNoZWRBbmNlc3RvckltcGwoYW5jZXN0b3JJRCkge1xuICB2YXIgYW5jZXN0b3IgPSBub2RlQ2FjaGVbYW5jZXN0b3JJRF07XG4gIGlmIChhbmNlc3RvciAmJiBpc1ZhbGlkKGFuY2VzdG9yLCBhbmNlc3RvcklEKSkge1xuICAgIGRlZXBlc3ROb2RlU29GYXIgPSBhbmNlc3RvcjtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIG5vZGUgaXNuJ3QgcG9wdWxhdGVkIGluIHRoZSBjYWNoZSwgc28gcHJlc3VtYWJseSBub25lIG9mIGl0c1xuICAgIC8vIGRlc2NlbmRhbnRzIGFyZS4gQnJlYWsgb3V0IG9mIHRoZSBsb29wLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB0aGUgZGVlcGVzdCBjYWNoZWQgbm9kZSB3aG9zZSBJRCBpcyBhIHByZWZpeCBvZiBgdGFyZ2V0SURgLlxuICovXG5mdW5jdGlvbiBmaW5kRGVlcGVzdENhY2hlZEFuY2VzdG9yKHRhcmdldElEKSB7XG4gIGRlZXBlc3ROb2RlU29GYXIgPSBudWxsO1xuICBSZWFjdEluc3RhbmNlSGFuZGxlcy50cmF2ZXJzZUFuY2VzdG9ycyh0YXJnZXRJRCwgZmluZERlZXBlc3RDYWNoZWRBbmNlc3RvckltcGwpO1xuXG4gIHZhciBmb3VuZE5vZGUgPSBkZWVwZXN0Tm9kZVNvRmFyO1xuICBkZWVwZXN0Tm9kZVNvRmFyID0gbnVsbDtcbiAgcmV0dXJuIGZvdW5kTm9kZTtcbn1cblxuLyoqXG4gKiBNb3VudHMgdGhpcyBjb21wb25lbnQgYW5kIGluc2VydHMgaXQgaW50byB0aGUgRE9NLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudEluc3RhbmNlIFRoZSBpbnN0YW5jZSB0byBtb3VudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgRE9NIElEIG9mIHRoZSByb290IG5vZGUuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byBtb3VudCBpbnRvLlxuICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBJZiB0cnVlLCBkbyBub3QgaW5zZXJ0IG1hcmt1cFxuICovXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudEludG9Ob2RlKGNvbXBvbmVudEluc3RhbmNlLCByb290SUQsIGNvbnRhaW5lciwgdHJhbnNhY3Rpb24sIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KSB7XG4gIGlmIChSZWFjdERPTUZlYXR1cmVGbGFncy51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgY29udGV4dCA9IGFzc2lnbih7fSwgY29udGV4dCk7XG4gICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSkge1xuICAgICAgY29udGV4dFtvd25lckRvY3VtZW50Q29udGV4dEtleV0gPSBjb250YWluZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHRbb3duZXJEb2N1bWVudENvbnRleHRLZXldID0gY29udGFpbmVyLm93bmVyRG9jdW1lbnQ7XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGNvbnRleHQgPT09IGVtcHR5T2JqZWN0KSB7XG4gICAgICBjb250ZXh0ID0ge307XG4gICAgfVxuICAgIHZhciB0YWcgPSBjb250YWluZXIubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBjb250ZXh0W3ZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5XSA9IHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvKG51bGwsIHRhZywgbnVsbCk7XG4gIH1cbiAgdmFyIG1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgcm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gIGNvbXBvbmVudEluc3RhbmNlLl9yZW5kZXJlZENvbXBvbmVudC5fdG9wTGV2ZWxXcmFwcGVyID0gY29tcG9uZW50SW5zdGFuY2U7XG4gIFJlYWN0TW91bnQuX21vdW50SW1hZ2VJbnRvTm9kZShtYXJrdXAsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIHRyYW5zYWN0aW9uKTtcbn1cblxuLyoqXG4gKiBCYXRjaGVkIG1vdW50LlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudEluc3RhbmNlIFRoZSBpbnN0YW5jZSB0byBtb3VudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgRE9NIElEIG9mIHRoZSByb290IG5vZGUuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byBtb3VudCBpbnRvLlxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBJZiB0cnVlLCBkbyBub3QgaW5zZXJ0IG1hcmt1cFxuICovXG5mdW5jdGlvbiBiYXRjaGVkTW91bnRDb21wb25lbnRJbnRvTm9kZShjb21wb25lbnRJbnN0YW5jZSwgcm9vdElELCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KSB7XG4gIHZhciB0cmFuc2FjdGlvbiA9IFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmdldFBvb2xlZChcbiAgLyogZm9yY2VIVE1MICovc2hvdWxkUmV1c2VNYXJrdXApO1xuICB0cmFuc2FjdGlvbi5wZXJmb3JtKG1vdW50Q29tcG9uZW50SW50b05vZGUsIG51bGwsIGNvbXBvbmVudEluc3RhbmNlLCByb290SUQsIGNvbnRhaW5lciwgdHJhbnNhY3Rpb24sIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KTtcbiAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XG59XG5cbi8qKlxuICogVW5tb3VudHMgYSBjb21wb25lbnQgYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGUgRE9NLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGluc3RhbmNlIFJlYWN0IGNvbXBvbmVudCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHVubW91bnQgZnJvbS5cbiAqIEBmaW5hbFxuICogQGludGVybmFsXG4gKiBAc2VlIHtSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGV9XG4gKi9cbmZ1bmN0aW9uIHVubW91bnRDb21wb25lbnRGcm9tTm9kZShpbnN0YW5jZSwgY29udGFpbmVyKSB7XG4gIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KGluc3RhbmNlKTtcblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFKSB7XG4gICAgY29udGFpbmVyID0gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2VtcHR5aW5nLWEtbm9kZVxuICB3aGlsZSAoY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIubGFzdENoaWxkKTtcbiAgfVxufVxuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGhhcyBhIGRpcmVjdCBSZWFjdC1yZW5kZXJlZCBjaGlsZCB0aGF0IGlzXG4gKiBub3QgYSBSZWFjdCByb290IGVsZW1lbnQuIFVzZWZ1bCBmb3Igd2FybmluZyBpbiBgcmVuZGVyYCxcbiAqIGB1bm1vdW50Q29tcG9uZW50QXROb2RlYCwgZXRjLlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBlbGVtZW50IGNvbnRhaW5zIGEgZGlyZWN0IGNoaWxkIHRoYXQgd2FzXG4gKiByZW5kZXJlZCBieSBSZWFjdCBidXQgaXMgbm90IGEgcm9vdCBlbGVtZW50LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGhhc05vblJvb3RSZWFjdENoaWxkKG5vZGUpIHtcbiAgdmFyIHJlYWN0Um9vdElEID0gZ2V0UmVhY3RSb290SUQobm9kZSk7XG4gIHJldHVybiByZWFjdFJvb3RJRCA/IHJlYWN0Um9vdElEICE9PSBSZWFjdEluc3RhbmNlSGFuZGxlcy5nZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQocmVhY3RSb290SUQpIDogZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgKGRlZXBlc3QpIGFuY2VzdG9yIG9mIGEgbm9kZSB3aGljaCBpcyByZW5kZXJlZCBieSB0aGlzIGNvcHlcbiAqIG9mIFJlYWN0LlxuICovXG5mdW5jdGlvbiBmaW5kRmlyc3RSZWFjdERPTUltcGwobm9kZSkge1xuICAvLyBUaGlzIG5vZGUgbWlnaHQgYmUgZnJvbSBhbm90aGVyIFJlYWN0IGluc3RhbmNlLCBzbyB3ZSBtYWtlIHN1cmUgbm90IHRvXG4gIC8vIGV4YW1pbmUgdGhlIG5vZGUgY2FjaGUgaGVyZVxuICBmb3IgKDsgbm9kZSAmJiBub2RlLnBhcmVudE5vZGUgIT09IG5vZGU7IG5vZGUgPSBub2RlLnBhcmVudE5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgLy8gTm90IGEgRE9NRWxlbWVudCwgdGhlcmVmb3JlIG5vdCBhIFJlYWN0IGNvbXBvbmVudFxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBub2RlSUQgPSBpbnRlcm5hbEdldElEKG5vZGUpO1xuICAgIGlmICghbm9kZUlEKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIHJlYWN0Um9vdElEID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEKG5vZGVJRCk7XG5cbiAgICAvLyBJZiBjb250YWluZXJzQnlSZWFjdFJvb3RJRCBjb250YWlucyB0aGUgY29udGFpbmVyIHdlIGZpbmQgYnkgY3Jhd2xpbmcgdXBcbiAgICAvLyB0aGUgdHJlZSwgd2Uga25vdyB0aGF0IHRoaXMgaW5zdGFuY2Ugb2YgUmVhY3QgcmVuZGVyZWQgdGhlIG5vZGUuXG4gICAgLy8gbmIuIGlzVmFsaWQncyBzdHJhdGVneSAod2l0aCBjb250YWluc05vZGUpIGRvZXMgbm90IHdvcmsgYmVjYXVzZSByZW5kZXJcbiAgICAvLyB0cmVlcyBtYXkgYmUgbmVzdGVkIGFuZCB3ZSBkb24ndCB3YW50IGEgZmFsc2UgcG9zaXRpdmUgaW4gdGhhdCBjYXNlLlxuICAgIHZhciBjdXJyZW50ID0gbm9kZTtcbiAgICB2YXIgbGFzdElEO1xuICAgIGRvIHtcbiAgICAgIGxhc3RJRCA9IGludGVybmFsR2V0SUQoY3VycmVudCk7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xuICAgICAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGUgcGFzc2VkLWluIG5vZGUgaGFzIGJlZW4gZGV0YWNoZWQgZnJvbSB0aGUgY29udGFpbmVyIGl0IHdhc1xuICAgICAgICAvLyBvcmlnaW5hbGx5IHJlbmRlcmVkIGludG8uXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGxhc3RJRCAhPT0gcmVhY3RSb290SUQpO1xuXG4gICAgaWYgKGN1cnJlbnQgPT09IGNvbnRhaW5lcnNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFRlbXBvcmFyeSAoPykgaGFjayBzbyB0aGF0IHdlIGNhbiBzdG9yZSBhbGwgdG9wLWxldmVsIHBlbmRpbmcgdXBkYXRlcyBvblxuICogY29tcG9zaXRlcyBpbnN0ZWFkIG9mIGhhdmluZyB0byB3b3JyeSBhYm91dCBkaWZmZXJlbnQgdHlwZXMgb2YgY29tcG9uZW50c1xuICogaGVyZS5cbiAqL1xudmFyIFRvcExldmVsV3JhcHBlciA9IGZ1bmN0aW9uICgpIHt9O1xuVG9wTGV2ZWxXcmFwcGVyLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBUb3BMZXZlbFdyYXBwZXIuZGlzcGxheU5hbWUgPSAnVG9wTGV2ZWxXcmFwcGVyJztcbn1cblRvcExldmVsV3JhcHBlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAvLyB0aGlzLnByb3BzIGlzIGFjdHVhbGx5IGEgUmVhY3RFbGVtZW50XG4gIHJldHVybiB0aGlzLnByb3BzO1xufTtcblxuLyoqXG4gKiBNb3VudGluZyBpcyB0aGUgcHJvY2VzcyBvZiBpbml0aWFsaXppbmcgYSBSZWFjdCBjb21wb25lbnQgYnkgY3JlYXRpbmcgaXRzXG4gKiByZXByZXNlbnRhdGl2ZSBET00gZWxlbWVudHMgYW5kIGluc2VydGluZyB0aGVtIGludG8gYSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAqIEFueSBwcmlvciBjb250ZW50IGluc2lkZSBgY29udGFpbmVyYCBpcyBkZXN0cm95ZWQgaW4gdGhlIHByb2Nlc3MuXG4gKlxuICogICBSZWFjdE1vdW50LnJlbmRlcihcbiAqICAgICBjb21wb25lbnQsXG4gKiAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lcicpXG4gKiAgICk7XG4gKlxuICogICA8ZGl2IGlkPVwiY29udGFpbmVyXCI+ICAgICAgICAgICAgICAgICAgIDwtLSBTdXBwbGllZCBgY29udGFpbmVyYC5cbiAqICAgICA8ZGl2IGRhdGEtcmVhY3RpZD1cIi4zXCI+ICAgICAgICAgICAgICA8LS0gUmVuZGVyZWQgcmVhY3RSb290IG9mIFJlYWN0XG4gKiAgICAgICAvLyAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuXG4gKiAgICAgPC9kaXY+XG4gKiAgIDwvZGl2PlxuICpcbiAqIEluc2lkZSBvZiBgY29udGFpbmVyYCwgdGhlIGZpcnN0IGVsZW1lbnQgcmVuZGVyZWQgaXMgdGhlIFwicmVhY3RSb290XCIuXG4gKi9cbnZhciBSZWFjdE1vdW50ID0ge1xuXG4gIFRvcExldmVsV3JhcHBlcjogVG9wTGV2ZWxXcmFwcGVyLFxuXG4gIC8qKiBFeHBvc2VkIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgKiovXG4gIF9pbnN0YW5jZXNCeVJlYWN0Um9vdElEOiBpbnN0YW5jZXNCeVJlYWN0Um9vdElELFxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgaG9vayBwcm92aWRlZCB0byBzdXBwb3J0IHJlbmRlcmluZyBSZWFjdCBjb21wb25lbnRzIHdoaWxlXG4gICAqIGVuc3VyaW5nIHRoYXQgdGhlIGFwcGFyZW50IHNjcm9sbCBwb3NpdGlvbiBvZiBpdHMgYGNvbnRhaW5lcmAgZG9lcyBub3RcbiAgICogY2hhbmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBUaGUgYGNvbnRhaW5lcmAgYmVpbmcgcmVuZGVyZWQgaW50by5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gcmVuZGVyQ2FsbGJhY2sgVGhpcyBtdXN0IGJlIGNhbGxlZCBvbmNlIHRvIGRvIHRoZSByZW5kZXIuXG4gICAqL1xuICBzY3JvbGxNb25pdG9yOiBmdW5jdGlvbiAoY29udGFpbmVyLCByZW5kZXJDYWxsYmFjaykge1xuICAgIHJlbmRlckNhbGxiYWNrKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRha2UgYSBjb21wb25lbnQgdGhhdCdzIGFscmVhZHkgbW91bnRlZCBpbnRvIHRoZSBET00gYW5kIHJlcGxhY2UgaXRzIHByb3BzXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IHByZXZDb21wb25lbnQgY29tcG9uZW50IGluc3RhbmNlIGFscmVhZHkgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgY29tcG9uZW50IGluc3RhbmNlIHRvIHJlbmRlclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXIgdG8gcmVuZGVyIGludG9cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBjb21wbGV0aW9uXG4gICAqL1xuICBfdXBkYXRlUm9vdENvbXBvbmVudDogZnVuY3Rpb24gKHByZXZDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgUmVhY3RNb3VudC5zY3JvbGxNb25pdG9yKGNvbnRhaW5lciwgZnVuY3Rpb24gKCkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlRWxlbWVudEludGVybmFsKHByZXZDb21wb25lbnQsIG5leHRFbGVtZW50KTtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVDYWxsYmFja0ludGVybmFsKHByZXZDb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBSZWNvcmQgdGhlIHJvb3QgZWxlbWVudCBpbiBjYXNlIGl0IGxhdGVyIGdldHMgdHJhbnNwbGFudGVkLlxuICAgICAgcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtnZXRSZWFjdFJvb3RJRChjb250YWluZXIpXSA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcmV2Q29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNvbXBvbmVudCBpbnRvIHRoZSBpbnN0YW5jZSBtYXAgYW5kIHN0YXJ0cyBzY3JvbGwgdmFsdWVcbiAgICogbW9uaXRvcmluZ1xuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBuZXh0Q29tcG9uZW50IGNvbXBvbmVudCBpbnN0YW5jZSB0byByZW5kZXJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIHRvIHJlbmRlciBpbnRvXG4gICAqIEByZXR1cm4ge3N0cmluZ30gcmVhY3RSb290IElEIHByZWZpeFxuICAgKi9cbiAgX3JlZ2lzdGVyQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dENvbXBvbmVudCwgY29udGFpbmVyKSB7XG4gICAgIShjb250YWluZXIgJiYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgfHwgY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFIHx8IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnX3JlZ2lzdGVyQ29tcG9uZW50KC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmVuc3VyZVNjcm9sbFZhbHVlTW9uaXRvcmluZygpO1xuXG4gICAgdmFyIHJlYWN0Um9vdElEID0gUmVhY3RNb3VudC5yZWdpc3RlckNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIGluc3RhbmNlc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdID0gbmV4dENvbXBvbmVudDtcbiAgICByZXR1cm4gcmVhY3RSb290SUQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIG5ldyBjb21wb25lbnQgaW50byB0aGUgRE9NLlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgZWxlbWVudCB0byByZW5kZXJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIHRvIHJlbmRlciBpbnRvXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUmV1c2VNYXJrdXAgaWYgd2Ugc2hvdWxkIHNraXAgdGhlIG1hcmt1cCBpbnNlcnRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IG5leHRDb21wb25lbnRcbiAgICovXG4gIF9yZW5kZXJOZXdSb290Q29tcG9uZW50OiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcbiAgICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAnX3JlbmRlck5ld1Jvb3RDb21wb25lbnQoKTogUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiAnICsgJ29mIHByb3BzIGFuZCBzdGF0ZTsgdHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSAnICsgJ3JlbmRlciBpcyBub3QgYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChuZXh0RWxlbWVudCwgbnVsbCk7XG4gICAgdmFyIHJlYWN0Um9vdElEID0gUmVhY3RNb3VudC5fcmVnaXN0ZXJDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIGNvbnRhaW5lcik7XG5cbiAgICAvLyBUaGUgaW5pdGlhbCByZW5kZXIgaXMgc3luY2hyb25vdXMgYnV0IGFueSB1cGRhdGVzIHRoYXQgaGFwcGVuIGR1cmluZ1xuICAgIC8vIHJlbmRlcmluZywgaW4gY29tcG9uZW50V2lsbE1vdW50IG9yIGNvbXBvbmVudERpZE1vdW50LCB3aWxsIGJlIGJhdGNoZWRcbiAgICAvLyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgYmF0Y2hpbmcgc3RyYXRlZ3kuXG5cbiAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMoYmF0Y2hlZE1vdW50Q29tcG9uZW50SW50b05vZGUsIGNvbXBvbmVudEluc3RhbmNlLCByZWFjdFJvb3RJRCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gUmVjb3JkIHRoZSByb290IGVsZW1lbnQgaW4gY2FzZSBpdCBsYXRlciBnZXRzIHRyYW5zcGxhbnRlZC5cbiAgICAgIHJvb3RFbGVtZW50c0J5UmVhY3RSb290SURbcmVhY3RSb290SURdID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBvbmVudEluc3RhbmNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgUmVhY3QgY29tcG9uZW50IGludG8gdGhlIERPTSBpbiB0aGUgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gICAqXG4gICAqIElmIHRoZSBSZWFjdCBjb21wb25lbnQgd2FzIHByZXZpb3VzbHkgcmVuZGVyZWQgaW50byBgY29udGFpbmVyYCwgdGhpcyB3aWxsXG4gICAqIHBlcmZvcm0gYW4gdXBkYXRlIG9uIGl0IGFuZCBvbmx5IG11dGF0ZSB0aGUgRE9NIGFzIG5lY2Vzc2FyeSB0byByZWZsZWN0IHRoZVxuICAgKiBsYXRlc3QgUmVhY3QgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBwYXJlbnRDb21wb25lbnQgVGhlIGNvbmNlcHR1YWwgcGFyZW50IG9mIHRoaXMgcmVuZGVyIHRyZWUuXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBDb21wb25lbnQgZWxlbWVudCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiBgY29udGFpbmVyYC5cbiAgICovXG4gIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgICEocGFyZW50Q29tcG9uZW50ICE9IG51bGwgJiYgcGFyZW50Q29tcG9uZW50Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncGFyZW50Q29tcG9uZW50IG11c3QgYmUgYSB2YWxpZCBSZWFjdCBDb21wb25lbnQnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spO1xuICB9LFxuXG4gIF9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogZnVuY3Rpb24gKHBhcmVudENvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICAhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG5leHRFbGVtZW50KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTS5yZW5kZXIoKTogSW52YWxpZCBjb21wb25lbnQgZWxlbWVudC4lcycsIHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ3N0cmluZycgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhbiBlbGVtZW50IHN0cmluZywgbWFrZSBzdXJlIHRvIGluc3RhbnRpYXRlICcgKyAnaXQgYnkgcGFzc2luZyBpdCB0byBSZWFjdC5jcmVhdGVFbGVtZW50LicgOiB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdmdW5jdGlvbicgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIGNvbXBvbmVudCBjbGFzcywgbWFrZSBzdXJlIHRvIGluc3RhbnRpYXRlICcgKyAnaXQgYnkgcGFzc2luZyBpdCB0byBSZWFjdC5jcmVhdGVFbGVtZW50LicgOlxuICAgIC8vIENoZWNrIGlmIGl0IHF1YWNrcyBsaWtlIGFuIGVsZW1lbnRcbiAgICBuZXh0RWxlbWVudCAhPSBudWxsICYmIG5leHRFbGVtZW50LnByb3BzICE9PSB1bmRlZmluZWQgPyAnIFRoaXMgbWF5IGJlIGNhdXNlZCBieSB1bmludGVudGlvbmFsbHkgbG9hZGluZyB0d28gaW5kZXBlbmRlbnQgJyArICdjb3BpZXMgb2YgUmVhY3QuJyA6ICcnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY29udGFpbmVyIHx8ICFjb250YWluZXIudGFnTmFtZSB8fCBjb250YWluZXIudGFnTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnQk9EWScsICdyZW5kZXIoKTogUmVuZGVyaW5nIGNvbXBvbmVudHMgZGlyZWN0bHkgaW50byBkb2N1bWVudC5ib2R5IGlzICcgKyAnZGlzY291cmFnZWQsIHNpbmNlIGl0cyBjaGlsZHJlbiBhcmUgb2Z0ZW4gbWFuaXB1bGF0ZWQgYnkgdGhpcmQtcGFydHkgJyArICdzY3JpcHRzIGFuZCBicm93c2VyIGV4dGVuc2lvbnMuIFRoaXMgbWF5IGxlYWQgdG8gc3VidGxlICcgKyAncmVjb25jaWxpYXRpb24gaXNzdWVzLiBUcnkgcmVuZGVyaW5nIGludG8gYSBjb250YWluZXIgZWxlbWVudCBjcmVhdGVkICcgKyAnZm9yIHlvdXIgYXBwLicpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIG5leHRXcmFwcGVkRWxlbWVudCA9IG5ldyBSZWFjdEVsZW1lbnQoVG9wTGV2ZWxXcmFwcGVyLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBuZXh0RWxlbWVudCk7XG5cbiAgICB2YXIgcHJldkNvbXBvbmVudCA9IGluc3RhbmNlc0J5UmVhY3RSb290SURbZ2V0UmVhY3RSb290SUQoY29udGFpbmVyKV07XG5cbiAgICBpZiAocHJldkNvbXBvbmVudCkge1xuICAgICAgdmFyIHByZXZXcmFwcGVkRWxlbWVudCA9IHByZXZDb21wb25lbnQuX2N1cnJlbnRFbGVtZW50O1xuICAgICAgdmFyIHByZXZFbGVtZW50ID0gcHJldldyYXBwZWRFbGVtZW50LnByb3BzO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkpIHtcbiAgICAgICAgdmFyIHB1YmxpY0luc3QgPSBwcmV2Q29tcG9uZW50Ll9yZW5kZXJlZENvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgICAgICB2YXIgdXBkYXRlZENhbGxiYWNrID0gY2FsbGJhY2sgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbGxiYWNrLmNhbGwocHVibGljSW5zdCk7XG4gICAgICAgIH07XG4gICAgICAgIFJlYWN0TW91bnQuX3VwZGF0ZVJvb3RDb21wb25lbnQocHJldkNvbXBvbmVudCwgbmV4dFdyYXBwZWRFbGVtZW50LCBjb250YWluZXIsIHVwZGF0ZWRDYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBwdWJsaWNJbnN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlKGNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlYWN0Um9vdEVsZW1lbnQgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICB2YXIgY29udGFpbmVySGFzUmVhY3RNYXJrdXAgPSByZWFjdFJvb3RFbGVtZW50ICYmICEhaW50ZXJuYWxHZXRJRChyZWFjdFJvb3RFbGVtZW50KTtcbiAgICB2YXIgY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSBoYXNOb25Sb290UmVhY3RDaGlsZChjb250YWluZXIpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCwgJ3JlbmRlciguLi4pOiBSZXBsYWNpbmcgUmVhY3QtcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIG5ldyByb290ICcgKyAnY29tcG9uZW50LiBJZiB5b3UgaW50ZW5kZWQgdG8gdXBkYXRlIHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUsICcgKyAneW91IHNob3VsZCBpbnN0ZWFkIGhhdmUgdGhlIGV4aXN0aW5nIGNoaWxkcmVuIHVwZGF0ZSB0aGVpciBzdGF0ZSAnICsgJ2FuZCByZW5kZXIgdGhlIG5ldyBjb21wb25lbnRzIGluc3RlYWQgb2YgY2FsbGluZyBSZWFjdERPTS5yZW5kZXIuJykgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICghY29udGFpbmVySGFzUmVhY3RNYXJrdXAgfHwgcmVhY3RSb290RWxlbWVudC5uZXh0U2libGluZykge1xuICAgICAgICB2YXIgcm9vdEVsZW1lbnRTaWJsaW5nID0gcmVhY3RSb290RWxlbWVudDtcbiAgICAgICAgd2hpbGUgKHJvb3RFbGVtZW50U2libGluZykge1xuICAgICAgICAgIGlmIChpbnRlcm5hbEdldElEKHJvb3RFbGVtZW50U2libGluZykpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKCk6IFRhcmdldCBub2RlIGhhcyBtYXJrdXAgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCB0aGVyZSAnICsgJ2FyZSB1bnJlbGF0ZWQgbm9kZXMgYXMgd2VsbC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGNhdXNlZCBieSAnICsgJ3doaXRlLXNwYWNlIGluc2VydGVkIGFyb3VuZCBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwLicpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJvb3RFbGVtZW50U2libGluZyA9IHJvb3RFbGVtZW50U2libGluZy5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzaG91bGRSZXVzZU1hcmt1cCA9IGNvbnRhaW5lckhhc1JlYWN0TWFya3VwICYmICFwcmV2Q29tcG9uZW50ICYmICFjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZDtcbiAgICB2YXIgY29tcG9uZW50ID0gUmVhY3RNb3VudC5fcmVuZGVyTmV3Um9vdENvbXBvbmVudChuZXh0V3JhcHBlZEVsZW1lbnQsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIHBhcmVudENvbXBvbmVudCAhPSBudWxsID8gcGFyZW50Q29tcG9uZW50Ll9yZWFjdEludGVybmFsSW5zdGFuY2UuX3Byb2Nlc3NDaGlsZENvbnRleHQocGFyZW50Q29tcG9uZW50Ll9yZWFjdEludGVybmFsSW5zdGFuY2UuX2NvbnRleHQpIDogZW1wdHlPYmplY3QpLl9yZW5kZXJlZENvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2suY2FsbChjb21wb25lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgUmVhY3QgY29tcG9uZW50IGludG8gdGhlIERPTSBpbiB0aGUgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gICAqXG4gICAqIElmIHRoZSBSZWFjdCBjb21wb25lbnQgd2FzIHByZXZpb3VzbHkgcmVuZGVyZWQgaW50byBgY29udGFpbmVyYCwgdGhpcyB3aWxsXG4gICAqIHBlcmZvcm0gYW4gdXBkYXRlIG9uIGl0IGFuZCBvbmx5IG11dGF0ZSB0aGUgRE9NIGFzIG5lY2Vzc2FyeSB0byByZWZsZWN0IHRoZVxuICAgKiBsYXRlc3QgUmVhY3QgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgQ29tcG9uZW50IGVsZW1lbnQgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byByZW5kZXIgaW50by5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBjb21wbGV0aW9uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBDb21wb25lbnQgaW5zdGFuY2UgcmVuZGVyZWQgaW4gYGNvbnRhaW5lcmAuXG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBSZWFjdE1vdW50Ll9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGNvbnRhaW5lciBub2RlIGludG8gd2hpY2ggUmVhY3QgY29tcG9uZW50cyB3aWxsIGJlIHJlbmRlcmVkLlxuICAgKiBUaGlzIGFsc28gY3JlYXRlcyB0aGUgXCJyZWFjdFJvb3RcIiBJRCB0aGF0IHdpbGwgYmUgYXNzaWduZWQgdG8gdGhlIGVsZW1lbnRcbiAgICogcmVuZGVyZWQgd2l0aGluLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byByZWdpc3RlciBhcyBhIGNvbnRhaW5lci5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgXCJyZWFjdFJvb3RcIiBJRCBvZiBlbGVtZW50cyByZW5kZXJlZCB3aXRoaW4uXG4gICAqL1xuICByZWdpc3RlckNvbnRhaW5lcjogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIHZhciByZWFjdFJvb3RJRCA9IGdldFJlYWN0Um9vdElEKGNvbnRhaW5lcik7XG4gICAgaWYgKHJlYWN0Um9vdElEKSB7XG4gICAgICAvLyBJZiBvbmUgZXhpc3RzLCBtYWtlIHN1cmUgaXQgaXMgYSB2YWxpZCBcInJlYWN0Um9vdFwiIElELlxuICAgICAgcmVhY3RSb290SUQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5nZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQocmVhY3RSb290SUQpO1xuICAgIH1cbiAgICBpZiAoIXJlYWN0Um9vdElEKSB7XG4gICAgICAvLyBObyB2YWxpZCBcInJlYWN0Um9vdFwiIElEIGZvdW5kLCBjcmVhdGUgb25lLlxuICAgICAgcmVhY3RSb290SUQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5jcmVhdGVSZWFjdFJvb3RJRCgpO1xuICAgIH1cbiAgICBjb250YWluZXJzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF0gPSBjb250YWluZXI7XG4gICAgcmV0dXJuIHJlYWN0Um9vdElEO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVbm1vdW50cyBhbmQgZGVzdHJveXMgdGhlIFJlYWN0IGNvbXBvbmVudCByZW5kZXJlZCBpbiB0aGUgYGNvbnRhaW5lcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IGNvbnRhaW5pbmcgYSBSZWFjdCBjb21wb25lbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYSBjb21wb25lbnQgd2FzIGZvdW5kIGluIGFuZCB1bm1vdW50ZWQgZnJvbVxuICAgKiAgICAgICAgICAgICAgICAgICBgY29udGFpbmVyYFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAgIC8vIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQpIGFzc3VtZSB0aGF0IGNhbGxzIHRvIHJlbmRlciBhcmVuJ3QgbmVzdGVkO1xuICAgIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS4gKFN0cmljdGx5IHNwZWFraW5nLCB1bm1vdW50aW5nIHdvbid0IGNhdXNlIGFcbiAgICAvLyByZW5kZXIgYnV0IHdlIHN0aWxsIGRvbid0IGV4cGVjdCB0byBiZSBpbiBhIHJlbmRlciBjYWxsIGhlcmUuKVxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCwgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoKTogUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiAnICsgJ29mIHByb3BzIGFuZCBzdGF0ZTsgdHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgJyArICdpcyBub3QgYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuXG4gICAgIShjb250YWluZXIgJiYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgfHwgY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFIHx8IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciByZWFjdFJvb3RJRCA9IGdldFJlYWN0Um9vdElEKGNvbnRhaW5lcik7XG4gICAgdmFyIGNvbXBvbmVudCA9IGluc3RhbmNlc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdO1xuICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGUgbm9kZSBiZWluZyB1bm1vdW50ZWQgd2FzIHJlbmRlcmVkIGJ5IFJlYWN0LCBidXQgaXNuJ3QgYVxuICAgICAgLy8gcm9vdCBub2RlLlxuICAgICAgdmFyIGNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkID0gaGFzTm9uUm9vdFJlYWN0Q2hpbGQoY29udGFpbmVyKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNvbnRhaW5lciBpdHNlbGYgaXMgYSBSZWFjdCByb290IG5vZGUuXG4gICAgICB2YXIgY29udGFpbmVySUQgPSBpbnRlcm5hbEdldElEKGNvbnRhaW5lcik7XG4gICAgICB2YXIgaXNDb250YWluZXJSZWFjdFJvb3QgPSBjb250YWluZXJJRCAmJiBjb250YWluZXJJRCA9PT0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEKGNvbnRhaW5lcklEKTtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBUaGUgbm9kZSB5b3VcXCdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgJyArICd3YXMgcmVuZGVyZWQgYnkgUmVhY3QgYW5kIGlzIG5vdCBhIHRvcC1sZXZlbCBjb250YWluZXIuICVzJywgaXNDb250YWluZXJSZWFjdFJvb3QgPyAnWW91IG1heSBoYXZlIGFjY2lkZW50YWxseSBwYXNzZWQgaW4gYSBSZWFjdCByb290IG5vZGUgaW5zdGVhZCAnICsgJ29mIGl0cyBjb250YWluZXIuJyA6ICdJbnN0ZWFkLCBoYXZlIHRoZSBwYXJlbnQgY29tcG9uZW50IHVwZGF0ZSBpdHMgc3RhdGUgYW5kICcgKyAncmVyZW5kZXIgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoaXMgY29tcG9uZW50LicpIDogdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyh1bm1vdW50Q29tcG9uZW50RnJvbU5vZGUsIGNvbXBvbmVudCwgY29udGFpbmVyKTtcbiAgICBkZWxldGUgaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF07XG4gICAgZGVsZXRlIGNvbnRhaW5lcnNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZGVsZXRlIHJvb3RFbGVtZW50c0J5UmVhY3RSb290SURbcmVhY3RSb290SURdO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgdGhlIGNvbnRhaW5lciBET00gZWxlbWVudCB0aGF0IGNvbnRhaW5zIFJlYWN0IGNvbXBvbmVudCB0byB3aGljaCB0aGVcbiAgICogc3VwcGxpZWQgRE9NIGBpZGAgYmVsb25ncy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCBvZiBhbiBlbGVtZW50IHJlbmRlcmVkIGJ5IGEgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHs/RE9NRWxlbWVudH0gRE9NIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgYGlkYC5cbiAgICovXG4gIGZpbmRSZWFjdENvbnRhaW5lckZvcklEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgcmVhY3RSb290SUQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5nZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQoaWQpO1xuICAgIHZhciBjb250YWluZXIgPSBjb250YWluZXJzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF07XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHJvb3RFbGVtZW50ID0gcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF07XG4gICAgICBpZiAocm9vdEVsZW1lbnQgJiYgcm9vdEVsZW1lbnQucGFyZW50Tm9kZSAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFxuICAgICAgICAvLyBDYWxsIGludGVybmFsR2V0SUQgaGVyZSBiZWNhdXNlIGdldElEIGNhbGxzIGlzVmFsaWQgd2hpY2ggY2FsbHNcbiAgICAgICAgLy8gZmluZFJlYWN0Q29udGFpbmVyRm9ySUQgKHRoaXMgZnVuY3Rpb24pLlxuICAgICAgICBpbnRlcm5hbEdldElEKHJvb3RFbGVtZW50KSA9PT0gcmVhY3RSb290SUQsICdSZWFjdE1vdW50OiBSb290IGVsZW1lbnQgSUQgZGlmZmVyZWQgZnJvbSByZWFjdFJvb3RJRC4nKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGNvbnRhaW5lckNoaWxkID0gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmIChjb250YWluZXJDaGlsZCAmJiByZWFjdFJvb3RJRCA9PT0gaW50ZXJuYWxHZXRJRChjb250YWluZXJDaGlsZCkpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgY29udGFpbmVyIGhhcyBhIG5ldyBjaGlsZCB3aXRoIHRoZSBzYW1lIElEIGFzIHRoZSBvbGRcbiAgICAgICAgICAvLyByb290IGVsZW1lbnQsIHRoZW4gcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF0gaXNcbiAgICAgICAgICAvLyBqdXN0IHN0YWxlIGFuZCBuZWVkcyB0byBiZSB1cGRhdGVkLiBUaGUgY2FzZSB0aGF0IGRlc2VydmVzIGFcbiAgICAgICAgICAvLyB3YXJuaW5nIGlzIHdoZW4gdGhlIGNvbnRhaW5lciBpcyBlbXB0eS5cbiAgICAgICAgICByb290RWxlbWVudHNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXSA9IGNvbnRhaW5lckNoaWxkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3RNb3VudDogUm9vdCBlbGVtZW50IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSBpdHMgb3JpZ2luYWwgJyArICdjb250YWluZXIuIE5ldyBjb250YWluZXI6ICVzJywgcm9vdEVsZW1lbnQucGFyZW50Tm9kZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kcyBhbiBlbGVtZW50IHJlbmRlcmVkIGJ5IFJlYWN0IHdpdGggdGhlIHN1cHBsaWVkIElELlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgYSBET00gbm9kZSBpbiB0aGUgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fSBSb290IERPTSBub2RlIG9mIHRoZSBSZWFjdCBjb21wb25lbnQuXG4gICAqL1xuICBmaW5kUmVhY3ROb2RlQnlJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIHJlYWN0Um9vdCA9IFJlYWN0TW91bnQuZmluZFJlYWN0Q29udGFpbmVyRm9ySUQoaWQpO1xuICAgIHJldHVybiBSZWFjdE1vdW50LmZpbmRDb21wb25lbnRSb290KHJlYWN0Um9vdCwgaWQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmF2ZXJzZXMgdXAgdGhlIGFuY2VzdG9ycyBvZiB0aGUgc3VwcGxpZWQgbm9kZSB0byBmaW5kIGEgbm9kZSB0aGF0IGlzIGFcbiAgICogRE9NIHJlcHJlc2VudGF0aW9uIG9mIGEgUmVhY3QgY29tcG9uZW50IHJlbmRlcmVkIGJ5IHRoaXMgY29weSBvZiBSZWFjdC5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBub2RlXG4gICAqIEByZXR1cm4gez9ET01FdmVudFRhcmdldH1cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXRGaXJzdFJlYWN0RE9NOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBmaW5kRmlyc3RSZWFjdERPTUltcGwobm9kZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIGEgbm9kZSB3aXRoIHRoZSBzdXBwbGllZCBgdGFyZ2V0SURgIGluc2lkZSBvZiB0aGUgc3VwcGxpZWRcbiAgICogYGFuY2VzdG9yTm9kZWAuICBFeHBsb2l0cyB0aGUgSUQgbmFtaW5nIHNjaGVtZSB0byBwZXJmb3JtIHRoZSBzZWFyY2hcbiAgICogcXVpY2tseS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gYW5jZXN0b3JOb2RlIFNlYXJjaCBmcm9tIHRoaXMgcm9vdC5cbiAgICogQHBhcmFybSB7c3RyaW5nfSB0YXJnZXRJRCBJRCBvZiB0aGUgRE9NIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb21wb25lbnQuXG4gICAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBET00gbm9kZSB3aXRoIHRoZSBzdXBwbGllZCBgdGFyZ2V0SURgLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGZpbmRDb21wb25lbnRSb290OiBmdW5jdGlvbiAoYW5jZXN0b3JOb2RlLCB0YXJnZXRJRCkge1xuICAgIHZhciBmaXJzdENoaWxkcmVuID0gZmluZENvbXBvbmVudFJvb3RSZXVzYWJsZUFycmF5O1xuICAgIHZhciBjaGlsZEluZGV4ID0gMDtcblxuICAgIHZhciBkZWVwZXN0QW5jZXN0b3IgPSBmaW5kRGVlcGVzdENhY2hlZEFuY2VzdG9yKHRhcmdldElEKSB8fCBhbmNlc3Rvck5vZGU7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IG9uIHRoZSBuZXh0IGxpbmU7IGdpdmUgYW4gZWFybHkgd2FybmluZ1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGVlcGVzdEFuY2VzdG9yICE9IG51bGwsICdSZWFjdCBjYW5cXCd0IGZpbmQgdGhlIHJvb3QgY29tcG9uZW50IG5vZGUgZm9yIGRhdGEtcmVhY3RpZCB2YWx1ZSAnICsgJ2Alc2AuIElmIHlvdVxcJ3JlIHNlZWluZyB0aGlzIG1lc3NhZ2UsIGl0IHByb2JhYmx5IG1lYW5zIHRoYXQgJyArICd5b3VcXCd2ZSBsb2FkZWQgdHdvIGNvcGllcyBvZiBSZWFjdCBvbiB0aGUgcGFnZS4gQXQgdGhpcyB0aW1lLCBvbmx5ICcgKyAnYSBzaW5nbGUgY29weSBvZiBSZWFjdCBjYW4gYmUgbG9hZGVkIGF0IGEgdGltZS4nLCB0YXJnZXRJRCkgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZmlyc3RDaGlsZHJlblswXSA9IGRlZXBlc3RBbmNlc3Rvci5maXJzdENoaWxkO1xuICAgIGZpcnN0Q2hpbGRyZW4ubGVuZ3RoID0gMTtcblxuICAgIHdoaWxlIChjaGlsZEluZGV4IDwgZmlyc3RDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHZhciBjaGlsZCA9IGZpcnN0Q2hpbGRyZW5bY2hpbGRJbmRleCsrXTtcbiAgICAgIHZhciB0YXJnZXRDaGlsZDtcblxuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIHZhciBjaGlsZElEID0gUmVhY3RNb3VudC5nZXRJRChjaGlsZCk7XG4gICAgICAgIGlmIChjaGlsZElEKSB7XG4gICAgICAgICAgLy8gRXZlbiBpZiB3ZSBmaW5kIHRoZSBub2RlIHdlJ3JlIGxvb2tpbmcgZm9yLCB3ZSBmaW5pc2ggbG9vcGluZ1xuICAgICAgICAgIC8vIHRocm91Z2ggaXRzIHNpYmxpbmdzIHRvIGVuc3VyZSB0aGV5J3JlIGNhY2hlZCBzbyB0aGF0IHdlIGRvbid0IGhhdmVcbiAgICAgICAgICAvLyB0byByZXZpc2l0IHRoaXMgbm9kZSBhZ2Fpbi4gT3RoZXJ3aXNlLCB3ZSBtYWtlIG5eMiBjYWxscyB0byBnZXRJRFxuICAgICAgICAgIC8vIHdoZW4gdmlzaXRpbmcgdGhlIG1hbnkgY2hpbGRyZW4gb2YgYSBzaW5nbGUgbm9kZSBpbiBvcmRlci5cblxuICAgICAgICAgIGlmICh0YXJnZXRJRCA9PT0gY2hpbGRJRCkge1xuICAgICAgICAgICAgdGFyZ2V0Q2hpbGQgPSBjaGlsZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKFJlYWN0SW5zdGFuY2VIYW5kbGVzLmlzQW5jZXN0b3JJRE9mKGNoaWxkSUQsIHRhcmdldElEKSkge1xuICAgICAgICAgICAgLy8gSWYgd2UgZmluZCBhIGNoaWxkIHdob3NlIElEIGlzIGFuIGFuY2VzdG9yIG9mIHRoZSBnaXZlbiBJRCxcbiAgICAgICAgICAgIC8vIHRoZW4gd2UgY2FuIGJlIHN1cmUgdGhhdCB3ZSBvbmx5IHdhbnQgdG8gc2VhcmNoIHRoZSBzdWJ0cmVlXG4gICAgICAgICAgICAvLyByb290ZWQgYXQgdGhpcyBjaGlsZCwgc28gd2UgY2FuIHRocm93IG91dCB0aGUgcmVzdCBvZiB0aGVcbiAgICAgICAgICAgIC8vIHNlYXJjaCBzdGF0ZS5cbiAgICAgICAgICAgIGZpcnN0Q2hpbGRyZW4ubGVuZ3RoID0gY2hpbGRJbmRleCA9IDA7XG4gICAgICAgICAgICBmaXJzdENoaWxkcmVuLnB1c2goY2hpbGQuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHRoaXMgY2hpbGQgaGFkIG5vIElELCB0aGVuIHRoZXJlJ3MgYSBjaGFuY2UgdGhhdCBpdCB3YXNcbiAgICAgICAgICAvLyBpbmplY3RlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBicm93c2VyLCBhcyB3aGVuIGEgYDx0YWJsZT5gXG4gICAgICAgICAgLy8gZWxlbWVudCBzcHJvdXRzIGFuIGV4dHJhIGA8dGJvZHk+YCBjaGlsZCBhcyBhIHNpZGUgZWZmZWN0IG9mXG4gICAgICAgICAgLy8gYC5pbm5lckhUTUxgIHBhcnNpbmcuIE9wdGltaXN0aWNhbGx5IGNvbnRpbnVlIGRvd24gdGhpc1xuICAgICAgICAgIC8vIGJyYW5jaCwgYnV0IG5vdCBiZWZvcmUgZXhhbWluaW5nIHRoZSBvdGhlciBzaWJsaW5ncy5cbiAgICAgICAgICBmaXJzdENoaWxkcmVuLnB1c2goY2hpbGQuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBpZiAodGFyZ2V0Q2hpbGQpIHtcbiAgICAgICAgLy8gRW1wdHlpbmcgZmlyc3RDaGlsZHJlbi9maW5kQ29tcG9uZW50Um9vdFJldXNhYmxlQXJyYXkgaXNcbiAgICAgICAgLy8gbm90IG5lY2Vzc2FyeSBmb3IgY29ycmVjdG5lc3MsIGJ1dCBpdCBoZWxwcyB0aGUgR0MgcmVjbGFpbVxuICAgICAgICAvLyBhbnkgbm9kZXMgdGhhdCB3ZXJlIGxlZnQgYXQgdGhlIGVuZCBvZiB0aGUgc2VhcmNoLlxuICAgICAgICBmaXJzdENoaWxkcmVuLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldENoaWxkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZpcnN0Q2hpbGRyZW4ubGVuZ3RoID0gMDtcblxuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdmaW5kQ29tcG9uZW50Um9vdCguLi4sICVzKTogVW5hYmxlIHRvIGZpbmQgZWxlbWVudC4gVGhpcyBwcm9iYWJseSAnICsgJ21lYW5zIHRoZSBET00gd2FzIHVuZXhwZWN0ZWRseSBtdXRhdGVkIChlLmcuLCBieSB0aGUgYnJvd3NlciksICcgKyAndXN1YWxseSBkdWUgdG8gZm9yZ2V0dGluZyBhIDx0Ym9keT4gd2hlbiB1c2luZyB0YWJsZXMsIG5lc3RpbmcgdGFncyAnICsgJ2xpa2UgPGZvcm0+LCA8cD4sIG9yIDxhPiwgb3IgdXNpbmcgbm9uLVNWRyBlbGVtZW50cyBpbiBhbiA8c3ZnPiAnICsgJ3BhcmVudC4gJyArICdUcnkgaW5zcGVjdGluZyB0aGUgY2hpbGQgbm9kZXMgb2YgdGhlIGVsZW1lbnQgd2l0aCBSZWFjdCBJRCBgJXNgLicsIHRhcmdldElELCBSZWFjdE1vdW50LmdldElEKGFuY2VzdG9yTm9kZSkpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfSxcblxuICBfbW91bnRJbWFnZUludG9Ob2RlOiBmdW5jdGlvbiAobWFya3VwLCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCB0cmFuc2FjdGlvbikge1xuICAgICEoY29udGFpbmVyICYmIChjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFIHx8IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSB8fCBjb250YWluZXIubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21vdW50Q29tcG9uZW50SW50b05vZGUoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgdmFsaWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKHNob3VsZFJldXNlTWFya3VwKSB7XG4gICAgICB2YXIgcm9vdEVsZW1lbnQgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgIGlmIChSZWFjdE1hcmt1cENoZWNrc3VtLmNhblJldXNlTWFya3VwKG1hcmt1cCwgcm9vdEVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjaGVja3N1bSA9IHJvb3RFbGVtZW50LmdldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG4gICAgICAgIHJvb3RFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG5cbiAgICAgICAgdmFyIHJvb3RNYXJrdXAgPSByb290RWxlbWVudC5vdXRlckhUTUw7XG4gICAgICAgIHJvb3RFbGVtZW50LnNldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSwgY2hlY2tzdW0pO1xuXG4gICAgICAgIHZhciBub3JtYWxpemVkTWFya3VwID0gbWFya3VwO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIC8vIGJlY2F1c2Ugcm9vdE1hcmt1cCBpcyByZXRyaWV2ZWQgZnJvbSB0aGUgRE9NLCB2YXJpb3VzIG5vcm1hbGl6YXRpb25zXG4gICAgICAgICAgLy8gd2lsbCBoYXZlIG9jY3VycmVkIHdoaWNoIHdpbGwgbm90IGJlIHByZXNlbnQgaW4gYG1hcmt1cGAuIEhlcmUsXG4gICAgICAgICAgLy8gaW5zZXJ0IG1hcmt1cCBpbnRvIGEgPGRpdj4gb3IgPGlmcmFtZT4gZGVwZW5kaW5nIG9uIHRoZSBjb250YWluZXJcbiAgICAgICAgICAvLyB0eXBlIHRvIHBlcmZvcm0gdGhlIHNhbWUgbm9ybWFsaXphdGlvbnMgYmVmb3JlIGNvbXBhcmluZy5cbiAgICAgICAgICB2YXIgbm9ybWFsaXplcjtcbiAgICAgICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSkge1xuICAgICAgICAgICAgbm9ybWFsaXplciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgbm9ybWFsaXplci5pbm5lckhUTUwgPSBtYXJrdXA7XG4gICAgICAgICAgICBub3JtYWxpemVkTWFya3VwID0gbm9ybWFsaXplci5pbm5lckhUTUw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobm9ybWFsaXplcik7XG4gICAgICAgICAgICBub3JtYWxpemVyLmNvbnRlbnREb2N1bWVudC53cml0ZShtYXJrdXApO1xuICAgICAgICAgICAgbm9ybWFsaXplZE1hcmt1cCA9IG5vcm1hbGl6ZXIuY29udGVudERvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vdXRlckhUTUw7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG5vcm1hbGl6ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaWZmSW5kZXggPSBmaXJzdERpZmZlcmVuY2VJbmRleChub3JtYWxpemVkTWFya3VwLCByb290TWFya3VwKTtcbiAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSAnIChjbGllbnQpICcgKyBub3JtYWxpemVkTWFya3VwLnN1YnN0cmluZyhkaWZmSW5kZXggLSAyMCwgZGlmZkluZGV4ICsgMjApICsgJ1xcbiAoc2VydmVyKSAnICsgcm9vdE1hcmt1cC5zdWJzdHJpbmcoZGlmZkluZGV4IC0gMjAsIGRpZmZJbmRleCArIDIwKTtcblxuICAgICAgICAhKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnWW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBhIGNvbXBvbmVudCB0byB0aGUgZG9jdW1lbnQgdXNpbmcgJyArICdzZXJ2ZXIgcmVuZGVyaW5nIGJ1dCB0aGUgY2hlY2tzdW0gd2FzIGludmFsaWQuIFRoaXMgdXN1YWxseSAnICsgJ21lYW5zIHlvdSByZW5kZXJlZCBhIGRpZmZlcmVudCBjb21wb25lbnQgdHlwZSBvciBwcm9wcyBvbiAnICsgJ3RoZSBjbGllbnQgZnJvbSB0aGUgb25lIG9uIHRoZSBzZXJ2ZXIsIG9yIHlvdXIgcmVuZGVyKCkgJyArICdtZXRob2RzIGFyZSBpbXB1cmUuIFJlYWN0IGNhbm5vdCBoYW5kbGUgdGhpcyBjYXNlIGR1ZSB0byAnICsgJ2Nyb3NzLWJyb3dzZXIgcXVpcmtzIGJ5IHJlbmRlcmluZyBhdCB0aGUgZG9jdW1lbnQgcm9vdC4gWW91ICcgKyAnc2hvdWxkIGxvb2sgZm9yIGVudmlyb25tZW50IGRlcGVuZGVudCBjb2RlIGluIHlvdXIgY29tcG9uZW50cyAnICsgJ2FuZCBlbnN1cmUgdGhlIHByb3BzIGFyZSB0aGUgc2FtZSBjbGllbnQgYW5kIHNlcnZlciBzaWRlOlxcbiVzJywgZGlmZmVyZW5jZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdCBhdHRlbXB0ZWQgdG8gcmV1c2UgbWFya3VwIGluIGEgY29udGFpbmVyIGJ1dCB0aGUgJyArICdjaGVja3N1bSB3YXMgaW52YWxpZC4gVGhpcyBnZW5lcmFsbHkgbWVhbnMgdGhhdCB5b3UgYXJlICcgKyAndXNpbmcgc2VydmVyIHJlbmRlcmluZyBhbmQgdGhlIG1hcmt1cCBnZW5lcmF0ZWQgb24gdGhlICcgKyAnc2VydmVyIHdhcyBub3Qgd2hhdCB0aGUgY2xpZW50IHdhcyBleHBlY3RpbmcuIFJlYWN0IGluamVjdGVkICcgKyAnbmV3IG1hcmt1cCB0byBjb21wZW5zYXRlIHdoaWNoIHdvcmtzIGJ1dCB5b3UgaGF2ZSBsb3N0IG1hbnkgJyArICdvZiB0aGUgYmVuZWZpdHMgb2Ygc2VydmVyIHJlbmRlcmluZy4gSW5zdGVhZCwgZmlndXJlIG91dCAnICsgJ3doeSB0aGUgbWFya3VwIGJlaW5nIGdlbmVyYXRlZCBpcyBkaWZmZXJlbnQgb24gdGhlIGNsaWVudCAnICsgJ29yIHNlcnZlcjpcXG4lcycsIGRpZmZlcmVuY2UpIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgIShjb250YWluZXIubm9kZVR5cGUgIT09IERPQ19OT0RFX1RZUEUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1lvdVxcJ3JlIHRyeWluZyB0byByZW5kZXIgYSBjb21wb25lbnQgdG8gdGhlIGRvY3VtZW50IGJ1dCAnICsgJ3lvdSBkaWRuXFwndCB1c2Ugc2VydmVyIHJlbmRlcmluZy4gV2UgY2FuXFwndCBkbyB0aGlzICcgKyAnd2l0aG91dCB1c2luZyBzZXJ2ZXIgcmVuZGVyaW5nIGR1ZSB0byBjcm9zcy1icm93c2VyIHF1aXJrcy4gJyArICdTZWUgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcoKSBmb3Igc2VydmVyIHJlbmRlcmluZy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xuICAgICAgd2hpbGUgKGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5sYXN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKG1hcmt1cCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldElubmVySFRNTChjb250YWluZXIsIG1hcmt1cCk7XG4gICAgfVxuICB9LFxuXG4gIG93bmVyRG9jdW1lbnRDb250ZXh0S2V5OiBvd25lckRvY3VtZW50Q29udGV4dEtleSxcblxuICAvKipcbiAgICogUmVhY3QgSUQgdXRpbGl0aWVzLlxuICAgKi9cblxuICBnZXRSZWFjdFJvb3RJRDogZ2V0UmVhY3RSb290SUQsXG5cbiAgZ2V0SUQ6IGdldElELFxuXG4gIHNldElEOiBzZXRJRCxcblxuICBnZXROb2RlOiBnZXROb2RlLFxuXG4gIGdldE5vZGVGcm9tSW5zdGFuY2U6IGdldE5vZGVGcm9tSW5zdGFuY2UsXG5cbiAgaXNWYWxpZDogaXNWYWxpZCxcblxuICBwdXJnZUlEOiBwdXJnZUlEXG59O1xuXG5SZWFjdFBlcmYubWVhc3VyZU1ldGhvZHMoUmVhY3RNb3VudCwgJ1JlYWN0TW91bnQnLCB7XG4gIF9yZW5kZXJOZXdSb290Q29tcG9uZW50OiAnX3JlbmRlck5ld1Jvb3RDb21wb25lbnQnLFxuICBfbW91bnRJbWFnZUludG9Ob2RlOiAnX21vdW50SW1hZ2VJbnRvTm9kZSdcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TW91bnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdE1vdW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlclxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblJlZ2lzdHJ5Jyk7XG52YXIgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiA9IHJlcXVpcmUoJy4vUmVhY3RFdmVudEVtaXR0ZXJNaXhpbicpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG52YXIgVmlld3BvcnRNZXRyaWNzID0gcmVxdWlyZSgnLi9WaWV3cG9ydE1ldHJpY3MnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRTdXBwb3J0ZWQnKTtcblxuLyoqXG4gKiBTdW1tYXJ5IG9mIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGV2ZW50IGhhbmRsaW5nOlxuICpcbiAqICAtIFRvcC1sZXZlbCBkZWxlZ2F0aW9uIGlzIHVzZWQgdG8gdHJhcCBtb3N0IG5hdGl2ZSBicm93c2VyIGV2ZW50cy4gVGhpc1xuICogICAgbWF5IG9ubHkgb2NjdXIgaW4gdGhlIG1haW4gdGhyZWFkIGFuZCBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2ZcbiAqICAgIFJlYWN0RXZlbnRMaXN0ZW5lciwgd2hpY2ggaXMgaW5qZWN0ZWQgYW5kIGNhbiB0aGVyZWZvcmUgc3VwcG9ydCBwbHVnZ2FibGVcbiAqICAgIGV2ZW50IHNvdXJjZXMuIFRoaXMgaXMgdGhlIG9ubHkgd29yayB0aGF0IG9jY3VycyBpbiB0aGUgbWFpbiB0aHJlYWQuXG4gKlxuICogIC0gV2Ugbm9ybWFsaXplIGFuZCBkZS1kdXBsaWNhdGUgZXZlbnRzIHRvIGFjY291bnQgZm9yIGJyb3dzZXIgcXVpcmtzLiBUaGlzXG4gKiAgICBtYXkgYmUgZG9uZSBpbiB0aGUgd29ya2VyIHRocmVhZC5cbiAqXG4gKiAgLSBGb3J3YXJkIHRoZXNlIG5hdGl2ZSBldmVudHMgKHdpdGggdGhlIGFzc29jaWF0ZWQgdG9wLWxldmVsIHR5cGUgdXNlZCB0b1xuICogICAgdHJhcCBpdCkgdG8gYEV2ZW50UGx1Z2luSHViYCwgd2hpY2ggaW4gdHVybiB3aWxsIGFzayBwbHVnaW5zIGlmIHRoZXkgd2FudFxuICogICAgdG8gZXh0cmFjdCBhbnkgc3ludGhldGljIGV2ZW50cy5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB3aWxsIHRoZW4gcHJvY2VzcyBlYWNoIGV2ZW50IGJ5IGFubm90YXRpbmcgdGhlbSB3aXRoXG4gKiAgICBcImRpc3BhdGNoZXNcIiwgYSBzZXF1ZW5jZSBvZiBsaXN0ZW5lcnMgYW5kIElEcyB0aGF0IGNhcmUgYWJvdXQgdGhhdCBldmVudC5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB0aGVuIGRpc3BhdGNoZXMgdGhlIGV2ZW50cy5cbiAqXG4gKiBPdmVydmlldyBvZiBSZWFjdCBhbmQgdGhlIGV2ZW50IHN5c3RlbTpcbiAqXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8ICAgIERPTSAgICAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiAgICAgICB8ICAgICAgICAgICAuXG4gKiAgICAgICB2ICAgICAgICAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuXG4gKiB8ICBMaXN0ZW5lciAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICArLS0tLS0tLS0rfFNpbXBsZUV2ZW50fFxuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgIHwgICAgICAgICB8UGx1Z2luICAgICB8XG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgdiAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fEV2ZW50UGx1Z2luSHVifCAgICAgICAgICAgICAgICAgICAgfCAgICBFdmVudCAgIHxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCBQcm9wYWdhdG9yc3xcbiAqIHwgUmVhY3RFdmVudCB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgfFRhcEV2ZW50ICAgfCAgfC0tLS0tLS0tLS0tLXxcbiAqIHwgIEVtaXR0ZXIgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfDwtLS0rfFBsdWdpbiAgICAgfCAgfG90aGVyIHBsdWdpbnxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCAgdXRpbGl0aWVzIHxcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tK1xuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICBeICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgIHwgICAgICAgIHxFbnRlci9MZWF2ZXxcbiAqICAgICAgICsgICAgICAgICAgIC4gICAgICAgICAgICAgICAgKy0tLS0tLS0rfFBsdWdpbiAgICAgfFxuICogKy0tLS0tLS0tLS0tLS0rICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8IGFwcGxpY2F0aW9uIHwgICAuXG4gKiB8LS0tLS0tLS0tLS0tLXwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiArLS0tLS0tLS0tLS0tLSsgICAuXG4gKiAgICAgICAgICAgICAgICAgICAuXG4gKiAgICBSZWFjdCBDb3JlICAgICAuICBHZW5lcmFsIFB1cnBvc2UgRXZlbnQgUGx1Z2luIFN5c3RlbVxuICovXG5cbnZhciBhbHJlYWR5TGlzdGVuaW5nVG8gPSB7fTtcbnZhciBpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSA9IGZhbHNlO1xudmFyIHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciA9IDA7XG5cbi8vIEZvciBldmVudHMgbGlrZSAnc3VibWl0JyB3aGljaCBkb24ndCBjb25zaXN0ZW50bHkgYnViYmxlICh3aGljaCB3ZSB0cmFwIGF0IGFcbi8vIGxvd2VyIG5vZGUgdGhhbiBgZG9jdW1lbnRgKSwgYmluZGluZyBhdCBgZG9jdW1lbnRgIHdvdWxkIGNhdXNlIGR1cGxpY2F0ZVxuLy8gZXZlbnRzIHNvIHdlIGRvbid0IGluY2x1ZGUgdGhlbSBoZXJlXG52YXIgdG9wRXZlbnRNYXBwaW5nID0ge1xuICB0b3BBYm9ydDogJ2Fib3J0JyxcbiAgdG9wQmx1cjogJ2JsdXInLFxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxuICB0b3BDaGFuZ2U6ICdjaGFuZ2UnLFxuICB0b3BDbGljazogJ2NsaWNrJyxcbiAgdG9wQ29tcG9zaXRpb25FbmQ6ICdjb21wb3NpdGlvbmVuZCcsXG4gIHRvcENvbXBvc2l0aW9uU3RhcnQ6ICdjb21wb3NpdGlvbnN0YXJ0JyxcbiAgdG9wQ29tcG9zaXRpb25VcGRhdGU6ICdjb21wb3NpdGlvbnVwZGF0ZScsXG4gIHRvcENvbnRleHRNZW51OiAnY29udGV4dG1lbnUnLFxuICB0b3BDb3B5OiAnY29weScsXG4gIHRvcEN1dDogJ2N1dCcsXG4gIHRvcERvdWJsZUNsaWNrOiAnZGJsY2xpY2snLFxuICB0b3BEcmFnOiAnZHJhZycsXG4gIHRvcERyYWdFbmQ6ICdkcmFnZW5kJyxcbiAgdG9wRHJhZ0VudGVyOiAnZHJhZ2VudGVyJyxcbiAgdG9wRHJhZ0V4aXQ6ICdkcmFnZXhpdCcsXG4gIHRvcERyYWdMZWF2ZTogJ2RyYWdsZWF2ZScsXG4gIHRvcERyYWdPdmVyOiAnZHJhZ292ZXInLFxuICB0b3BEcmFnU3RhcnQ6ICdkcmFnc3RhcnQnLFxuICB0b3BEcm9wOiAnZHJvcCcsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiAnZHVyYXRpb25jaGFuZ2UnLFxuICB0b3BFbXB0aWVkOiAnZW1wdGllZCcsXG4gIHRvcEVuY3J5cHRlZDogJ2VuY3J5cHRlZCcsXG4gIHRvcEVuZGVkOiAnZW5kZWQnLFxuICB0b3BFcnJvcjogJ2Vycm9yJyxcbiAgdG9wRm9jdXM6ICdmb2N1cycsXG4gIHRvcElucHV0OiAnaW5wdXQnLFxuICB0b3BLZXlEb3duOiAna2V5ZG93bicsXG4gIHRvcEtleVByZXNzOiAna2V5cHJlc3MnLFxuICB0b3BLZXlVcDogJ2tleXVwJyxcbiAgdG9wTG9hZGVkRGF0YTogJ2xvYWRlZGRhdGEnLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogJ2xvYWRlZG1ldGFkYXRhJyxcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcbiAgdG9wTW91c2VEb3duOiAnbW91c2Vkb3duJyxcbiAgdG9wTW91c2VNb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgdG9wTW91c2VPdXQ6ICdtb3VzZW91dCcsXG4gIHRvcE1vdXNlT3ZlcjogJ21vdXNlb3ZlcicsXG4gIHRvcE1vdXNlVXA6ICdtb3VzZXVwJyxcbiAgdG9wUGFzdGU6ICdwYXN0ZScsXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxuICB0b3BQbGF5OiAncGxheScsXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcbiAgdG9wU2Nyb2xsOiAnc2Nyb2xsJyxcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcbiAgdG9wU2Vla2luZzogJ3NlZWtpbmcnLFxuICB0b3BTZWxlY3Rpb25DaGFuZ2U6ICdzZWxlY3Rpb25jaGFuZ2UnLFxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcbiAgdG9wVGV4dElucHV0OiAndGV4dElucHV0JyxcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxuICB0b3BUb3VjaENhbmNlbDogJ3RvdWNoY2FuY2VsJyxcbiAgdG9wVG91Y2hFbmQ6ICd0b3VjaGVuZCcsXG4gIHRvcFRvdWNoTW92ZTogJ3RvdWNobW92ZScsXG4gIHRvcFRvdWNoU3RhcnQ6ICd0b3VjaHN0YXJ0JyxcbiAgdG9wVm9sdW1lQ2hhbmdlOiAndm9sdW1lY2hhbmdlJyxcbiAgdG9wV2FpdGluZzogJ3dhaXRpbmcnLFxuICB0b3BXaGVlbDogJ3doZWVsJ1xufTtcblxuLyoqXG4gKiBUbyBlbnN1cmUgbm8gY29uZmxpY3RzIHdpdGggb3RoZXIgcG90ZW50aWFsIFJlYWN0IGluc3RhbmNlcyBvbiB0aGUgcGFnZVxuICovXG52YXIgdG9wTGlzdGVuZXJzSURLZXkgPSAnX3JlYWN0TGlzdGVuZXJzSUQnICsgU3RyaW5nKE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpO1xuXG5mdW5jdGlvbiBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KSB7XG4gIC8vIEluIElFOCwgYG1vdW50QXRgIGlzIGEgaG9zdCBvYmplY3QgYW5kIGRvZXNuJ3QgaGF2ZSBgaGFzT3duUHJvcGVydHlgXG4gIC8vIGRpcmVjdGx5LlxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3VudEF0LCB0b3BMaXN0ZW5lcnNJREtleSkpIHtcbiAgICBtb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XSA9IHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlcisrO1xuICAgIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV0gPSB7fTtcbiAgfVxuICByZXR1cm4gYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXTtcbn1cblxuLyoqXG4gKiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBpcyB1c2VkIHRvIGF0dGFjaCB0b3AtbGV2ZWwgZXZlbnQgbGlzdGVuZXJzLiBGb3JcbiAqIGV4YW1wbGU6XG4gKlxuICogICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIucHV0TGlzdGVuZXIoJ215SUQnLCAnb25DbGljaycsIG15RnVuY3Rpb24pO1xuICpcbiAqIFRoaXMgd291bGQgYWxsb2NhdGUgYSBcInJlZ2lzdHJhdGlvblwiIG9mIGAoJ29uQ2xpY2snLCBteUZ1bmN0aW9uKWAgb24gJ215SUQnLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gYXNzaWduKHt9LCBSZWFjdEV2ZW50RW1pdHRlck1peGluLCB7XG5cbiAgLyoqXG4gICAqIEluamVjdGFibGUgZXZlbnQgYmFja2VuZFxuICAgKi9cbiAgUmVhY3RFdmVudExpc3RlbmVyOiBudWxsLFxuXG4gIGluamVjdGlvbjoge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBSZWFjdEV2ZW50TGlzdGVuZXJcbiAgICAgKi9cbiAgICBpbmplY3RSZWFjdEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIChSZWFjdEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5zZXRIYW5kbGVUb3BMZXZlbChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaGFuZGxlVG9wTGV2ZWwpO1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lciA9IFJlYWN0RXZlbnRMaXN0ZW5lcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciBvciBub3QgYW55IGNyZWF0ZWQgY2FsbGJhY2tzIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgVHJ1ZSBpZiBjYWxsYmFja3Mgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXRFbmFibGVkOiBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgIGlmIChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyKSB7XG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnNldEVuYWJsZWQoZW5hYmxlZCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGNhbGxiYWNrcyBhcmUgZW5hYmxlZC5cbiAgICovXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIShSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyICYmIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuaXNFbmFibGVkKCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSBsaXN0ZW4gZm9yIGJ1YmJsZWQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gICAqXG4gICAqIEZpcmVmb3ggdjguMDEgKGFuZCBwb3NzaWJseSBvdGhlcnMpIGV4aGliaXRlZCBzdHJhbmdlIGJlaGF2aW9yIHdoZW5cbiAgICogbW91bnRpbmcgYG9ubW91c2Vtb3ZlYCBldmVudHMgYXQgc29tZSBub2RlIHRoYXQgd2FzIG5vdCB0aGUgZG9jdW1lbnRcbiAgICogZWxlbWVudC4gVGhlIHN5bXB0b21zIHdlcmUgdGhhdCBpZiB5b3VyIG1vdXNlIGlzIG5vdCBtb3Zpbmcgb3ZlciBzb21ldGhpbmdcbiAgICogY29udGFpbmVkIHdpdGhpbiB0aGF0IG1vdW50IHBvaW50IChmb3IgZXhhbXBsZSBvbiB0aGUgYmFja2dyb3VuZCkgdGhlXG4gICAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgZm9yIGBvbm1vdXNlbW92ZWAgd29uJ3QgYmUgY2FsbGVkLiBIb3dldmVyLCBpZiB5b3VcbiAgICogcmVnaXN0ZXIgdGhlIGBtb3VzZW1vdmVgIG9uIHRoZSBkb2N1bWVudCBvYmplY3QsIHRoZW4gaXQgd2lsbCBvZiBjb3Vyc2VcbiAgICogY2F0Y2ggYWxsIGBtb3VzZW1vdmVgcy4gVGhpcyBhbG9uZyB3aXRoIGlPUyBxdWlya3MsIGp1c3RpZmllcyByZXN0cmljdGluZ1xuICAgKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIHRvIHRoZSBkb2N1bWVudCBvYmplY3Qgb25seSwgYXQgbGVhc3QgZm9yIHRoZXNlXG4gICAqIG1vdmVtZW50IHR5cGVzIG9mIGV2ZW50cyBhbmQgcG9zc2libHkgYWxsIGV2ZW50cy5cbiAgICpcbiAgICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICAgKlxuICAgKiBBbHNvLCBga2V5dXBgL2BrZXlwcmVzc2AvYGtleWRvd25gIGRvIG5vdCBidWJibGUgdG8gdGhlIHdpbmRvdyBvbiBJRSwgYnV0XG4gICAqIHRoZXkgYnViYmxlIHRvIGRvY3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZW50RG9jdW1lbnRIYW5kbGUgRG9jdW1lbnQgd2hpY2ggb3ducyB0aGUgY29udGFpbmVyXG4gICAqL1xuICBsaXN0ZW5UbzogZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbk5hbWUsIGNvbnRlbnREb2N1bWVudEhhbmRsZSkge1xuICAgIHZhciBtb3VudEF0ID0gY29udGVudERvY3VtZW50SGFuZGxlO1xuICAgIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICAgIHZhciBkZXBlbmRlbmNpZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG5cbiAgICB2YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldO1xuICAgICAgaWYgKCEoaXNMaXN0ZW5pbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkgJiYgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0pKSB7XG4gICAgICAgIGlmIChkZXBlbmRlbmN5ID09PSB0b3BMZXZlbFR5cGVzLnRvcFdoZWVsKSB7XG4gICAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ3doZWVsJykpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFdoZWVsLCAnd2hlZWwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ21vdXNld2hlZWwnKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wV2hlZWwsICdtb3VzZXdoZWVsJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggbmVlZHMgdG8gY2FwdHVyZSBhIGRpZmZlcmVudCBtb3VzZSBzY3JvbGwgZXZlbnQuXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvZG9tL2V2ZW50cy90ZXN0cy9zY3JvbGwuaHRtbFxuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wV2hlZWwsICdET01Nb3VzZVNjcm9sbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSB0b3BMZXZlbFR5cGVzLnRvcFNjcm9sbCkge1xuXG4gICAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ3Njcm9sbCcsIHRydWUpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wU2Nyb2xsLCAnc2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFNjcm9sbCwgJ3Njcm9sbCcsIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuV0lORE9XX0hBTkRMRSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09IHRvcExldmVsVHlwZXMudG9wRm9jdXMgfHwgZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BCbHVyKSB7XG5cbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnZm9jdXMnLCB0cnVlKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLCAnZm9jdXMnLCBtb3VudEF0KTtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BCbHVyLCAnYmx1cicsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNFdmVudFN1cHBvcnRlZCgnZm9jdXNpbicpKSB7XG4gICAgICAgICAgICAvLyBJRSBoYXMgYGZvY3VzaW5gIGFuZCBgZm9jdXNvdXRgIGV2ZW50cyB3aGljaCBidWJibGUuXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDA4LzA0L2RlbGVnYXRpbmdfdGhlLmh0bWxcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLCAnZm9jdXNpbicsIG1vdW50QXQpO1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wQmx1ciwgJ2ZvY3Vzb3V0JywgbW91bnRBdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdG8gbWFrZSBzdXJlIGJsdXIgYW5kIGZvY3VzIGV2ZW50IGxpc3RlbmVycyBhcmUgb25seSBhdHRhY2hlZCBvbmNlXG4gICAgICAgICAgaXNMaXN0ZW5pbmdbdG9wTGV2ZWxUeXBlcy50b3BCbHVyXSA9IHRydWU7XG4gICAgICAgICAgaXNMaXN0ZW5pbmdbdG9wTGV2ZWxUeXBlcy50b3BGb2N1c10gPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRvcEV2ZW50TWFwcGluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSkge1xuICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudChkZXBlbmRlbmN5LCB0b3BFdmVudE1hcHBpbmdbZGVwZW5kZW5jeV0sIG1vdW50QXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB0cmFwQnViYmxlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHJldHVybiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSk7XG4gIH0sXG5cbiAgdHJhcENhcHR1cmVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgcmV0dXJuIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIExpc3RlbnMgdG8gd2luZG93IHNjcm9sbCBhbmQgcmVzaXplIGV2ZW50cy4gV2UgY2FjaGUgc2Nyb2xsIHZhbHVlcyBzbyB0aGF0XG4gICAqIGFwcGxpY2F0aW9uIGNvZGUgY2FuIGFjY2VzcyB0aGVtIHdpdGhvdXQgdHJpZ2dlcmluZyByZWZsb3dzLlxuICAgKlxuICAgKiBOT1RFOiBTY3JvbGwgZXZlbnRzIGRvIG5vdCBidWJibGUuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Njcm9sbC5odG1sXG4gICAqL1xuICBlbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3Jpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlKSB7XG4gICAgICB2YXIgcmVmcmVzaCA9IFZpZXdwb3J0TWV0cmljcy5yZWZyZXNoU2Nyb2xsVmFsdWVzO1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5tb25pdG9yU2Nyb2xsVmFsdWUocmVmcmVzaCk7XG4gICAgICBpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczogRXZlbnRQbHVnaW5IdWIuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLFxuXG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzOiBFdmVudFBsdWdpbkh1Yi5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcyxcblxuICBwdXRMaXN0ZW5lcjogRXZlbnRQbHVnaW5IdWIucHV0TGlzdGVuZXIsXG5cbiAgZ2V0TGlzdGVuZXI6IEV2ZW50UGx1Z2luSHViLmdldExpc3RlbmVyLFxuXG4gIGRlbGV0ZUxpc3RlbmVyOiBFdmVudFBsdWdpbkh1Yi5kZWxldGVMaXN0ZW5lcixcblxuICBkZWxldGVBbGxMaXN0ZW5lcnM6IEV2ZW50UGx1Z2luSHViLmRlbGV0ZUFsbExpc3RlbmVyc1xuXG59KTtcblxuUmVhY3RQZXJmLm1lYXN1cmVNZXRob2RzKFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciwgJ1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicsIHtcbiAgcHV0TGlzdGVuZXI6ICdwdXRMaXN0ZW5lcicsXG4gIGRlbGV0ZUxpc3RlbmVyOiAnZGVsZXRlTGlzdGVuZXInXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRDb25zdGFudHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrZXlNaXJyb3IgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlNaXJyb3InKTtcblxudmFyIFByb3BhZ2F0aW9uUGhhc2VzID0ga2V5TWlycm9yKHsgYnViYmxlZDogbnVsbCwgY2FwdHVyZWQ6IG51bGwgfSk7XG5cbi8qKlxuICogVHlwZXMgb2YgcmF3IHNpZ25hbHMgZnJvbSB0aGUgYnJvd3NlciBjYXVnaHQgYXQgdGhlIHRvcCBsZXZlbC5cbiAqL1xudmFyIHRvcExldmVsVHlwZXMgPSBrZXlNaXJyb3Ioe1xuICB0b3BBYm9ydDogbnVsbCxcbiAgdG9wQmx1cjogbnVsbCxcbiAgdG9wQ2FuUGxheTogbnVsbCxcbiAgdG9wQ2FuUGxheVRocm91Z2g6IG51bGwsXG4gIHRvcENoYW5nZTogbnVsbCxcbiAgdG9wQ2xpY2s6IG51bGwsXG4gIHRvcENvbXBvc2l0aW9uRW5kOiBudWxsLFxuICB0b3BDb21wb3NpdGlvblN0YXJ0OiBudWxsLFxuICB0b3BDb21wb3NpdGlvblVwZGF0ZTogbnVsbCxcbiAgdG9wQ29udGV4dE1lbnU6IG51bGwsXG4gIHRvcENvcHk6IG51bGwsXG4gIHRvcEN1dDogbnVsbCxcbiAgdG9wRG91YmxlQ2xpY2s6IG51bGwsXG4gIHRvcERyYWc6IG51bGwsXG4gIHRvcERyYWdFbmQ6IG51bGwsXG4gIHRvcERyYWdFbnRlcjogbnVsbCxcbiAgdG9wRHJhZ0V4aXQ6IG51bGwsXG4gIHRvcERyYWdMZWF2ZTogbnVsbCxcbiAgdG9wRHJhZ092ZXI6IG51bGwsXG4gIHRvcERyYWdTdGFydDogbnVsbCxcbiAgdG9wRHJvcDogbnVsbCxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6IG51bGwsXG4gIHRvcEVtcHRpZWQ6IG51bGwsXG4gIHRvcEVuY3J5cHRlZDogbnVsbCxcbiAgdG9wRW5kZWQ6IG51bGwsXG4gIHRvcEVycm9yOiBudWxsLFxuICB0b3BGb2N1czogbnVsbCxcbiAgdG9wSW5wdXQ6IG51bGwsXG4gIHRvcEtleURvd246IG51bGwsXG4gIHRvcEtleVByZXNzOiBudWxsLFxuICB0b3BLZXlVcDogbnVsbCxcbiAgdG9wTG9hZDogbnVsbCxcbiAgdG9wTG9hZGVkRGF0YTogbnVsbCxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6IG51bGwsXG4gIHRvcExvYWRTdGFydDogbnVsbCxcbiAgdG9wTW91c2VEb3duOiBudWxsLFxuICB0b3BNb3VzZU1vdmU6IG51bGwsXG4gIHRvcE1vdXNlT3V0OiBudWxsLFxuICB0b3BNb3VzZU92ZXI6IG51bGwsXG4gIHRvcE1vdXNlVXA6IG51bGwsXG4gIHRvcFBhc3RlOiBudWxsLFxuICB0b3BQYXVzZTogbnVsbCxcbiAgdG9wUGxheTogbnVsbCxcbiAgdG9wUGxheWluZzogbnVsbCxcbiAgdG9wUHJvZ3Jlc3M6IG51bGwsXG4gIHRvcFJhdGVDaGFuZ2U6IG51bGwsXG4gIHRvcFJlc2V0OiBudWxsLFxuICB0b3BTY3JvbGw6IG51bGwsXG4gIHRvcFNlZWtlZDogbnVsbCxcbiAgdG9wU2Vla2luZzogbnVsbCxcbiAgdG9wU2VsZWN0aW9uQ2hhbmdlOiBudWxsLFxuICB0b3BTdGFsbGVkOiBudWxsLFxuICB0b3BTdWJtaXQ6IG51bGwsXG4gIHRvcFN1c3BlbmQ6IG51bGwsXG4gIHRvcFRleHRJbnB1dDogbnVsbCxcbiAgdG9wVGltZVVwZGF0ZTogbnVsbCxcbiAgdG9wVG91Y2hDYW5jZWw6IG51bGwsXG4gIHRvcFRvdWNoRW5kOiBudWxsLFxuICB0b3BUb3VjaE1vdmU6IG51bGwsXG4gIHRvcFRvdWNoU3RhcnQ6IG51bGwsXG4gIHRvcFZvbHVtZUNoYW5nZTogbnVsbCxcbiAgdG9wV2FpdGluZzogbnVsbCxcbiAgdG9wV2hlZWw6IG51bGxcbn0pO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSB7XG4gIHRvcExldmVsVHlwZXM6IHRvcExldmVsVHlwZXMsXG4gIFByb3BhZ2F0aW9uUGhhc2VzOiBQcm9wYWdhdGlvblBoYXNlc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudENvbnN0YW50cztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0V2ZW50Q29uc3RhbnRzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UGx1Z2luSHViXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luVXRpbHMnKTtcbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKCcuL1JlYWN0RXJyb3JVdGlscycpO1xuXG52YXIgYWNjdW11bGF0ZUludG8gPSByZXF1aXJlKCcuL2FjY3VtdWxhdGVJbnRvJyk7XG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkID0gcmVxdWlyZSgnLi9mb3JFYWNoQWNjdW11bGF0ZWQnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIEludGVybmFsIHN0b3JlIGZvciBldmVudCBsaXN0ZW5lcnNcbiAqL1xudmFyIGxpc3RlbmVyQmFuayA9IHt9O1xuXG4vKipcbiAqIEludGVybmFsIHF1ZXVlIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWNjdW11bGF0ZWQgdGhlaXIgZGlzcGF0Y2hlcyBhbmQgYXJlXG4gKiB3YWl0aW5nIHRvIGhhdmUgdGhlaXIgZGlzcGF0Y2hlcyBleGVjdXRlZC5cbiAqL1xudmFyIGV2ZW50UXVldWUgPSBudWxsO1xuXG4vKipcbiAqIERpc3BhdGNoZXMgYW4gZXZlbnQgYW5kIHJlbGVhc2VzIGl0IGJhY2sgaW50byB0aGUgcG9vbCwgdW5sZXNzIHBlcnNpc3RlbnQuXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBldmVudCBTeW50aGV0aWMgZXZlbnQgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltdWxhdGVkIElmIHRoZSBldmVudCBpcyBzaW11bGF0ZWQgKGNoYW5nZXMgZXhuIGJlaGF2aW9yKVxuICogQHByaXZhdGVcbiAqL1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZSA9IGZ1bmN0aW9uIChldmVudCwgc2ltdWxhdGVkKSB7XG4gIGlmIChldmVudCkge1xuICAgIEV2ZW50UGx1Z2luVXRpbHMuZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpO1xuXG4gICAgaWYgKCFldmVudC5pc1BlcnNpc3RlbnQoKSkge1xuICAgICAgZXZlbnQuY29uc3RydWN0b3IucmVsZWFzZShldmVudCk7XG4gICAgfVxuICB9XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgdHJ1ZSk7XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIC0gYEluc3RhbmNlSGFuZGxlYDogW3JlcXVpcmVkXSBNb2R1bGUgdGhhdCBwZXJmb3JtcyBsb2dpY2FsIHRyYXZlcnNhbHMgb2YgRE9NXG4gKiAgIGhpZXJhcmNoeSBnaXZlbiBpZHMgb2YgdGhlIGxvZ2ljYWwgRE9NIGVsZW1lbnRzIGludm9sdmVkLlxuICovXG52YXIgSW5zdGFuY2VIYW5kbGUgPSBudWxsO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUluc3RhbmNlSGFuZGxlKCkge1xuICB2YXIgdmFsaWQgPSBJbnN0YW5jZUhhbmRsZSAmJiBJbnN0YW5jZUhhbmRsZS50cmF2ZXJzZVR3b1BoYXNlICYmIEluc3RhbmNlSGFuZGxlLnRyYXZlcnNlRW50ZXJMZWF2ZTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodmFsaWQsICdJbnN0YW5jZUhhbmRsZSBub3QgaW5qZWN0ZWQgYmVmb3JlIHVzZSEnKSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGEgdW5pZmllZCBpbnRlcmZhY2UgZm9yIGV2ZW50IHBsdWdpbnMgdG8gYmUgaW5zdGFsbGVkIGFuZCBjb25maWd1cmVkLlxuICpcbiAqIEV2ZW50IHBsdWdpbnMgY2FuIGltcGxlbWVudCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICBgZXh0cmFjdEV2ZW50c2Age2Z1bmN0aW9uKHN0cmluZywgRE9NRXZlbnRUYXJnZXQsIHN0cmluZywgb2JqZWN0KTogKn1cbiAqICAgICBSZXF1aXJlZC4gV2hlbiBhIHRvcC1sZXZlbCBldmVudCBpcyBmaXJlZCwgdGhpcyBtZXRob2QgaXMgZXhwZWN0ZWQgdG9cbiAqICAgICBleHRyYWN0IHN5bnRoZXRpYyBldmVudHMgdGhhdCB3aWxsIGluIHR1cm4gYmUgcXVldWVkIGFuZCBkaXNwYXRjaGVkLlxuICpcbiAqICAgYGV2ZW50VHlwZXNgIHtvYmplY3R9XG4gKiAgICAgT3B0aW9uYWwsIHBsdWdpbnMgdGhhdCBmaXJlIGV2ZW50cyBtdXN0IHB1Ymxpc2ggYSBtYXBwaW5nIG9mIHJlZ2lzdHJhdGlvblxuICogICAgIG5hbWVzIHRoYXQgYXJlIHVzZWQgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLiBWYWx1ZXMgb2YgdGhpcyBtYXBwaW5nIG11c3RcbiAqICAgICBiZSBvYmplY3RzIHRoYXQgY29udGFpbiBgcmVnaXN0cmF0aW9uTmFtZWAgb3IgYHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzYC5cbiAqXG4gKiAgIGBleGVjdXRlRGlzcGF0Y2hgIHtmdW5jdGlvbihvYmplY3QsIGZ1bmN0aW9uLCBzdHJpbmcpfVxuICogICAgIE9wdGlvbmFsLCBhbGxvd3MgcGx1Z2lucyB0byBvdmVycmlkZSBob3cgYW4gZXZlbnQgZ2V0cyBkaXNwYXRjaGVkLiBCeVxuICogICAgIGRlZmF1bHQsIHRoZSBsaXN0ZW5lciBpcyBzaW1wbHkgaW52b2tlZC5cbiAqXG4gKiBFYWNoIHBsdWdpbiB0aGF0IGlzIGluamVjdGVkIGludG8gYEV2ZW50c1BsdWdpbkh1YmAgaXMgaW1tZWRpYXRlbHkgb3BlcmFibGUuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgRXZlbnRQbHVnaW5IdWIgPSB7XG5cbiAgLyoqXG4gICAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gICAqL1xuICBpbmplY3Rpb246IHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBJbmplY3RlZE1vdW50XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluamVjdE1vdW50OiBFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RNb3VudCxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBJbmplY3RlZEluc3RhbmNlSGFuZGxlXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluamVjdEluc3RhbmNlSGFuZGxlOiBmdW5jdGlvbiAoSW5qZWN0ZWRJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgSW5zdGFuY2VIYW5kbGUgPSBJbmplY3RlZEluc3RhbmNlSGFuZGxlO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFsaWRhdGVJbnN0YW5jZUhhbmRsZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRJbnN0YW5jZUhhbmRsZTogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFsaWRhdGVJbnN0YW5jZUhhbmRsZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEluc3RhbmNlSGFuZGxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogRXZlbnRQbHVnaW5SZWdpc3RyeS5pbmplY3RFdmVudFBsdWdpbk9yZGVyLFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAgICovXG4gICAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZVxuXG4gIH0sXG5cbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyxcblxuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlczogRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcyxcblxuICAvKipcbiAgICogU3RvcmVzIGBsaXN0ZW5lcmAgYXQgYGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtpZF1gLiBJcyBpZGVtcG90ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIERPTSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgY2FsbGJhY2sgdG8gc3RvcmUuXG4gICAqL1xuICBwdXRMaXN0ZW5lcjogZnVuY3Rpb24gKGlkLCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgICEodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCAlcyBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCB0eXBlICVzJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV0gfHwgKGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXSA9IHt9KTtcbiAgICBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtpZF0gPSBsaXN0ZW5lcjtcblxuICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLmRpZFB1dExpc3RlbmVyKSB7XG4gICAgICBQbHVnaW5Nb2R1bGUuZGlkUHV0TGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufSBUaGUgc3RvcmVkIGNhbGxiYWNrLlxuICAgKi9cbiAgZ2V0TGlzdGVuZXI6IGZ1bmN0aW9uIChpZCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICByZXR1cm4gYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgJiYgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVbaWRdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgbGlzdGVuZXIgZnJvbSB0aGUgcmVnaXN0cmF0aW9uIGJhbmsuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICovXG4gIGRlbGV0ZUxpc3RlbmVyOiBmdW5jdGlvbiAoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIpIHtcbiAgICAgIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIH1cblxuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBuZXZlciBiZSBudWxsIC0tIHdoZW4gaXMgaXQ/XG4gICAgaWYgKGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgICBkZWxldGUgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVbaWRdO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhbGwgbGlzdGVuZXJzIGZvciB0aGUgRE9NIGVsZW1lbnQgd2l0aCB0aGUgc3VwcGxpZWQgSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqL1xuICBkZWxldGVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIChpZCkge1xuICAgIGZvciAodmFyIHJlZ2lzdHJhdGlvbk5hbWUgaW4gbGlzdGVuZXJCYW5rKSB7XG4gICAgICBpZiAoIWxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtpZF0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKSB7XG4gICAgICAgIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2lkXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFsbG93cyByZWdpc3RlcmVkIHBsdWdpbnMgYW4gb3Bwb3J0dW5pdHkgdG8gZXh0cmFjdCBldmVudHMgZnJvbSB0b3AtbGV2ZWxcbiAgICogbmF0aXZlIGJyb3dzZXIgZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGV2ZW50cztcbiAgICB2YXIgcGx1Z2lucyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2lucztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIE5vdCBldmVyeSBwbHVnaW4gaW4gdGhlIG9yZGVyaW5nIG1heSBiZSBsb2FkZWQgYXQgcnVudGltZS5cbiAgICAgIHZhciBwb3NzaWJsZVBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgICBpZiAocG9zc2libGVQbHVnaW4pIHtcbiAgICAgICAgdmFyIGV4dHJhY3RlZEV2ZW50cyA9IHBvc3NpYmxlUGx1Z2luLmV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgaWYgKGV4dHJhY3RlZEV2ZW50cykge1xuICAgICAgICAgIGV2ZW50cyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50cywgZXh0cmFjdGVkRXZlbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIHN5bnRoZXRpYyBldmVudCB0aGF0IHNob3VsZCBiZSBkaXNwYXRjaGVkIHdoZW5cbiAgICogYHByb2Nlc3NFdmVudFF1ZXVlYCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGV2ZW50cyBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRXZlbnRzOiBmdW5jdGlvbiAoZXZlbnRzKSB7XG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgZXZlbnRRdWV1ZSA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50UXVldWUsIGV2ZW50cyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGFsbCBzeW50aGV0aWMgZXZlbnRzIG9uIHRoZSBldmVudCBxdWV1ZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm9jZXNzRXZlbnRRdWV1ZTogZnVuY3Rpb24gKHNpbXVsYXRlZCkge1xuICAgIC8vIFNldCBgZXZlbnRRdWV1ZWAgdG8gbnVsbCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIG1vcmVcbiAgICAvLyBldmVudHMgZ2V0IGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcuXG4gICAgdmFyIHByb2Nlc3NpbmdFdmVudFF1ZXVlID0gZXZlbnRRdWV1ZTtcbiAgICBldmVudFF1ZXVlID0gbnVsbDtcbiAgICBpZiAoc2ltdWxhdGVkKSB7XG4gICAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwpO1xuICAgIH1cbiAgICAhIWV2ZW50UXVldWUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncHJvY2Vzc0V2ZW50UXVldWUoKTogQWRkaXRpb25hbCBldmVudHMgd2VyZSBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nICcgKyAnYW4gZXZlbnQgcXVldWUuIFN1cHBvcnQgZm9yIHRoaXMgaGFzIG5vdCB5ZXQgYmVlbiBpbXBsZW1lbnRlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG4gICAgUmVhY3RFcnJvclV0aWxzLnJldGhyb3dDYXVnaHRFcnJvcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGVzZSBhcmUgbmVlZGVkIGZvciB0ZXN0cyBvbmx5LiBEbyBub3QgdXNlIVxuICAgKi9cbiAgX19wdXJnZTogZnVuY3Rpb24gKCkge1xuICAgIGxpc3RlbmVyQmFuayA9IHt9O1xuICB9LFxuXG4gIF9fZ2V0TGlzdGVuZXJCYW5rOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQmFuaztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luSHViO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvRXZlbnRQbHVnaW5IdWIuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRQbHVnaW5SZWdpc3RyeVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG9yZGVyaW5nIG9mIGV2ZW50IHBsdWdpbnMuXG4gKi9cbnZhciBFdmVudFBsdWdpbk9yZGVyID0gbnVsbDtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG1hcHBpbmcgZnJvbSBuYW1lcyB0byBldmVudCBwbHVnaW4gbW9kdWxlcy5cbiAqL1xudmFyIG5hbWVzVG9QbHVnaW5zID0ge307XG5cbi8qKlxuICogUmVjb21wdXRlcyB0aGUgcGx1Z2luIGxpc3QgdXNpbmcgdGhlIGluamVjdGVkIHBsdWdpbnMgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpIHtcbiAgaWYgKCFFdmVudFBsdWdpbk9yZGVyKSB7XG4gICAgLy8gV2FpdCB1bnRpbCBhbiBgRXZlbnRQbHVnaW5PcmRlcmAgaXMgaW5qZWN0ZWQuXG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gbmFtZXNUb1BsdWdpbnMpIHtcbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgdmFyIHBsdWdpbkluZGV4ID0gRXZlbnRQbHVnaW5PcmRlci5pbmRleE9mKHBsdWdpbk5hbWUpO1xuICAgICEocGx1Z2luSW5kZXggPiAtMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW5zIHRoYXQgZG8gbm90IGV4aXN0IGluICcgKyAndGhlIHBsdWdpbiBvcmRlcmluZywgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2luc1twbHVnaW5JbmRleF0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAhUGx1Z2luTW9kdWxlLmV4dHJhY3RFdmVudHMgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRXZlbnQgcGx1Z2lucyBtdXN0IGltcGxlbWVudCBhbiBgZXh0cmFjdEV2ZW50c2AgJyArICdtZXRob2QsIGJ1dCBgJXNgIGRvZXMgbm90LicsIHBsdWdpbk5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnNbcGx1Z2luSW5kZXhdID0gUGx1Z2luTW9kdWxlO1xuICAgIHZhciBwdWJsaXNoZWRFdmVudHMgPSBQbHVnaW5Nb2R1bGUuZXZlbnRUeXBlcztcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gcHVibGlzaGVkRXZlbnRzKSB7XG4gICAgICAhcHVibGlzaEV2ZW50Rm9yUGx1Z2luKHB1Ymxpc2hlZEV2ZW50c1tldmVudE5hbWVdLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRmFpbGVkIHRvIHB1Ymxpc2ggZXZlbnQgYCVzYCBmb3IgcGx1Z2luIGAlc2AuJywgZXZlbnROYW1lLCBwbHVnaW5OYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGFuIGV2ZW50IHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYnkgdGhlIHN1cHBsaWVkIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgRGlzcGF0Y2ggY29uZmlndXJhdGlvbiBmb3IgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hFdmVudEZvclBsdWdpbihkaXNwYXRjaENvbmZpZywgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSAnICsgJ2V2ZW50IG5hbWUsIGAlc2AuJywgZXZlbnROYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIEV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV0gPSBkaXNwYXRjaENvbmZpZztcblxuICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgPSBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztcbiAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgZm9yICh2YXIgcGhhc2VOYW1lIGluIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2VOYW1lKSkge1xuICAgICAgICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZSA9IHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3BoYXNlTmFtZV07XG4gICAgICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUsIFBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUsIFBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGEgcmVnaXN0cmF0aW9uIG5hbWUgdGhhdCBpcyB1c2VkIHRvIGlkZW50aWZ5IGRpc3BhdGNoZWQgZXZlbnRzIGFuZFxuICogY2FuIGJlIHVzZWQgd2l0aCBgRXZlbnRQbHVnaW5IdWIucHV0TGlzdGVuZXJgIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBSZWdpc3RyYXRpb24gbmFtZSB0byBhZGQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHJlZ2lzdHJhdGlvbk5hbWUsIFBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgJyArICdyZWdpc3RyYXRpb24gbmFtZSwgYCVzYC4nLCByZWdpc3RyYXRpb25OYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBQbHVnaW5Nb2R1bGU7XG4gIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXSA9IFBsdWdpbk1vZHVsZS5ldmVudFR5cGVzW2V2ZW50TmFtZV0uZGVwZW5kZW5jaWVzO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBwbHVnaW5zIHNvIHRoYXQgdGhleSBjYW4gZXh0cmFjdCBhbmQgZGlzcGF0Y2ggZXZlbnRzLlxuICpcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHVifVxuICovXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHtcblxuICAvKipcbiAgICogT3JkZXJlZCBsaXN0IG9mIGluamVjdGVkIHBsdWdpbnMuXG4gICAqL1xuICBwbHVnaW5zOiBbXSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGV2ZW50IG5hbWUgdG8gZGlzcGF0Y2ggY29uZmlnXG4gICAqL1xuICBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gcGx1Z2luIG1vZHVsZVxuICAgKi9cbiAgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gZXZlbnQgbmFtZVxuICAgKi9cbiAgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llczoge30sXG5cbiAgLyoqXG4gICAqIEluamVjdHMgYW4gb3JkZXJpbmcgb2YgcGx1Z2lucyAoYnkgcGx1Z2luIG5hbWUpLiBUaGlzIGFsbG93cyB0aGUgb3JkZXJpbmdcbiAgICogdG8gYmUgZGVjb3VwbGVkIGZyb20gaW5qZWN0aW9uIG9mIHRoZSBhY3R1YWwgcGx1Z2lucyBzbyB0aGF0IG9yZGVyaW5nIGlzXG4gICAqIGFsd2F5cyBkZXRlcm1pbmlzdGljIHJlZ2FyZGxlc3Mgb2YgcGFja2FnaW5nLCBvbi10aGUtZmx5IGluamVjdGlvbiwgZXRjLlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICogQGludGVybmFsXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbk9yZGVyfVxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogZnVuY3Rpb24gKEluamVjdGVkRXZlbnRQbHVnaW5PcmRlcikge1xuICAgICEhRXZlbnRQbHVnaW5PcmRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbiBvcmRlcmluZyBtb3JlIHRoYW4gJyArICdvbmNlLiBZb3UgYXJlIGxpa2VseSB0cnlpbmcgdG8gbG9hZCBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIC8vIENsb25lIHRoZSBvcmRlcmluZyBzbyBpdCBjYW5ub3QgYmUgZHluYW1pY2FsbHkgbXV0YXRlZC5cbiAgICBFdmVudFBsdWdpbk9yZGVyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKTtcbiAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbmplY3RzIHBsdWdpbnMgdG8gYmUgdXNlZCBieSBgRXZlbnRQbHVnaW5IdWJgLiBUaGUgcGx1Z2luIG5hbWVzIG11c3QgYmVcbiAgICogaW4gdGhlIG9yZGVyaW5nIGluamVjdGVkIGJ5IGBpbmplY3RFdmVudFBsdWdpbk9yZGVyYC5cbiAgICpcbiAgICogUGx1Z2lucyBjYW4gYmUgaW5qZWN0ZWQgYXMgcGFydCBvZiBwYWdlIGluaXRpYWxpemF0aW9uIG9yIG9uLXRoZS1mbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZX1cbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogZnVuY3Rpb24gKGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgICB2YXIgaXNPcmRlcmluZ0RpcnR5ID0gZmFsc2U7XG4gICAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gICAgICBpZiAoIWluamVjdGVkTmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgUGx1Z2luTW9kdWxlID0gaW5qZWN0ZWROYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICAgIGlmICghbmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkgfHwgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gIT09IFBsdWdpbk1vZHVsZSkge1xuICAgICAgICAhIW5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgdHdvIGRpZmZlcmVudCBldmVudCBwbHVnaW5zICcgKyAndXNpbmcgdGhlIHNhbWUgbmFtZSwgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID0gUGx1Z2luTW9kdWxlO1xuICAgICAgICBpc09yZGVyaW5nRGlydHkgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNPcmRlcmluZ0RpcnR5KSB7XG4gICAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTG9va3MgdXAgdGhlIHBsdWdpbiBmb3IgdGhlIHN1cHBsaWVkIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgQSBzeW50aGV0aWMgZXZlbnQuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IFRoZSBwbHVnaW4gdGhhdCBjcmVhdGVkIHRoZSBzdXBwbGllZCBldmVudC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXRQbHVnaW5Nb2R1bGVGb3JFdmVudDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGRpc3BhdGNoQ29uZmlnID0gZXZlbnQuZGlzcGF0Y2hDb25maWc7XG4gICAgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICAgIHJldHVybiBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW2Rpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWVdIHx8IG51bGw7XG4gICAgfVxuICAgIGZvciAodmFyIHBoYXNlIGluIGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgICBpZiAoIWRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW2Rpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3BoYXNlXV07XG4gICAgICBpZiAoUGx1Z2luTW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBQbHVnaW5Nb2R1bGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciB1bml0IHRlc3RpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVzZXRFdmVudFBsdWdpbnM6IGZ1bmN0aW9uICgpIHtcbiAgICBFdmVudFBsdWdpbk9yZGVyID0gbnVsbDtcbiAgICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIG5hbWVzVG9QbHVnaW5zKSB7XG4gICAgICBpZiAobmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkpIHtcbiAgICAgICAgZGVsZXRlIG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnMubGVuZ3RoID0gMDtcblxuICAgIHZhciBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncztcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzKSB7XG4gICAgICBpZiAoZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgZGVsZXRlIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM7XG4gICAgZm9yICh2YXIgcmVnaXN0cmF0aW9uTmFtZSBpbiByZWdpc3RyYXRpb25OYW1lTW9kdWxlcykge1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHJlZ2lzdHJhdGlvbk5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSByZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvRXZlbnRQbHVnaW5SZWdpc3RyeS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFBsdWdpblV0aWxzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgUmVhY3RFcnJvclV0aWxzID0gcmVxdWlyZSgnLi9SZWFjdEVycm9yVXRpbHMnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogSW5qZWN0ZWQgZGVwZW5kZW5jaWVzOlxuICovXG5cbi8qKlxuICogLSBgTW91bnRgOiBbcmVxdWlyZWRdIE1vZHVsZSB0aGF0IGNhbiBjb252ZXJ0IGJldHdlZW4gUmVhY3QgZG9tIElEcyBhbmRcbiAqICAgYWN0dWFsIG5vZGUgcmVmZXJlbmNlcy5cbiAqL1xudmFyIGluamVjdGlvbiA9IHtcbiAgTW91bnQ6IG51bGwsXG4gIGluamVjdE1vdW50OiBmdW5jdGlvbiAoSW5qZWN0ZWRNb3VudCkge1xuICAgIGluamVjdGlvbi5Nb3VudCA9IEluamVjdGVkTW91bnQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKEluamVjdGVkTW91bnQgJiYgSW5qZWN0ZWRNb3VudC5nZXROb2RlICYmIEluamVjdGVkTW91bnQuZ2V0SUQsICdFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RNb3VudCguLi4pOiBJbmplY3RlZCBNb3VudCAnICsgJ21vZHVsZSBpcyBtaXNzaW5nIGdldE5vZGUgb3IgZ2V0SUQuJykgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbmZ1bmN0aW9uIGlzRW5kaXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXAgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoRW5kIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BUb3VjaENhbmNlbDtcbn1cblxuZnVuY3Rpb24gaXNNb3ZlaXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlTW92ZSB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hNb3ZlO1xufVxuZnVuY3Rpb24gaXNTdGFydGlzaCh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd24gfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoU3RhcnQ7XG59XG5cbnZhciB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcztcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICAgIHZhciBkaXNwYXRjaElEcyA9IGV2ZW50Ll9kaXNwYXRjaElEcztcblxuICAgIHZhciBsaXN0ZW5lcnNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpO1xuICAgIHZhciBpZHNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hJRHMpO1xuICAgIHZhciBJRHNMZW4gPSBpZHNJc0FyciA/IGRpc3BhdGNoSURzLmxlbmd0aCA6IGRpc3BhdGNoSURzID8gMSA6IDA7XG4gICAgdmFyIGxpc3RlbmVyc0xlbiA9IGxpc3RlbmVyc0lzQXJyID8gZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoIDogZGlzcGF0Y2hMaXN0ZW5lcnMgPyAxIDogMDtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGlkc0lzQXJyID09PSBsaXN0ZW5lcnNJc0FyciAmJiBJRHNMZW4gPT09IGxpc3RlbmVyc0xlbiwgJ0V2ZW50UGx1Z2luVXRpbHM6IEludmFsaWQgYGV2ZW50YC4nKSA6IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCB0aGUgZXZlbnQgdG8gdGhlIGxpc3RlbmVyLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgU3ludGhldGljRXZlbnQgdG8gaGFuZGxlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIEFwcGxpY2F0aW9uLWxldmVsIGNhbGxiYWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gZG9tSUQgRE9NIGlkIHRvIHBhc3MgdG8gdGhlIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgbGlzdGVuZXIsIGRvbUlEKSB7XG4gIHZhciB0eXBlID0gZXZlbnQudHlwZSB8fCAndW5rbm93bi1ldmVudCc7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBpbmplY3Rpb24uTW91bnQuZ2V0Tm9kZShkb21JRCk7XG4gIGlmIChzaW11bGF0ZWQpIHtcbiAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrV2l0aENhdGNoKHR5cGUsIGxpc3RlbmVyLCBldmVudCwgZG9tSUQpO1xuICB9IGVsc2Uge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sodHlwZSwgbGlzdGVuZXIsIGV2ZW50LCBkb21JRCk7XG4gIH1cbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG59XG5cbi8qKlxuICogU3RhbmRhcmQvc2ltcGxlIGl0ZXJhdGlvbiB0aHJvdWdoIGFuIGV2ZW50J3MgY29sbGVjdGVkIGRpc3BhdGNoZXMuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSURzID0gZXZlbnQuX2Rpc3BhdGNoSURzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSURzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaElEc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaElEcyk7XG4gIH1cbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSURzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcywgYnV0IHN0b3BzXG4gKiBhdCB0aGUgZmlyc3QgZGlzcGF0Y2ggZXhlY3V0aW9uIHJldHVybmluZyB0cnVlLCBhbmQgcmV0dXJucyB0aGF0IGlkLlxuICpcbiAqIEByZXR1cm4gez9zdHJpbmd9IGlkIG9mIHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gd2hvJ3MgbGlzdGVuZXIgcmV0dXJuc1xuICogdHJ1ZSwgb3IgbnVsbCBpZiBubyBsaXN0ZW5lciByZXR1cm5lZCB0cnVlLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbChldmVudCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaElEcyA9IGV2ZW50Ll9kaXNwYXRjaElEcztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIElEcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICAgIGlmIChkaXNwYXRjaExpc3RlbmVyc1tpXShldmVudCwgZGlzcGF0Y2hJRHNbaV0pKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaElEc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMoZXZlbnQsIGRpc3BhdGNoSURzKSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoSURzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUoZXZlbnQpIHtcbiAgdmFyIHJldCA9IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KTtcbiAgZXZlbnQuX2Rpc3BhdGNoSURzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBFeGVjdXRpb24gb2YgYSBcImRpcmVjdFwiIGRpc3BhdGNoIC0gdGhlcmUgbXVzdCBiZSBhdCBtb3N0IG9uZSBkaXNwYXRjaFxuICogYWNjdW11bGF0ZWQgb24gdGhlIGV2ZW50IG9yIGl0IGlzIGNvbnNpZGVyZWQgYW4gZXJyb3IuIEl0IGRvZXNuJ3QgcmVhbGx5IG1ha2VcbiAqIHNlbnNlIGZvciBhbiBldmVudCB3aXRoIG11bHRpcGxlIGRpc3BhdGNoZXMgKGJ1YmJsZWQpIHRvIGtlZXAgdHJhY2sgb2YgdGhlXG4gKiByZXR1cm4gdmFsdWVzIGF0IGVhY2ggZGlzcGF0Y2ggZXhlY3V0aW9uLCBidXQgaXQgZG9lcyB0ZW5kIHRvIG1ha2Ugc2Vuc2Ugd2hlblxuICogZGVhbGluZyB3aXRoIFwiZGlyZWN0XCIgZGlzcGF0Y2hlcy5cbiAqXG4gKiBAcmV0dXJuIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIGV4ZWN1dGluZyB0aGUgc2luZ2xlIGRpc3BhdGNoLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlyZWN0RGlzcGF0Y2goZXZlbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXIgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaElEID0gZXZlbnQuX2Rpc3BhdGNoSURzO1xuICAhIUFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZXhlY3V0ZURpcmVjdERpc3BhdGNoKC4uLik6IEludmFsaWQgYGV2ZW50YC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIHZhciByZXMgPSBkaXNwYXRjaExpc3RlbmVyID8gZGlzcGF0Y2hMaXN0ZW5lcihldmVudCwgZGlzcGF0Y2hJRCkgOiBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hJRHMgPSBudWxsO1xuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmZiBudW1iZXIgb2YgZGlzcGF0Y2hlcyBhY2N1bXVsYXRlZCBpcyBncmVhdGVyIHRoYW4gMC5cbiAqL1xuZnVuY3Rpb24gaGFzRGlzcGF0Y2hlcyhldmVudCkge1xuICByZXR1cm4gISFldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG59XG5cbi8qKlxuICogR2VuZXJhbCB1dGlsaXRpZXMgdGhhdCBhcmUgdXNlZnVsIGluIGNyZWF0aW5nIGN1c3RvbSBFdmVudCBQbHVnaW5zLlxuICovXG52YXIgRXZlbnRQbHVnaW5VdGlscyA9IHtcbiAgaXNFbmRpc2g6IGlzRW5kaXNoLFxuICBpc01vdmVpc2g6IGlzTW92ZWlzaCxcbiAgaXNTdGFydGlzaDogaXNTdGFydGlzaCxcblxuICBleGVjdXRlRGlyZWN0RGlzcGF0Y2g6IGV4ZWN1dGVEaXJlY3REaXNwYXRjaCxcbiAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyOiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIsXG4gIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWU6IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUsXG4gIGhhc0Rpc3BhdGNoZXM6IGhhc0Rpc3BhdGNoZXMsXG5cbiAgZ2V0Tm9kZTogZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIGluamVjdGlvbi5Nb3VudC5nZXROb2RlKGlkKTtcbiAgfSxcbiAgZ2V0SUQ6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIGluamVjdGlvbi5Nb3VudC5nZXRJRChub2RlKTtcbiAgfSxcblxuICBpbmplY3Rpb246IGluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpblV0aWxzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvRXZlbnRQbHVnaW5VdGlscy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVycm9yVXRpbHNcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2F1Z2h0RXJyb3IgPSBudWxsO1xuXG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiB3aGlsZSBndWFyZGluZyBhZ2FpbnN0IGVycm9ycyB0aGF0IGhhcHBlbnMgd2l0aGluIGl0LlxuICpcbiAqIEBwYXJhbSB7P1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGEgRmlyc3QgYXJndW1lbnRcbiAqIEBwYXJhbSB7Kn0gYiBTZWNvbmQgYXJndW1lbnRcbiAqL1xuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrKG5hbWUsIGZ1bmMsIGEsIGIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnVuYyhhLCBiKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIGlmIChjYXVnaHRFcnJvciA9PT0gbnVsbCkge1xuICAgICAgY2F1Z2h0RXJyb3IgPSB4O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbnZhciBSZWFjdEVycm9yVXRpbHMgPSB7XG4gIGludm9rZUd1YXJkZWRDYWxsYmFjazogaW52b2tlR3VhcmRlZENhbGxiYWNrLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIGJ5IFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlIHNvIHRoYXQgYW55IGVycm9ycyB0aHJvd24gYnkgdGhlIGV2ZW50XG4gICAqIGhhbmRsZXIgYXJlIHN1cmUgdG8gYmUgcmV0aHJvd24gYnkgcmV0aHJvd0NhdWdodEVycm9yLlxuICAgKi9cbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrV2l0aENhdGNoOiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssXG5cbiAgLyoqXG4gICAqIER1cmluZyBleGVjdXRpb24gb2YgZ3VhcmRlZCBmdW5jdGlvbnMgd2Ugd2lsbCBjYXB0dXJlIHRoZSBmaXJzdCBlcnJvciB3aGljaFxuICAgKiB3ZSB3aWxsIHJldGhyb3cgdG8gYmUgaGFuZGxlZCBieSB0aGUgdG9wIGxldmVsIGVycm9yIGhhbmRsZXIuXG4gICAqL1xuICByZXRocm93Q2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2F1Z2h0RXJyb3IpIHtcbiAgICAgIHZhciBlcnJvciA9IGNhdWdodEVycm9yO1xuICAgICAgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvKipcbiAgICogVG8gaGVscCBkZXZlbG9wbWVudCB3ZSBjYW4gZ2V0IGJldHRlciBkZXZ0b29scyBpbnRlZ3JhdGlvbiBieSBzaW11bGF0aW5nIGFcbiAgICogcmVhbCBicm93c2VyIGV2ZW50LlxuICAgKi9cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZGlzcGF0Y2hFdmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBmYWtlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3JlYWN0Jyk7XG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjayA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBhLCBiKSB7XG4gICAgICB2YXIgYm91bmRGdW5jID0gZnVuYy5iaW5kKG51bGwsIGEsIGIpO1xuICAgICAgdmFyIGV2dFR5cGUgPSAncmVhY3QtJyArIG5hbWU7XG4gICAgICBmYWtlTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGJvdW5kRnVuYywgZmFsc2UpO1xuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgZXZ0LmluaXRFdmVudChldnRUeXBlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgZmFrZU5vZGUuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgICAgZmFrZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBib3VuZEZ1bmMsIGZhbHNlKTtcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFcnJvclV0aWxzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RFcnJvclV0aWxzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGFjY3VtdWxhdGVJbnRvXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICpcbiAqIEFjY3VtdWxhdGVzIGl0ZW1zIHRoYXQgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQgaW50byB0aGUgZmlyc3Qgb25lLiBUaGlzXG4gKiBpcyB1c2VkIHRvIGNvbnNlcnZlIG1lbW9yeSBieSBhdm9pZGluZyBhcnJheSBhbGxvY2F0aW9ucywgYW5kIHRodXMgc2FjcmlmaWNlc1xuICogQVBJIGNsZWFubmVzcy4gU2luY2UgYGN1cnJlbnRgIGNhbiBiZSBudWxsIGJlZm9yZSBiZWluZyBwYXNzZWQgaW4gYW5kIG5vdFxuICogbnVsbCBhZnRlciB0aGlzIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdG8gYXNzaWduIGl0IGJhY2sgdG8gYGN1cnJlbnRgOlxuICpcbiAqIGBhID0gYWNjdW11bGF0ZUludG8oYSwgYik7YFxuICpcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBzcGFyaW5nbHkgdXNlZC4gVHJ5IGBhY2N1bXVsYXRlYCBmb3Igc29tZXRoaW5nIGNsZWFuZXIuXG4gKlxuICogQHJldHVybiB7KnxhcnJheTwqPn0gQW4gYWNjdW11bGF0aW9uIG9mIGl0ZW1zLlxuICovXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVJbnRvKGN1cnJlbnQsIG5leHQpIHtcbiAgIShuZXh0ICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2FjY3VtdWxhdGVJbnRvKC4uLik6IEFjY3VtdWxhdGVkIGl0ZW1zIG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgLy8gQm90aCBhcmUgbm90IGVtcHR5LiBXYXJuaW5nOiBOZXZlciBjYWxsIHguY29uY2F0KHkpIHdoZW4geW91IGFyZSBub3RcbiAgLy8gY2VydGFpbiB0aGF0IHggaXMgYW4gQXJyYXkgKHggY291bGQgYmUgYSBzdHJpbmcgd2l0aCBjb25jYXQgbWV0aG9kKS5cbiAgdmFyIGN1cnJlbnRJc0FycmF5ID0gQXJyYXkuaXNBcnJheShjdXJyZW50KTtcbiAgdmFyIG5leHRJc0FycmF5ID0gQXJyYXkuaXNBcnJheShuZXh0KTtcblxuICBpZiAoY3VycmVudElzQXJyYXkgJiYgbmV4dElzQXJyYXkpIHtcbiAgICBjdXJyZW50LnB1c2guYXBwbHkoY3VycmVudCwgbmV4dCk7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cblxuICBpZiAoY3VycmVudElzQXJyYXkpIHtcbiAgICBjdXJyZW50LnB1c2gobmV4dCk7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cblxuICBpZiAobmV4dElzQXJyYXkpIHtcbiAgICAvLyBBIGJpdCB0b28gZGFuZ2Vyb3VzIHRvIG11dGF0ZSBgbmV4dGAuXG4gICAgcmV0dXJuIFtjdXJyZW50XS5jb25jYXQobmV4dCk7XG4gIH1cblxuICByZXR1cm4gW2N1cnJlbnQsIG5leHRdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFjY3VtdWxhdGVJbnRvO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvYWNjdW11bGF0ZUludG8uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZm9yRWFjaEFjY3VtdWxhdGVkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7YXJyYXl9IGFyciBhbiBcImFjY3VtdWxhdGlvblwiIG9mIGl0ZW1zIHdoaWNoIGlzIGVpdGhlciBhbiBBcnJheSBvclxuICogYSBzaW5nbGUgaXRlbS4gVXNlZnVsIHdoZW4gcGFpcmVkIHdpdGggdGhlIGBhY2N1bXVsYXRlYCBtb2R1bGUuIFRoaXMgaXMgYVxuICogc2ltcGxlIHV0aWxpdHkgdGhhdCBhbGxvd3MgdXMgdG8gcmVhc29uIGFib3V0IGEgY29sbGVjdGlvbiBvZiBpdGVtcywgYnV0XG4gKiBoYW5kbGluZyB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIGV4YWN0bHkgb25lIGl0ZW0gKGFuZCB3ZSBkbyBub3QgbmVlZCB0b1xuICogYWxsb2NhdGUgYW4gYXJyYXkpLlxuICovXG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkID0gZnVuY3Rpb24gKGFyciwgY2IsIHNjb3BlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBhcnIuZm9yRWFjaChjYiwgc2NvcGUpO1xuICB9IGVsc2UgaWYgKGFycikge1xuICAgIGNiLmNhbGwoc2NvcGUsIGFycik7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaEFjY3VtdWxhdGVkO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvZm9yRWFjaEFjY3VtdWxhdGVkLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcblxuZnVuY3Rpb24gcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKSB7XG4gIEV2ZW50UGx1Z2luSHViLmVucXVldWVFdmVudHMoZXZlbnRzKTtcbiAgRXZlbnRQbHVnaW5IdWIucHJvY2Vzc0V2ZW50UXVldWUoZmFsc2UpO1xufVxuXG52YXIgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiA9IHtcblxuICAvKipcbiAgICogU3RyZWFtcyBhIGZpcmVkIHRvcC1sZXZlbCBldmVudCB0byBgRXZlbnRQbHVnaW5IdWJgIHdoZXJlIHBsdWdpbnMgaGF2ZSB0aGVcbiAgICogb3Bwb3J0dW5pdHkgdG8gY3JlYXRlIGBSZWFjdEV2ZW50YHMgdG8gYmUgZGlzcGF0Y2hlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGVudmlyb25tZW50IGV2ZW50LlxuICAgKi9cbiAgaGFuZGxlVG9wTGV2ZWw6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZXZlbnRzID0gRXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cyk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFdmVudEVtaXR0ZXJNaXhpbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RXZlbnRFbWl0dGVyTWl4aW4uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgVmlld3BvcnRNZXRyaWNzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVmlld3BvcnRNZXRyaWNzID0ge1xuXG4gIGN1cnJlbnRTY3JvbGxMZWZ0OiAwLFxuXG4gIGN1cnJlbnRTY3JvbGxUb3A6IDAsXG5cbiAgcmVmcmVzaFNjcm9sbFZhbHVlczogZnVuY3Rpb24gKHNjcm9sbFBvc2l0aW9uKSB7XG4gICAgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxMZWZ0ID0gc2Nyb2xsUG9zaXRpb24ueDtcbiAgICBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbFRvcCA9IHNjcm9sbFBvc2l0aW9uLnk7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3cG9ydE1ldHJpY3M7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9WaWV3cG9ydE1ldHJpY3MuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgT2JqZWN0LmFzc2lnblxuICovXG5cbi8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1vYmplY3QuYXNzaWduXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlcykge1xuICBpZiAodGFyZ2V0ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIHRhcmdldCBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgfVxuXG4gIHZhciB0byA9IE9iamVjdCh0YXJnZXQpO1xuICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gIGZvciAodmFyIG5leHRJbmRleCA9IDE7IG5leHRJbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IG5leHRJbmRleCsrKSB7XG4gICAgdmFyIG5leHRTb3VyY2UgPSBhcmd1bWVudHNbbmV4dEluZGV4XTtcbiAgICBpZiAobmV4dFNvdXJjZSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgZnJvbSA9IE9iamVjdChuZXh0U291cmNlKTtcblxuICAgIC8vIFdlIGRvbid0IGN1cnJlbnRseSBzdXBwb3J0IGFjY2Vzc29ycyBub3IgcHJveGllcy4gVGhlcmVmb3JlIHRoaXNcbiAgICAvLyBjb3B5IGNhbm5vdCB0aHJvdy4gSWYgd2UgZXZlciBzdXBwb3J0ZWQgdGhpcyB0aGVuIHdlIG11c3QgaGFuZGxlXG4gICAgLy8gZXhjZXB0aW9ucyBhbmQgc2lkZS1lZmZlY3RzLiBXZSBkb24ndCBzdXBwb3J0IHN5bWJvbHMgc28gdGhleSB3b24ndFxuICAgIC8vIGJlIHRyYW5zZmVycmVkLlxuXG4gICAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcbiAgICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvT2JqZWN0LmFzc2lnbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpc0V2ZW50U3VwcG9ydGVkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgdXNlSGFzRmVhdHVyZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdXNlSGFzRmVhdHVyZSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uICYmIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUgJiZcbiAgLy8gYWx3YXlzIHJldHVybnMgdHJ1ZSBpbiBuZXdlciBicm93c2VycyBhcyBwZXIgdGhlIHN0YW5kYXJkLlxuICAvLyBAc2VlIGh0dHA6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZG9taW1wbGVtZW50YXRpb24taGFzZmVhdHVyZVxuICBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCcnLCAnJykgIT09IHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGV2ZW50IGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBleGVjdXRpb24gZW52aXJvbm1lbnQuXG4gKlxuICogTk9URTogVGhpcyB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseSBmb3Igbm9uLWdlbmVyaWMgZXZlbnRzIHN1Y2ggYXMgYGNoYW5nZWAsXG4gKiBgcmVzZXRgLCBgbG9hZGAsIGBlcnJvcmAsIGFuZCBgc2VsZWN0YC5cbiAqXG4gKiBCb3Jyb3dzIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVTdWZmaXggRXZlbnQgbmFtZSwgZS5nLiBcImNsaWNrXCIuXG4gKiBAcGFyYW0gez9ib29sZWFufSBjYXB0dXJlIENoZWNrIGlmIHRoZSBjYXB0dXJlIHBoYXNlIGlzIHN1cHBvcnRlZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IGlzIHN1cHBvcnRlZC5cbiAqIEBpbnRlcm5hbFxuICogQGxpY2Vuc2UgTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXG4gKi9cbmZ1bmN0aW9uIGlzRXZlbnRTdXBwb3J0ZWQoZXZlbnROYW1lU3VmZml4LCBjYXB0dXJlKSB7XG4gIGlmICghRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NIHx8IGNhcHR1cmUgJiYgISgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gZG9jdW1lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGV2ZW50TmFtZSA9ICdvbicgKyBldmVudE5hbWVTdWZmaXg7XG4gIHZhciBpc1N1cHBvcnRlZCA9IChldmVudE5hbWUgaW4gZG9jdW1lbnQpO1xuXG4gIGlmICghaXNTdXBwb3J0ZWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGV2ZW50TmFtZSwgJ3JldHVybjsnKTtcbiAgICBpc1N1cHBvcnRlZCA9IHR5cGVvZiBlbGVtZW50W2V2ZW50TmFtZV0gPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICBpZiAoIWlzU3VwcG9ydGVkICYmIHVzZUhhc0ZlYXR1cmUgJiYgZXZlbnROYW1lU3VmZml4ID09PSAnd2hlZWwnKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgb25seSB3YXkgdG8gdGVzdCBzdXBwb3J0IGZvciB0aGUgYHdoZWVsYCBldmVudCBpbiBJRTkrLlxuICAgIGlzU3VwcG9ydGVkID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnRXZlbnRzLndoZWVsJywgJzMuMCcpO1xuICB9XG5cbiAgcmV0dXJuIGlzU3VwcG9ydGVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRXZlbnRTdXBwb3J0ZWQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9pc0V2ZW50U3VwcG9ydGVkLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NRmVhdHVyZUZsYWdzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01GZWF0dXJlRmxhZ3MgPSB7XG4gIHVzZUNyZWF0ZUVsZW1lbnQ6IGZhbHNlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NRmVhdHVyZUZsYWdzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01GZWF0dXJlRmxhZ3MuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFbGVtZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50IHR5cGUuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFsnZm9yJ10gJiYgU3ltYm9sWydmb3InXSgncmVhY3QuZWxlbWVudCcpIHx8IDB4ZWFjNztcblxudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcblxuLyoqXG4gKiBCYXNlIGNvbnN0cnVjdG9yIGZvciBhbGwgUmVhY3QgZWxlbWVudHMuIFRoaXMgaXMgb25seSB1c2VkIHRvIG1ha2UgdGhpc1xuICogd29yayB3aXRoIGEgZHluYW1pYyBpbnN0YW5jZW9mIGNoZWNrLiBOb3RoaW5nIHNob3VsZCBsaXZlIG9uIHRoaXMgcHJvdG90eXBlLlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTtcblxuICAgIC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cbiAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHNlbGZcbiAgICAgIH0pO1xuICAgICAgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogc291cmNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICBlbGVtZW50Ll9zZWxmID0gc2VsZjtcbiAgICAgIGVsZW1lbnQuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG5SZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBwcm9wcyA9IHt9O1xuXG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICByZWYgPSBjb25maWcucmVmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLnJlZjtcbiAgICBrZXkgPSBjb25maWcua2V5ID09PSB1bmRlZmluZWQgPyBudWxsIDogJycgKyBjb25maWcua2V5O1xuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7XG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BzW3Byb3BOYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbn07XG5cblJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgdmFyIGZhY3RvcnkgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudC5iaW5kKG51bGwsIHR5cGUpO1xuICAvLyBFeHBvc2UgdGhlIHR5cGUgb24gdGhlIGZhY3RvcnkgYW5kIHRoZSBwcm90b3R5cGUgc28gdGhhdCBpdCBjYW4gYmVcbiAgLy8gZWFzaWx5IGFjY2Vzc2VkIG9uIGVsZW1lbnRzLiBFLmcuIGA8Rm9vIC8+LnR5cGUgPT09IEZvb2AuXG4gIC8vIFRoaXMgc2hvdWxkIG5vdCBiZSBuYW1lZCBgY29uc3RydWN0b3JgIHNpbmNlIHRoaXMgbWF5IG5vdCBiZSB0aGUgZnVuY3Rpb25cbiAgLy8gdGhhdCBjcmVhdGVkIHRoZSBlbGVtZW50LCBhbmQgaXQgbWF5IG5vdCBldmVuIGJlIGEgY29uc3RydWN0b3IuXG4gIC8vIExlZ2FjeSBob29rIFRPRE86IFdhcm4gaWYgdGhpcyBpcyBhY2Nlc3NlZFxuICBmYWN0b3J5LnR5cGUgPSB0eXBlO1xuICByZXR1cm4gZmFjdG9yeTtcbn07XG5cblJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VLZXkgPSBmdW5jdGlvbiAob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG5cbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59O1xuXG5SZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlUHJvcHMgPSBmdW5jdGlvbiAob2xkRWxlbWVudCwgbmV3UHJvcHMpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBvbGRFbGVtZW50LmtleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG5ld1Byb3BzKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIElmIHRoZSBrZXkgb24gdGhlIG9yaWdpbmFsIGlzIHZhbGlkLCB0aGVuIHRoZSBjbG9uZSBpcyB2YWxpZFxuICAgIG5ld0VsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IG9sZEVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZDtcbiAgfVxuXG4gIHJldHVybiBuZXdFbGVtZW50O1xufTtcblxuUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG4gIHZhciBwcm9wcyA9IGFzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cbiAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmO1xuICAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXG4gIC8vIHRyYW5zcGlsZXIsIGFuZCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHByb2JhYmx5IGEgYmV0dGVyIGluZGljYXRvciBvZiB0aGVcbiAgLy8gdHJ1ZSBvd25lci5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcblxuICAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChjb25maWcucmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgY29tcG9uZW50LlxuICogQGZpbmFsXG4gKi9cblJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbGVtZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RFbGVtZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNhbkRlZmluZVByb3BlcnR5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSBmYWxzZTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7fSB9KTtcbiAgICBjYW5EZWZpbmVQcm9wZXJ0eSA9IHRydWU7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICAvLyBJRSB3aWxsIGZhaWwgb24gZGVmaW5lUHJvcGVydHlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbkRlZmluZVByb3BlcnR5O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvY2FuRGVmaW5lUHJvcGVydHkuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGlzIHJlZ2lzdHJ5IGtlZXBzIHRyYWNrIG9mIHRoZSBSZWFjdCBJRHMgb2YgdGhlIGNvbXBvbmVudHMgdGhhdCByZW5kZXJlZCB0b1xuLy8gYG51bGxgIChpbiByZWFsaXR5IGEgcGxhY2Vob2xkZXIgc3VjaCBhcyBgbm9zY3JpcHRgKVxudmFyIG51bGxDb21wb25lbnRJRHNSZWdpc3RyeSA9IHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBDb21wb25lbnQncyBgX3Jvb3ROb2RlSURgLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29tcG9uZW50IGlzIHJlbmRlcmVkIHRvIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGlzTnVsbENvbXBvbmVudElEKGlkKSB7XG4gIHJldHVybiAhIW51bGxDb21wb25lbnRJRHNSZWdpc3RyeVtpZF07XG59XG5cbi8qKlxuICogTWFyayB0aGUgY29tcG9uZW50IGFzIGhhdmluZyByZW5kZXJlZCB0byBudWxsLlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIENvbXBvbmVudCdzIGBfcm9vdE5vZGVJRGAuXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyTnVsbENvbXBvbmVudElEKGlkKSB7XG4gIG51bGxDb21wb25lbnRJRHNSZWdpc3RyeVtpZF0gPSB0cnVlO1xufVxuXG4vKipcbiAqIFVubWFyayB0aGUgY29tcG9uZW50IGFzIGhhdmluZyByZW5kZXJlZCB0byBudWxsOiBpdCByZW5kZXJzIHRvIHNvbWV0aGluZyBub3cuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQ29tcG9uZW50J3MgYF9yb290Tm9kZUlEYC5cbiAqL1xuZnVuY3Rpb24gZGVyZWdpc3Rlck51bGxDb21wb25lbnRJRChpZCkge1xuICBkZWxldGUgbnVsbENvbXBvbmVudElEc1JlZ2lzdHJ5W2lkXTtcbn1cblxudmFyIFJlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeSA9IHtcbiAgaXNOdWxsQ29tcG9uZW50SUQ6IGlzTnVsbENvbXBvbmVudElELFxuICByZWdpc3Rlck51bGxDb21wb25lbnRJRDogcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQsXG4gIGRlcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQ6IGRlcmVnaXN0ZXJOdWxsQ29tcG9uZW50SURcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SW5zdGFuY2VIYW5kbGVzXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Um9vdEluZGV4ID0gcmVxdWlyZSgnLi9SZWFjdFJvb3RJbmRleCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU0VQQVJBVE9SX0xFTkdUSCA9IFNFUEFSQVRPUi5sZW5ndGg7XG5cbi8qKlxuICogTWF4aW11bSBkZXB0aCBvZiB0cmF2ZXJzYWxzIGJlZm9yZSB3ZSBjb25zaWRlciB0aGUgcG9zc2liaWxpdHkgb2YgYSBiYWQgSUQuXG4gKi9cbnZhciBNQVhfVFJFRV9ERVBUSCA9IDEwMDAwO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBET00gSUQgcHJlZml4IHRvIHVzZSB3aGVuIG1vdW50aW5nIFJlYWN0IGNvbXBvbmVudHMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEEgdW5pcXVlIGludGVnZXJcbiAqIEByZXR1cm4ge3N0cmluZ30gUmVhY3Qgcm9vdCBJRC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RJRFN0cmluZyhpbmRleCkge1xuICByZXR1cm4gU0VQQVJBVE9SICsgaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGNoYXJhY3RlciBpbiB0aGUgc3VwcGxpZWQgSUQgaXMgYSBzZXBhcmF0b3Igb3IgdGhlIGVuZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQSBSZWFjdCBET00gSUQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggb2YgdGhlIGNoYXJhY3RlciB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNoYXJhY3RlciBpcyBhIHNlcGFyYXRvciBvciBlbmQgb2YgdGhlIElELlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNCb3VuZGFyeShpZCwgaW5kZXgpIHtcbiAgcmV0dXJuIGlkLmNoYXJBdChpbmRleCkgPT09IFNFUEFSQVRPUiB8fCBpbmRleCA9PT0gaWQubGVuZ3RoO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgc3VwcGxpZWQgc3RyaW5nIGlzIGEgdmFsaWQgUmVhY3QgRE9NIElELlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBIFJlYWN0IERPTSBJRCwgbWF5YmUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBzdHJpbmcgaXMgYSB2YWxpZCBSZWFjdCBET00gSUQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkSUQoaWQpIHtcbiAgcmV0dXJuIGlkID09PSAnJyB8fCBpZC5jaGFyQXQoMCkgPT09IFNFUEFSQVRPUiAmJiBpZC5jaGFyQXQoaWQubGVuZ3RoIC0gMSkgIT09IFNFUEFSQVRPUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGZpcnN0IElEIGlzIGFuIGFuY2VzdG9yIG9mIG9yIGVxdWFsIHRvIHRoZSBzZWNvbmQgSUQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFuY2VzdG9ySURcbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXNjZW5kYW50SURcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYGFuY2VzdG9ySURgIGlzIGFuIGFuY2VzdG9yIG9mIGBkZXNjZW5kYW50SURgLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGlzQW5jZXN0b3JJRE9mKGFuY2VzdG9ySUQsIGRlc2NlbmRhbnRJRCkge1xuICByZXR1cm4gZGVzY2VuZGFudElELmluZGV4T2YoYW5jZXN0b3JJRCkgPT09IDAgJiYgaXNCb3VuZGFyeShkZXNjZW5kYW50SUQsIGFuY2VzdG9ySUQubGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBwYXJlbnQgSUQgb2YgdGhlIHN1cHBsaWVkIFJlYWN0IERPTSBJRCwgYGlkYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgYSBjb21wb25lbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IElEIG9mIHRoZSBwYXJlbnQsIG9yIGFuIGVtcHR5IHN0cmluZy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudElEKGlkKSB7XG4gIHJldHVybiBpZCA/IGlkLnN1YnN0cigwLCBpZC5sYXN0SW5kZXhPZihTRVBBUkFUT1IpKSA6ICcnO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5leHQgRE9NIElEIG9uIHRoZSB0cmVlIHBhdGggZnJvbSB0aGUgc3VwcGxpZWQgYGFuY2VzdG9ySURgIHRvIHRoZVxuICogc3VwcGxpZWQgYGRlc3RpbmF0aW9uSURgLiBJZiB0aGV5IGFyZSBlcXVhbCwgdGhlIElEIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbmNlc3RvcklEIElEIG9mIGFuIGFuY2VzdG9yIG5vZGUgb2YgYGRlc3RpbmF0aW9uSURgLlxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3RpbmF0aW9uSUQgSUQgb2YgdGhlIGRlc3RpbmF0aW9uIG5vZGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5leHQgSUQgb24gdGhlIHBhdGggZnJvbSBgYW5jZXN0b3JJRGAgdG8gYGRlc3RpbmF0aW9uSURgLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0TmV4dERlc2NlbmRhbnRJRChhbmNlc3RvcklELCBkZXN0aW5hdGlvbklEKSB7XG4gICEoaXNWYWxpZElEKGFuY2VzdG9ySUQpICYmIGlzVmFsaWRJRChkZXN0aW5hdGlvbklEKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0TmV4dERlc2NlbmRhbnRJRCglcywgJXMpOiBSZWNlaXZlZCBhbiBpbnZhbGlkIFJlYWN0IERPTSBJRC4nLCBhbmNlc3RvcklELCBkZXN0aW5hdGlvbklEKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICFpc0FuY2VzdG9ySURPZihhbmNlc3RvcklELCBkZXN0aW5hdGlvbklEKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXROZXh0RGVzY2VuZGFudElEKC4uLik6IFJlYWN0IGhhcyBtYWRlIGFuIGludmFsaWQgYXNzdW1wdGlvbiBhYm91dCAnICsgJ3RoZSBET00gaGllcmFyY2h5LiBFeHBlY3RlZCBgJXNgIHRvIGJlIGFuIGFuY2VzdG9yIG9mIGAlc2AuJywgYW5jZXN0b3JJRCwgZGVzdGluYXRpb25JRCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBpZiAoYW5jZXN0b3JJRCA9PT0gZGVzdGluYXRpb25JRCkge1xuICAgIHJldHVybiBhbmNlc3RvcklEO1xuICB9XG4gIC8vIFNraXAgb3ZlciB0aGUgYW5jZXN0b3IgYW5kIHRoZSBpbW1lZGlhdGUgc2VwYXJhdG9yLiBUcmF2ZXJzZSB1bnRpbCB3ZSBoaXRcbiAgLy8gYW5vdGhlciBzZXBhcmF0b3Igb3Igd2UgcmVhY2ggdGhlIGVuZCBvZiBgZGVzdGluYXRpb25JRGAuXG4gIHZhciBzdGFydCA9IGFuY2VzdG9ySUQubGVuZ3RoICsgU0VQQVJBVE9SX0xFTkdUSDtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IHN0YXJ0OyBpIDwgZGVzdGluYXRpb25JRC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpc0JvdW5kYXJ5KGRlc3RpbmF0aW9uSUQsIGkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlc3RpbmF0aW9uSUQuc3Vic3RyKDAsIGkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIElEIG9mIHR3byBJRHMuXG4gKlxuICogVXNpbmcgdGhpcyBJRCBzY2hlbWUsIHRoZSBuZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBJRCBpcyB0aGUgbG9uZ2VzdCBjb21tb25cbiAqIHByZWZpeCBvZiB0aGUgdHdvIElEcyB0aGF0IGltbWVkaWF0ZWx5IHByZWNlZGVkIGEgXCJtYXJrZXJcIiBpbiBib3RoIHN0cmluZ3MuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG9uZUlEXG4gKiBAcGFyYW0ge3N0cmluZ30gdHdvSURcbiAqIEByZXR1cm4ge3N0cmluZ30gTmVhcmVzdCBjb21tb24gYW5jZXN0b3IgSUQsIG9yIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm9uZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldEZpcnN0Q29tbW9uQW5jZXN0b3JJRChvbmVJRCwgdHdvSUQpIHtcbiAgdmFyIG1pbkxlbmd0aCA9IE1hdGgubWluKG9uZUlELmxlbmd0aCwgdHdvSUQubGVuZ3RoKTtcbiAgaWYgKG1pbkxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICB2YXIgbGFzdENvbW1vbk1hcmtlckluZGV4ID0gMDtcbiAgLy8gVXNlIGA8PWAgdG8gdHJhdmVyc2UgdW50aWwgdGhlIFwiRU9MXCIgb2YgdGhlIHNob3J0ZXIgc3RyaW5nLlxuICBmb3IgKHZhciBpID0gMDsgaSA8PSBtaW5MZW5ndGg7IGkrKykge1xuICAgIGlmIChpc0JvdW5kYXJ5KG9uZUlELCBpKSAmJiBpc0JvdW5kYXJ5KHR3b0lELCBpKSkge1xuICAgICAgbGFzdENvbW1vbk1hcmtlckluZGV4ID0gaTtcbiAgICB9IGVsc2UgaWYgKG9uZUlELmNoYXJBdChpKSAhPT0gdHdvSUQuY2hhckF0KGkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdmFyIGxvbmdlc3RDb21tb25JRCA9IG9uZUlELnN1YnN0cigwLCBsYXN0Q29tbW9uTWFya2VySW5kZXgpO1xuICAhaXNWYWxpZElEKGxvbmdlc3RDb21tb25JRCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0Rmlyc3RDb21tb25BbmNlc3RvcklEKCVzLCAlcyk6IEV4cGVjdGVkIGEgdmFsaWQgUmVhY3QgRE9NIElEOiAlcycsIG9uZUlELCB0d29JRCwgbG9uZ2VzdENvbW1vbklEKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBsb25nZXN0Q29tbW9uSUQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIHRoZSBwYXJlbnQgcGF0aCBiZXR3ZWVuIHR3byBJRHMgKGVpdGhlciB1cCBvciBkb3duKS4gVGhlIElEcyBtdXN0XG4gKiBub3QgYmUgdGhlIHNhbWUsIGFuZCB0aGVyZSBtdXN0IGV4aXN0IGEgcGFyZW50IHBhdGggYmV0d2VlbiB0aGVtLiBJZiB0aGVcbiAqIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYCwgdHJhdmVyc2FsIGlzIHN0b3BwZWQuXG4gKlxuICogQHBhcmFtIHs/c3RyaW5nfSBzdGFydCBJRCBhdCB3aGljaCB0byBzdGFydCB0cmF2ZXJzYWwuXG4gKiBAcGFyYW0gez9zdHJpbmd9IHN0b3AgSUQgYXQgd2hpY2ggdG8gZW5kIHRyYXZlcnNhbC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIHRvIGludm9rZSBlYWNoIElEIHdpdGguXG4gKiBAcGFyYW0geyp9IGFyZyBBcmd1bWVudCB0byBpbnZva2UgdGhlIGNhbGxiYWNrIHdpdGguXG4gKiBAcGFyYW0gez9ib29sZWFufSBza2lwRmlyc3QgV2hldGhlciBvciBub3QgdG8gc2tpcCB0aGUgZmlyc3Qgbm9kZS5cbiAqIEBwYXJhbSB7P2Jvb2xlYW59IHNraXBMYXN0IFdoZXRoZXIgb3Igbm90IHRvIHNraXAgdGhlIGxhc3Qgbm9kZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlUGFyZW50UGF0aChzdGFydCwgc3RvcCwgY2IsIGFyZywgc2tpcEZpcnN0LCBza2lwTGFzdCkge1xuICBzdGFydCA9IHN0YXJ0IHx8ICcnO1xuICBzdG9wID0gc3RvcCB8fCAnJztcbiAgIShzdGFydCAhPT0gc3RvcCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndHJhdmVyc2VQYXJlbnRQYXRoKC4uLik6IENhbm5vdCB0cmF2ZXJzZSBmcm9tIGFuZCB0byB0aGUgc2FtZSBJRCwgYCVzYC4nLCBzdGFydCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB2YXIgdHJhdmVyc2VVcCA9IGlzQW5jZXN0b3JJRE9mKHN0b3AsIHN0YXJ0KTtcbiAgISh0cmF2ZXJzZVVwIHx8IGlzQW5jZXN0b3JJRE9mKHN0YXJ0LCBzdG9wKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndHJhdmVyc2VQYXJlbnRQYXRoKCVzLCAlcywgLi4uKTogQ2Fubm90IHRyYXZlcnNlIGZyb20gdHdvIElEcyB0aGF0IGRvICcgKyAnbm90IGhhdmUgYSBwYXJlbnQgcGF0aC4nLCBzdGFydCwgc3RvcCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAvLyBUcmF2ZXJzZSBmcm9tIGBzdGFydGAgdG8gYHN0b3BgIG9uZSBkZXB0aCBhdCBhIHRpbWUuXG4gIHZhciBkZXB0aCA9IDA7XG4gIHZhciB0cmF2ZXJzZSA9IHRyYXZlcnNlVXAgPyBnZXRQYXJlbnRJRCA6IGdldE5leHREZXNjZW5kYW50SUQ7XG4gIGZvciAodmFyIGlkID0gc3RhcnQ7OyAvKiB1bnRpbCBicmVhayAqL2lkID0gdHJhdmVyc2UoaWQsIHN0b3ApKSB7XG4gICAgdmFyIHJldDtcbiAgICBpZiAoKCFza2lwRmlyc3QgfHwgaWQgIT09IHN0YXJ0KSAmJiAoIXNraXBMYXN0IHx8IGlkICE9PSBzdG9wKSkge1xuICAgICAgcmV0ID0gY2IoaWQsIHRyYXZlcnNlVXAsIGFyZyk7XG4gICAgfVxuICAgIGlmIChyZXQgPT09IGZhbHNlIHx8IGlkID09PSBzdG9wKSB7XG4gICAgICAvLyBPbmx5IGJyZWFrIC8vYWZ0ZXIvLyB2aXNpdGluZyBgc3RvcGAuXG4gICAgICBicmVhaztcbiAgICB9XG4gICAgIShkZXB0aCsrIDwgTUFYX1RSRUVfREVQVEgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RyYXZlcnNlUGFyZW50UGF0aCglcywgJXMsIC4uLik6IERldGVjdGVkIGFuIGluZmluaXRlIGxvb3Agd2hpbGUgJyArICd0cmF2ZXJzaW5nIHRoZSBSZWFjdCBET00gSUQgdHJlZS4gVGhpcyBtYXkgYmUgZHVlIHRvIG1hbGZvcm1lZCBJRHM6ICVzJywgc3RhcnQsIHN0b3AsIGlkKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBNYW5hZ2VzIHRoZSBJRHMgYXNzaWduZWQgdG8gRE9NIHJlcHJlc2VudGF0aW9ucyBvZiBSZWFjdCBjb21wb25lbnRzLiBUaGlzXG4gKiB1c2VzIGEgc3BlY2lmaWMgc2NoZW1lIGluIG9yZGVyIHRvIHRyYXZlcnNlIHRoZSBET00gZWZmaWNpZW50bHkgKGUuZy4gaW5cbiAqIG9yZGVyIHRvIHNpbXVsYXRlIGV2ZW50cykuXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIFJlYWN0IHJvb3QgSURcbiAgICogQHJldHVybiB7c3RyaW5nfSBBIFJlYWN0IHJvb3QgSUQuXG4gICAqL1xuICBjcmVhdGVSZWFjdFJvb3RJRDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRSZWFjdFJvb3RJRFN0cmluZyhSZWFjdFJvb3RJbmRleC5jcmVhdGVSZWFjdFJvb3RJbmRleCgpKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIFJlYWN0IElEIGJ5IGpvaW5pbmcgYSByb290IElEIHdpdGggYSBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIFJvb3QgSUQgb2YgYSBwYXJlbnQgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBIGNvbXBvbmVudCdzIG5hbWUgKGFzIGZsYXR0ZW5lZCBjaGlsZHJlbikuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQSBSZWFjdCBJRC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBjcmVhdGVSZWFjdElEOiBmdW5jdGlvbiAocm9vdElELCBuYW1lKSB7XG4gICAgcmV0dXJuIHJvb3RJRCArIG5hbWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIERPTSBJRCBvZiB0aGUgUmVhY3QgY29tcG9uZW50IHRoYXQgaXMgdGhlIHJvb3Qgb2YgdGhlIHRyZWUgdGhhdFxuICAgKiBjb250YWlucyB0aGUgUmVhY3QgY29tcG9uZW50IHdpdGggdGhlIHN1cHBsaWVkIERPTSBJRC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIERPTSBJRCBvZiBhIFJlYWN0IGNvbXBvbmVudC5cbiAgICogQHJldHVybiB7P3N0cmluZ30gRE9NIElEIG9mIHRoZSBSZWFjdCBjb21wb25lbnQgdGhhdCBpcyB0aGUgcm9vdC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIGlmIChpZCAmJiBpZC5jaGFyQXQoMCkgPT09IFNFUEFSQVRPUiAmJiBpZC5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgaW5kZXggPSBpZC5pbmRleE9mKFNFUEFSQVRPUiwgMSk7XG4gICAgICByZXR1cm4gaW5kZXggPiAtMSA/IGlkLnN1YnN0cigwLCBpbmRleCkgOiBpZDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXZlcnNlcyB0aGUgSUQgaGllcmFyY2h5IGFuZCBpbnZva2VzIHRoZSBzdXBwbGllZCBgY2JgIG9uIGFueSBJRHMgdGhhdFxuICAgKiBzaG91bGQgd291bGQgcmVjZWl2ZSBhIGBtb3VzZUVudGVyYCBvciBgbW91c2VMZWF2ZWAgZXZlbnQuXG4gICAqXG4gICAqIE5PVEU6IERvZXMgbm90IGludm9rZSB0aGUgY2FsbGJhY2sgb24gdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIGJlY2F1c2VcbiAgICogbm90aGluZyBcImVudGVyZWRcIiBvciBcImxlZnRcIiB0aGF0IGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsZWF2ZUlEIElEIGJlaW5nIGxlZnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbnRlcklEIElEIGJlaW5nIGVudGVyZWQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIHRvIGludm9rZSBvbiBlYWNoIGVudGVyZWQvbGVmdCBJRC5cbiAgICogQHBhcmFtIHsqfSB1cEFyZyBBcmd1bWVudCB0byBpbnZva2UgdGhlIGNhbGxiYWNrIHdpdGggb24gbGVmdCBJRHMuXG4gICAqIEBwYXJhbSB7Kn0gZG93bkFyZyBBcmd1bWVudCB0byBpbnZva2UgdGhlIGNhbGxiYWNrIHdpdGggb24gZW50ZXJlZCBJRHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhdmVyc2VFbnRlckxlYXZlOiBmdW5jdGlvbiAobGVhdmVJRCwgZW50ZXJJRCwgY2IsIHVwQXJnLCBkb3duQXJnKSB7XG4gICAgdmFyIGFuY2VzdG9ySUQgPSBnZXRGaXJzdENvbW1vbkFuY2VzdG9ySUQobGVhdmVJRCwgZW50ZXJJRCk7XG4gICAgaWYgKGFuY2VzdG9ySUQgIT09IGxlYXZlSUQpIHtcbiAgICAgIHRyYXZlcnNlUGFyZW50UGF0aChsZWF2ZUlELCBhbmNlc3RvcklELCBjYiwgdXBBcmcsIGZhbHNlLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGFuY2VzdG9ySUQgIT09IGVudGVySUQpIHtcbiAgICAgIHRyYXZlcnNlUGFyZW50UGF0aChhbmNlc3RvcklELCBlbnRlcklELCBjYiwgZG93bkFyZywgdHJ1ZSwgZmFsc2UpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2ltdWxhdGVzIHRoZSB0cmF2ZXJzYWwgb2YgYSB0d28tcGhhc2UsIGNhcHR1cmUvYnViYmxlIGV2ZW50IGRpc3BhdGNoLlxuICAgKlxuICAgKiBOT1RFOiBUaGlzIHRyYXZlcnNhbCBoYXBwZW5zIG9uIElEcyB3aXRob3V0IHRvdWNoaW5nIHRoZSBET00uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRJRCBJRCBvZiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIHRvIGludm9rZS5cbiAgICogQHBhcmFtIHsqfSBhcmcgQXJndW1lbnQgdG8gaW52b2tlIHRoZSBjYWxsYmFjayB3aXRoLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXZlcnNlVHdvUGhhc2U6IGZ1bmN0aW9uICh0YXJnZXRJRCwgY2IsIGFyZykge1xuICAgIGlmICh0YXJnZXRJRCkge1xuICAgICAgdHJhdmVyc2VQYXJlbnRQYXRoKCcnLCB0YXJnZXRJRCwgY2IsIGFyZywgdHJ1ZSwgZmFsc2UpO1xuICAgICAgdHJhdmVyc2VQYXJlbnRQYXRoKHRhcmdldElELCAnJywgY2IsIGFyZywgZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyBgdHJhdmVyc2VUd29QaGFzZWAgYnV0IHNraXBzIHRoZSBgdGFyZ2V0SURgLlxuICAgKi9cbiAgdHJhdmVyc2VUd29QaGFzZVNraXBUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXRJRCwgY2IsIGFyZykge1xuICAgIGlmICh0YXJnZXRJRCkge1xuICAgICAgdHJhdmVyc2VQYXJlbnRQYXRoKCcnLCB0YXJnZXRJRCwgY2IsIGFyZywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB0cmF2ZXJzZVBhcmVudFBhdGgodGFyZ2V0SUQsICcnLCBjYiwgYXJnLCB0cnVlLCB0cnVlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXZlcnNlIGEgbm9kZSBJRCwgY2FsbGluZyB0aGUgc3VwcGxpZWQgYGNiYCBmb3IgZWFjaCBhbmNlc3RvciBJRC4gRm9yXG4gICAqIGV4YW1wbGUsIHBhc3NpbmcgYC4wLiRyb3ctMC4xYCB3b3VsZCByZXN1bHQgaW4gYGNiYCBnZXR0aW5nIGNhbGxlZFxuICAgKiB3aXRoIGAuMGAsIGAuMC4kcm93LTBgLCBhbmQgYC4wLiRyb3ctMC4xYC5cbiAgICpcbiAgICogTk9URTogVGhpcyB0cmF2ZXJzYWwgaGFwcGVucyBvbiBJRHMgd2l0aG91dCB0b3VjaGluZyB0aGUgRE9NLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0SUQgSUQgb2YgdGhlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBDYWxsYmFjayB0byBpbnZva2UuXG4gICAqIEBwYXJhbSB7Kn0gYXJnIEFyZ3VtZW50IHRvIGludm9rZSB0aGUgY2FsbGJhY2sgd2l0aC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB0cmF2ZXJzZUFuY2VzdG9yczogZnVuY3Rpb24gKHRhcmdldElELCBjYiwgYXJnKSB7XG4gICAgdHJhdmVyc2VQYXJlbnRQYXRoKCcnLCB0YXJnZXRJRCwgY2IsIGFyZywgdHJ1ZSwgZmFsc2UpO1xuICB9LFxuXG4gIGdldEZpcnN0Q29tbW9uQW5jZXN0b3JJRDogZ2V0Rmlyc3RDb21tb25BbmNlc3RvcklELFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciB1bml0IHRlc3RpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0TmV4dERlc2NlbmRhbnRJRDogZ2V0TmV4dERlc2NlbmRhbnRJRCxcblxuICBpc0FuY2VzdG9ySURPZjogaXNBbmNlc3RvcklET2YsXG5cbiAgU0VQQVJBVE9SOiBTRVBBUkFUT1JcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEluc3RhbmNlSGFuZGxlcztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0SW5zdGFuY2VIYW5kbGVzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Um9vdEluZGV4XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Um9vdEluZGV4SW5qZWN0aW9uID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gX2NyZWF0ZVJlYWN0Um9vdEluZGV4XG4gICAqL1xuICBpbmplY3RDcmVhdGVSZWFjdFJvb3RJbmRleDogZnVuY3Rpb24gKF9jcmVhdGVSZWFjdFJvb3RJbmRleCkge1xuICAgIFJlYWN0Um9vdEluZGV4LmNyZWF0ZVJlYWN0Um9vdEluZGV4ID0gX2NyZWF0ZVJlYWN0Um9vdEluZGV4O1xuICB9XG59O1xuXG52YXIgUmVhY3RSb290SW5kZXggPSB7XG4gIGNyZWF0ZVJlYWN0Um9vdEluZGV4OiBudWxsLFxuICBpbmplY3Rpb246IFJlYWN0Um9vdEluZGV4SW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Um9vdEluZGV4O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RSb290SW5kZXguanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbnN0YW5jZU1hcFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBgUmVhY3RJbnN0YW5jZU1hcGAgbWFpbnRhaW5zIGEgbWFwcGluZyBmcm9tIGEgcHVibGljIGZhY2luZyBzdGF0ZWZ1bFxuICogaW5zdGFuY2UgKGtleSkgYW5kIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiAodmFsdWUpLiBUaGlzIGFsbG93cyBwdWJsaWNcbiAqIG1ldGhvZHMgdG8gYWNjZXB0IHRoZSB1c2VyIGZhY2luZyBpbnN0YW5jZSBhcyBhbiBhcmd1bWVudCBhbmQgbWFwIHRoZW0gYmFja1xuICogdG8gaW50ZXJuYWwgbWV0aG9kcy5cbiAqL1xuXG4vLyBUT0RPOiBSZXBsYWNlIHRoaXMgd2l0aCBFUzY6IHZhciBSZWFjdEluc3RhbmNlTWFwID0gbmV3IE1hcCgpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSB7XG5cbiAgLyoqXG4gICAqIFRoaXMgQVBJIHNob3VsZCBiZSBjYWxsZWQgYGRlbGV0ZWAgYnV0IHdlJ2QgaGF2ZSB0byBtYWtlIHN1cmUgdG8gYWx3YXlzXG4gICAqIHRyYW5zZm9ybSB0aGVzZSB0byBzdHJpbmdzIGZvciBJRSBzdXBwb3J0LiBXaGVuIHRoaXMgdHJhbnNmb3JtIGlzIGZ1bGx5XG4gICAqIHN1cHBvcnRlZCB3ZSBjYW4gcmVuYW1lIGl0LlxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlO1xuICB9LFxuXG4gIGhhczogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSAhPT0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IHZhbHVlO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbnN0YW5jZU1hcDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0SW5zdGFuY2VNYXAuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RNYXJrdXBDaGVja3N1bVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFkbGVyMzIgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcblxudmFyIFRBR19FTkQgPSAvXFwvPz4vO1xuXG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHtcbiAgQ0hFQ0tTVU1fQVRUUl9OQU1FOiAnZGF0YS1yZWFjdC1jaGVja3N1bScsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcgd2l0aCBjaGVja3N1bSBhdHRyaWJ1dGUgYXR0YWNoZWRcbiAgICovXG4gIGFkZENoZWNrc3VtVG9NYXJrdXA6IGZ1bmN0aW9uIChtYXJrdXApIHtcbiAgICB2YXIgY2hlY2tzdW0gPSBhZGxlcjMyKG1hcmt1cCk7XG5cbiAgICAvLyBBZGQgY2hlY2tzdW0gKGhhbmRsZSBib3RoIHBhcmVudCB0YWdzIGFuZCBzZWxmLWNsb3NpbmcgdGFncylcbiAgICByZXR1cm4gbWFya3VwLnJlcGxhY2UoVEFHX0VORCwgJyAnICsgUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUgKyAnPVwiJyArIGNoZWNrc3VtICsgJ1wiJCYnKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCB0byB1c2VcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IHJvb3QgUmVhY3QgZWxlbWVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBvciBub3QgdGhlIG1hcmt1cCBpcyB0aGUgc2FtZVxuICAgKi9cbiAgY2FuUmV1c2VNYXJrdXA6IGZ1bmN0aW9uIChtYXJrdXAsIGVsZW1lbnQpIHtcbiAgICB2YXIgZXhpc3RpbmdDaGVja3N1bSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FKTtcbiAgICBleGlzdGluZ0NoZWNrc3VtID0gZXhpc3RpbmdDaGVja3N1bSAmJiBwYXJzZUludChleGlzdGluZ0NoZWNrc3VtLCAxMCk7XG4gICAgdmFyIG1hcmt1cENoZWNrc3VtID0gYWRsZXIzMihtYXJrdXApO1xuICAgIHJldHVybiBtYXJrdXBDaGVja3N1bSA9PT0gZXhpc3RpbmdDaGVja3N1bTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1hcmt1cENoZWNrc3VtO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RNYXJrdXBDaGVja3N1bS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBhZGxlcjMyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTU9EID0gNjU1MjE7XG5cbi8vIGFkbGVyMzIgaXMgbm90IGNyeXB0b2dyYXBoaWNhbGx5IHN0cm9uZywgYW5kIGlzIG9ubHkgdXNlZCB0byBzYW5pdHkgY2hlY2sgdGhhdFxuLy8gbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgc2VydmVyIG1hdGNoZXMgdGhlIG1hcmt1cCBnZW5lcmF0ZWQgb24gdGhlIGNsaWVudC5cbi8vIFRoaXMgaW1wbGVtZW50YXRpb24gKGEgbW9kaWZpZWQgdmVyc2lvbiBvZiB0aGUgU2hlZXRKUyB2ZXJzaW9uKSBoYXMgYmVlbiBvcHRpbWl6ZWRcbi8vIGZvciBvdXIgdXNlIGNhc2UsIGF0IHRoZSBleHBlbnNlIG9mIGNvbmZvcm1pbmcgdG8gdGhlIGFkbGVyMzIgc3BlY2lmaWNhdGlvblxuLy8gZm9yIG5vbi1hc2NpaSBpbnB1dHMuXG5mdW5jdGlvbiBhZGxlcjMyKGRhdGEpIHtcbiAgdmFyIGEgPSAxO1xuICB2YXIgYiA9IDA7XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBkYXRhLmxlbmd0aDtcbiAgdmFyIG0gPSBsICYgfjB4MztcbiAgd2hpbGUgKGkgPCBtKSB7XG4gICAgZm9yICg7IGkgPCBNYXRoLm1pbihpICsgNDA5NiwgbSk7IGkgKz0gNCkge1xuICAgICAgYiArPSAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSkpICsgKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkgKyAxKSkgKyAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSArIDIpKSArIChhICs9IGRhdGEuY2hhckNvZGVBdChpICsgMykpO1xuICAgIH1cbiAgICBhICU9IE1PRDtcbiAgICBiICU9IE1PRDtcbiAgfVxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGIgKz0gYSArPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgYSAlPSBNT0Q7XG4gIGIgJT0gTU9EO1xuICByZXR1cm4gYSB8IGIgPDwgMTY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2FkbGVyMzIuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RSZWNvbmNpbGVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RSZWYgPSByZXF1aXJlKCcuL1JlYWN0UmVmJyk7XG5cbi8qKlxuICogSGVscGVyIHRvIGNhbGwgUmVhY3RSZWYuYXR0YWNoUmVmcyB3aXRoIHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCwgc3BsaXQgb3V0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW9ucyBpbiB0aGUgdHJhbnNhY3Rpb24gbW91bnQtcmVhZHkgcXVldWUuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaFJlZnMoKSB7XG4gIFJlYWN0UmVmLmF0dGFjaFJlZnModGhpcywgdGhpcy5fY3VycmVudEVsZW1lbnQpO1xufVxuXG52YXIgUmVhY3RSZWNvbmNpbGVyID0ge1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY29tcG9uZW50LCByZW5kZXJzIG1hcmt1cCwgYW5kIHJlZ2lzdGVycyBldmVudCBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGludGVybmFsSW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBET00gSUQgb2YgdGhlIHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IFJlbmRlcmVkIG1hcmt1cCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgcm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBtYXJrdXAgPSBpbnRlcm5hbEluc3RhbmNlLm1vdW50Q29tcG9uZW50KHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5yZWYgIT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShhdHRhY2hSZWZzLCBpbnRlcm5hbEluc3RhbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICAvKipcbiAgICogUmVsZWFzZXMgYW55IHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgYG1vdW50Q29tcG9uZW50YC5cbiAgICpcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UpIHtcbiAgICBSZWFjdFJlZi5kZXRhY2hSZWZzKGludGVybmFsSW5zdGFuY2UsIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50KTtcbiAgICBpbnRlcm5hbEluc3RhbmNlLnVubW91bnRDb21wb25lbnQoKTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIGEgY29tcG9uZW50IHVzaW5nIGEgbmV3IGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGludGVybmFsSW5zdGFuY2VcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQGludGVybmFsXG4gICAqL1xuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgbmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHByZXZFbGVtZW50ID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQ7XG5cbiAgICBpZiAobmV4dEVsZW1lbnQgPT09IHByZXZFbGVtZW50ICYmIGNvbnRleHQgPT09IGludGVybmFsSW5zdGFuY2UuX2NvbnRleHQpIHtcbiAgICAgIC8vIFNpbmNlIGVsZW1lbnRzIGFyZSBpbW11dGFibGUgYWZ0ZXIgdGhlIG93bmVyIGlzIHJlbmRlcmVkLFxuICAgICAgLy8gd2UgY2FuIGRvIGEgY2hlYXAgaWRlbnRpdHkgY29tcGFyZSBoZXJlIHRvIGRldGVybWluZSBpZiB0aGlzIGlzIGFcbiAgICAgIC8vIHN1cGVyZmx1b3VzIHJlY29uY2lsZS4gSXQncyBwb3NzaWJsZSBmb3Igc3RhdGUgdG8gYmUgbXV0YWJsZSBidXQgc3VjaFxuICAgICAgLy8gY2hhbmdlIHNob3VsZCB0cmlnZ2VyIGFuIHVwZGF0ZSBvZiB0aGUgb3duZXIgd2hpY2ggd291bGQgcmVjcmVhdGVcbiAgICAgIC8vIHRoZSBlbGVtZW50LiBXZSBleHBsaWNpdGx5IGNoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIGFuIG93bmVyIHNpbmNlXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIGZvciBhbiBlbGVtZW50IGNyZWF0ZWQgb3V0c2lkZSBhIGNvbXBvc2l0ZSB0byBiZVxuICAgICAgLy8gZGVlcGx5IG11dGF0ZWQgYW5kIHJldXNlZC5cblxuICAgICAgLy8gVE9ETzogQmFpbGluZyBvdXQgZWFybHkgaXMganVzdCBhIHBlcmYgb3B0aW1pemF0aW9uIHJpZ2h0P1xuICAgICAgLy8gVE9ETzogUmVtb3ZpbmcgdGhlIHJldHVybiBzdGF0ZW1lbnQgc2hvdWxkIGFmZmVjdCBjb3JyZWN0bmVzcz9cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVmc0NoYW5nZWQgPSBSZWFjdFJlZi5zaG91bGRVcGRhdGVSZWZzKHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCk7XG5cbiAgICBpZiAocmVmc0NoYW5nZWQpIHtcbiAgICAgIFJlYWN0UmVmLmRldGFjaFJlZnMoaW50ZXJuYWxJbnN0YW5jZSwgcHJldkVsZW1lbnQpO1xuICAgIH1cblxuICAgIGludGVybmFsSW5zdGFuY2UucmVjZWl2ZUNvbXBvbmVudChuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuXG4gICAgaWYgKHJlZnNDaGFuZ2VkICYmIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50ICYmIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LnJlZiAhPSBudWxsKSB7XG4gICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGF0dGFjaFJlZnMsIGludGVybmFsSW5zdGFuY2UpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRmx1c2ggYW55IGRpcnR5IGNoYW5nZXMgaW4gYSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGludGVybmFsSW5zdGFuY2VcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeTogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHRyYW5zYWN0aW9uKSB7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5wZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkodHJhbnNhY3Rpb24pO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSZWNvbmNpbGVyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RSZWNvbmNpbGVyLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UmVmXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RPd25lcicpO1xuXG52YXIgUmVhY3RSZWYgPSB7fTtcblxuZnVuY3Rpb24gYXR0YWNoUmVmKHJlZiwgY29tcG9uZW50LCBvd25lcikge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlZihjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTGVnYWN5IHJlZlxuICAgIFJlYWN0T3duZXIuYWRkQ29tcG9uZW50QXNSZWZUbyhjb21wb25lbnQsIHJlZiwgb3duZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGFjaFJlZihyZWYsIGNvbXBvbmVudCwgb3duZXIpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZWYobnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTGVnYWN5IHJlZlxuICAgIFJlYWN0T3duZXIucmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tKGNvbXBvbmVudCwgcmVmLCBvd25lcik7XG4gIH1cbn1cblxuUmVhY3RSZWYuYXR0YWNoUmVmcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIGlmIChyZWYgIT0gbnVsbCkge1xuICAgIGF0dGFjaFJlZihyZWYsIGluc3RhbmNlLCBlbGVtZW50Ll9vd25lcik7XG4gIH1cbn07XG5cblJlYWN0UmVmLnNob3VsZFVwZGF0ZVJlZnMgPSBmdW5jdGlvbiAocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSB7XG4gIC8vIElmIGVpdGhlciB0aGUgb3duZXIgb3IgYSBgcmVmYCBoYXMgY2hhbmdlZCwgbWFrZSBzdXJlIHRoZSBuZXdlc3Qgb3duZXJcbiAgLy8gaGFzIHN0b3JlZCBhIHJlZmVyZW5jZSB0byBgdGhpc2AsIGFuZCB0aGUgcHJldmlvdXMgb3duZXIgKGlmIGRpZmZlcmVudClcbiAgLy8gaGFzIGZvcmdvdHRlbiB0aGUgcmVmZXJlbmNlIHRvIGB0aGlzYC4gV2UgdXNlIHRoZSBlbGVtZW50IGluc3RlYWRcbiAgLy8gb2YgdGhlIHB1YmxpYyB0aGlzLnByb3BzIGJlY2F1c2UgdGhlIHBvc3QgcHJvY2Vzc2luZyBjYW5ub3QgZGV0ZXJtaW5lXG4gIC8vIGEgcmVmLiBUaGUgcmVmIGNvbmNlcHR1YWxseSBsaXZlcyBvbiB0aGUgZWxlbWVudC5cblxuICAvLyBUT0RPOiBTaG91bGQgdGhpcyBldmVuIGJlIHBvc3NpYmxlPyBUaGUgb3duZXIgY2Fubm90IGNoYW5nZSBiZWNhdXNlXG4gIC8vIGl0J3MgZm9yYmlkZGVuIGJ5IHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50LiBUaGUgcmVmIGNhbiBjaGFuZ2VcbiAgLy8gaWYgeW91IHN3YXAgdGhlIGtleXMgb2YgYnV0IG5vdCB0aGUgcmVmcy4gUmVjb25zaWRlciB3aGVyZSB0aGlzIGNoZWNrXG4gIC8vIGlzIG1hZGUuIEl0IHByb2JhYmx5IGJlbG9uZ3Mgd2hlcmUgdGhlIGtleSBjaGVja2luZyBhbmRcbiAgLy8gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCBpcyBkb25lLlxuXG4gIHZhciBwcmV2RW1wdHkgPSBwcmV2RWxlbWVudCA9PT0gbnVsbCB8fCBwcmV2RWxlbWVudCA9PT0gZmFsc2U7XG4gIHZhciBuZXh0RW1wdHkgPSBuZXh0RWxlbWVudCA9PT0gbnVsbCB8fCBuZXh0RWxlbWVudCA9PT0gZmFsc2U7XG5cbiAgcmV0dXJuKFxuICAgIC8vIFRoaXMgaGFzIGEgZmV3IGZhbHNlIHBvc2l0aXZlcyB3L3IvdCBlbXB0eSBjb21wb25lbnRzLlxuICAgIHByZXZFbXB0eSB8fCBuZXh0RW1wdHkgfHwgbmV4dEVsZW1lbnQuX293bmVyICE9PSBwcmV2RWxlbWVudC5fb3duZXIgfHwgbmV4dEVsZW1lbnQucmVmICE9PSBwcmV2RWxlbWVudC5yZWZcbiAgKTtcbn07XG5cblJlYWN0UmVmLmRldGFjaFJlZnMgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAocmVmICE9IG51bGwpIHtcbiAgICBkZXRhY2hSZWYocmVmLCBpbnN0YW5jZSwgZWxlbWVudC5fb3duZXIpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVmO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RSZWYuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RPd25lclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFJlYWN0T3duZXJzIGFyZSBjYXBhYmxlIG9mIHN0b3JpbmcgcmVmZXJlbmNlcyB0byBvd25lZCBjb21wb25lbnRzLlxuICpcbiAqIEFsbCBjb21wb25lbnRzIGFyZSBjYXBhYmxlIG9mIC8vYmVpbmcvLyByZWZlcmVuY2VkIGJ5IG93bmVyIGNvbXBvbmVudHMsIGJ1dFxuICogb25seSBSZWFjdE93bmVyIGNvbXBvbmVudHMgYXJlIGNhcGFibGUgb2YgLy9yZWZlcmVuY2luZy8vIG93bmVkIGNvbXBvbmVudHMuXG4gKiBUaGUgbmFtZWQgcmVmZXJlbmNlIGlzIGtub3duIGFzIGEgXCJyZWZcIi5cbiAqXG4gKiBSZWZzIGFyZSBhdmFpbGFibGUgd2hlbiBtb3VudGVkIGFuZCB1cGRhdGVkIGR1cmluZyByZWNvbmNpbGlhdGlvbi5cbiAqXG4gKiAgIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIChcbiAqICAgICAgICAgPGRpdiBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrfT5cbiAqICAgICAgICAgICA8Q3VzdG9tQ29tcG9uZW50IHJlZj1cImN1c3RvbVwiIC8+XG4gKiAgICAgICAgIDwvZGl2PlxuICogICAgICAgKTtcbiAqICAgICB9LFxuICogICAgIGhhbmRsZUNsaWNrOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHRoaXMucmVmcy5jdXN0b20uaGFuZGxlQ2xpY2soKTtcbiAqICAgICB9LFxuICogICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHRoaXMucmVmcy5jdXN0b20uaW5pdGlhbGl6ZSgpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogUmVmcyBzaG91bGQgcmFyZWx5IGJlIHVzZWQuIFdoZW4gcmVmcyBhcmUgdXNlZCwgdGhleSBzaG91bGQgb25seSBiZSBkb25lIHRvXG4gKiBjb250cm9sIGRhdGEgdGhhdCBpcyBub3QgaGFuZGxlZCBieSBSZWFjdCdzIGRhdGEgZmxvdy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RPd25lclxuICovXG52YXIgUmVhY3RPd25lciA9IHtcblxuICAvKipcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIHZhbGlkIG93bmVyLlxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzVmFsaWRPd25lcjogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiAhIShvYmplY3QgJiYgdHlwZW9mIG9iamVjdC5hdHRhY2hSZWYgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iamVjdC5kZXRhY2hSZWYgPT09ICdmdW5jdGlvbicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY29tcG9uZW50IGJ5IHJlZiB0byBhbiBvd25lciBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gcmVmZXJlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgYnkgd2hpY2ggdG8gcmVmZXIgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtSZWFjdE93bmVyfSBvd25lciBDb21wb25lbnQgb24gd2hpY2ggdG8gcmVjb3JkIHRoZSByZWYuXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFkZENvbXBvbmVudEFzUmVmVG86IGZ1bmN0aW9uIChjb21wb25lbnQsIHJlZiwgb3duZXIpIHtcbiAgICAhUmVhY3RPd25lci5pc1ZhbGlkT3duZXIob3duZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2FkZENvbXBvbmVudEFzUmVmVG8oLi4uKTogT25seSBhIFJlYWN0T3duZXIgY2FuIGhhdmUgcmVmcy4gWW91IG1pZ2h0ICcgKyAnYmUgYWRkaW5nIGEgcmVmIHRvIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBhIGNvbXBvbmVudFxcJ3MgJyArICdgcmVuZGVyYCBtZXRob2QsIG9yIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWQgJyArICcoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIG93bmVyLmF0dGFjaFJlZihyZWYsIGNvbXBvbmVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjb21wb25lbnQgYnkgcmVmIGZyb20gYW4gb3duZXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIGRlcmVmZXJlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgb2YgdGhlIHJlZiB0byByZW1vdmUuXG4gICAqIEBwYXJhbSB7UmVhY3RPd25lcn0gb3duZXIgQ29tcG9uZW50IG9uIHdoaWNoIHRoZSByZWYgaXMgcmVjb3JkZWQuXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlbW92ZUNvbXBvbmVudEFzUmVmRnJvbTogZnVuY3Rpb24gKGNvbXBvbmVudCwgcmVmLCBvd25lcikge1xuICAgICFSZWFjdE93bmVyLmlzVmFsaWRPd25lcihvd25lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tKC4uLik6IE9ubHkgYSBSZWFjdE93bmVyIGNhbiBoYXZlIHJlZnMuIFlvdSBtaWdodCAnICsgJ2JlIHJlbW92aW5nIGEgcmVmIHRvIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBhIGNvbXBvbmVudFxcJ3MgJyArICdgcmVuZGVyYCBtZXRob2QsIG9yIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWQgJyArICcoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIC8vIENoZWNrIHRoYXQgYGNvbXBvbmVudGAgaXMgc3RpbGwgdGhlIGN1cnJlbnQgcmVmIGJlY2F1c2Ugd2UgZG8gbm90IHdhbnQgdG9cbiAgICAvLyBkZXRhY2ggdGhlIHJlZiBpZiBhbm90aGVyIGNvbXBvbmVudCBzdG9sZSBpdC5cbiAgICBpZiAob3duZXIuZ2V0UHVibGljSW5zdGFuY2UoKS5yZWZzW3JlZl0gPT09IGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKSB7XG4gICAgICBvd25lci5kZXRhY2hSZWYocmVmKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE93bmVyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RPd25lci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RVcGRhdGVRdWV1ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpIHtcbiAgUmVhY3RVcGRhdGVzLmVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHB1YmxpY0luc3RhbmNlKTtcbiAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIE9ubHkgd2FybiB3aGVuIHdlIGhhdmUgYSBjYWxsZXJOYW1lLiBPdGhlcndpc2Ugd2Ugc2hvdWxkIGJlIHNpbGVudC5cbiAgICAgIC8vIFdlJ3JlIHByb2JhYmx5IGNhbGxpbmcgZnJvbSBlbnF1ZXVlQ2FsbGJhY2suIFdlIGRvbid0IHdhbnQgdG8gd2FyblxuICAgICAgLy8gdGhlcmUgYmVjYXVzZSB3ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgbGlmZWN5Y2xlIG1ldGhvZC5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjYWxsZXJOYW1lLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiAnICsgJ1RoaXMgaXMgYSBuby1vcC4gUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCwgJyVzKC4uLik6IENhbm5vdCB1cGRhdGUgZHVyaW5nIGFuIGV4aXN0aW5nIHN0YXRlIHRyYW5zaXRpb24gJyArICcoc3VjaCBhcyB3aXRoaW4gYHJlbmRlcmApLiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uICcgKyAnb2YgcHJvcHMgYW5kIHN0YXRlLicsIGNhbGxlck5hbWUpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIGludGVybmFsSW5zdGFuY2U7XG59XG5cbi8qKlxuICogUmVhY3RVcGRhdGVRdWV1ZSBhbGxvd3MgZm9yIHN0YXRlIHVwZGF0ZXMgdG8gYmUgc2NoZWR1bGVkIGludG8gYSBsYXRlclxuICogcmVjb25jaWxpYXRpb24gc3RlcC5cbiAqL1xudmFyIFJlYWN0VXBkYXRlUXVldWUgPSB7XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgICBpZiAob3duZXIgIT09IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcob3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgICBvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHB1YmxpY0luc3RhbmNlKTtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgLy8gRHVyaW5nIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgcmVuZGVyIHRoaXMgd2lsbCBzdGlsbCBiZSBudWxsIGJ1dCBhZnRlclxuICAgICAgLy8gdGhhdCB3aWxsIGFsd2F5cyByZW5kZXIgdG8gc29tZXRoaW5nLiBBdCBsZWFzdCBmb3Igbm93LiBTbyB3ZSBjYW4gdXNlXG4gICAgICAvLyB0aGlzIGhhY2suXG4gICAgICByZXR1cm4gISFpbnRlcm5hbEluc3RhbmNlLl9yZW5kZXJlZENvbXBvbmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBhbGwgdGhlIHBlbmRpbmcgdXBkYXRlc1xuICAgKiBoYXZlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gdXNlIGFzIGB0aGlzYCBjb250ZXh0LlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUNhbGxiYWNrOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrKSB7XG4gICAgISh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2VucXVldWVDYWxsYmFjayguLi4pOiBZb3UgY2FsbGVkIGBzZXRQcm9wc2AsIGByZXBsYWNlUHJvcHNgLCAnICsgJ2BzZXRTdGF0ZWAsIGByZXBsYWNlU3RhdGVgLCBvciBgZm9yY2VVcGRhdGVgIHdpdGggYSBjYWxsYmFjayB0aGF0ICcgKyAnaXNuXFwndCBjYWxsYWJsZS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UpO1xuXG4gICAgLy8gUHJldmlvdXNseSB3ZSB3b3VsZCB0aHJvdyBhbiBlcnJvciBpZiB3ZSBkaWRuJ3QgaGF2ZSBhbiBpbnRlcm5hbFxuICAgIC8vIGluc3RhbmNlLiBTaW5jZSB3ZSB3YW50IHRvIG1ha2UgaXQgYSBuby1vcCBpbnN0ZWFkLCB3ZSBtaXJyb3IgdGhlIHNhbWVcbiAgICAvLyBiZWhhdmlvciB3ZSBoYXZlIGluIG90aGVyIGVucXVldWUqIG1ldGhvZHMuXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIGlnbm9yZSBjYWxsYmFja3MgaW4gY29tcG9uZW50V2lsbE1vdW50LiBTZWVcbiAgICAvLyBlbnF1ZXVlVXBkYXRlcy5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzKSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzID0gW2NhbGxiYWNrXTtcbiAgICB9XG4gICAgLy8gVE9ETzogVGhlIGNhbGxiYWNrIGhlcmUgaXMgaWdub3JlZCB3aGVuIHNldFN0YXRlIGlzIGNhbGxlZCBmcm9tXG4gICAgLy8gY29tcG9uZW50V2lsbE1vdW50LiBFaXRoZXIgZml4IGl0IG9yIGRpc2FsbG93IGRvaW5nIHNvIGNvbXBsZXRlbHkgaW5cbiAgICAvLyBmYXZvciBvZiBnZXRJbml0aWFsU3RhdGUuIEFsdGVybmF0aXZlbHksIHdlIGNhbiBkaXNhbGxvd1xuICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBkdXJpbmcgc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgZW5xdWV1ZUNhbGxiYWNrSW50ZXJuYWw6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBjYWxsYmFjaykge1xuICAgICEodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdlbnF1ZXVlQ2FsbGJhY2soLi4uKTogWW91IGNhbGxlZCBgc2V0UHJvcHNgLCBgcmVwbGFjZVByb3BzYCwgJyArICdgc2V0U3RhdGVgLCBgcmVwbGFjZVN0YXRlYCwgb3IgYGZvcmNlVXBkYXRlYCB3aXRoIGEgY2FsbGJhY2sgdGhhdCAnICsgJ2lzblxcJ3QgY2FsbGFibGUuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzKSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzID0gW2NhbGxiYWNrXTtcbiAgICB9XG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IHRydWU7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gW2NvbXBsZXRlU3RhdGVdO1xuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSB0cnVlO1xuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcXVldWUgPSBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nU3RhdGVRdWV1ZSB8fCAoaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1N0YXRlUXVldWUgPSBbXSk7XG4gICAgcXVldWUucHVzaChwYXJ0aWFsU3RhdGUpO1xuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgcHJvcHMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFByb3BzIFN1YnNldCBvZiB0aGUgbmV4dCBwcm9wcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0UHJvcHM6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFByb3BzKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdzZXRQcm9wcycpO1xuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVTZXRQcm9wc0ludGVybmFsKGludGVybmFsSW5zdGFuY2UsIHBhcnRpYWxQcm9wcyk7XG4gIH0sXG5cbiAgZW5xdWV1ZVNldFByb3BzSW50ZXJuYWw6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBwYXJ0aWFsUHJvcHMpIHtcbiAgICB2YXIgdG9wTGV2ZWxXcmFwcGVyID0gaW50ZXJuYWxJbnN0YW5jZS5fdG9wTGV2ZWxXcmFwcGVyO1xuICAgICF0b3BMZXZlbFdyYXBwZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnc2V0UHJvcHMoLi4uKTogWW91IGNhbGxlZCBgc2V0UHJvcHNgIG9uIGEgJyArICdjb21wb25lbnQgd2l0aCBhIHBhcmVudC4gVGhpcyBpcyBhbiBhbnRpLXBhdHRlcm4gc2luY2UgcHJvcHMgd2lsbCAnICsgJ2dldCByZWFjdGl2ZWx5IHVwZGF0ZWQgd2hlbiByZW5kZXJlZC4gSW5zdGVhZCwgY2hhbmdlIHRoZSBvd25lclxcJ3MgJyArICdgcmVuZGVyYCBtZXRob2QgdG8gcGFzcyB0aGUgY29ycmVjdCB2YWx1ZSBhcyBwcm9wcyB0byB0aGUgY29tcG9uZW50ICcgKyAnd2hlcmUgaXQgaXMgY3JlYXRlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBNZXJnZSB3aXRoIHRoZSBwZW5kaW5nIGVsZW1lbnQgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2Ugd2l0aCBleGlzdGluZ1xuICAgIC8vIGVsZW1lbnQgcHJvcHMuXG4gICAgdmFyIHdyYXBFbGVtZW50ID0gdG9wTGV2ZWxXcmFwcGVyLl9wZW5kaW5nRWxlbWVudCB8fCB0b3BMZXZlbFdyYXBwZXIuX2N1cnJlbnRFbGVtZW50O1xuICAgIHZhciBlbGVtZW50ID0gd3JhcEVsZW1lbnQucHJvcHM7XG4gICAgdmFyIHByb3BzID0gYXNzaWduKHt9LCBlbGVtZW50LnByb3BzLCBwYXJ0aWFsUHJvcHMpO1xuICAgIHRvcExldmVsV3JhcHBlci5fcGVuZGluZ0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlUHJvcHMod3JhcEVsZW1lbnQsIFJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VQcm9wcyhlbGVtZW50LCBwcm9wcykpO1xuXG4gICAgZW5xdWV1ZVVwZGF0ZSh0b3BMZXZlbFdyYXBwZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHByb3BzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzIE5ldyBwcm9wcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVByb3BzOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHByb3BzKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdyZXBsYWNlUHJvcHMnKTtcbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlUmVwbGFjZVByb3BzSW50ZXJuYWwoaW50ZXJuYWxJbnN0YW5jZSwgcHJvcHMpO1xuICB9LFxuXG4gIGVucXVldWVSZXBsYWNlUHJvcHNJbnRlcm5hbDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHByb3BzKSB7XG4gICAgdmFyIHRvcExldmVsV3JhcHBlciA9IGludGVybmFsSW5zdGFuY2UuX3RvcExldmVsV3JhcHBlcjtcbiAgICAhdG9wTGV2ZWxXcmFwcGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3JlcGxhY2VQcm9wcyguLi4pOiBZb3UgY2FsbGVkIGByZXBsYWNlUHJvcHNgIG9uIGEgJyArICdjb21wb25lbnQgd2l0aCBhIHBhcmVudC4gVGhpcyBpcyBhbiBhbnRpLXBhdHRlcm4gc2luY2UgcHJvcHMgd2lsbCAnICsgJ2dldCByZWFjdGl2ZWx5IHVwZGF0ZWQgd2hlbiByZW5kZXJlZC4gSW5zdGVhZCwgY2hhbmdlIHRoZSBvd25lclxcJ3MgJyArICdgcmVuZGVyYCBtZXRob2QgdG8gcGFzcyB0aGUgY29ycmVjdCB2YWx1ZSBhcyBwcm9wcyB0byB0aGUgY29tcG9uZW50ICcgKyAnd2hlcmUgaXQgaXMgY3JlYXRlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBNZXJnZSB3aXRoIHRoZSBwZW5kaW5nIGVsZW1lbnQgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2Ugd2l0aCBleGlzdGluZ1xuICAgIC8vIGVsZW1lbnQgcHJvcHMuXG4gICAgdmFyIHdyYXBFbGVtZW50ID0gdG9wTGV2ZWxXcmFwcGVyLl9wZW5kaW5nRWxlbWVudCB8fCB0b3BMZXZlbFdyYXBwZXIuX2N1cnJlbnRFbGVtZW50O1xuICAgIHZhciBlbGVtZW50ID0gd3JhcEVsZW1lbnQucHJvcHM7XG4gICAgdG9wTGV2ZWxXcmFwcGVyLl9wZW5kaW5nRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VQcm9wcyh3cmFwRWxlbWVudCwgUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZVByb3BzKGVsZW1lbnQsIHByb3BzKSk7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKHRvcExldmVsV3JhcHBlcik7XG4gIH0sXG5cbiAgZW5xdWV1ZUVsZW1lbnRJbnRlcm5hbDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIG5ld0VsZW1lbnQpIHtcbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nRWxlbWVudCA9IG5ld0VsZW1lbnQ7XG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VXBkYXRlUXVldWU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFVwZGF0ZVF1ZXVlLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0VXBkYXRlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENhbGxiYWNrUXVldWUgPSByZXF1aXJlKCcuL0NhbGxiYWNrUXVldWUnKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIGRpcnR5Q29tcG9uZW50cyA9IFtdO1xudmFyIGFzYXBDYWxsYmFja1F1ZXVlID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKTtcbnZhciBhc2FwRW5xdWV1ZWQgPSBmYWxzZTtcblxudmFyIGJhdGNoaW5nU3RyYXRlZ3kgPSBudWxsO1xuXG5mdW5jdGlvbiBlbnN1cmVJbmplY3RlZCgpIHtcbiAgIShSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiAmJiBiYXRjaGluZ1N0cmF0ZWd5KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgaW5qZWN0IGEgcmVjb25jaWxlIHRyYW5zYWN0aW9uIGNsYXNzIGFuZCBiYXRjaGluZyAnICsgJ3N0cmF0ZWd5JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xufVxuXG52YXIgTkVTVEVEX1VQREFURVMgPSB7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IGRpcnR5Q29tcG9uZW50cy5sZW5ndGg7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoICE9PSBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBBZGRpdGlvbmFsIHVwZGF0ZXMgd2VyZSBlbnF1ZXVlZCBieSBjb21wb25lbnREaWRVcGRhdGUgaGFuZGxlcnMgb3JcbiAgICAgIC8vIHNpbWlsYXI7IGJlZm9yZSBvdXIgb3duIFVQREFURV9RVUVVRUlORyB3cmFwcGVyIGNsb3Nlcywgd2Ugd2FudCB0byBydW5cbiAgICAgIC8vIHRoZXNlIG5ldyB1cGRhdGVzIHNvIHRoYXQgaWYgQSdzIGNvbXBvbmVudERpZFVwZGF0ZSBjYWxscyBzZXRTdGF0ZSBvblxuICAgICAgLy8gQiwgQiB3aWxsIHVwZGF0ZSBiZWZvcmUgdGhlIGNhbGxiYWNrIEEncyB1cGRhdGVyIHByb3ZpZGVkIHdoZW4gY2FsbGluZ1xuICAgICAgLy8gc2V0U3RhdGUuXG4gICAgICBkaXJ0eUNvbXBvbmVudHMuc3BsaWNlKDAsIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoKTtcbiAgICAgIGZsdXNoQmF0Y2hlZFVwZGF0ZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlydHlDb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9XG59O1xuXG52YXIgVVBEQVRFX1FVRVVFSU5HID0ge1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlLnJlc2V0KCk7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlLm5vdGlmeUFsbCgpO1xuICB9XG59O1xuXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbTkVTVEVEX1VQREFURVMsIFVQREFURV9RVUVVRUlOR107XG5cbmZ1bmN0aW9uIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24oKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbiAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBudWxsO1xuICB0aGlzLmNhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xuICB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKCAvKiBmb3JjZUhUTUwgKi9mYWxzZSk7XG59XG5cbmFzc2lnbihSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24uTWl4aW4sIHtcbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBudWxsO1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLmNhbGxiYWNrUXVldWUpO1xuICAgIHRoaXMuY2FsbGJhY2tRdWV1ZSA9IG51bGw7XG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucmVsZWFzZSh0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uKTtcbiAgICB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uID0gbnVsbDtcbiAgfSxcblxuICBwZXJmb3JtOiBmdW5jdGlvbiAobWV0aG9kLCBzY29wZSwgYSkge1xuICAgIC8vIEVzc2VudGlhbGx5IGNhbGxzIGB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLnBlcmZvcm0obWV0aG9kLCBzY29wZSwgYSlgXG4gICAgLy8gd2l0aCB0aGlzIHRyYW5zYWN0aW9uJ3Mgd3JhcHBlcnMgYXJvdW5kIGl0LlxuICAgIHJldHVybiBUcmFuc2FjdGlvbi5NaXhpbi5wZXJmb3JtLmNhbGwodGhpcywgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbi5wZXJmb3JtLCB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLCBtZXRob2QsIHNjb3BlLCBhKTtcbiAgfVxufSk7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uKTtcblxuZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpIHtcbiAgZW5zdXJlSW5qZWN0ZWQoKTtcbiAgYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyhjYWxsYmFjaywgYSwgYiwgYywgZCwgZSk7XG59XG5cbi8qKlxuICogQXJyYXkgY29tcGFyYXRvciBmb3IgUmVhY3RDb21wb25lbnRzIGJ5IG1vdW50IG9yZGVyaW5nLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGMxIGZpcnN0IGNvbXBvbmVudCB5b3UncmUgY29tcGFyaW5nXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjMiBzZWNvbmQgY29tcG9uZW50IHlvdSdyZSBjb21wYXJpbmdcbiAqIEByZXR1cm4ge251bWJlcn0gUmV0dXJuIHZhbHVlIHVzYWJsZSBieSBBcnJheS5wcm90b3R5cGUuc29ydCgpLlxuICovXG5mdW5jdGlvbiBtb3VudE9yZGVyQ29tcGFyYXRvcihjMSwgYzIpIHtcbiAgcmV0dXJuIGMxLl9tb3VudE9yZGVyIC0gYzIuX21vdW50T3JkZXI7XG59XG5cbmZ1bmN0aW9uIHJ1bkJhdGNoZWRVcGRhdGVzKHRyYW5zYWN0aW9uKSB7XG4gIHZhciBsZW4gPSB0cmFuc2FjdGlvbi5kaXJ0eUNvbXBvbmVudHNMZW5ndGg7XG4gICEobGVuID09PSBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBmbHVzaCB0cmFuc2FjdGlvblxcJ3Mgc3RvcmVkIGRpcnR5LWNvbXBvbmVudHMgbGVuZ3RoICglcykgdG8gJyArICdtYXRjaCBkaXJ0eS1jb21wb25lbnRzIGFycmF5IGxlbmd0aCAoJXMpLicsIGxlbiwgZGlydHlDb21wb25lbnRzLmxlbmd0aCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIC8vIFNpbmNlIHJlY29uY2lsaW5nIGEgY29tcG9uZW50IGhpZ2hlciBpbiB0aGUgb3duZXIgaGllcmFyY2h5IHVzdWFsbHkgKG5vdFxuICAvLyBhbHdheXMgLS0gc2VlIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpKSB3aWxsIHJlY29uY2lsZSBjaGlsZHJlbiwgcmVjb25jaWxlXG4gIC8vIHRoZW0gYmVmb3JlIHRoZWlyIGNoaWxkcmVuIGJ5IHNvcnRpbmcgdGhlIGFycmF5LlxuICBkaXJ0eUNvbXBvbmVudHMuc29ydChtb3VudE9yZGVyQ29tcGFyYXRvcik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIC8vIElmIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBiZWZvcmUgcGVuZGluZyBjaGFuZ2VzIGFwcGx5LCBpdCB3aWxsIHN0aWxsXG4gICAgLy8gYmUgaGVyZSwgYnV0IHdlIGFzc3VtZSB0aGF0IGl0IGhhcyBjbGVhcmVkIGl0cyBfcGVuZGluZ0NhbGxiYWNrcyBhbmRcbiAgICAvLyB0aGF0IHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSBpcyBhIG5vb3AuXG4gICAgdmFyIGNvbXBvbmVudCA9IGRpcnR5Q29tcG9uZW50c1tpXTtcblxuICAgIC8vIElmIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSBoYXBwZW5zIHRvIGVucXVldWUgYW55IG5ldyB1cGRhdGVzLCB3ZVxuICAgIC8vIHNob3VsZG4ndCBleGVjdXRlIHRoZSBjYWxsYmFja3MgdW50aWwgdGhlIG5leHQgcmVuZGVyIGhhcHBlbnMsIHNvXG4gICAgLy8gc3Rhc2ggdGhlIGNhbGxiYWNrcyBmaXJzdFxuICAgIHZhciBjYWxsYmFja3MgPSBjb21wb25lbnQuX3BlbmRpbmdDYWxsYmFja3M7XG4gICAgY29tcG9uZW50Ll9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcblxuICAgIFJlYWN0UmVjb25jaWxlci5wZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkoY29tcG9uZW50LCB0cmFuc2FjdGlvbi5yZWNvbmNpbGVUcmFuc2FjdGlvbik7XG5cbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNhbGxiYWNrcy5sZW5ndGg7IGorKykge1xuICAgICAgICB0cmFuc2FjdGlvbi5jYWxsYmFja1F1ZXVlLmVucXVldWUoY2FsbGJhY2tzW2pdLCBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBmbHVzaEJhdGNoZWRVcGRhdGVzID0gZnVuY3Rpb24gKCkge1xuICAvLyBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uJ3Mgd3JhcHBlcnMgd2lsbCBjbGVhciB0aGUgZGlydHlDb21wb25lbnRzXG4gIC8vIGFycmF5IGFuZCBwZXJmb3JtIGFueSB1cGRhdGVzIGVucXVldWVkIGJ5IG1vdW50LXJlYWR5IGhhbmRsZXJzIChpLmUuLFxuICAvLyBjb21wb25lbnREaWRVcGRhdGUpIGJ1dCB3ZSBuZWVkIHRvIGNoZWNrIGhlcmUgdG9vIGluIG9yZGVyIHRvIGNhdGNoXG4gIC8vIHVwZGF0ZXMgZW5xdWV1ZWQgYnkgc2V0U3RhdGUgY2FsbGJhY2tzIGFuZCBhc2FwIGNhbGxzLlxuICB3aGlsZSAoZGlydHlDb21wb25lbnRzLmxlbmd0aCB8fCBhc2FwRW5xdWV1ZWQpIHtcbiAgICBpZiAoZGlydHlDb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgdmFyIHRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5nZXRQb29sZWQoKTtcbiAgICAgIHRyYW5zYWN0aW9uLnBlcmZvcm0ocnVuQmF0Y2hlZFVwZGF0ZXMsIG51bGwsIHRyYW5zYWN0aW9uKTtcbiAgICAgIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGFzYXBFbnF1ZXVlZCkge1xuICAgICAgYXNhcEVucXVldWVkID0gZmFsc2U7XG4gICAgICB2YXIgcXVldWUgPSBhc2FwQ2FsbGJhY2tRdWV1ZTtcbiAgICAgIGFzYXBDYWxsYmFja1F1ZXVlID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKTtcbiAgICAgIHF1ZXVlLm5vdGlmeUFsbCgpO1xuICAgICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHF1ZXVlKTtcbiAgICB9XG4gIH1cbn07XG5mbHVzaEJhdGNoZWRVcGRhdGVzID0gUmVhY3RQZXJmLm1lYXN1cmUoJ1JlYWN0VXBkYXRlcycsICdmbHVzaEJhdGNoZWRVcGRhdGVzJywgZmx1c2hCYXRjaGVkVXBkYXRlcyk7XG5cbi8qKlxuICogTWFyayBhIGNvbXBvbmVudCBhcyBuZWVkaW5nIGEgcmVyZW5kZXIsIGFkZGluZyBhbiBvcHRpb25hbCBjYWxsYmFjayB0byBhXG4gKiBsaXN0IG9mIGZ1bmN0aW9ucyB3aGljaCB3aWxsIGJlIGV4ZWN1dGVkIG9uY2UgdGhlIHJlcmVuZGVyIG9jY3Vycy5cbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShjb21wb25lbnQpIHtcbiAgZW5zdXJlSW5qZWN0ZWQoKTtcblxuICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgLy8gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCkgYXNzdW1lIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFyZW4ndCBuZXN0ZWQ7XG4gIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS4gKFRoaXMgaXMgY2FsbGVkIGJ5IGVhY2ggdG9wLWxldmVsIHVwZGF0ZVxuICAvLyBmdW5jdGlvbiwgbGlrZSBzZXRQcm9wcywgc2V0U3RhdGUsIGZvcmNlVXBkYXRlLCBldGMuOyBjcmVhdGlvbiBhbmRcbiAgLy8gZGVzdHJ1Y3Rpb24gb2YgdG9wLWxldmVsIGNvbXBvbmVudHMgaXMgZ3VhcmRlZCBpbiBSZWFjdE1vdW50LilcblxuICBpZiAoIWJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICBiYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzKGVucXVldWVVcGRhdGUsIGNvbXBvbmVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGlydHlDb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbn1cblxuLyoqXG4gKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdG8gYmUgcnVuIGF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYmF0Y2hpbmcgY3ljbGUuIFRocm93c1xuICogaWYgbm8gdXBkYXRlcyBhcmUgY3VycmVudGx5IGJlaW5nIHBlcmZvcm1lZC5cbiAqL1xuZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgY29udGV4dCkge1xuICAhYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXMuYXNhcDogQ2FuXFwndCBlbnF1ZXVlIGFuIGFzYXAgY2FsbGJhY2sgaW4gYSBjb250ZXh0IHdoZXJlJyArICd1cGRhdGVzIGFyZSBub3QgYmVpbmcgYmF0Y2hlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIGFzYXBDYWxsYmFja1F1ZXVlLmVucXVldWUoY2FsbGJhY2ssIGNvbnRleHQpO1xuICBhc2FwRW5xdWV1ZWQgPSB0cnVlO1xufVxuXG52YXIgUmVhY3RVcGRhdGVzSW5qZWN0aW9uID0ge1xuICBpbmplY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjogZnVuY3Rpb24gKFJlY29uY2lsZVRyYW5zYWN0aW9uKSB7XG4gICAgIVJlY29uY2lsZVRyYW5zYWN0aW9uID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGEgcmVjb25jaWxlIHRyYW5zYWN0aW9uIGNsYXNzJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uID0gUmVjb25jaWxlVHJhbnNhY3Rpb247XG4gIH0sXG5cbiAgaW5qZWN0QmF0Y2hpbmdTdHJhdGVneTogZnVuY3Rpb24gKF9iYXRjaGluZ1N0cmF0ZWd5KSB7XG4gICAgIV9iYXRjaGluZ1N0cmF0ZWd5ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGEgYmF0Y2hpbmcgc3RyYXRlZ3knKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgISh0eXBlb2YgX2JhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMgPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGEgYmF0Y2hlZFVwZGF0ZXMoKSBmdW5jdGlvbicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAhKHR5cGVvZiBfYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9PT0gJ2Jvb2xlYW4nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhbiBpc0JhdGNoaW5nVXBkYXRlcyBib29sZWFuIGF0dHJpYnV0ZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBiYXRjaGluZ1N0cmF0ZWd5ID0gX2JhdGNoaW5nU3RyYXRlZ3k7XG4gIH1cbn07XG5cbnZhciBSZWFjdFVwZGF0ZXMgPSB7XG4gIC8qKlxuICAgKiBSZWFjdCByZWZlcmVuY2VzIGBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uYCB1c2luZyB0aGlzIHByb3BlcnR5IGluIG9yZGVyXG4gICAqIHRvIGFsbG93IGRlcGVuZGVuY3kgaW5qZWN0aW9uLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb246IG51bGwsXG5cbiAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuICBlbnF1ZXVlVXBkYXRlOiBlbnF1ZXVlVXBkYXRlLFxuICBmbHVzaEJhdGNoZWRVcGRhdGVzOiBmbHVzaEJhdGNoZWRVcGRhdGVzLFxuICBpbmplY3Rpb246IFJlYWN0VXBkYXRlc0luamVjdGlvbixcbiAgYXNhcDogYXNhcFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFVwZGF0ZXM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFVwZGF0ZXMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ2FsbGJhY2tRdWV1ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCBwc2V1ZG8tZXZlbnQgbW9kdWxlIHRvIGhlbHAga2VlcCB0cmFjayBvZiBjb21wb25lbnRzIHdhaXRpbmcgdG9cbiAqIGJlIG5vdGlmaWVkIHdoZW4gdGhlaXIgRE9NIHJlcHJlc2VudGF0aW9ucyBhcmUgYXZhaWxhYmxlIGZvciB1c2UuXG4gKlxuICogVGhpcyBpbXBsZW1lbnRzIGBQb29sZWRDbGFzc2AsIHNvIHlvdSBzaG91bGQgbmV2ZXIgbmVlZCB0byBpbnN0YW50aWF0ZSB0aGlzLlxuICogSW5zdGVhZCwgdXNlIGBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpYC5cbiAqXG4gKiBAY2xhc3MgUmVhY3RNb3VudFJlYWR5XG4gKiBAaW1wbGVtZW50cyBQb29sZWRDbGFzc1xuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIENhbGxiYWNrUXVldWUoKSB7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbn1cblxuYXNzaWduKENhbGxiYWNrUXVldWUucHJvdG90eXBlLCB7XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGBub3RpZnlBbGxgIGlzIGludm9rZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIEludm9rZWQgd2hlbiBgbm90aWZ5QWxsYCBpcyBpbnZva2VkLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IGNvbnRleHQgQ29udGV4dCB0byBjYWxsIGBjYWxsYmFja2Agd2l0aC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwgW107XG4gICAgdGhpcy5fY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cyB8fCBbXTtcbiAgICB0aGlzLl9jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgdGhpcy5fY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlcyBhbGwgZW5xdWV1ZWQgY2FsbGJhY2tzIGFuZCBjbGVhcnMgdGhlIHF1ZXVlLiBUaGlzIGlzIGludm9rZWQgYWZ0ZXJcbiAgICogdGhlIERPTSByZXByZXNlbnRhdGlvbiBvZiBhIGNvbXBvbmVudCBoYXMgYmVlbiBjcmVhdGVkIG9yIHVwZGF0ZWQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbm90aWZ5QWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcztcbiAgICB2YXIgY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cztcbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAhKGNhbGxiYWNrcy5sZW5ndGggPT09IGNvbnRleHRzLmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTWlzbWF0Y2hlZCBsaXN0IG9mIGNvbnRleHRzIGluIGNhbGxiYWNrIHF1ZXVlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgICAgIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKGNvbnRleHRzW2ldKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgICAgY29udGV4dHMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgaW50ZXJuYWwgcXVldWUuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxufSk7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhDYWxsYmFja1F1ZXVlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYWxsYmFja1F1ZXVlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvQ2FsbGJhY2tRdWV1ZS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBQb29sZWRDbGFzc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFN0YXRpYyBwb29sZXJzLiBTZXZlcmFsIGN1c3RvbSB2ZXJzaW9ucyBmb3IgZWFjaCBwb3RlbnRpYWwgbnVtYmVyIG9mXG4gKiBhcmd1bWVudHMuIEEgY29tcGxldGVseSBnZW5lcmljIHBvb2xlciBpcyBlYXN5IHRvIGltcGxlbWVudCwgYnV0IHdvdWxkXG4gKiByZXF1aXJlIGFjY2Vzc2luZyB0aGUgYGFyZ3VtZW50c2Agb2JqZWN0LiBJbiBlYWNoIG9mIHRoZXNlLCBgdGhpc2AgcmVmZXJzIHRvXG4gKiB0aGUgQ2xhc3MgaXRzZWxmLCBub3QgYW4gaW5zdGFuY2UuIElmIGFueSBvdGhlcnMgYXJlIG5lZWRlZCwgc2ltcGx5IGFkZCB0aGVtXG4gKiBoZXJlLCBvciBpbiB0aGVpciBvd24gZmlsZXMuXG4gKi9cbnZhciBvbmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChjb3B5RmllbGRzRnJvbSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBjb3B5RmllbGRzRnJvbSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoY29weUZpZWxkc0Zyb20pO1xuICB9XG59O1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMik7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyKTtcbiAgfVxufTtcblxudmFyIHRocmVlQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMykge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzKTtcbiAgfVxufTtcblxudmFyIGZvdXJBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMywgYTQpO1xuICB9XG59O1xuXG52YXIgZml2ZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCwgYTUpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMsIGE0LCBhNSk7XG4gIH1cbn07XG5cbnZhciBzdGFuZGFyZFJlbGVhc2VyID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gICEoaW5zdGFuY2UgaW5zdGFuY2VvZiBLbGFzcykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJ5aW5nIHRvIHJlbGVhc2UgYW4gaW5zdGFuY2UgaW50byBhIHBvb2wgb2YgYSBkaWZmZXJlbnQgdHlwZS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIGluc3RhbmNlLmRlc3RydWN0b3IoKTtcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGggPCBLbGFzcy5wb29sU2l6ZSkge1xuICAgIEtsYXNzLmluc3RhbmNlUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufTtcblxudmFyIERFRkFVTFRfUE9PTF9TSVpFID0gMTA7XG52YXIgREVGQVVMVF9QT09MRVIgPSBvbmVBcmd1bWVudFBvb2xlcjtcblxuLyoqXG4gKiBBdWdtZW50cyBgQ29weUNvbnN0cnVjdG9yYCB0byBiZSBhIHBvb2xhYmxlIGNsYXNzLCBhdWdtZW50aW5nIG9ubHkgdGhlIGNsYXNzXG4gKiBpdHNlbGYgKHN0YXRpY2FsbHkpIG5vdCBhZGRpbmcgYW55IHByb3RvdHlwaWNhbCBmaWVsZHMuIEFueSBDb3B5Q29uc3RydWN0b3JcbiAqIHlvdSBnaXZlIHRoaXMgbWF5IGhhdmUgYSBgcG9vbFNpemVgIHByb3BlcnR5LCBhbmQgd2lsbCBsb29rIGZvciBhXG4gKiBwcm90b3R5cGljYWwgYGRlc3RydWN0b3JgIG9uIGluc3RhbmNlcyAob3B0aW9uYWwpLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IENvcHlDb25zdHJ1Y3RvciBDb25zdHJ1Y3RvciB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlc2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcG9vbGVyIEN1c3RvbWl6YWJsZSBwb29sZXIuXG4gKi9cbnZhciBhZGRQb29saW5nVG8gPSBmdW5jdGlvbiAoQ29weUNvbnN0cnVjdG9yLCBwb29sZXIpIHtcbiAgdmFyIE5ld0tsYXNzID0gQ29weUNvbnN0cnVjdG9yO1xuICBOZXdLbGFzcy5pbnN0YW5jZVBvb2wgPSBbXTtcbiAgTmV3S2xhc3MuZ2V0UG9vbGVkID0gcG9vbGVyIHx8IERFRkFVTFRfUE9PTEVSO1xuICBpZiAoIU5ld0tsYXNzLnBvb2xTaXplKSB7XG4gICAgTmV3S2xhc3MucG9vbFNpemUgPSBERUZBVUxUX1BPT0xfU0laRTtcbiAgfVxuICBOZXdLbGFzcy5yZWxlYXNlID0gc3RhbmRhcmRSZWxlYXNlcjtcbiAgcmV0dXJuIE5ld0tsYXNzO1xufTtcblxudmFyIFBvb2xlZENsYXNzID0ge1xuICBhZGRQb29saW5nVG86IGFkZFBvb2xpbmdUbyxcbiAgb25lQXJndW1lbnRQb29sZXI6IG9uZUFyZ3VtZW50UG9vbGVyLFxuICB0d29Bcmd1bWVudFBvb2xlcjogdHdvQXJndW1lbnRQb29sZXIsXG4gIHRocmVlQXJndW1lbnRQb29sZXI6IHRocmVlQXJndW1lbnRQb29sZXIsXG4gIGZvdXJBcmd1bWVudFBvb2xlcjogZm91ckFyZ3VtZW50UG9vbGVyLFxuICBmaXZlQXJndW1lbnRQb29sZXI6IGZpdmVBcmd1bWVudFBvb2xlclxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb29sZWRDbGFzcztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1Bvb2xlZENsYXNzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFRyYW5zYWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogYFRyYW5zYWN0aW9uYCBjcmVhdGVzIGEgYmxhY2sgYm94IHRoYXQgaXMgYWJsZSB0byB3cmFwIGFueSBtZXRob2Qgc3VjaCB0aGF0XG4gKiBjZXJ0YWluIGludmFyaWFudHMgYXJlIG1haW50YWluZWQgYmVmb3JlIGFuZCBhZnRlciB0aGUgbWV0aG9kIGlzIGludm9rZWRcbiAqIChFdmVuIGlmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gd2hpbGUgaW52b2tpbmcgdGhlIHdyYXBwZWQgbWV0aG9kKS4gV2hvZXZlclxuICogaW5zdGFudGlhdGVzIGEgdHJhbnNhY3Rpb24gY2FuIHByb3ZpZGUgZW5mb3JjZXJzIG9mIHRoZSBpbnZhcmlhbnRzIGF0XG4gKiBjcmVhdGlvbiB0aW1lLiBUaGUgYFRyYW5zYWN0aW9uYCBjbGFzcyBpdHNlbGYgd2lsbCBzdXBwbHkgb25lIGFkZGl0aW9uYWxcbiAqIGF1dG9tYXRpYyBpbnZhcmlhbnQgZm9yIHlvdSAtIHRoZSBpbnZhcmlhbnQgdGhhdCBhbnkgdHJhbnNhY3Rpb24gaW5zdGFuY2VcbiAqIHNob3VsZCBub3QgYmUgcnVuIHdoaWxlIGl0IGlzIGFscmVhZHkgYmVpbmcgcnVuLiBZb3Ugd291bGQgdHlwaWNhbGx5IGNyZWF0ZSBhXG4gKiBzaW5nbGUgaW5zdGFuY2Ugb2YgYSBgVHJhbnNhY3Rpb25gIGZvciByZXVzZSBtdWx0aXBsZSB0aW1lcywgdGhhdCBwb3RlbnRpYWxseVxuICogaXMgdXNlZCB0byB3cmFwIHNldmVyYWwgZGlmZmVyZW50IG1ldGhvZHMuIFdyYXBwZXJzIGFyZSBleHRyZW1lbHkgc2ltcGxlIC1cbiAqIHRoZXkgb25seSByZXF1aXJlIGltcGxlbWVudGluZyB0d28gbWV0aG9kcy5cbiAqXG4gKiA8cHJlPlxuICogICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXJzIChpbmplY3RlZCBhdCBjcmVhdGlvbiB0aW1lKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgICAgICAgICtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tK1xuICogICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgIHYgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgICAgKy0tLS0tLS0tLS0tLS0tLSsgICB8ICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICstLXwgICAgd3JhcHBlcjEgICB8LS0tfC0tLS0rICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICArLS0tLS0tLS0tLS0tLS0tKyAgIHYgICAgfCAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgICAgICArLS0tLS0tLS0tLS0tLSsgIHwgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgICstLS0tfCAgIHdyYXBwZXIyICB8LS0tLS0tLS0rICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICB8ICAgICstLS0tLS0tLS0tLS0tKyAgfCAgICAgfCAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgfCAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHYgICAgIHYgICAgICAgICAgICAgICAgICAgICB2ICAgICB2ICAgfCB3cmFwcGVyXG4gKiAgICAgICAgICAgICAgICAgICAgfCArLS0tKyArLS0tKyAgICstLS0tLS0tLS0rICAgKy0tLSsgKy0tLSsgfCBpbnZhcmlhbnRzXG4gKiBwZXJmb3JtKGFueU1ldGhvZCkgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfCBtYWludGFpbmVkXG4gKiArLS0tLS0tLS0tLS0tLS0tLS0+fC18LS0tfC18LS0tfC0tPnxhbnlNZXRob2R8LS0tfC0tLXwtfC0tLXwtfC0tLS0tLS0tPlxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgKy0tLSsgKy0tLSsgICArLS0tLS0tLS0tKyAgICstLS0rICstLS0rIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICBpbml0aWFsaXplICAgICAgICAgICAgICAgICAgICBjbG9zZSAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICogPC9wcmU+XG4gKlxuICogVXNlIGNhc2VzOlxuICogLSBQcmVzZXJ2aW5nIHRoZSBpbnB1dCBzZWxlY3Rpb24gcmFuZ2VzIGJlZm9yZS9hZnRlciByZWNvbmNpbGlhdGlvbi5cbiAqICAgUmVzdG9yaW5nIHNlbGVjdGlvbiBldmVuIGluIHRoZSBldmVudCBvZiBhbiB1bmV4cGVjdGVkIGVycm9yLlxuICogLSBEZWFjdGl2YXRpbmcgZXZlbnRzIHdoaWxlIHJlYXJyYW5naW5nIHRoZSBET00sIHByZXZlbnRpbmcgYmx1cnMvZm9jdXNlcyxcbiAqICAgd2hpbGUgZ3VhcmFudGVlaW5nIHRoYXQgYWZ0ZXJ3YXJkcywgdGhlIGV2ZW50IHN5c3RlbSBpcyByZWFjdGl2YXRlZC5cbiAqIC0gRmx1c2hpbmcgYSBxdWV1ZSBvZiBjb2xsZWN0ZWQgRE9NIG11dGF0aW9ucyB0byB0aGUgbWFpbiBVSSB0aHJlYWQgYWZ0ZXIgYVxuICogICByZWNvbmNpbGlhdGlvbiB0YWtlcyBwbGFjZSBpbiBhIHdvcmtlciB0aHJlYWQuXG4gKiAtIEludm9raW5nIGFueSBjb2xsZWN0ZWQgYGNvbXBvbmVudERpZFVwZGF0ZWAgY2FsbGJhY2tzIGFmdGVyIHJlbmRlcmluZyBuZXdcbiAqICAgY29udGVudC5cbiAqIC0gKEZ1dHVyZSB1c2UgY2FzZSk6IFdyYXBwaW5nIHBhcnRpY3VsYXIgZmx1c2hlcyBvZiB0aGUgYFJlYWN0V29ya2VyYCBxdWV1ZVxuICogICB0byBwcmVzZXJ2ZSB0aGUgYHNjcm9sbFRvcGAgKGFuIGF1dG9tYXRpYyBzY3JvbGwgYXdhcmUgRE9NKS5cbiAqIC0gKEZ1dHVyZSB1c2UgY2FzZSk6IExheW91dCBjYWxjdWxhdGlvbnMgYmVmb3JlIGFuZCBhZnRlciBET00gdXBkYXRlcy5cbiAqXG4gKiBUcmFuc2FjdGlvbmFsIHBsdWdpbiBBUEk6XG4gKiAtIEEgbW9kdWxlIHRoYXQgaGFzIGFuIGBpbml0aWFsaXplYCBtZXRob2QgdGhhdCByZXR1cm5zIGFueSBwcmVjb21wdXRhdGlvbi5cbiAqIC0gYW5kIGEgYGNsb3NlYCBtZXRob2QgdGhhdCBhY2NlcHRzIHRoZSBwcmVjb21wdXRhdGlvbi4gYGNsb3NlYCBpcyBpbnZva2VkXG4gKiAgIHdoZW4gdGhlIHdyYXBwZWQgcHJvY2VzcyBpcyBjb21wbGV0ZWQsIG9yIGhhcyBmYWlsZWQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxUcmFuc2FjdGlvbmFsV3JhcHBlcj59IHRyYW5zYWN0aW9uV3JhcHBlciBXcmFwcGVyIG1vZHVsZXNcbiAqIHRoYXQgaW1wbGVtZW50IGBpbml0aWFsaXplYCBhbmQgYGNsb3NlYC5cbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSBTaW5nbGUgdHJhbnNhY3Rpb24gZm9yIHJldXNlIGluIHRocmVhZC5cbiAqXG4gKiBAY2xhc3MgVHJhbnNhY3Rpb25cbiAqL1xudmFyIE1peGluID0ge1xuICAvKipcbiAgICogU2V0cyB1cCB0aGlzIGluc3RhbmNlIHNvIHRoYXQgaXQgaXMgcHJlcGFyZWQgZm9yIGNvbGxlY3RpbmcgbWV0cmljcy4gRG9lc1xuICAgKiBzbyBzdWNoIHRoYXQgdGhpcyBzZXR1cCBtZXRob2QgbWF5IGJlIHVzZWQgb24gYW4gaW5zdGFuY2UgdGhhdCBpcyBhbHJlYWR5XG4gICAqIGluaXRpYWxpemVkLCBpbiBhIHdheSB0aGF0IGRvZXMgbm90IGNvbnN1bWUgYWRkaXRpb25hbCBtZW1vcnkgdXBvbiByZXVzZS5cbiAgICogVGhhdCBjYW4gYmUgdXNlZnVsIGlmIHlvdSBkZWNpZGUgdG8gbWFrZSB5b3VyIHN1YmNsYXNzIG9mIHRoaXMgbWl4aW4gYVxuICAgKiBcIlBvb2xlZENsYXNzXCIuXG4gICAqL1xuICByZWluaXRpYWxpemVUcmFuc2FjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25XcmFwcGVycygpO1xuICAgIGlmICh0aGlzLndyYXBwZXJJbml0RGF0YSkge1xuICAgICAgdGhpcy53cmFwcGVySW5pdERhdGEubGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53cmFwcGVySW5pdERhdGEgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gIH0sXG5cbiAgX2lzSW5UcmFuc2FjdGlvbjogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtBcnJheTxUcmFuc2FjdGlvbldyYXBwZXI+fSBBcnJheSBvZiB0cmFuc2FjdGlvbiB3cmFwcGVycy5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IG51bGwsXG5cbiAgaXNJblRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5faXNJblRyYW5zYWN0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgZnVuY3Rpb24gd2l0aGluIGEgc2FmZXR5IHdpbmRvdy4gVXNlIHRoaXMgZm9yIHRoZSB0b3AgbGV2ZWxcbiAgICogbWV0aG9kcyB0aGF0IHJlc3VsdCBpbiBsYXJnZSBhbW91bnRzIG9mIGNvbXB1dGF0aW9uL211dGF0aW9ucyB0aGF0IHdvdWxkXG4gICAqIG5lZWQgdG8gYmUgc2FmZXR5IGNoZWNrZWQuIFRoZSBvcHRpb25hbCBhcmd1bWVudHMgaGVscHMgcHJldmVudCB0aGUgbmVlZFxuICAgKiB0byBiaW5kIGluIG1hbnkgY2FzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZW1iZXIgb2Ygc2NvcGUgdG8gY2FsbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIFNjb3BlIHRvIGludm9rZSBmcm9tLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBhIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gYiBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGMgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBkIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gZSBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGYgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKlxuICAgKiBAcmV0dXJuIHsqfSBSZXR1cm4gdmFsdWUgZnJvbSBgbWV0aG9kYC5cbiAgICovXG4gIHBlcmZvcm06IGZ1bmN0aW9uIChtZXRob2QsIHNjb3BlLCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgISF0aGlzLmlzSW5UcmFuc2FjdGlvbigpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyYW5zYWN0aW9uLnBlcmZvcm0oLi4uKTogQ2Fubm90IGluaXRpYWxpemUgYSB0cmFuc2FjdGlvbiB3aGVuIHRoZXJlICcgKyAnaXMgYWxyZWFkeSBhbiBvdXRzdGFuZGluZyB0cmFuc2FjdGlvbi4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGVycm9yVGhyb3duO1xuICAgIHZhciByZXQ7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2lzSW5UcmFuc2FjdGlvbiA9IHRydWU7XG4gICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoXG4gICAgICAvLyBlcnJvclRocm93biBzZXQgdG8gdHJ1ZSBiZWZvcmUgc2V0dGluZyBpdCB0byBmYWxzZSBhZnRlciBjYWxsaW5nXG4gICAgICAvLyBjbG9zZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byB0cnVlIGluIHRoZSBmaW5hbGx5IGJsb2NrLCBpdCBtZWFuc1xuICAgICAgLy8gb25lIG9mIHRoZXNlIGNhbGxzIHRocmV3LlxuICAgICAgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgdGhpcy5pbml0aWFsaXplQWxsKDApO1xuICAgICAgcmV0ID0gbWV0aG9kLmNhbGwoc2NvcGUsIGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgLy8gSWYgYG1ldGhvZGAgdGhyb3dzLCBwcmVmZXIgdG8gc2hvdyB0aGF0IHN0YWNrIHRyYWNlIG92ZXIgYW55IHRocm93blxuICAgICAgICAgIC8vIGJ5IGludm9raW5nIGBjbG9zZUFsbGAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VBbGwoMCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNpbmNlIGBtZXRob2RgIGRpZG4ndCB0aHJvdywgd2UgZG9uJ3Qgd2FudCB0byBzaWxlbmNlIHRoZSBleGNlcHRpb25cbiAgICAgICAgICAvLyBoZXJlLlxuICAgICAgICAgIHRoaXMuY2xvc2VBbGwoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuX2lzSW5UcmFuc2FjdGlvbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIGluaXRpYWxpemVBbGw6IGZ1bmN0aW9uIChzdGFydEluZGV4KSB7XG4gICAgdmFyIHRyYW5zYWN0aW9uV3JhcHBlcnMgPSB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnM7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCB0cmFuc2FjdGlvbldyYXBwZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd3JhcHBlciA9IHRyYW5zYWN0aW9uV3JhcHBlcnNbaV07XG4gICAgICB0cnkge1xuICAgICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoIHRoZVxuICAgICAgICAvLyBPQlNFUlZFRF9FUlJPUiBzdGF0ZSBiZWZvcmUgb3ZlcndyaXRpbmcgaXQgd2l0aCB0aGUgcmVhbCByZXR1cm4gdmFsdWVcbiAgICAgICAgLy8gb2YgaW5pdGlhbGl6ZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byBPQlNFUlZFRF9FUlJPUiBpbiB0aGUgZmluYWxseVxuICAgICAgICAvLyBibG9jaywgaXQgbWVhbnMgd3JhcHBlci5pbml0aWFsaXplIHRocmV3LlxuICAgICAgICB0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9IFRyYW5zYWN0aW9uLk9CU0VSVkVEX0VSUk9SO1xuICAgICAgICB0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9IHdyYXBwZXIuaW5pdGlhbGl6ZSA/IHdyYXBwZXIuaW5pdGlhbGl6ZS5jYWxsKHRoaXMpIDogbnVsbDtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9PT0gVHJhbnNhY3Rpb24uT0JTRVJWRURfRVJST1IpIHtcbiAgICAgICAgICAvLyBUaGUgaW5pdGlhbGl6ZXIgZm9yIHdyYXBwZXIgaSB0aHJldyBhbiBlcnJvcjsgaW5pdGlhbGl6ZSB0aGVcbiAgICAgICAgICAvLyByZW1haW5pbmcgd3JhcHBlcnMgYnV0IHNpbGVuY2UgYW55IGV4Y2VwdGlvbnMgZnJvbSB0aGVtIHRvIGVuc3VyZVxuICAgICAgICAgIC8vIHRoYXQgdGhlIGZpcnN0IGVycm9yIGlzIHRoZSBvbmUgdG8gYnViYmxlIHVwLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVBbGwoaSArIDEpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlcyBlYWNoIG9mIGB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMuY2xvc2VbaV1gIGZ1bmN0aW9ucywgcGFzc2luZyBpbnRvXG4gICAqIHRoZW0gdGhlIHJlc3BlY3RpdmUgcmV0dXJuIHZhbHVlcyBvZiBgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzLmluaXRbaV1gXG4gICAqIChgY2xvc2VgcnMgdGhhdCBjb3JyZXNwb25kIHRvIGluaXRpYWxpemVycyB0aGF0IGZhaWxlZCB3aWxsIG5vdCBiZVxuICAgKiBpbnZva2VkKS5cbiAgICovXG4gIGNsb3NlQWxsOiBmdW5jdGlvbiAoc3RhcnRJbmRleCkge1xuICAgICF0aGlzLmlzSW5UcmFuc2FjdGlvbigpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyYW5zYWN0aW9uLmNsb3NlQWxsKCk6IENhbm5vdCBjbG9zZSB0cmFuc2FjdGlvbiB3aGVuIG5vbmUgYXJlIG9wZW4uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHZhciB0cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgdHJhbnNhY3Rpb25XcmFwcGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdyYXBwZXIgPSB0cmFuc2FjdGlvbldyYXBwZXJzW2ldO1xuICAgICAgdmFyIGluaXREYXRhID0gdGhpcy53cmFwcGVySW5pdERhdGFbaV07XG4gICAgICB2YXIgZXJyb3JUaHJvd247XG4gICAgICB0cnkge1xuICAgICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoXG4gICAgICAgIC8vIGVycm9yVGhyb3duIHNldCB0byB0cnVlIGJlZm9yZSBzZXR0aW5nIGl0IHRvIGZhbHNlIGFmdGVyIGNhbGxpbmdcbiAgICAgICAgLy8gY2xvc2UgLS0gaWYgaXQncyBzdGlsbCBzZXQgdG8gdHJ1ZSBpbiB0aGUgZmluYWxseSBibG9jaywgaXQgbWVhbnNcbiAgICAgICAgLy8gd3JhcHBlci5jbG9zZSB0aHJldy5cbiAgICAgICAgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICBpZiAoaW5pdERhdGEgIT09IFRyYW5zYWN0aW9uLk9CU0VSVkVEX0VSUk9SICYmIHdyYXBwZXIuY2xvc2UpIHtcbiAgICAgICAgICB3cmFwcGVyLmNsb3NlLmNhbGwodGhpcywgaW5pdERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAvLyBUaGUgY2xvc2VyIGZvciB3cmFwcGVyIGkgdGhyZXcgYW4gZXJyb3I7IGNsb3NlIHRoZSByZW1haW5pbmdcbiAgICAgICAgICAvLyB3cmFwcGVycyBidXQgc2lsZW5jZSBhbnkgZXhjZXB0aW9ucyBmcm9tIHRoZW0gdG8gZW5zdXJlIHRoYXQgdGhlXG4gICAgICAgICAgLy8gZmlyc3QgZXJyb3IgaXMgdGhlIG9uZSB0byBidWJibGUgdXAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VBbGwoaSArIDEpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy53cmFwcGVySW5pdERhdGEubGVuZ3RoID0gMDtcbiAgfVxufTtcblxudmFyIFRyYW5zYWN0aW9uID0ge1xuXG4gIE1peGluOiBNaXhpbixcblxuICAvKipcbiAgICogVG9rZW4gdG8gbG9vayBmb3IgdG8gZGV0ZXJtaW5lIGlmIGFuIGVycm9yIG9jY3VycmVkLlxuICAgKi9cbiAgT0JTRVJWRURfRVJST1I6IHt9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNhY3Rpb247XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9UcmFuc2FjdGlvbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlbXB0eU9iamVjdFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5T2JqZWN0O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9lbXB0eU9iamVjdC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjb250YWluc05vZGVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNUZXh0Tm9kZSA9IHJlcXVpcmUoJy4vaXNUZXh0Tm9kZScpO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBET00gbm9kZSBjb250YWlucyBvciBpcyBhbm90aGVyIERPTSBub2RlLlxuICpcbiAqIEBwYXJhbSB7P0RPTU5vZGV9IG91dGVyTm9kZSBPdXRlciBET00gbm9kZS5cbiAqIEBwYXJhbSB7P0RPTU5vZGV9IGlubmVyTm9kZSBJbm5lciBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG91dGVyTm9kZWAgY29udGFpbnMgb3IgaXMgYGlubmVyTm9kZWAuXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zTm9kZShfeCwgX3gyKSB7XG4gIHZhciBfYWdhaW4gPSB0cnVlO1xuXG4gIF9mdW5jdGlvbjogd2hpbGUgKF9hZ2Fpbikge1xuICAgIHZhciBvdXRlck5vZGUgPSBfeCxcbiAgICAgICAgaW5uZXJOb2RlID0gX3gyO1xuICAgIF9hZ2FpbiA9IGZhbHNlO1xuXG4gICAgaWYgKCFvdXRlck5vZGUgfHwgIWlubmVyTm9kZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShvdXRlck5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc1RleHROb2RlKGlubmVyTm9kZSkpIHtcbiAgICAgIF94ID0gb3V0ZXJOb2RlO1xuICAgICAgX3gyID0gaW5uZXJOb2RlLnBhcmVudE5vZGU7XG4gICAgICBfYWdhaW4gPSB0cnVlO1xuICAgICAgY29udGludWUgX2Z1bmN0aW9uO1xuICAgIH0gZWxzZSBpZiAob3V0ZXJOb2RlLmNvbnRhaW5zKSB7XG4gICAgICByZXR1cm4gb3V0ZXJOb2RlLmNvbnRhaW5zKGlubmVyTm9kZSk7XG4gICAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICAgIHJldHVybiAhIShvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oaW5uZXJOb2RlKSAmIDE2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRhaW5zTm9kZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvY29udGFpbnNOb2RlLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGlzVGV4dE5vZGVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9pc05vZGUnKTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSB0ZXh0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGlzVGV4dE5vZGUob2JqZWN0KSB7XG4gIHJldHVybiBpc05vZGUob2JqZWN0KSAmJiBvYmplY3Qubm9kZVR5cGUgPT0gMztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1RleHROb2RlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9pc1RleHROb2RlLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGlzTm9kZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIG5vZGUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gaXNOb2RlKG9iamVjdCkge1xuICByZXR1cm4gISEob2JqZWN0ICYmICh0eXBlb2YgTm9kZSA9PT0gJ2Z1bmN0aW9uJyA/IG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgOiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTm9kZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvaXNOb2RlLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50Jyk7XG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbXB0eUNvbXBvbmVudCcpO1xudmFyIFJlYWN0TmF0aXZlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdE5hdGl2ZUNvbXBvbmVudCcpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLy8gVG8gYXZvaWQgYSBjeWNsaWMgZGVwZW5kZW5jeSwgd2UgY3JlYXRlIHRoZSBmaW5hbCBjbGFzcyBpbiB0aGlzIG1vZHVsZVxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlciA9IGZ1bmN0aW9uICgpIHt9O1xuYXNzaWduKFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlci5wcm90b3R5cGUsIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50Lk1peGluLCB7XG4gIF9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50OiBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50XG59KTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSB7XG4gIGlmIChvd25lcikge1xuICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHR5cGUgcmVmZXJlbmNlIGlzIGEga25vd24gaW50ZXJuYWwgdHlwZS4gSS5lLiBub3QgYSB1c2VyXG4gKiBwcm92aWRlZCBjb21wb3NpdGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0eXBlXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhpcyBpcyBhIHZhbGlkIGludGVybmFsIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzSW50ZXJuYWxDb21wb25lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlLm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZS5yZWNlaXZlQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgUmVhY3ROb2RlLCBjcmVhdGUgYW4gaW5zdGFuY2UgdGhhdCB3aWxsIGFjdHVhbGx5IGJlIG1vdW50ZWQuXG4gKlxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGVcbiAqIEByZXR1cm4ge29iamVjdH0gQSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGVsZW1lbnQncyBjb25zdHJ1Y3Rvci5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuZnVuY3Rpb24gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChub2RlKSB7XG4gIHZhciBpbnN0YW5jZTtcblxuICBpZiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSBmYWxzZSkge1xuICAgIGluc3RhbmNlID0gbmV3IFJlYWN0RW1wdHlDb21wb25lbnQoaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBub2RlO1xuICAgICEoZWxlbWVudCAmJiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpICcgKyAnb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIGVsZW1lbnQudHlwZSA9PSBudWxsID8gZWxlbWVudC50eXBlIDogdHlwZW9mIGVsZW1lbnQudHlwZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGVsZW1lbnQuX293bmVyKSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gU3BlY2lhbCBjYXNlIHN0cmluZyB2YWx1ZXNcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGluc3RhbmNlID0gUmVhY3ROYXRpdmVDb21wb25lbnQuY3JlYXRlSW50ZXJuYWxDb21wb25lbnQoZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmIChpc0ludGVybmFsQ29tcG9uZW50VHlwZShlbGVtZW50LnR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIHRlbXBvcmFyaWx5IGF2YWlsYWJsZSBmb3IgY3VzdG9tIGNvbXBvbmVudHMgdGhhdCBhcmUgbm90IHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW50YXRpb25zLiBJLmUuIEFSVC4gT25jZSB0aG9zZSBhcmUgdXBkYXRlZCB0byB1c2UgdGhlIHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW50YXRpb24sIHdlIGNhbiBkcm9wIHRoaXMgY29kZSBwYXRoLlxuICAgICAgaW5zdGFuY2UgPSBuZXcgZWxlbWVudC50eXBlKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZSA9IG5ldyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFdyYXBwZXIoKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBub2RlID09PSAnbnVtYmVyJykge1xuICAgIGluc3RhbmNlID0gUmVhY3ROYXRpdmVDb21wb25lbnQuY3JlYXRlSW5zdGFuY2VGb3JUZXh0KG5vZGUpO1xuICB9IGVsc2Uge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFbmNvdW50ZXJlZCBpbnZhbGlkIFJlYWN0IG5vZGUgb2YgdHlwZSAlcycsIHR5cGVvZiBub2RlKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0YW5jZS5jb25zdHJ1Y3QgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5yZWNlaXZlQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS51bm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nLCAnT25seSBSZWFjdCBDb21wb25lbnRzIGNhbiBiZSBtb3VudGVkLicpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gU2V0cyB1cCB0aGUgaW5zdGFuY2UuIFRoaXMgY2FuIHByb2JhYmx5IGp1c3QgbW92ZSBpbnRvIHRoZSBjb25zdHJ1Y3RvciBub3cuXG4gIGluc3RhbmNlLmNvbnN0cnVjdChub2RlKTtcblxuICAvLyBUaGVzZSB0d28gZmllbGRzIGFyZSB1c2VkIGJ5IHRoZSBET00gYW5kIEFSVCBkaWZmaW5nIGFsZ29yaXRobXNcbiAgLy8gcmVzcGVjdGl2ZWx5LiBJbnN0ZWFkIG9mIHVzaW5nIGV4cGFuZG9zIG9uIGNvbXBvbmVudHMsIHdlIHNob3VsZCBiZVxuICAvLyBzdG9yaW5nIHRoZSBzdGF0ZSBuZWVkZWQgYnkgdGhlIGRpZmZpbmcgYWxnb3JpdGhtcyBlbHNld2hlcmUuXG4gIGluc3RhbmNlLl9tb3VudEluZGV4ID0gMDtcbiAgaW5zdGFuY2UuX21vdW50SW1hZ2UgPSBudWxsO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuX2lzT3duZXJOZWNlc3NhcnkgPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIEludGVybmFsIGluc3RhbmNlcyBzaG91bGQgZnVsbHkgY29uc3RydWN0ZWQgYXQgdGhpcyBwb2ludCwgc28gdGhleSBzaG91bGRcbiAgLy8gbm90IGdldCBhbnkgbmV3IGZpZWxkcyBhZGRlZCB0byB0aGVtIGF0IHRoaXMgcG9pbnQuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucykge1xuICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKGluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDb21wb3NpdGVDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZSgnLi9SZWFjdFBlcmYnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25zJyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkge1xuICB2YXIgb3duZXIgPSBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lciB8fCBudWxsO1xuICBpZiAob3duZXIpIHtcbiAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBTdGF0ZWxlc3NDb21wb25lbnQoQ29tcG9uZW50KSB7fVxuU3RhdGVsZXNzQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBDb21wb25lbnQgPSBSZWFjdEluc3RhbmNlTWFwLmdldCh0aGlzKS5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgcmV0dXJuIENvbXBvbmVudCh0aGlzLnByb3BzLCB0aGlzLmNvbnRleHQsIHRoaXMudXBkYXRlcik7XG59O1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLSBUaGUgTGlmZS1DeWNsZSBvZiBhIENvbXBvc2l0ZSBDb21wb25lbnQgLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogLSBjb25zdHJ1Y3RvcjogSW5pdGlhbGl6YXRpb24gb2Ygc3RhdGUuIFRoZSBpbnN0YW5jZSBpcyBub3cgcmV0YWluZWQuXG4gKiAgIC0gY29tcG9uZW50V2lsbE1vdW50XG4gKiAgIC0gcmVuZGVyXG4gKiAgIC0gW2NoaWxkcmVuJ3MgY29uc3RydWN0b3JzXVxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50V2lsbE1vdW50IGFuZCByZW5kZXJdXG4gKiAgICAgLSBbY2hpbGRyZW4ncyBjb21wb25lbnREaWRNb3VudF1cbiAqICAgICAtIGNvbXBvbmVudERpZE1vdW50XG4gKlxuICogICAgICAgVXBkYXRlIFBoYXNlczpcbiAqICAgICAgIC0gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAob25seSBjYWxsZWQgaWYgcGFyZW50IHVwZGF0ZWQpXG4gKiAgICAgICAtIHNob3VsZENvbXBvbmVudFVwZGF0ZVxuICogICAgICAgICAtIGNvbXBvbmVudFdpbGxVcGRhdGVcbiAqICAgICAgICAgICAtIHJlbmRlclxuICogICAgICAgICAgIC0gW2NoaWxkcmVuJ3MgY29uc3RydWN0b3JzIG9yIHJlY2VpdmUgcHJvcHMgcGhhc2VzXVxuICogICAgICAgICAtIGNvbXBvbmVudERpZFVwZGF0ZVxuICpcbiAqICAgICAtIGNvbXBvbmVudFdpbGxVbm1vdW50XG4gKiAgICAgLSBbY2hpbGRyZW4ncyBjb21wb25lbnRXaWxsVW5tb3VudF1cbiAqICAgLSBbY2hpbGRyZW4gZGVzdHJveWVkXVxuICogLSAoZGVzdHJveWVkKTogVGhlIGluc3RhbmNlIGlzIG5vdyBibGFuaywgcmVsZWFzZWQgYnkgUmVhY3QgYW5kIHJlYWR5IGZvciBHQy5cbiAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbi8qKlxuICogQW4gaW5jcmVtZW50aW5nIElEIGFzc2lnbmVkIHRvIGVhY2ggY29tcG9uZW50IHdoZW4gaXQgaXMgbW91bnRlZC4gVGhpcyBpc1xuICogdXNlZCB0byBlbmZvcmNlIHRoZSBvcmRlciBpbiB3aGljaCBgUmVhY3RVcGRhdGVzYCB1cGRhdGVzIGRpcnR5IGNvbXBvbmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIG5leHRNb3VudElEID0gMTtcblxuLyoqXG4gKiBAbGVuZHMge1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50LnByb3RvdHlwZX1cbiAqL1xudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50TWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIEJhc2UgY29uc3RydWN0b3IgZm9yIGFsbCBjb21wb3NpdGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSBudWxsO1xuICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcblxuICAgIC8vIFNlZSBSZWFjdFVwZGF0ZVF1ZXVlXG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG5cbiAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9tb3VudE9yZGVyID0gMDtcbiAgICB0aGlzLl90b3BMZXZlbFdyYXBwZXIgPSBudWxsO1xuXG4gICAgLy8gU2VlIFJlYWN0VXBkYXRlcyBhbmQgUmVhY3RVcGRhdGVRdWV1ZS5cbiAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIERPTSBJRCBvZiB0aGUgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHJldHVybiB7P3N0cmluZ30gUmVuZGVyZWQgbWFya3VwIHRvIGJlIGluc2VydGVkIGludG8gdGhlIERPTS5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChyb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5fbW91bnRPcmRlciA9IG5leHRNb3VudElEKys7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IHJvb3RJRDtcblxuICAgIHZhciBwdWJsaWNQcm9wcyA9IHRoaXMuX3Byb2Nlc3NQcm9wcyh0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcyk7XG4gICAgdmFyIHB1YmxpY0NvbnRleHQgPSB0aGlzLl9wcm9jZXNzQ29udGV4dChjb250ZXh0KTtcblxuICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgcHVibGljIGNsYXNzXG4gICAgdmFyIGluc3Q7XG4gICAgdmFyIHJlbmRlcmVkRWxlbWVudDtcblxuICAgIC8vIFRoaXMgaXMgYSB3YXkgdG8gZGV0ZWN0IGlmIENvbXBvbmVudCBpcyBhIHN0YXRlbGVzcyBhcnJvdyBmdW5jdGlvblxuICAgIC8vIGNvbXBvbmVudCwgd2hpY2ggaXMgbm90IG5ld2FibGUuIEl0IG1pZ2h0IG5vdCBiZSAxMDAlIHJlbGlhYmxlIGJ1dCBpc1xuICAgIC8vIHNvbWV0aGluZyB3ZSBjYW4gZG8gdW50aWwgd2Ugc3RhcnQgZGV0ZWN0aW5nIHRoYXQgQ29tcG9uZW50IGV4dGVuZHNcbiAgICAvLyBSZWFjdC5Db21wb25lbnQuIFdlIGFscmVhZHkgYXNzdW1lIHRoYXQgdHlwZW9mIENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJy5cbiAgICB2YXIgY2FuSW5zdGFudGlhdGUgPSAoJ3Byb3RvdHlwZScgaW4gQ29tcG9uZW50KTtcblxuICAgIGlmIChjYW5JbnN0YW50aWF0ZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5zdCA9IG5ldyBDb21wb25lbnQocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIFJlYWN0VXBkYXRlUXVldWUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0ID0gbmV3IENvbXBvbmVudChwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgUmVhY3RVcGRhdGVRdWV1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjYW5JbnN0YW50aWF0ZSB8fCBpbnN0ID09PSBudWxsIHx8IGluc3QgPT09IGZhbHNlIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChpbnN0KSkge1xuICAgICAgcmVuZGVyZWRFbGVtZW50ID0gaW5zdDtcbiAgICAgIGluc3QgPSBuZXcgU3RhdGVsZXNzQ29tcG9uZW50KENvbXBvbmVudCk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBsYXRlciBpbiBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50LCBidXQgYWRkIGFuIGVhcmx5XG4gICAgICAvLyB3YXJuaW5nIG5vdyB0byBoZWxwIGRlYnVnZ2luZ1xuICAgICAgaWYgKGluc3QucmVuZGVyID09IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYCwgcmV0dXJuZWQgJyArICdudWxsL2ZhbHNlIGZyb20gYSBzdGF0ZWxlc3MgY29tcG9uZW50LCBvciB0cmllZCB0byByZW5kZXIgYW4gJyArICdlbGVtZW50IHdob3NlIHR5cGUgaXMgYSBmdW5jdGlvbiB0aGF0IGlzblxcJ3QgYSBSZWFjdCBjb21wb25lbnQuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIHN1cHBvcnQgRVM2IGluaGVyaXRpbmcgZnJvbSBSZWFjdC5Db21wb25lbnQsIHRoZSBtb2R1bGUgcGF0dGVybixcbiAgICAgICAgLy8gYW5kIHN0YXRlbGVzcyBjb21wb25lbnRzLCBidXQgbm90IEVTNiBjbGFzc2VzIHRoYXQgZG9uJ3QgZXh0ZW5kXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50IHx8ICFjYW5JbnN0YW50aWF0ZSB8fCAhKGluc3QgaW5zdGFuY2VvZiBDb21wb25lbnQpLCAnJXMoLi4uKTogUmVhY3QgY29tcG9uZW50IGNsYXNzZXMgbXVzdCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlc2Ugc2hvdWxkIGJlIHNldCB1cCBpbiB0aGUgY29uc3RydWN0b3IsIGJ1dCBhcyBhIGNvbnZlbmllbmNlIGZvclxuICAgIC8vIHNpbXBsZXIgY2xhc3MgYWJzdHJhY3Rpb25zLCB3ZSBzZXQgdGhlbSB1cCBhZnRlciB0aGUgZmFjdC5cbiAgICBpbnN0LnByb3BzID0gcHVibGljUHJvcHM7XG4gICAgaW5zdC5jb250ZXh0ID0gcHVibGljQ29udGV4dDtcbiAgICBpbnN0LnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICBpbnN0LnVwZGF0ZXIgPSBSZWFjdFVwZGF0ZVF1ZXVlO1xuXG4gICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0O1xuXG4gICAgLy8gU3RvcmUgYSByZWZlcmVuY2UgZnJvbSB0aGUgaW5zdGFuY2UgYmFjayB0byB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cbiAgICBSZWFjdEluc3RhbmNlTWFwLnNldChpbnN0LCB0aGlzKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBTaW5jZSBwbGFpbiBKUyBjbGFzc2VzIGFyZSBkZWZpbmVkIHdpdGhvdXQgYW55IHNwZWNpYWwgaW5pdGlhbGl6YXRpb25cbiAgICAgIC8vIGxvZ2ljLCB3ZSBjYW4gbm90IGNhdGNoIGNvbW1vbiBlcnJvcnMgZWFybHkuIFRoZXJlZm9yZSwgd2UgaGF2ZSB0b1xuICAgICAgLy8gY2F0Y2ggdGhlbSBoZXJlLCBhdCBpbml0aWFsaXphdGlvbiB0aW1lLCBpbnN0ZWFkLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QuZ2V0SW5pdGlhbFN0YXRlIHx8IGluc3QuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QuZ2V0RGVmYXVsdFByb3BzIHx8IGluc3QuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ1VzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuJywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5wcm9wVHlwZXMsICdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LmNvbnRleHRUeXBlcywgJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgJyArICdzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3QuY29tcG9uZW50U2hvdWxkVXBkYXRlICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgdGhpcy5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdC5jb21wb25lbnREaWRVbm1vdW50ICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT8nLCB0aGlzLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0LmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgIT09ICdmdW5jdGlvbicsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciBpbml0aWFsU3RhdGUgPSBpbnN0LnN0YXRlO1xuICAgIGlmIChpbml0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5zdC5zdGF0ZSA9IGluaXRpYWxTdGF0ZSA9IG51bGw7XG4gICAgfVxuICAgICEodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5pdGlhbFN0YXRlKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcblxuICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxNb3VudCkge1xuICAgICAgaW5zdC5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgIC8vIFdoZW4gbW91bnRpbmcsIGNhbGxzIHRvIGBzZXRTdGF0ZWAgYnkgYGNvbXBvbmVudFdpbGxNb3VudGAgd2lsbCBzZXRcbiAgICAgIC8vIGB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZWAgd2l0aG91dCB0cmlnZ2VyaW5nIGEgcmUtcmVuZGVyLlxuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlKSB7XG4gICAgICAgIGluc3Quc3RhdGUgPSB0aGlzLl9wcm9jZXNzUGVuZGluZ1N0YXRlKGluc3QucHJvcHMsIGluc3QuY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm90IGEgc3RhdGVsZXNzIGNvbXBvbmVudCwgd2Ugbm93IHJlbmRlclxuICAgIGlmIChyZW5kZXJlZEVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVuZGVyZWRFbGVtZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSB0aGlzLl9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KHJlbmRlcmVkRWxlbWVudCk7XG5cbiAgICB2YXIgbWFya3VwID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50LCByb290SUQsIHRyYW5zYWN0aW9uLCB0aGlzLl9wcm9jZXNzQ2hpbGRDb250ZXh0KGNvbnRleHQpKTtcbiAgICBpZiAoaW5zdC5jb21wb25lbnREaWRNb3VudCkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnN0LmNvbXBvbmVudERpZE1vdW50LCBpbnN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyBhbnkgcmVzb3VyY2VzIGFsbG9jYXRlZCBieSBgbW91bnRDb21wb25lbnRgLlxuICAgKlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcblxuICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxVbm1vdW50KSB7XG4gICAgICBpbnN0LmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgfVxuXG4gICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQodGhpcy5fcmVuZGVyZWRDb21wb25lbnQpO1xuICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gbnVsbDtcbiAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG5cbiAgICAvLyBSZXNldCBwZW5kaW5nIGZpZWxkc1xuICAgIC8vIEV2ZW4gaWYgdGhpcyBjb21wb25lbnQgaXMgc2NoZWR1bGVkIGZvciBhbm90aGVyIHVwZGF0ZSBpbiBSZWFjdFVwZGF0ZXMsXG4gICAgLy8gaXQgd291bGQgc3RpbGwgYmUgaWdub3JlZCBiZWNhdXNlIHRoZXNlIGZpZWxkcyBhcmUgcmVzZXQuXG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XG5cbiAgICAvLyBUaGVzZSBmaWVsZHMgZG8gbm90IHJlYWxseSBuZWVkIHRvIGJlIHJlc2V0IHNpbmNlIHRoaXMgb2JqZWN0IGlzIG5vXG4gICAgLy8gbG9uZ2VyIGFjY2Vzc2libGUuXG4gICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IG51bGw7XG4gICAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcblxuICAgIC8vIERlbGV0ZSB0aGUgcmVmZXJlbmNlIGZyb20gdGhlIGluc3RhbmNlIHRvIHRoaXMgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cbiAgICAvLyB3aGljaCBhbGxvdyB0aGUgaW50ZXJuYWxzIHRvIGJlIHByb3Blcmx5IGNsZWFuZWQgdXAgZXZlbiBpZiB0aGUgdXNlclxuICAgIC8vIGxlYWtzIGEgcmVmZXJlbmNlIHRvIHRoZSBwdWJsaWMgaW5zdGFuY2UuXG4gICAgUmVhY3RJbnN0YW5jZU1hcC5yZW1vdmUoaW5zdCk7XG5cbiAgICAvLyBTb21lIGV4aXN0aW5nIGNvbXBvbmVudHMgcmVseSBvbiBpbnN0LnByb3BzIGV2ZW4gYWZ0ZXIgdGhleSd2ZSBiZWVuXG4gICAgLy8gZGVzdHJveWVkIChpbiBldmVudCBoYW5kbGVycykuXG4gICAgLy8gVE9ETzogaW5zdC5wcm9wcyA9IG51bGw7XG4gICAgLy8gVE9ETzogaW5zdC5zdGF0ZSA9IG51bGw7XG4gICAgLy8gVE9ETzogaW5zdC5jb250ZXh0ID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogRmlsdGVycyB0aGUgY29udGV4dCBvYmplY3QgdG8gb25seSBjb250YWluIGtleXMgc3BlY2lmaWVkIGluXG4gICAqIGBjb250ZXh0VHlwZXNgXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbWFza0NvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIG1hc2tlZENvbnRleHQgPSBudWxsO1xuICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgIHZhciBjb250ZXh0VHlwZXMgPSBDb21wb25lbnQuY29udGV4dFR5cGVzO1xuICAgIGlmICghY29udGV4dFR5cGVzKSB7XG4gICAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gICAgfVxuICAgIG1hc2tlZENvbnRleHQgPSB7fTtcbiAgICBmb3IgKHZhciBjb250ZXh0TmFtZSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICAgIG1hc2tlZENvbnRleHRbY29udGV4dE5hbWVdID0gY29udGV4dFtjb250ZXh0TmFtZV07XG4gICAgfVxuICAgIHJldHVybiBtYXNrZWRDb250ZXh0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaWx0ZXJzIHRoZSBjb250ZXh0IG9iamVjdCB0byBvbmx5IGNvbnRhaW4ga2V5cyBzcGVjaWZpZWQgaW5cbiAgICogYGNvbnRleHRUeXBlc2AsIGFuZCBhc3NlcnRzIHRoYXQgdGhleSBhcmUgdmFsaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc0NvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIG1hc2tlZENvbnRleHQgPSB0aGlzLl9tYXNrQ29udGV4dChjb250ZXh0KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgICBpZiAoQ29tcG9uZW50LmNvbnRleHRUeXBlcykge1xuICAgICAgICB0aGlzLl9jaGVja1Byb3BUeXBlcyhDb21wb25lbnQuY29udGV4dFR5cGVzLCBtYXNrZWRDb250ZXh0LCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFza2VkQ29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGN1cnJlbnRDb250ZXh0XG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcm9jZXNzQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoY3VycmVudENvbnRleHQpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIHZhciBjaGlsZENvbnRleHQgPSBpbnN0LmdldENoaWxkQ29udGV4dCAmJiBpbnN0LmdldENoaWxkQ29udGV4dCgpO1xuICAgIGlmIChjaGlsZENvbnRleHQpIHtcbiAgICAgICEodHlwZW9mIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcyA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJyArICd1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tQcm9wVHlwZXMoQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHQsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMuY2hpbGRDb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgICAgICEobmFtZSBpbiBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXCIlc1wiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcsIG5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhc3NpZ24oe30sIGN1cnJlbnRDb250ZXh0LCBjaGlsZENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudENvbnRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBwcm9wcyBieSBzZXR0aW5nIGRlZmF1bHQgdmFsdWVzIGZvciB1bnNwZWNpZmllZCBwcm9wcyBhbmRcbiAgICogYXNzZXJ0aW5nIHRoYXQgdGhlIHByb3BzIGFyZSB2YWxpZC4gRG9lcyBub3QgbXV0YXRlIGl0cyBhcmd1bWVudDsgcmV0dXJuc1xuICAgKiBhIG5ldyBwcm9wcyBvYmplY3Qgd2l0aCBkZWZhdWx0cyBtZXJnZWQgaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdQcm9wc1xuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc1Byb3BzOiBmdW5jdGlvbiAobmV3UHJvcHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgICBpZiAoQ29tcG9uZW50LnByb3BUeXBlcykge1xuICAgICAgICB0aGlzLl9jaGVja1Byb3BUeXBlcyhDb21wb25lbnQucHJvcFR5cGVzLCBuZXdQcm9wcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld1Byb3BzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBc3NlcnQgdGhhdCB0aGUgcHJvcHMgYXJlIHZhbGlkXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wVHlwZXMgTWFwIG9mIHByb3AgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jaGVja1Byb3BUeXBlczogZnVuY3Rpb24gKHByb3BUeXBlcywgcHJvcHMsIGxvY2F0aW9uKSB7XG4gICAgLy8gVE9ETzogU3RvcCB2YWxpZGF0aW5nIHByb3AgdHlwZXMgaGVyZSBhbmQgb25seSB1c2UgdGhlIGVsZW1lbnRcbiAgICAvLyB2YWxpZGF0aW9uLlxuICAgIHZhciBjb21wb25lbnROYW1lID0gdGhpcy5nZXROYW1lKCk7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcFR5cGVzKSB7XG4gICAgICBpZiAocHJvcFR5cGVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgICEodHlwZW9mIHByb3BUeXBlc1twcm9wTmFtZV0gPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5ICcgKyAnZnJvbSBSZWFjdC5Qcm9wVHlwZXMuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHByb3BOYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgZXJyb3IgPSBwcm9wVHlwZXNbcHJvcE5hbWVdKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAvLyBXZSBtYXkgd2FudCB0byBleHRlbmQgdGhpcyBsb2dpYyBmb3Igc2ltaWxhciBlcnJvcnMgaW5cbiAgICAgICAgICAvLyB0b3AtbGV2ZWwgcmVuZGVyIGNhbGxzLCBzbyBJJ20gYWJzdHJhY3RpbmcgaXQgYXdheSBpbnRvXG4gICAgICAgICAgLy8gYSBmdW5jdGlvbiB0byBtaW5pbWl6ZSByZWZhY3RvcmluZyBpbiB0aGUgZnV0dXJlXG4gICAgICAgICAgdmFyIGFkZGVuZHVtID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKHRoaXMpO1xuXG4gICAgICAgICAgaWYgKGxvY2F0aW9uID09PSBSZWFjdFByb3BUeXBlTG9jYXRpb25zLnByb3ApIHtcbiAgICAgICAgICAgIC8vIFByZWZhY2UgZ2l2ZXMgdXMgc29tZXRoaW5nIHRvIGJsYWNrbGlzdCBpbiB3YXJuaW5nIG1vZHVsZVxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAlcyVzJywgZXJyb3IubWVzc2FnZSwgYWRkZW5kdW0pIDogdW5kZWZpbmVkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCBDb250ZXh0IFR5cGVzOiAlcyVzJywgZXJyb3IubWVzc2FnZSwgYWRkZW5kdW0pIDogdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBuZXh0Q29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50O1xuICAgIHZhciBwcmV2Q29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG5cbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XG5cbiAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudCh0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBwcmV2Q29udGV4dCwgbmV4dENvbnRleHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBhbnkgb2YgYF9wZW5kaW5nRWxlbWVudGAsIGBfcGVuZGluZ1N0YXRlUXVldWVgLCBvciBgX3BlbmRpbmdGb3JjZVVwZGF0ZWBcbiAgICogaXMgc2V0LCB1cGRhdGUgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeTogZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRoaXMuX3BlbmRpbmdFbGVtZW50ICE9IG51bGwpIHtcbiAgICAgIFJlYWN0UmVjb25jaWxlci5yZWNlaXZlQ29tcG9uZW50KHRoaXMsIHRoaXMuX3BlbmRpbmdFbGVtZW50IHx8IHRoaXMuX2N1cnJlbnRFbGVtZW50LCB0cmFuc2FjdGlvbiwgdGhpcy5fY29udGV4dCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlICE9PSBudWxsIHx8IHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSkge1xuICAgICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHRoaXMuX2N1cnJlbnRFbGVtZW50LCB0aGlzLl9jdXJyZW50RWxlbWVudCwgdGhpcy5fY29udGV4dCwgdGhpcy5fY29udGV4dCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIHVwZGF0ZSB0byBhIG1vdW50ZWQgY29tcG9uZW50LiBUaGUgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBhbmRcbiAgICogc2hvdWxkQ29tcG9uZW50VXBkYXRlIG1ldGhvZHMgYXJlIGNhbGxlZCwgdGhlbiAoYXNzdW1pbmcgdGhlIHVwZGF0ZSBpc24ndFxuICAgKiBza2lwcGVkKSB0aGUgcmVtYWluaW5nIHVwZGF0ZSBsaWZlY3ljbGUgbWV0aG9kcyBhcmUgY2FsbGVkIGFuZCB0aGUgRE9NXG4gICAqIHJlcHJlc2VudGF0aW9uIGlzIHVwZGF0ZWQuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoaXMgaW1wbGVtZW50cyBSZWFjdCdzIHJlbmRlcmluZyBhbmQgcmVjb25jaWxpYXRpb24gYWxnb3JpdGhtLlxuICAgKiBTb3BoaXN0aWNhdGVkIGNsaWVudHMgbWF5IHdpc2ggdG8gb3ZlcnJpZGUgdGhpcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gcHJldlBhcmVudEVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRQYXJlbnRFbGVtZW50XG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcmV2UGFyZW50RWxlbWVudCwgbmV4dFBhcmVudEVsZW1lbnQsIHByZXZVbm1hc2tlZENvbnRleHQsIG5leHRVbm1hc2tlZENvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuXG4gICAgdmFyIG5leHRDb250ZXh0ID0gdGhpcy5fY29udGV4dCA9PT0gbmV4dFVubWFza2VkQ29udGV4dCA/IGluc3QuY29udGV4dCA6IHRoaXMuX3Byb2Nlc3NDb250ZXh0KG5leHRVbm1hc2tlZENvbnRleHQpO1xuICAgIHZhciBuZXh0UHJvcHM7XG5cbiAgICAvLyBEaXN0aW5ndWlzaCBiZXR3ZWVuIGEgcHJvcHMgdXBkYXRlIHZlcnN1cyBhIHNpbXBsZSBzdGF0ZSB1cGRhdGVcbiAgICBpZiAocHJldlBhcmVudEVsZW1lbnQgPT09IG5leHRQYXJlbnRFbGVtZW50KSB7XG4gICAgICAvLyBTa2lwIGNoZWNraW5nIHByb3AgdHlwZXMgYWdhaW4gLS0gd2UgZG9uJ3QgcmVhZCBpbnN0LnByb3BzIHRvIGF2b2lkXG4gICAgICAvLyB3YXJuaW5nIGZvciBET00gY29tcG9uZW50IHByb3BzIGluIHRoaXMgdXBncmFkZVxuICAgICAgbmV4dFByb3BzID0gbmV4dFBhcmVudEVsZW1lbnQucHJvcHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRQcm9wcyA9IHRoaXMuX3Byb2Nlc3NQcm9wcyhuZXh0UGFyZW50RWxlbWVudC5wcm9wcyk7XG4gICAgICAvLyBBbiB1cGRhdGUgaGVyZSB3aWxsIHNjaGVkdWxlIGFuIHVwZGF0ZSBidXQgaW1tZWRpYXRlbHkgc2V0XG4gICAgICAvLyBfcGVuZGluZ1N0YXRlUXVldWUgd2hpY2ggd2lsbCBlbnN1cmUgdGhhdCBhbnkgc3RhdGUgdXBkYXRlcyBnZXRzXG4gICAgICAvLyBpbW1lZGlhdGVseSByZWNvbmNpbGVkIGluc3RlYWQgb2Ygd2FpdGluZyBmb3IgdGhlIG5leHQgYmF0Y2guXG5cbiAgICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMpIHtcbiAgICAgICAgaW5zdC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcywgbmV4dENvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZXh0U3RhdGUgPSB0aGlzLl9wcm9jZXNzUGVuZGluZ1N0YXRlKG5leHRQcm9wcywgbmV4dENvbnRleHQpO1xuXG4gICAgdmFyIHNob3VsZFVwZGF0ZSA9IHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSB8fCAhaW5zdC5zaG91bGRDb21wb25lbnRVcGRhdGUgfHwgaW5zdC5zaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2Ygc2hvdWxkVXBkYXRlICE9PSAndW5kZWZpbmVkJywgJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgKyAnYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgLy8gV2lsbCBzZXQgYHRoaXMucHJvcHNgLCBgdGhpcy5zdGF0ZWAgYW5kIGB0aGlzLmNvbnRleHRgLlxuICAgICAgdGhpcy5fcGVyZm9ybUNvbXBvbmVudFVwZGF0ZShuZXh0UGFyZW50RWxlbWVudCwgbmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0LCB0cmFuc2FjdGlvbiwgbmV4dFVubWFza2VkQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGl0J3MgZGV0ZXJtaW5lZCB0aGF0IGEgY29tcG9uZW50IHNob3VsZCBub3QgdXBkYXRlLCB3ZSBzdGlsbCB3YW50XG4gICAgICAvLyB0byBzZXQgcHJvcHMgYW5kIHN0YXRlIGJ1dCB3ZSBzaG9ydGN1dCB0aGUgcmVzdCBvZiB0aGUgdXBkYXRlLlxuICAgICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0UGFyZW50RWxlbWVudDtcbiAgICAgIHRoaXMuX2NvbnRleHQgPSBuZXh0VW5tYXNrZWRDb250ZXh0O1xuICAgICAgaW5zdC5wcm9wcyA9IG5leHRQcm9wcztcbiAgICAgIGluc3Quc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICBpbnN0LmNvbnRleHQgPSBuZXh0Q29udGV4dDtcbiAgICB9XG4gIH0sXG5cbiAgX3Byb2Nlc3NQZW5kaW5nU3RhdGU6IGZ1bmN0aW9uIChwcm9wcywgY29udGV4dCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5fcGVuZGluZ1N0YXRlUXVldWU7XG4gICAgdmFyIHJlcGxhY2UgPSB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG5cbiAgICBpZiAoIXF1ZXVlKSB7XG4gICAgICByZXR1cm4gaW5zdC5zdGF0ZTtcbiAgICB9XG5cbiAgICBpZiAocmVwbGFjZSAmJiBxdWV1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBxdWV1ZVswXTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFN0YXRlID0gYXNzaWduKHt9LCByZXBsYWNlID8gcXVldWVbMF0gOiBpbnN0LnN0YXRlKTtcbiAgICBmb3IgKHZhciBpID0gcmVwbGFjZSA/IDEgOiAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXJ0aWFsID0gcXVldWVbaV07XG4gICAgICBhc3NpZ24obmV4dFN0YXRlLCB0eXBlb2YgcGFydGlhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcnRpYWwuY2FsbChpbnN0LCBuZXh0U3RhdGUsIHByb3BzLCBjb250ZXh0KSA6IHBhcnRpYWwpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0U3RhdGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1lcmdlcyBuZXcgcHJvcHMgYW5kIHN0YXRlLCBub3RpZmllcyBkZWxlZ2F0ZSBtZXRob2RzIG9mIHVwZGF0ZSBhbmRcbiAgICogcGVyZm9ybXMgdXBkYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgTmV4dCBlbGVtZW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHMgTmV4dCBwdWJsaWMgb2JqZWN0IHRvIHNldCBhcyBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZSBOZXh0IG9iamVjdCB0byBzZXQgYXMgc3RhdGUuXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHQgTmV4dCBwdWJsaWMgb2JqZWN0IHRvIHNldCBhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gdW5tYXNrZWRDb250ZXh0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcGVyZm9ybUNvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQsIHRyYW5zYWN0aW9uLCB1bm1hc2tlZENvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuXG4gICAgdmFyIGhhc0NvbXBvbmVudERpZFVwZGF0ZSA9IEJvb2xlYW4oaW5zdC5jb21wb25lbnREaWRVcGRhdGUpO1xuICAgIHZhciBwcmV2UHJvcHM7XG4gICAgdmFyIHByZXZTdGF0ZTtcbiAgICB2YXIgcHJldkNvbnRleHQ7XG4gICAgaWYgKGhhc0NvbXBvbmVudERpZFVwZGF0ZSkge1xuICAgICAgcHJldlByb3BzID0gaW5zdC5wcm9wcztcbiAgICAgIHByZXZTdGF0ZSA9IGluc3Quc3RhdGU7XG4gICAgICBwcmV2Q29udGV4dCA9IGluc3QuY29udGV4dDtcbiAgICB9XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsVXBkYXRlKSB7XG4gICAgICBpbnN0LmNvbXBvbmVudFdpbGxVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgIHRoaXMuX2NvbnRleHQgPSB1bm1hc2tlZENvbnRleHQ7XG4gICAgaW5zdC5wcm9wcyA9IG5leHRQcm9wcztcbiAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgIGluc3QuY29udGV4dCA9IG5leHRDb250ZXh0O1xuXG4gICAgdGhpcy5fdXBkYXRlUmVuZGVyZWRDb21wb25lbnQodHJhbnNhY3Rpb24sIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICBpZiAoaGFzQ29tcG9uZW50RGlkVXBkYXRlKSB7XG4gICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGluc3QuY29tcG9uZW50RGlkVXBkYXRlLmJpbmQoaW5zdCwgcHJldlByb3BzLCBwcmV2U3RhdGUsIHByZXZDb250ZXh0KSwgaW5zdCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxsIHRoZSBjb21wb25lbnQncyBgcmVuZGVyYCBtZXRob2QgYW5kIHVwZGF0ZSB0aGUgRE9NIGFjY29yZGluZ2x5LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3VwZGF0ZVJlbmRlcmVkQ29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJldkNvbXBvbmVudEluc3RhbmNlID0gdGhpcy5fcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgdmFyIHByZXZSZW5kZXJlZEVsZW1lbnQgPSBwcmV2Q29tcG9uZW50SW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuICAgIHZhciBuZXh0UmVuZGVyZWRFbGVtZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KCk7XG4gICAgaWYgKHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZSZW5kZXJlZEVsZW1lbnQsIG5leHRSZW5kZXJlZEVsZW1lbnQpKSB7XG4gICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudChwcmV2Q29tcG9uZW50SW5zdGFuY2UsIG5leHRSZW5kZXJlZEVsZW1lbnQsIHRyYW5zYWN0aW9uLCB0aGlzLl9wcm9jZXNzQ2hpbGRDb250ZXh0KGNvbnRleHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlc2UgdHdvIElEcyBhcmUgYWN0dWFsbHkgdGhlIHNhbWUhIEJ1dCBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoYXQuXG4gICAgICB2YXIgdGhpc0lEID0gdGhpcy5fcm9vdE5vZGVJRDtcbiAgICAgIHZhciBwcmV2Q29tcG9uZW50SUQgPSBwcmV2Q29tcG9uZW50SW5zdGFuY2UuX3Jvb3ROb2RlSUQ7XG4gICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q29tcG9uZW50SW5zdGFuY2UpO1xuXG4gICAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IHRoaXMuX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobmV4dFJlbmRlcmVkRWxlbWVudCk7XG4gICAgICB2YXIgbmV4dE1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudCh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCwgdGhpc0lELCB0cmFuc2FjdGlvbiwgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSk7XG4gICAgICB0aGlzLl9yZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEKHByZXZDb21wb25lbnRJRCwgbmV4dE1hcmt1cCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfcmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRDogZnVuY3Rpb24gKHByZXZDb21wb25lbnRJRCwgbmV4dE1hcmt1cCkge1xuICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRChwcmV2Q29tcG9uZW50SUQsIG5leHRNYXJrdXApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50V2l0aG91dE93bmVyT3JDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICB2YXIgcmVuZGVyZWRDb21wb25lbnQgPSBpbnN0LnJlbmRlcigpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgIGlmICh0eXBlb2YgcmVuZGVyZWRDb21wb25lbnQgPT09ICd1bmRlZmluZWQnICYmIGluc3QucmVuZGVyLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxuICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxuICAgICAgICByZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbmRlcmVkQ29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIHZhciByZW5kZXJlZENvbXBvbmVudDtcbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcztcbiAgICB0cnkge1xuICAgICAgcmVuZGVyZWRDb21wb25lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnRXaXRob3V0T3duZXJPckNvbnRleHQoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgICEoXG4gICAgLy8gVE9ETzogQW4gYGlzVmFsaWROb2RlYCBmdW5jdGlvbiB3b3VsZCBwcm9iYWJseSBiZSBtb3JlIGFwcHJvcHJpYXRlXG4gICAgcmVuZGVyZWRDb21wb25lbnQgPT09IG51bGwgfHwgcmVuZGVyZWRDb21wb25lbnQgPT09IGZhbHNlIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChyZW5kZXJlZENvbXBvbmVudCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLnJlbmRlcigpOiBBIHZhbGlkIFJlYWN0Q29tcG9uZW50IG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSAnICsgJ3JldHVybmVkIHVuZGVmaW5lZCwgYW4gYXJyYXkgb3Igc29tZSBvdGhlciBpbnZhbGlkIG9iamVjdC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlbmRlcmVkQ29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBMYXppbHkgYWxsb2NhdGVzIHRoZSByZWZzIG9iamVjdCBhbmQgc3RvcmVzIGBjb21wb25lbnRgIGFzIGByZWZgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIFJlZmVyZW5jZSBuYW1lLlxuICAgKiBAcGFyYW0ge2NvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byBzdG9yZSBhcyBgcmVmYC5cbiAgICogQGZpbmFsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhdHRhY2hSZWY6IGZ1bmN0aW9uIChyZWYsIGNvbXBvbmVudCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgICEoaW5zdCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgaGF2ZSByZWZzLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgcHVibGljQ29tcG9uZW50SW5zdGFuY2UgPSBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQgJiYgY29tcG9uZW50LmdldE5hbWUgPyBjb21wb25lbnQuZ2V0TmFtZSgpIDogJ2EgY29tcG9uZW50JztcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHB1YmxpY0NvbXBvbmVudEluc3RhbmNlICE9IG51bGwsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgYmUgZ2l2ZW4gcmVmcyAnICsgJyhTZWUgcmVmIFwiJXNcIiBpbiAlcyBjcmVhdGVkIGJ5ICVzKS4gJyArICdBdHRlbXB0cyB0byBhY2Nlc3MgdGhpcyByZWYgd2lsbCBmYWlsLicsIHJlZiwgY29tcG9uZW50TmFtZSwgdGhpcy5nZXROYW1lKCkpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YXIgcmVmcyA9IGluc3QucmVmcyA9PT0gZW1wdHlPYmplY3QgPyBpbnN0LnJlZnMgPSB7fSA6IGluc3QucmVmcztcbiAgICByZWZzW3JlZl0gPSBwdWJsaWNDb21wb25lbnRJbnN0YW5jZTtcbiAgfSxcblxuICAvKipcbiAgICogRGV0YWNoZXMgYSByZWZlcmVuY2UgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIHRvIGRlcmVmZXJlbmNlLlxuICAgKiBAZmluYWxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRldGFjaFJlZjogZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciByZWZzID0gdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSgpLnJlZnM7XG4gICAgZGVsZXRlIHJlZnNbcmVmXTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGEgdGV4dCBkZXNjcmlwdGlvbiBvZiB0aGUgY29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgaXRcbiAgICogaW4gZXJyb3IgbWVzc2FnZXMuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG5hbWUgb3IgbnVsbC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXROYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHR5cGUgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHRoaXMuX2luc3RhbmNlICYmIHRoaXMuX2luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yICYmIGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBjb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3Rvci5uYW1lIHx8IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHVibGljbHkgYWNjZXNzaWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbXBvbmVudCAtIGkuZS4gd2hhdFxuICAgKiBpcyBleHBvc2VkIGJ5IHJlZnMgYW5kIHJldHVybmVkIGJ5IHJlbmRlci4gQ2FuIGJlIG51bGwgZm9yIHN0YXRlbGVzc1xuICAgKiBjb21wb25lbnRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gdGhlIHB1YmxpYyBjb21wb25lbnQgaW5zdGFuY2UuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0UHVibGljSW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIGlmIChpbnN0IGluc3RhbmNlb2YgU3RhdGVsZXNzQ29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGluc3Q7XG4gIH0sXG5cbiAgLy8gU3R1YlxuICBfaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDogbnVsbFxuXG59O1xuXG5SZWFjdFBlcmYubWVhc3VyZU1ldGhvZHMoUmVhY3RDb21wb3NpdGVDb21wb25lbnRNaXhpbiwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50Jywge1xuICBtb3VudENvbXBvbmVudDogJ21vdW50Q29tcG9uZW50JyxcbiAgdXBkYXRlQ29tcG9uZW50OiAndXBkYXRlQ29tcG9uZW50JyxcbiAgX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudDogJ19yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQnXG59KTtcblxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0ge1xuXG4gIE1peGluOiBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudE1peGluXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb3NpdGVDb21wb25lbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvbmVudEVudmlyb25tZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBpbmplY3RlZCA9IGZhbHNlO1xuXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHtcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGVudmlyb25tZW50IGRlcGVuZGVudCBjbGVhbnVwIGhvb2suIChzZXJ2ZXIgdnMuXG4gICAqIGJyb3dzZXIgZXRjKS4gRXhhbXBsZTogQSBicm93c2VyIHN5c3RlbSBjYWNoZXMgRE9NIG5vZGVzIGJhc2VkIG9uIGNvbXBvbmVudFxuICAgKiBJRCBhbmQgbXVzdCByZW1vdmUgdGhhdCBjYWNoZSBlbnRyeSB3aGVuIHRoaXMgaW5zdGFuY2UgaXMgdW5tb3VudGVkLlxuICAgKi9cbiAgdW5tb3VudElERnJvbUVudmlyb25tZW50OiBudWxsLFxuXG4gIC8qKlxuICAgKiBPcHRpb25hbGx5IGluamVjdGFibGUgaG9vayBmb3Igc3dhcHBpbmcgb3V0IG1vdW50IGltYWdlcyBpbiB0aGUgbWlkZGxlIG9mXG4gICAqIHRoZSB0cmVlLlxuICAgKi9cbiAgcmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRDogbnVsbCxcblxuICAvKipcbiAgICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGhvb2sgZm9yIHByb2Nlc3NpbmcgYSBxdWV1ZSBvZiBjaGlsZCB1cGRhdGVzLiBXaWxsXG4gICAqIGxhdGVyIG1vdmUgaW50byBNdWx0aUNoaWxkQ29tcG9uZW50cy5cbiAgICovXG4gIHByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IG51bGwsXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0RW52aXJvbm1lbnQ6IGZ1bmN0aW9uIChlbnZpcm9ubWVudCkge1xuICAgICAgISFpbmplY3RlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDogaW5qZWN0RW52aXJvbm1lbnQoKSBjYW4gb25seSBiZSBjYWxsZWQgb25jZS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnVubW91bnRJREZyb21FbnZpcm9ubWVudCA9IGVudmlyb25tZW50LnVubW91bnRJREZyb21FbnZpcm9ubWVudDtcbiAgICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRCA9IGVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQ7XG4gICAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnByb2Nlc3NDaGlsZHJlblVwZGF0ZXMgPSBlbnZpcm9ubWVudC5wcm9jZXNzQ2hpbGRyZW5VcGRhdGVzO1xuICAgICAgaW5qZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrZXlNaXJyb3IgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlNaXJyb3InKTtcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSBrZXlNaXJyb3Ioe1xuICBwcm9wOiBudWxsLFxuICBjb250ZXh0OiBudWxsLFxuICBjaGlsZENvbnRleHQ6IG51bGxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbnM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25zLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7XG4gICAgcHJvcDogJ3Byb3AnLFxuICAgIGNvbnRleHQ6ICdjb250ZXh0JyxcbiAgICBjaGlsZENvbnRleHQ6ICdjaGlsZCBjb250ZXh0J1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdpdmVuIGEgYHByZXZFbGVtZW50YCBhbmQgYG5leHRFbGVtZW50YCwgZGV0ZXJtaW5lcyBpZiB0aGUgZXhpc3RpbmdcbiAqIGluc3RhbmNlIHNob3VsZCBiZSB1cGRhdGVkIGFzIG9wcG9zZWQgdG8gYmVpbmcgZGVzdHJveWVkIG9yIHJlcGxhY2VkIGJ5IGEgbmV3XG4gKiBpbnN0YW5jZS4gQm90aCBhcmd1bWVudHMgYXJlIGVsZW1lbnRzLiBUaGlzIGVuc3VyZXMgdGhhdCB0aGlzIGxvZ2ljIGNhblxuICogb3BlcmF0ZSBvbiBzdGF0ZWxlc3MgdHJlZXMgd2l0aG91dCBhbnkgYmFja2luZyBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IHByZXZFbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG5leHRFbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBleGlzdGluZyBpbnN0YW5jZSBzaG91bGQgYmUgdXBkYXRlZC5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSB7XG4gIHZhciBwcmV2RW1wdHkgPSBwcmV2RWxlbWVudCA9PT0gbnVsbCB8fCBwcmV2RWxlbWVudCA9PT0gZmFsc2U7XG4gIHZhciBuZXh0RW1wdHkgPSBuZXh0RWxlbWVudCA9PT0gbnVsbCB8fCBuZXh0RWxlbWVudCA9PT0gZmFsc2U7XG4gIGlmIChwcmV2RW1wdHkgfHwgbmV4dEVtcHR5KSB7XG4gICAgcmV0dXJuIHByZXZFbXB0eSA9PT0gbmV4dEVtcHR5O1xuICB9XG5cbiAgdmFyIHByZXZUeXBlID0gdHlwZW9mIHByZXZFbGVtZW50O1xuICB2YXIgbmV4dFR5cGUgPSB0eXBlb2YgbmV4dEVsZW1lbnQ7XG4gIGlmIChwcmV2VHlwZSA9PT0gJ3N0cmluZycgfHwgcHJldlR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIG5leHRUeXBlID09PSAnc3RyaW5nJyB8fCBuZXh0VHlwZSA9PT0gJ251bWJlcic7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5leHRUeXBlID09PSAnb2JqZWN0JyAmJiBwcmV2RWxlbWVudC50eXBlID09PSBuZXh0RWxlbWVudC50eXBlICYmIHByZXZFbGVtZW50LmtleSA9PT0gbmV4dEVsZW1lbnQua2V5O1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RW1wdHlDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeSA9IHJlcXVpcmUoJy4vUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5Jyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xuXG52YXIgcGxhY2Vob2xkZXJFbGVtZW50O1xuXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbiA9IHtcbiAgaW5qZWN0RW1wdHlDb21wb25lbnQ6IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICBwbGFjZWhvbGRlckVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudChjb21wb25lbnQpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWdpc3Rlck51bGxDb21wb25lbnRJRCgpIHtcbiAgUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5LnJlZ2lzdGVyTnVsbENvbXBvbmVudElEKHRoaXMuX3Jvb3ROb2RlSUQpO1xufVxuXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IGZ1bmN0aW9uIChpbnN0YW50aWF0ZSkge1xuICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG51bGw7XG4gIHRoaXMuX3Jvb3ROb2RlSUQgPSBudWxsO1xuICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IGluc3RhbnRpYXRlKHBsYWNlaG9sZGVyRWxlbWVudCk7XG59O1xuYXNzaWduKFJlYWN0RW1wdHlDb21wb25lbnQucHJvdG90eXBlLCB7XG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGVsZW1lbnQpIHt9LFxuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHJlZ2lzdGVyTnVsbENvbXBvbmVudElELCB0aGlzKTtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gcm9vdElEO1xuICAgIHJldHVybiBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQodGhpcy5fcmVuZGVyZWRDb21wb25lbnQsIHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICB9LFxuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7fSxcbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudCh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCk7XG4gICAgUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5LmRlcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IG51bGw7XG4gICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xuICB9XG59KTtcblxuUmVhY3RFbXB0eUNvbXBvbmVudC5pbmplY3Rpb24gPSBSZWFjdEVtcHR5Q29tcG9uZW50SW5qZWN0aW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RW1wdHlDb21wb25lbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEVtcHR5Q29tcG9uZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TmF0aXZlQ29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBhdXRvR2VuZXJhdGVXcmFwcGVyQ2xhc3MgPSBudWxsO1xudmFyIGdlbmVyaWNDb21wb25lbnRDbGFzcyA9IG51bGw7XG4vLyBUaGlzIHJlZ2lzdHJ5IGtlZXBzIHRyYWNrIG9mIHdyYXBwZXIgY2xhc3NlcyBhcm91bmQgbmF0aXZlIHRhZ3MuXG52YXIgdGFnVG9Db21wb25lbnRDbGFzcyA9IHt9O1xudmFyIHRleHRDb21wb25lbnRDbGFzcyA9IG51bGw7XG5cbnZhciBSZWFjdE5hdGl2ZUNvbXBvbmVudEluamVjdGlvbiA9IHtcbiAgLy8gVGhpcyBhY2NlcHRzIGEgY2xhc3MgdGhhdCByZWNlaXZlcyB0aGUgdGFnIHN0cmluZy4gVGhpcyBpcyBhIGNhdGNoIGFsbFxuICAvLyB0aGF0IGNhbiByZW5kZXIgYW55IGtpbmQgb2YgdGFnLlxuICBpbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3M6IGZ1bmN0aW9uIChjb21wb25lbnRDbGFzcykge1xuICAgIGdlbmVyaWNDb21wb25lbnRDbGFzcyA9IGNvbXBvbmVudENsYXNzO1xuICB9LFxuICAvLyBUaGlzIGFjY2VwdHMgYSB0ZXh0IGNvbXBvbmVudCBjbGFzcyB0aGF0IHRha2VzIHRoZSB0ZXh0IHN0cmluZyB0byBiZVxuICAvLyByZW5kZXJlZCBhcyBwcm9wcy5cbiAgaW5qZWN0VGV4dENvbXBvbmVudENsYXNzOiBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3MpIHtcbiAgICB0ZXh0Q29tcG9uZW50Q2xhc3MgPSBjb21wb25lbnRDbGFzcztcbiAgfSxcbiAgLy8gVGhpcyBhY2NlcHRzIGEga2V5ZWQgb2JqZWN0IHdpdGggY2xhc3NlcyBhcyB2YWx1ZXMuIEVhY2gga2V5IHJlcHJlc2VudHMgYVxuICAvLyB0YWcuIFRoYXQgcGFydGljdWxhciB0YWcgd2lsbCB1c2UgdGhpcyBjbGFzcyBpbnN0ZWFkIG9mIHRoZSBnZW5lcmljIG9uZS5cbiAgaW5qZWN0Q29tcG9uZW50Q2xhc3NlczogZnVuY3Rpb24gKGNvbXBvbmVudENsYXNzZXMpIHtcbiAgICBhc3NpZ24odGFnVG9Db21wb25lbnRDbGFzcywgY29tcG9uZW50Q2xhc3Nlcyk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IGEgY29tcG9zaXRlIGNvbXBvbmVudCB3cmFwcGVyIGNsYXNzIGZvciBhIHNwZWNpZmljIHRhZy5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBUaGUgdGFnIGZvciB3aGljaCB0byBnZXQgdGhlIGNsYXNzLlxuICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBSZWFjdCBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50Q2xhc3NGb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZWxlbWVudC50eXBlO1xuICB9XG4gIHZhciB0YWcgPSBlbGVtZW50LnR5cGU7XG4gIHZhciBjb21wb25lbnRDbGFzcyA9IHRhZ1RvQ29tcG9uZW50Q2xhc3NbdGFnXTtcbiAgaWYgKGNvbXBvbmVudENsYXNzID09IG51bGwpIHtcbiAgICB0YWdUb0NvbXBvbmVudENsYXNzW3RhZ10gPSBjb21wb25lbnRDbGFzcyA9IGF1dG9HZW5lcmF0ZVdyYXBwZXJDbGFzcyh0YWcpO1xuICB9XG4gIHJldHVybiBjb21wb25lbnRDbGFzcztcbn1cblxuLyoqXG4gKiBHZXQgYSBuYXRpdmUgaW50ZXJuYWwgY29tcG9uZW50IGNsYXNzIGZvciBhIHNwZWNpZmljIHRhZy5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBjcmVhdGUuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGludGVybmFsIGNsYXNzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnRlcm5hbENvbXBvbmVudChlbGVtZW50KSB7XG4gICFnZW5lcmljQ29tcG9uZW50Q2xhc3MgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVGhlcmUgaXMgbm8gcmVnaXN0ZXJlZCBjb21wb25lbnQgZm9yIHRoZSB0YWcgJXMnLCBlbGVtZW50LnR5cGUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG5ldyBnZW5lcmljQ29tcG9uZW50Q2xhc3MoZWxlbWVudC50eXBlLCBlbGVtZW50LnByb3BzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0VGV4dH0gdGV4dFxuICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlRm9yVGV4dCh0ZXh0KSB7XG4gIHJldHVybiBuZXcgdGV4dENvbXBvbmVudENsYXNzKHRleHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Q29tcG9uZW50KGNvbXBvbmVudCkge1xuICByZXR1cm4gY29tcG9uZW50IGluc3RhbmNlb2YgdGV4dENvbXBvbmVudENsYXNzO1xufVxuXG52YXIgUmVhY3ROYXRpdmVDb21wb25lbnQgPSB7XG4gIGdldENvbXBvbmVudENsYXNzRm9yRWxlbWVudDogZ2V0Q29tcG9uZW50Q2xhc3NGb3JFbGVtZW50LFxuICBjcmVhdGVJbnRlcm5hbENvbXBvbmVudDogY3JlYXRlSW50ZXJuYWxDb21wb25lbnQsXG4gIGNyZWF0ZUluc3RhbmNlRm9yVGV4dDogY3JlYXRlSW5zdGFuY2VGb3JUZXh0LFxuICBpc1RleHRDb21wb25lbnQ6IGlzVGV4dENvbXBvbmVudCxcbiAgaW5qZWN0aW9uOiBSZWFjdE5hdGl2ZUNvbXBvbmVudEluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE5hdGl2ZUNvbXBvbmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0TmF0aXZlQ29tcG9uZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSB2YWxpZGF0ZURPTU5lc3RpbmdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBUaGlzIHZhbGlkYXRpb24gY29kZSB3YXMgd3JpdHRlbiBiYXNlZCBvbiB0aGUgSFRNTDUgcGFyc2luZyBzcGVjOlxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICAvL1xuICAvLyBOb3RlOiB0aGlzIGRvZXMgbm90IGNhdGNoIGFsbCBpbnZhbGlkIG5lc3RpbmcsIG5vciBkb2VzIGl0IHRyeSB0byAoYXMgaXQnc1xuICAvLyBub3QgY2xlYXIgd2hhdCBwcmFjdGljYWwgYmVuZWZpdCBkb2luZyBzbyBwcm92aWRlcyk7IGluc3RlYWQsIHdlIHdhcm4gb25seVxuICAvLyBmb3IgY2FzZXMgd2hlcmUgdGhlIHBhcnNlciB3aWxsIGdpdmUgYSBwYXJzZSB0cmVlIGRpZmZlcmluZyBmcm9tIHdoYXQgUmVhY3RcbiAgLy8gaW50ZW5kZWQuIEZvciBleGFtcGxlLCA8Yj48ZGl2PjwvZGl2PjwvYj4gaXMgaW52YWxpZCBidXQgd2UgZG9uJ3Qgd2FyblxuICAvLyBiZWNhdXNlIGl0IHN0aWxsIHBhcnNlcyBjb3JyZWN0bHk7IHdlIGRvIHdhcm4gZm9yIG90aGVyIGNhc2VzIGxpa2UgbmVzdGVkXG4gIC8vIDxwPiB0YWdzIHdoZXJlIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlY29uZCBlbGVtZW50IGltcGxpY2l0bHkgY2xvc2VzIHRoZVxuICAvLyBmaXJzdCwgY2F1c2luZyBhIGNvbmZ1c2luZyBtZXNzLlxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3NwZWNpYWxcbiAgdmFyIHNwZWNpYWxUYWdzID0gWydhZGRyZXNzJywgJ2FwcGxldCcsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmFzZScsICdiYXNlZm9udCcsICdiZ3NvdW5kJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FwdGlvbicsICdjZW50ZXInLCAnY29sJywgJ2NvbGdyb3VwJywgJ2RkJywgJ2RldGFpbHMnLCAnZGlyJywgJ2RpdicsICdkbCcsICdkdCcsICdlbWJlZCcsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb290ZXInLCAnZm9ybScsICdmcmFtZScsICdmcmFtZXNldCcsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkJywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLCAnaHRtbCcsICdpZnJhbWUnLCAnaW1nJywgJ2lucHV0JywgJ2lzaW5kZXgnLCAnbGknLCAnbGluaycsICdsaXN0aW5nJywgJ21haW4nLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGEnLCAnbmF2JywgJ25vZW1iZWQnLCAnbm9mcmFtZXMnLCAnbm9zY3JpcHQnLCAnb2JqZWN0JywgJ29sJywgJ3AnLCAncGFyYW0nLCAncGxhaW50ZXh0JywgJ3ByZScsICdzY3JpcHQnLCAnc2VjdGlvbicsICdzZWxlY3QnLCAnc291cmNlJywgJ3N0eWxlJywgJ3N1bW1hcnknLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGl0bGUnLCAndHInLCAndHJhY2snLCAndWwnLCAnd2JyJywgJ3htcCddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIHZhciBpblNjb3BlVGFncyA9IFsnYXBwbGV0JywgJ2NhcHRpb24nLCAnaHRtbCcsICd0YWJsZScsICd0ZCcsICd0aCcsICdtYXJxdWVlJywgJ29iamVjdCcsICd0ZW1wbGF0ZScsXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaHRtbC1pbnRlZ3JhdGlvbi1wb2ludFxuICAvLyBUT0RPOiBEaXN0aW5ndWlzaCBieSBuYW1lc3BhY2UgaGVyZSAtLSBmb3IgPHRpdGxlPiwgaW5jbHVkaW5nIGl0IGhlcmVcbiAgLy8gZXJycyBvbiB0aGUgc2lkZSBvZiBmZXdlciB3YXJuaW5nc1xuICAnZm9yZWlnbk9iamVjdCcsICdkZXNjJywgJ3RpdGxlJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tYnV0dG9uLXNjb3BlXG4gIHZhciBidXR0b25TY29wZVRhZ3MgPSBpblNjb3BlVGFncy5jb25jYXQoWydidXR0b24nXSk7XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjZ2VuZXJhdGUtaW1wbGllZC1lbmQtdGFnc1xuICB2YXIgaW1wbGllZEVuZFRhZ3MgPSBbJ2RkJywgJ2R0JywgJ2xpJywgJ29wdGlvbicsICdvcHRncm91cCcsICdwJywgJ3JwJywgJ3J0J107XG5cbiAgdmFyIGVtcHR5QW5jZXN0b3JJbmZvID0ge1xuICAgIHBhcmVudFRhZzogbnVsbCxcblxuICAgIGZvcm1UYWc6IG51bGwsXG4gICAgYVRhZ0luU2NvcGU6IG51bGwsXG4gICAgYnV0dG9uVGFnSW5TY29wZTogbnVsbCxcbiAgICBub2JyVGFnSW5TY29wZTogbnVsbCxcbiAgICBwVGFnSW5CdXR0b25TY29wZTogbnVsbCxcblxuICAgIGxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGwsXG4gICAgZGxJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGxcbiAgfTtcblxuICB2YXIgdXBkYXRlZEFuY2VzdG9ySW5mbyA9IGZ1bmN0aW9uIChvbGRJbmZvLCB0YWcsIGluc3RhbmNlKSB7XG4gICAgdmFyIGFuY2VzdG9ySW5mbyA9IGFzc2lnbih7fSwgb2xkSW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGluZm8gPSB7IHRhZzogdGFnLCBpbnN0YW5jZTogaW5zdGFuY2UgfTtcblxuICAgIGlmIChpblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGJ1dHRvblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlZSBydWxlcyBmb3IgJ2xpJywgJ2RkJywgJ2R0JyBzdGFydCB0YWdzIGluXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIGlmIChzcGVjaWFsVGFncy5pbmRleE9mKHRhZykgIT09IC0xICYmIHRhZyAhPT0gJ2FkZHJlc3MnICYmIHRhZyAhPT0gJ2RpdicgJiYgdGFnICE9PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgfVxuXG4gICAgYW5jZXN0b3JJbmZvLnBhcmVudFRhZyA9IGluZm87XG5cbiAgICBpZiAodGFnID09PSAnZm9ybScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5mb3JtVGFnID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2EnKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYnV0dG9uJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbm9icicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2xpJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnZGQnIHx8IHRhZyA9PT0gJ2R0Jykge1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jZXN0b3JJbmZvO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBpc1RhZ1ZhbGlkV2l0aFBhcmVudCA9IGZ1bmN0aW9uICh0YWcsIHBhcmVudFRhZykge1xuICAgIC8vIEZpcnN0LCBsZXQncyBjaGVjayBpZiB3ZSdyZSBpbiBhbiB1bnVzdWFsIHBhcnNpbmcgbW9kZS4uLlxuICAgIHN3aXRjaCAocGFyZW50VGFnKSB7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5zZWxlY3RcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJ29wdGdyb3VwJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICBjYXNlICdvcHRncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIFN0cmljdGx5IHNwZWFraW5nLCBzZWVpbmcgYW4gPG9wdGlvbj4gZG9lc24ndCBtZWFuIHdlJ3JlIGluIGEgPHNlbGVjdD5cbiAgICAgIC8vIGJ1dFxuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJyN0ZXh0JztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGRcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNhcHRpb25cbiAgICAgIC8vIE5vIHNwZWNpYWwgYmVoYXZpb3Igc2luY2UgdGhlc2UgcnVsZXMgZmFsbCBiYWNrIHRvIFwiaW4gYm9keVwiIG1vZGUgZm9yXG4gICAgICAvLyBhbGwgZXhjZXB0IHNwZWNpYWwgdGFibGUgbm9kZXMgd2hpY2ggY2F1c2UgYmFkIHBhcnNpbmcgYmVoYXZpb3IgYW55d2F5LlxuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50clxuICAgICAgY2FzZSAndHInOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndGgnIHx8IHRhZyA9PT0gJ3RkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRib2R5XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0cicgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jb2xncm91cFxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY29sJyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRhYmxlXG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjYXB0aW9uJyB8fCB0YWcgPT09ICdjb2xncm91cCcgfHwgdGFnID09PSAndGJvZHknIHx8IHRhZyA9PT0gJ3Rmb290JyB8fCB0YWcgPT09ICd0aGVhZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5oZWFkXG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2Jhc2UnIHx8IHRhZyA9PT0gJ2Jhc2Vmb250JyB8fCB0YWcgPT09ICdiZ3NvdW5kJyB8fCB0YWcgPT09ICdsaW5rJyB8fCB0YWcgPT09ICdtZXRhJyB8fCB0YWcgPT09ICd0aXRsZScgfHwgdGFnID09PSAnbm9zY3JpcHQnIHx8IHRhZyA9PT0gJ25vZnJhbWVzJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI3RoZS1odG1sLWVsZW1lbnRcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaGVhZCcgfHwgdGFnID09PSAnYm9keSc7XG4gICAgfVxuXG4gICAgLy8gUHJvYmFibHkgaW4gdGhlIFwiaW4gYm9keVwiIHBhcnNpbmcgbW9kZSwgc28gd2Ugb3V0bGF3IG9ubHkgdGFnIGNvbWJvc1xuICAgIC8vIHdoZXJlIHRoZSBwYXJzaW5nIHJ1bGVzIGNhdXNlIGltcGxpY2l0IG9wZW5zIG9yIGNsb3NlcyB0byBiZSBhZGRlZC5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyAhPT0gJ2gxJyAmJiBwYXJlbnRUYWcgIT09ICdoMicgJiYgcGFyZW50VGFnICE9PSAnaDMnICYmIHBhcmVudFRhZyAhPT0gJ2g0JyAmJiBwYXJlbnRUYWcgIT09ICdoNScgJiYgcGFyZW50VGFnICE9PSAnaDYnO1xuXG4gICAgICBjYXNlICdycCc6XG4gICAgICBjYXNlICdydCc6XG4gICAgICAgIHJldHVybiBpbXBsaWVkRW5kVGFncy5pbmRleE9mKHBhcmVudFRhZykgPT09IC0xO1xuXG4gICAgICBjYXNlICdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2NvbCc6XG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgIGNhc2UgJ3RoJzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgLy8gVGhlc2UgdGFncyBhcmUgb25seSB2YWxpZCB3aXRoIGEgZmV3IHBhcmVudHMgdGhhdCBoYXZlIHNwZWNpYWwgY2hpbGRcbiAgICAgICAgLy8gcGFyc2luZyBydWxlcyAtLSBpZiB3ZSdyZSBkb3duIGhlcmUsIHRoZW4gbm9uZSBvZiB0aG9zZSBtYXRjaGVkIGFuZFxuICAgICAgICAvLyBzbyB3ZSBhbGxvdyBpdCBvbmx5IGlmIHdlIGRvbid0IGtub3cgd2hhdCB0aGUgcGFyZW50IGlzLCBhcyBhbGwgb3RoZXJcbiAgICAgICAgLy8gY2FzZXMgYXJlIGludmFsaWQuXG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgPT0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgZmluZEludmFsaWRBbmNlc3RvckZvclRhZyA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdhZGRyZXNzJzpcbiAgICAgIGNhc2UgJ2FydGljbGUnOlxuICAgICAgY2FzZSAnYXNpZGUnOlxuICAgICAgY2FzZSAnYmxvY2txdW90ZSc6XG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICBjYXNlICdkaWFsb2cnOlxuICAgICAgY2FzZSAnZGlyJzpcbiAgICAgIGNhc2UgJ2Rpdic6XG4gICAgICBjYXNlICdkbCc6XG4gICAgICBjYXNlICdmaWVsZHNldCc6XG4gICAgICBjYXNlICdmaWdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2ZpZ3VyZSc6XG4gICAgICBjYXNlICdmb290ZXInOlxuICAgICAgY2FzZSAnaGVhZGVyJzpcbiAgICAgIGNhc2UgJ2hncm91cCc6XG4gICAgICBjYXNlICdtYWluJzpcbiAgICAgIGNhc2UgJ21lbnUnOlxuICAgICAgY2FzZSAnbmF2JzpcbiAgICAgIGNhc2UgJ29sJzpcbiAgICAgIGNhc2UgJ3AnOlxuICAgICAgY2FzZSAnc2VjdGlvbic6XG4gICAgICBjYXNlICdzdW1tYXJ5JzpcbiAgICAgIGNhc2UgJ3VsJzpcblxuICAgICAgY2FzZSAncHJlJzpcbiAgICAgIGNhc2UgJ2xpc3RpbmcnOlxuXG4gICAgICBjYXNlICd0YWJsZSc6XG5cbiAgICAgIGNhc2UgJ2hyJzpcblxuICAgICAgY2FzZSAneG1wJzpcblxuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5mb3JtVGFnIHx8IGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnbGknOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2RkJzpcbiAgICAgIGNhc2UgJ2R0JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgLy8gU3BlYyBzYXlzIHNvbWV0aGluZyBhYm91dCBzdG9yaW5nIGEgbGlzdCBvZiBtYXJrZXJzLCBidXQgaXQgc291bmRzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gdGhpcyBjaGVjay5cbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnbm9icic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgaW5zdGFuY2UsIHJldHVybiBhIGxpc3Qgb2YgaXRzIHJlY3Vyc2l2ZVxuICAgKiBvd25lcnMsIHN0YXJ0aW5nIGF0IHRoZSByb290IGFuZCBlbmRpbmcgd2l0aCB0aGUgaW5zdGFuY2UgaXRzZWxmLlxuICAgKi9cbiAgdmFyIGZpbmRPd25lclN0YWNrID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIC8qZXNsaW50LWRpc2FibGUgc3BhY2UtYWZ0ZXIta2V5d29yZHMgKi9cbiAgICBkbyB7XG4gICAgICAvKmVzbGludC1lbmFibGUgc3BhY2UtYWZ0ZXIta2V5d29yZHMgKi9cbiAgICAgIHN0YWNrLnB1c2goaW5zdGFuY2UpO1xuICAgIH0gd2hpbGUgKGluc3RhbmNlID0gaW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG4gICAgc3RhY2sucmV2ZXJzZSgpO1xuICAgIHJldHVybiBzdGFjaztcbiAgfTtcblxuICB2YXIgZGlkV2FybiA9IHt9O1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZyA9IGZ1bmN0aW9uIChjaGlsZFRhZywgY2hpbGRJbnN0YW5jZSwgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLnBhcmVudFRhZztcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcblxuICAgIHZhciBpbnZhbGlkUGFyZW50ID0gaXNUYWdWYWxpZFdpdGhQYXJlbnQoY2hpbGRUYWcsIHBhcmVudFRhZykgPyBudWxsIDogcGFyZW50SW5mbztcbiAgICB2YXIgaW52YWxpZEFuY2VzdG9yID0gaW52YWxpZFBhcmVudCA/IG51bGwgOiBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKGNoaWxkVGFnLCBhbmNlc3RvckluZm8pO1xuICAgIHZhciBwcm9ibGVtYXRpYyA9IGludmFsaWRQYXJlbnQgfHwgaW52YWxpZEFuY2VzdG9yO1xuXG4gICAgaWYgKHByb2JsZW1hdGljKSB7XG4gICAgICB2YXIgYW5jZXN0b3JUYWcgPSBwcm9ibGVtYXRpYy50YWc7XG4gICAgICB2YXIgYW5jZXN0b3JJbnN0YW5jZSA9IHByb2JsZW1hdGljLmluc3RhbmNlO1xuXG4gICAgICB2YXIgY2hpbGRPd25lciA9IGNoaWxkSW5zdGFuY2UgJiYgY2hpbGRJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIGFuY2VzdG9yT3duZXIgPSBhbmNlc3Rvckluc3RhbmNlICYmIGFuY2VzdG9ySW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcblxuICAgICAgdmFyIGNoaWxkT3duZXJzID0gZmluZE93bmVyU3RhY2soY2hpbGRPd25lcik7XG4gICAgICB2YXIgYW5jZXN0b3JPd25lcnMgPSBmaW5kT3duZXJTdGFjayhhbmNlc3Rvck93bmVyKTtcblxuICAgICAgdmFyIG1pblN0YWNrTGVuID0gTWF0aC5taW4oY2hpbGRPd25lcnMubGVuZ3RoLCBhbmNlc3Rvck93bmVycy5sZW5ndGgpO1xuICAgICAgdmFyIGk7XG5cbiAgICAgIHZhciBkZWVwZXN0Q29tbW9uID0gLTE7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbWluU3RhY2tMZW47IGkrKykge1xuICAgICAgICBpZiAoY2hpbGRPd25lcnNbaV0gPT09IGFuY2VzdG9yT3duZXJzW2ldKSB7XG4gICAgICAgICAgZGVlcGVzdENvbW1vbiA9IGk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIFVOS05PV04gPSAnKHVua25vd24pJztcbiAgICAgIHZhciBjaGlsZE93bmVyTmFtZXMgPSBjaGlsZE93bmVycy5zbGljZShkZWVwZXN0Q29tbW9uICsgMSkubWFwKGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgICAgIHJldHVybiBpbnN0LmdldE5hbWUoKSB8fCBVTktOT1dOO1xuICAgICAgfSk7XG4gICAgICB2YXIgYW5jZXN0b3JPd25lck5hbWVzID0gYW5jZXN0b3JPd25lcnMuc2xpY2UoZGVlcGVzdENvbW1vbiArIDEpLm1hcChmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgICByZXR1cm4gaW5zdC5nZXROYW1lKCkgfHwgVU5LTk9XTjtcbiAgICAgIH0pO1xuICAgICAgdmFyIG93bmVySW5mbyA9IFtdLmNvbmNhdChcbiAgICAgIC8vIElmIHRoZSBwYXJlbnQgYW5kIGNoaWxkIGluc3RhbmNlcyBoYXZlIGEgY29tbW9uIG93bmVyIGFuY2VzdG9yLCBzdGFydFxuICAgICAgLy8gd2l0aCB0aGF0IC0tIG90aGVyd2lzZSB3ZSBqdXN0IHN0YXJ0IHdpdGggdGhlIHBhcmVudCdzIG93bmVycy5cbiAgICAgIGRlZXBlc3RDb21tb24gIT09IC0xID8gY2hpbGRPd25lcnNbZGVlcGVzdENvbW1vbl0uZ2V0TmFtZSgpIHx8IFVOS05PV04gOiBbXSwgYW5jZXN0b3JPd25lck5hbWVzLCBhbmNlc3RvclRhZyxcbiAgICAgIC8vIElmIHdlJ3JlIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCAobm9uLXBhcmVudCkgYW5jZXN0cnksIGFkZCAnLi4uJ1xuICAgICAgaW52YWxpZEFuY2VzdG9yID8gWycuLi4nXSA6IFtdLCBjaGlsZE93bmVyTmFtZXMsIGNoaWxkVGFnKS5qb2luKCcgPiAnKTtcblxuICAgICAgdmFyIHdhcm5LZXkgPSAhIWludmFsaWRQYXJlbnQgKyAnfCcgKyBjaGlsZFRhZyArICd8JyArIGFuY2VzdG9yVGFnICsgJ3wnICsgb3duZXJJbmZvO1xuICAgICAgaWYgKGRpZFdhcm5bd2FybktleV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGlkV2Fyblt3YXJuS2V5XSA9IHRydWU7XG5cbiAgICAgIGlmIChpbnZhbGlkUGFyZW50KSB7XG4gICAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICAgIGlmIChhbmNlc3RvclRhZyA9PT0gJ3RhYmxlJyAmJiBjaGlsZFRhZyA9PT0gJ3RyJykge1xuICAgICAgICAgIGluZm8gKz0gJyBBZGQgYSA8dGJvZHk+IHRvIHlvdXIgY29kZSB0byBtYXRjaCB0aGUgRE9NIHRyZWUgZ2VuZXJhdGVkIGJ5ICcgKyAndGhlIGJyb3dzZXIuJztcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiA8JXM+IGNhbm5vdCBhcHBlYXIgYXMgYSBjaGlsZCBvZiA8JXM+LiAnICsgJ1NlZSAlcy4lcycsIGNoaWxkVGFnLCBhbmNlc3RvclRhZywgb3duZXJJbmZvLCBpbmZvKSA6IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6IDwlcz4gY2Fubm90IGFwcGVhciBhcyBhIGRlc2NlbmRhbnQgb2YgJyArICc8JXM+LiBTZWUgJXMuJywgY2hpbGRUYWcsIGFuY2VzdG9yVGFnLCBvd25lckluZm8pIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcuYW5jZXN0b3JJbmZvQ29udGV4dEtleSA9ICdfX3ZhbGlkYXRlRE9NTmVzdGluZ19hbmNlc3RvckluZm8kJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbztcblxuICAvLyBGb3IgdGVzdGluZ1xuICB2YWxpZGF0ZURPTU5lc3RpbmcuaXNUYWdWYWxpZEluQ29udGV4dCA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5wYXJlbnRUYWc7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG4gICAgcmV0dXJuIGlzVGFnVmFsaWRXaXRoUGFyZW50KHRhZywgcGFyZW50VGFnKSAmJiAhZmluZEludmFsaWRBbmNlc3RvckZvclRhZyh0YWcsIGFuY2VzdG9ySW5mbyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRhdGVET01OZXN0aW5nO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvdmFsaWRhdGVET01OZXN0aW5nLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RGVmYXVsdEluamVjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEJlZm9yZUlucHV0RXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4nKTtcbnZhciBDaGFuZ2VFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vQ2hhbmdlRXZlbnRQbHVnaW4nKTtcbnZhciBDbGllbnRSZWFjdFJvb3RJbmRleCA9IHJlcXVpcmUoJy4vQ2xpZW50UmVhY3RSb290SW5kZXgnKTtcbnZhciBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlciA9IHJlcXVpcmUoJy4vRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXInKTtcbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0VudGVyTGVhdmVFdmVudFBsdWdpbicpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBIVE1MRE9NUHJvcGVydHlDb25maWcgPSByZXF1aXJlKCcuL0hUTUxET01Qcm9wZXJ0eUNvbmZpZycpO1xudmFyIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbicpO1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kgPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3knKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnQnKTtcbnZhciBSZWFjdERPTVRleHRDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RE9NVGV4dENvbXBvbmVudCcpO1xudmFyIFJlYWN0RXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJy4vUmVhY3RFdmVudExpc3RlbmVyJyk7XG52YXIgUmVhY3RJbmplY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5qZWN0aW9uJyk7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VIYW5kbGVzJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24nKTtcbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vU2VsZWN0RXZlbnRQbHVnaW4nKTtcbnZhciBTZXJ2ZXJSZWFjdFJvb3RJbmRleCA9IHJlcXVpcmUoJy4vU2VydmVyUmVhY3RSb290SW5kZXgnKTtcbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vU2ltcGxlRXZlbnRQbHVnaW4nKTtcbnZhciBTVkdET01Qcm9wZXJ0eUNvbmZpZyA9IHJlcXVpcmUoJy4vU1ZHRE9NUHJvcGVydHlDb25maWcnKTtcblxudmFyIGFscmVhZHlJbmplY3RlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpbmplY3QoKSB7XG4gIGlmIChhbHJlYWR5SW5qZWN0ZWQpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGlzIGN1cnJlbnRseSB0cnVlIGJlY2F1c2UgdGhlc2UgaW5qZWN0aW9ucyBhcmUgc2hhcmVkIGJldHdlZW5cbiAgICAvLyB0aGUgY2xpZW50IGFuZCB0aGUgc2VydmVyIHBhY2thZ2UuIFRoZXkgc2hvdWxkIGJlIGJ1aWx0IGluZGVwZW5kZW50bHlcbiAgICAvLyBhbmQgbm90IHNoYXJlIGFueSBpbmplY3Rpb24gc3RhdGUuIFRoZW4gdGhpcyBwcm9ibGVtIHdpbGwgYmUgc29sdmVkLlxuICAgIHJldHVybjtcbiAgfVxuICBhbHJlYWR5SW5qZWN0ZWQgPSB0cnVlO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50RW1pdHRlci5pbmplY3RSZWFjdEV2ZW50TGlzdGVuZXIoUmVhY3RFdmVudExpc3RlbmVyKTtcblxuICAvKipcbiAgICogSW5qZWN0IG1vZHVsZXMgZm9yIHJlc29sdmluZyBET00gaGllcmFyY2h5IGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gICAqL1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RFdmVudFBsdWdpbk9yZGVyKERlZmF1bHRFdmVudFBsdWdpbk9yZGVyKTtcbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0SW5zdGFuY2VIYW5kbGUoUmVhY3RJbnN0YW5jZUhhbmRsZXMpO1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RNb3VudChSZWFjdE1vdW50KTtcblxuICAvKipcbiAgICogU29tZSBpbXBvcnRhbnQgZXZlbnQgcGx1Z2lucyBpbmNsdWRlZCBieSBkZWZhdWx0ICh3aXRob3V0IGhhdmluZyB0byByZXF1aXJlXG4gICAqIHRoZW0pLlxuICAgKi9cbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtcbiAgICBTaW1wbGVFdmVudFBsdWdpbjogU2ltcGxlRXZlbnRQbHVnaW4sXG4gICAgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOiBFbnRlckxlYXZlRXZlbnRQbHVnaW4sXG4gICAgQ2hhbmdlRXZlbnRQbHVnaW46IENoYW5nZUV2ZW50UGx1Z2luLFxuICAgIFNlbGVjdEV2ZW50UGx1Z2luOiBTZWxlY3RFdmVudFBsdWdpbixcbiAgICBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luOiBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXG4gIH0pO1xuXG4gIFJlYWN0SW5qZWN0aW9uLk5hdGl2ZUNvbXBvbmVudC5pbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3MoUmVhY3RET01Db21wb25lbnQpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLk5hdGl2ZUNvbXBvbmVudC5pbmplY3RUZXh0Q29tcG9uZW50Q2xhc3MoUmVhY3RET01UZXh0Q29tcG9uZW50KTtcblxuICBSZWFjdEluamVjdGlvbi5DbGFzcy5pbmplY3RNaXhpbihSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbik7XG5cbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoSFRNTERPTVByb3BlcnR5Q29uZmlnKTtcbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoU1ZHRE9NUHJvcGVydHlDb25maWcpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkVtcHR5Q29tcG9uZW50LmluamVjdEVtcHR5Q29tcG9uZW50KCdub3NjcmlwdCcpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0UmVjb25jaWxlVHJhbnNhY3Rpb24oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbik7XG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0QmF0Y2hpbmdTdHJhdGVneShSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5KTtcblxuICBSZWFjdEluamVjdGlvbi5Sb290SW5kZXguaW5qZWN0Q3JlYXRlUmVhY3RSb290SW5kZXgoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gQ2xpZW50UmVhY3RSb290SW5kZXguY3JlYXRlUmVhY3RSb290SW5kZXggOiBTZXJ2ZXJSZWFjdFJvb3RJbmRleC5jcmVhdGVSZWFjdFJvb3RJbmRleCk7XG5cbiAgUmVhY3RJbmplY3Rpb24uQ29tcG9uZW50LmluamVjdEVudmlyb25tZW50KFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50KTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciB1cmwgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LmxvY2F0aW9uLmhyZWYgfHwgJyc7XG4gICAgaWYgKC9bPyZdcmVhY3RfcGVyZlxcYi8udGVzdCh1cmwpKSB7XG4gICAgICB2YXIgUmVhY3REZWZhdWx0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0UGVyZicpO1xuICAgICAgUmVhY3REZWZhdWx0UGVyZi5zdGFydCgpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5qZWN0OiBpbmplY3Rcbn07XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERlZmF1bHRJbmplY3Rpb24uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlID0gcmVxdWlyZSgnLi9GYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUnKTtcbnZhciBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50Jyk7XG52YXIgU3ludGhldGljSW5wdXRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljSW5wdXRFdmVudCcpO1xuXG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xuXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxudmFyIFNUQVJUX0tFWUNPREUgPSAyMjk7XG5cbnZhciBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdDb21wb3NpdGlvbkV2ZW50JyBpbiB3aW5kb3c7XG5cbnZhciBkb2N1bWVudE1vZGUgPSBudWxsO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkge1xuICBkb2N1bWVudE1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG59XG5cbi8vIFdlYmtpdCBvZmZlcnMgYSB2ZXJ5IHVzZWZ1bCBgdGV4dElucHV0YCBldmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4vLyBkaXJlY3RseSByZXByZXNlbnQgYGJlZm9yZUlucHV0YC4gVGhlIElFIGB0ZXh0aW5wdXRgIGV2ZW50IGlzIG5vdCBhc1xuLy8gdXNlZnVsLCBzbyB3ZSBkb24ndCB1c2UgaXQuXG52YXIgY2FuVXNlVGV4dElucHV0RXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgJiYgIWlzUHJlc3RvKCk7XG5cbi8vIEluIElFOSssIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2l0aW9uIGV2ZW50cywgYnV0IHRoZSBkYXRhIHN1cHBsaWVkXG4vLyBieSB0aGUgbmF0aXZlIGNvbXBvc2l0aW9uZW5kIGV2ZW50IG1heSBiZSBpbmNvcnJlY3QuIEphcGFuZXNlIGlkZW9ncmFwaGljXG4vLyBzcGFjZXMsIGZvciBpbnN0YW5jZSAoXFx1MzAwMCkgYXJlIG5vdCByZWNvcmRlZCBjb3JyZWN0bHkuXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IHx8IGRvY3VtZW50TW9kZSAmJiBkb2N1bWVudE1vZGUgPiA4ICYmIGRvY3VtZW50TW9kZSA8PSAxMSk7XG5cbi8qKlxuICogT3BlcmEgPD0gMTIgaW5jbHVkZXMgVGV4dEV2ZW50IGluIHdpbmRvdywgYnV0IGRvZXMgbm90IGZpcmVcbiAqIHRleHQgaW5wdXQgZXZlbnRzLiBSZWx5IG9uIGtleXByZXNzIGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uIGlzUHJlc3RvKCkge1xuICB2YXIgb3BlcmEgPSB3aW5kb3cub3BlcmE7XG4gIHJldHVybiB0eXBlb2Ygb3BlcmEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcGVyYS52ZXJzaW9uID09PSAnZnVuY3Rpb24nICYmIHBhcnNlSW50KG9wZXJhLnZlcnNpb24oKSwgMTApIDw9IDEyO1xufVxuXG52YXIgU1BBQ0VCQVJfQ09ERSA9IDMyO1xudmFyIFNQQUNFQkFSX0NIQVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFNQQUNFQkFSX0NPREUpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbi8vIEV2ZW50cyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSBuYW1lcy5cbnZhciBldmVudFR5cGVzID0ge1xuICBiZWZvcmVJbnB1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQmVmb3JlSW5wdXQ6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkJlZm9yZUlucHV0Q2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZCwgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcywgdG9wTGV2ZWxUeXBlcy50b3BUZXh0SW5wdXQsIHRvcExldmVsVHlwZXMudG9wUGFzdGVdXG4gIH0sXG4gIGNvbXBvc2l0aW9uRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvbkVuZDogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25FbmRDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcywgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd25dXG4gIH0sXG4gIGNvbXBvc2l0aW9uU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uU3RhcnQ6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uU3RhcnRDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25TdGFydCwgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLCB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzLCB0b3BMZXZlbFR5cGVzLnRvcEtleVVwLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bl1cbiAgfSxcbiAgY29tcG9zaXRpb25VcGRhdGU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uVXBkYXRlOiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvblVwZGF0ZUNhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQmx1ciwgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvblVwZGF0ZSwgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLCB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzLCB0b3BMZXZlbFR5cGVzLnRvcEtleVVwLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bl1cbiAgfVxufTtcblxuLy8gVHJhY2sgd2hldGhlciB3ZSd2ZSBldmVyIGhhbmRsZWQgYSBrZXlwcmVzcyBvbiB0aGUgc3BhY2Uga2V5LlxudmFyIGhhc1NwYWNlS2V5cHJlc3MgPSBmYWxzZTtcblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBhIG5hdGl2ZSBrZXlwcmVzcyBldmVudCBpcyBhc3N1bWVkIHRvIGJlIGEgY29tbWFuZC5cbiAqIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBGaXJlZm94IGZpcmVzIGBrZXlwcmVzc2AgZXZlbnRzIGZvciBrZXkgY29tbWFuZHNcbiAqIChjdXQsIGNvcHksIHNlbGVjdC1hbGwsIGV0Yy4pIGV2ZW4gdGhvdWdoIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIChuYXRpdmVFdmVudC5jdHJsS2V5IHx8IG5hdGl2ZUV2ZW50LmFsdEtleSB8fCBuYXRpdmVFdmVudC5tZXRhS2V5KSAmJlxuICAvLyBjdHJsS2V5ICYmIGFsdEtleSBpcyBlcXVpdmFsZW50IHRvIEFsdEdyLCBhbmQgaXMgbm90IGEgY29tbWFuZC5cbiAgIShuYXRpdmVFdmVudC5jdHJsS2V5ICYmIG5hdGl2ZUV2ZW50LmFsdEtleSk7XG59XG5cbi8qKlxuICogVHJhbnNsYXRlIG5hdGl2ZSB0b3AgbGV2ZWwgZXZlbnRzIGludG8gZXZlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25TdGFydDpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uVXBkYXRlOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25VcGRhdGU7XG4gIH1cbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBiZXN0LWd1ZXNzIG1vZGVsIHRoaW5rIHRoaXMgZXZlbnQgc2lnbmlmaWVzIHRoYXRcbiAqIGNvbXBvc2l0aW9uIGhhcyBiZWd1bj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duICYmIG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IFNUQVJUX0tFWUNPREU7XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgbW9kZSB0aGluayB0aGF0IHRoaXMgZXZlbnQgaXMgdGhlIGVuZCBvZiBjb21wb3NpdGlvbj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwOlxuICAgICAgLy8gQ29tbWFuZCBrZXlzIGluc2VydCBvciBjbGVhciBJTUUgaW5wdXQuXG4gICAgICByZXR1cm4gRU5EX0tFWUNPREVTLmluZGV4T2YobmF0aXZlRXZlbnQua2V5Q29kZSkgIT09IC0xO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duOlxuICAgICAgLy8gRXhwZWN0IElNRSBrZXlDb2RlIG9uIGVhY2gga2V5ZG93bi4gSWYgd2UgZ2V0IGFueSBvdGhlclxuICAgICAgLy8gY29kZSB3ZSBtdXN0IGhhdmUgZXhpdGVkIGVhcmxpZXIuXG4gICAgICByZXR1cm4gbmF0aXZlRXZlbnQua2V5Q29kZSAhPT0gU1RBUlRfS0VZQ09ERTtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3M6XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bjpcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQmx1cjpcbiAgICAgIC8vIEV2ZW50cyBhcmUgbm90IHBvc3NpYmxlIHdpdGhvdXQgY2FuY2VsbGluZyBJTUUuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogR29vZ2xlIElucHV0IFRvb2xzIHByb3ZpZGVzIGNvbXBvc2l0aW9uIGRhdGEgdmlhIGEgQ3VzdG9tRXZlbnQsXG4gKiB3aXRoIHRoZSBgZGF0YWAgcHJvcGVydHkgcG9wdWxhdGVkIGluIHRoZSBgZGV0YWlsYCBvYmplY3QuIElmIHRoaXNcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgZXZlbnQgb2JqZWN0LCB1c2UgaXQuIElmIG5vdCwgdGhpcyBpcyBhIHBsYWluXG4gKiBjb21wb3NpdGlvbiBldmVudCBhbmQgd2UgaGF2ZSBub3RoaW5nIHNwZWNpYWwgdG8gZXh0cmFjdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9zdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGRldGFpbCA9IG5hdGl2ZUV2ZW50LmRldGFpbDtcbiAgaWYgKHR5cGVvZiBkZXRhaWwgPT09ICdvYmplY3QnICYmICdkYXRhJyBpbiBkZXRhaWwpIHtcbiAgICByZXR1cm4gZGV0YWlsLmRhdGE7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIFRyYWNrIHRoZSBjdXJyZW50IElNRSBjb21wb3NpdGlvbiBmYWxsYmFjayBvYmplY3QsIGlmIGFueS5cbnZhciBjdXJyZW50Q29tcG9zaXRpb24gPSBudWxsO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRUeXBlO1xuICB2YXIgZmFsbGJhY2tEYXRhO1xuXG4gIGlmIChjYW5Vc2VDb21wb3NpdGlvbkV2ZW50KSB7XG4gICAgZXZlbnRUeXBlID0gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKTtcbiAgfSBlbHNlIGlmICghY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gIH1cblxuICBpZiAoIWV2ZW50VHlwZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQgY29tcG9zaXRpb24gaXMgc3RvcmVkIHN0YXRpY2FsbHkgYW5kIG11c3Qgbm90IGJlXG4gICAgLy8gb3ZlcndyaXR0ZW4gd2hpbGUgY29tcG9zaXRpb24gY29udGludWVzLlxuICAgIGlmICghY3VycmVudENvbXBvc2l0aW9uICYmIGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0KSB7XG4gICAgICBjdXJyZW50Q29tcG9zaXRpb24gPSBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUuZ2V0UG9vbGVkKHRvcExldmVsVGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZCkge1xuICAgICAgaWYgKGN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgICAgICBmYWxsYmFja0RhdGEgPSBjdXJyZW50Q29tcG9zaXRpb24uZ2V0RGF0YSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZSwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBpZiAoZmFsbGJhY2tEYXRhKSB7XG4gICAgLy8gSW5qZWN0IGRhdGEgZ2VuZXJhdGVkIGZyb20gZmFsbGJhY2sgcGF0aCBpbnRvIHRoZSBzeW50aGV0aWMgZXZlbnQuXG4gICAgLy8gVGhpcyBtYXRjaGVzIHRoZSBwcm9wZXJ0eSBvZiBuYXRpdmUgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZS5cbiAgICBldmVudC5kYXRhID0gZmFsbGJhY2tEYXRhO1xuICB9IGVsc2Uge1xuICAgIHZhciBjdXN0b21EYXRhID0gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgaWYgKGN1c3RvbURhdGEgIT09IG51bGwpIHtcbiAgICAgIGV2ZW50LmRhdGEgPSBjdXN0b21EYXRhO1xuICAgIH1cbiAgfVxuXG4gIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgc3RyaW5nIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQ6XG4gICAgICByZXR1cm4gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzOlxuICAgICAgLyoqXG4gICAgICAgKiBJZiBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRzIGFyZSBhdmFpbGFibGUsIG91ciBnb2FsIGlzIHRvIG1ha2VcbiAgICAgICAqIHVzZSBvZiB0aGVtLiBIb3dldmVyLCB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZTogdGhlIHNwYWNlYmFyIGtleS5cbiAgICAgICAqIEluIFdlYmtpdCwgcHJldmVudGluZyBkZWZhdWx0IG9uIGEgc3BhY2ViYXIgYHRleHRJbnB1dGAgZXZlbnRcbiAgICAgICAqIGNhbmNlbHMgY2hhcmFjdGVyIGluc2VydGlvbiwgYnV0IGl0ICphbHNvKiBjYXVzZXMgdGhlIGJyb3dzZXJcbiAgICAgICAqIHRvIGZhbGwgYmFjayB0byBpdHMgZGVmYXVsdCBzcGFjZWJhciBiZWhhdmlvciBvZiBzY3JvbGxpbmcgdGhlXG4gICAgICAgKiBwYWdlLlxuICAgICAgICpcbiAgICAgICAqIFRyYWNraW5nIGF0OlxuICAgICAgICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM1NTEwM1xuICAgICAgICpcbiAgICAgICAqIFRvIGF2b2lkIHRoaXMgaXNzdWUsIHVzZSB0aGUga2V5cHJlc3MgZXZlbnQgYXMgaWYgbm8gYHRleHRJbnB1dGBcbiAgICAgICAqIGV2ZW50IGlzIGF2YWlsYWJsZS5cbiAgICAgICAqL1xuICAgICAgdmFyIHdoaWNoID0gbmF0aXZlRXZlbnQud2hpY2g7XG4gICAgICBpZiAod2hpY2ggIT09IFNQQUNFQkFSX0NPREUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGhhc1NwYWNlS2V5cHJlc3MgPSB0cnVlO1xuICAgICAgcmV0dXJuIFNQQUNFQkFSX0NIQVI7XG5cbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVGV4dElucHV0OlxuICAgICAgLy8gUmVjb3JkIHRoZSBjaGFyYWN0ZXJzIHRvIGJlIGFkZGVkIHRvIHRoZSBET00uXG4gICAgICB2YXIgY2hhcnMgPSBuYXRpdmVFdmVudC5kYXRhO1xuXG4gICAgICAvLyBJZiBpdCdzIGEgc3BhY2ViYXIgY2hhcmFjdGVyLCBhc3N1bWUgdGhhdCB3ZSBoYXZlIGFscmVhZHkgaGFuZGxlZFxuICAgICAgLy8gaXQgYXQgdGhlIGtleXByZXNzIGxldmVsIGFuZCBiYWlsIGltbWVkaWF0ZWx5LiBBbmRyb2lkIENocm9tZVxuICAgICAgLy8gZG9lc24ndCBnaXZlIHVzIGtleWNvZGVzLCBzbyB3ZSBuZWVkIHRvIGJsYWNrbGlzdCBpdC5cbiAgICAgIGlmIChjaGFycyA9PT0gU1BBQ0VCQVJfQ0hBUiAmJiBoYXNTcGFjZUtleXByZXNzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhcnM7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gRm9yIG90aGVyIG5hdGl2ZSBldmVudCB0eXBlcywgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHByb3ZpZGUgdGhlIGB0ZXh0SW5wdXRgIGV2ZW50LCBleHRyYWN0IHRoZVxuICogYXBwcm9wcmlhdGUgc3RyaW5nIHRvIHVzZSBmb3IgU3ludGhldGljSW5wdXRFdmVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgZmFsbGJhY2sgc3RyaW5nIGZvciB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgY29tcG9zaW5nIChJTUUpIGFuZCB1c2luZyBhIGZhbGxiYWNrIHRvIGRvIHNvLFxuICAvLyB0cnkgdG8gZXh0cmFjdCB0aGUgY29tcG9zZWQgY2hhcmFjdGVycyBmcm9tIHRoZSBmYWxsYmFjayBvYmplY3QuXG4gIGlmIChjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kIHx8IGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgdmFyIGNoYXJzID0gY3VycmVudENvbXBvc2l0aW9uLmdldERhdGEoKTtcbiAgICAgIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5yZWxlYXNlKGN1cnJlbnRDb21wb3NpdGlvbik7XG4gICAgICBjdXJyZW50Q29tcG9zaXRpb24gPSBudWxsO1xuICAgICAgcmV0dXJuIGNoYXJzO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBhc3RlOlxuICAgICAgLy8gSWYgYSBwYXN0ZSBldmVudCBvY2N1cnMgYWZ0ZXIgYSBrZXlwcmVzcywgdGhyb3cgb3V0IHRoZSBpbnB1dFxuICAgICAgLy8gY2hhcnMuIFBhc3RlIGV2ZW50cyBzaG91bGQgbm90IGxlYWQgdG8gQmVmb3JlSW5wdXQgZXZlbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzOlxuICAgICAgLyoqXG4gICAgICAgKiBBcyBvZiB2MjcsIEZpcmVmb3ggbWF5IGZpcmUga2V5cHJlc3MgZXZlbnRzIGV2ZW4gd2hlbiBubyBjaGFyYWN0ZXJcbiAgICAgICAqIHdpbGwgYmUgaW5zZXJ0ZWQuIEEgZmV3IHBvc3NpYmlsaXRpZXM6XG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIGAwYC4gQXJyb3cga2V5cywgRXNjIGtleSwgZXRjLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IG5vIGNoYXIgaXMgYXZhaWxhYmxlLlxuICAgICAgICogICBFeDogJ0FsdEdyICsgZGAgaW4gUG9saXNoLiBUaGVyZSBpcyBubyBtb2RpZmllZCBjaGFyYWN0ZXIgZm9yXG4gICAgICAgKiAgIHRoaXMga2V5IGNvbWJpbmF0aW9uIGFuZCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQgaW50byB0aGVcbiAgICAgICAqICAgZG9jdW1lbnQsIGJ1dCBGRiBmaXJlcyB0aGUga2V5cHJlc3MgZm9yIGNoYXIgY29kZSBgMTAwYCBhbnl3YXkuXG4gICAgICAgKiAgIE5vIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBhIGNvbW1hbmQgY29tYmluYXRpb24gaXNcbiAgICAgICAqICAgYmVpbmcgdXNlZC4gRXg6IGBDbWQrQ2AuIE5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCwgYW5kIG5vXG4gICAgICAgKiAgIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqL1xuICAgICAgaWYgKG5hdGl2ZUV2ZW50LndoaWNoICYmICFpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobmF0aXZlRXZlbnQud2hpY2gpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kOlxuICAgICAgcmV0dXJuIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID8gbnVsbCA6IG5hdGl2ZUV2ZW50LmRhdGE7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCBhIFN5bnRoZXRpY0lucHV0RXZlbnQgZm9yIGBiZWZvcmVJbnB1dGAsIGJhc2VkIG9uIGVpdGhlciBuYXRpdmVcbiAqIGB0ZXh0SW5wdXRgIG9yIGZhbGxiYWNrIGJlaGF2aW9yLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgY2hhcnM7XG5cbiAgaWYgKGNhblVzZVRleHRJbnB1dEV2ZW50KSB7XG4gICAgY2hhcnMgPSBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIGNoYXJzID0gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICB9XG5cbiAgLy8gSWYgbm8gY2hhcmFjdGVycyBhcmUgYmVpbmcgaW5zZXJ0ZWQsIG5vIEJlZm9yZUlucHV0IGV2ZW50IHNob3VsZFxuICAvLyBiZSBmaXJlZC5cbiAgaWYgKCFjaGFycykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGV2ZW50ID0gU3ludGhldGljSW5wdXRFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5iZWZvcmVJbnB1dCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBldmVudC5kYXRhID0gY2hhcnM7XG4gIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gYG9uQmVmb3JlSW5wdXRgIGV2ZW50IHRvIG1hdGNoXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNS8jZXZlbnRzLWlucHV0ZXZlbnRzLlxuICpcbiAqIFRoaXMgZXZlbnQgcGx1Z2luIGlzIGJhc2VkIG9uIHRoZSBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRcbiAqIGF2YWlsYWJsZSBpbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEsIGFuZCBJRS4gVGhpcyBldmVudCBmaXJlcyBhZnRlclxuICogYG9uS2V5UHJlc3NgIGFuZCBgb25Db21wb3NpdGlvbkVuZGAsIGJ1dCBiZWZvcmUgYG9uSW5wdXRgLlxuICpcbiAqIGBiZWZvcmVJbnB1dGAgaXMgc3BlYydkIGJ1dCBub3QgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJzLCBhbmRcbiAqIHRoZSBgaW5wdXRgIGV2ZW50IGRvZXMgbm90IHByb3ZpZGUgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhc1xuICogYWN0dWFsbHkgYmVlbiBhZGRlZCwgY29udHJhcnkgdG8gdGhlIHNwZWMuIFRodXMsIGB0ZXh0SW5wdXRgIGlzIHRoZSBiZXN0XG4gKiBhdmFpbGFibGUgZXZlbnQgdG8gaWRlbnRpZnkgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gaW5zZXJ0ZWRcbiAqIGludG8gdGhlIHRhcmdldCBub2RlLlxuICpcbiAqIFRoaXMgcGx1Z2luIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGVtaXR0aW5nIGBjb21wb3NpdGlvbmAgZXZlbnRzLCB0aHVzXG4gKiBhbGxvd2luZyB1cyB0byBzaGFyZSBjb21wb3NpdGlvbiBmYWxsYmFjayBjb2RlIGZvciBib3RoIGBiZWZvcmVJbnB1dGAgYW5kXG4gKiBgY29tcG9zaXRpb25gIGV2ZW50IHR5cGVzLlxuICovXG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50c31cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICByZXR1cm4gW2V4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCksIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCldO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJlZm9yZUlucHV0RXZlbnRQbHVnaW47XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9CZWZvcmVJbnB1dEV2ZW50UGx1Z2luLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UHJvcGFnYXRvcnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBhY2N1bXVsYXRlSW50byA9IHJlcXVpcmUoJy4vYWNjdW11bGF0ZUludG8nKTtcbnZhciBmb3JFYWNoQWNjdW11bGF0ZWQgPSByZXF1aXJlKCcuL2ZvckVhY2hBY2N1bXVsYXRlZCcpO1xuXG52YXIgUHJvcGFnYXRpb25QaGFzZXMgPSBFdmVudENvbnN0YW50cy5Qcm9wYWdhdGlvblBoYXNlcztcbnZhciBnZXRMaXN0ZW5lciA9IEV2ZW50UGx1Z2luSHViLmdldExpc3RlbmVyO1xuXG4vKipcbiAqIFNvbWUgZXZlbnQgdHlwZXMgaGF2ZSBhIG5vdGlvbiBvZiBkaWZmZXJlbnQgcmVnaXN0cmF0aW9uIG5hbWVzIGZvciBkaWZmZXJlbnRcbiAqIFwicGhhc2VzXCIgb2YgcHJvcGFnYXRpb24uIFRoaXMgZmluZHMgbGlzdGVuZXJzIGJ5IGEgZ2l2ZW4gcGhhc2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RlbmVyQXRQaGFzZShpZCwgZXZlbnQsIHByb3BhZ2F0aW9uUGhhc2UpIHtcbiAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1twcm9wYWdhdGlvblBoYXNlXTtcbiAgcmV0dXJuIGdldExpc3RlbmVyKGlkLCByZWdpc3RyYXRpb25OYW1lKTtcbn1cblxuLyoqXG4gKiBUYWdzIGEgYFN5bnRoZXRpY0V2ZW50YCB3aXRoIGRpc3BhdGNoZWQgbGlzdGVuZXJzLiBDcmVhdGluZyB0aGlzIGZ1bmN0aW9uXG4gKiBoZXJlLCBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gYmluZCBvciBjcmVhdGUgZnVuY3Rpb25zIGZvciBlYWNoIGV2ZW50LlxuICogTXV0YXRpbmcgdGhlIGV2ZW50J3MgbWVtYmVycyBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gY3JlYXRlIGEgd3JhcHBpbmdcbiAqIFwiZGlzcGF0Y2hcIiBvYmplY3QgdGhhdCBwYWlycyB0aGUgZXZlbnQgd2l0aCB0aGUgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMoZG9tSUQsIHVwd2FyZHMsIGV2ZW50KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZG9tSUQsICdEaXNwYXRjaGluZyBpZCBtdXN0IG5vdCBiZSBudWxsJykgOiB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIHBoYXNlID0gdXB3YXJkcyA/IFByb3BhZ2F0aW9uUGhhc2VzLmJ1YmJsZWQgOiBQcm9wYWdhdGlvblBoYXNlcy5jYXB0dXJlZDtcbiAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJBdFBoYXNlKGRvbUlELCBldmVudCwgcGhhc2UpO1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICBldmVudC5fZGlzcGF0Y2hJRHMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJRHMsIGRvbUlEKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbGxlY3QgZGlzcGF0Y2hlcyAobXVzdCBiZSBlbnRpcmVseSBjb2xsZWN0ZWQgYmVmb3JlIGRpc3BhdGNoaW5nIC0gc2VlIHVuaXRcbiAqIHRlc3RzKS4gTGF6aWx5IGFsbG9jYXRlIHRoZSBhcnJheSB0byBjb25zZXJ2ZSBtZW1vcnkuICBXZSBtdXN0IGxvb3AgdGhyb3VnaFxuICogZWFjaCBldmVudCBhbmQgcGVyZm9ybSB0aGUgdHJhdmVyc2FsIGZvciBlYWNoIG9uZS4gV2UgY2Fubm90IHBlcmZvcm0gYVxuICogc2luZ2xlIHRyYXZlcnNhbCBmb3IgdGhlIGVudGlyZSBjb2xsZWN0aW9uIG9mIGV2ZW50cyBiZWNhdXNlIGVhY2ggZXZlbnQgbWF5XG4gKiBoYXZlIGEgZGlmZmVyZW50IHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uZ2V0SW5zdGFuY2VIYW5kbGUoKS50cmF2ZXJzZVR3b1BoYXNlKGV2ZW50LmRpc3BhdGNoTWFya2VyLCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTYW1lIGFzIGBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlYCwgYnV0IHNraXBzIG92ZXIgdGhlIHRhcmdldElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldChldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uZ2V0SW5zdGFuY2VIYW5kbGUoKS50cmF2ZXJzZVR3b1BoYXNlU2tpcFRhcmdldChldmVudC5kaXNwYXRjaE1hcmtlciwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgd2l0aG91dCByZWdhcmQgdG8gZGlyZWN0aW9uLCBkb2VzIG5vdCBsb29rIGZvciBwaGFzZWRcbiAqIHJlZ2lzdHJhdGlvbiBuYW1lcy4gU2FtZSBhcyBgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGVgIGJ1dCB3aXRob3V0XG4gKiByZXF1aXJpbmcgdGhhdCB0aGUgYGRpc3BhdGNoTWFya2VyYCBiZSB0aGUgc2FtZSBhcyB0aGUgZGlzcGF0Y2hlZCBJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpc3BhdGNoZXMoaWQsIGlnbm9yZWREaXJlY3Rpb24sIGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lO1xuICAgIHZhciBsaXN0ZW5lciA9IGdldExpc3RlbmVyKGlkLCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoSURzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSURzLCBpZCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgZGlzcGF0Y2hlcyBvbiBhbiBgU3ludGhldGljRXZlbnRgLCBidXQgb25seSBmb3IgdGhlXG4gKiBgZGlzcGF0Y2hNYXJrZXJgLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhldmVudC5kaXNwYXRjaE1hcmtlciwgbnVsbCwgZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldChldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tSUQsIHRvSUQpIHtcbiAgRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmdldEluc3RhbmNlSGFuZGxlKCkudHJhdmVyc2VFbnRlckxlYXZlKGZyb21JRCwgdG9JRCwgYWNjdW11bGF0ZURpc3BhdGNoZXMsIGxlYXZlLCBlbnRlcik7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbi8qKlxuICogQSBzbWFsbCBzZXQgb2YgcHJvcGFnYXRpb24gcGF0dGVybnMsIGVhY2ggb2Ygd2hpY2ggd2lsbCBhY2NlcHQgYSBzbWFsbCBhbW91bnRcbiAqIG9mIGluZm9ybWF0aW9uLCBhbmQgZ2VuZXJhdGUgYSBzZXQgb2YgXCJkaXNwYXRjaCByZWFkeSBldmVudCBvYmplY3RzXCIgLSB3aGljaFxuICogYXJlIHNldHMgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gYW5ub3RhdGVkIHdpdGggYSBzZXQgb2YgZGlzcGF0Y2hlZFxuICogbGlzdGVuZXIgZnVuY3Rpb25zL2lkcy4gVGhlIEFQSSBpcyBkZXNpZ25lZCB0aGlzIHdheSB0byBkaXNjb3VyYWdlIHRoZXNlXG4gKiBwcm9wYWdhdGlvbiBzdHJhdGVnaWVzIGZyb20gYWN0dWFsbHkgZXhlY3V0aW5nIHRoZSBkaXNwYXRjaGVzLCBzaW5jZSB3ZVxuICogYWx3YXlzIHdhbnQgdG8gY29sbGVjdCB0aGUgZW50aXJlIHNldCBvZiBkaXNwYXRjaGVzIGJlZm9yZSBleGVjdXRpbmcgZXZlbnQgYVxuICogc2luZ2xlIG9uZS5cbiAqXG4gKiBAY29uc3RydWN0b3IgRXZlbnRQcm9wYWdhdG9yc1xuICovXG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHtcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlczogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyxcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQ6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0LFxuICBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlczogYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMsXG4gIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlczogYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UHJvcGFnYXRvcnM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9FdmVudFByb3BhZ2F0b3JzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGdldFRleHRDb250ZW50QWNjZXNzb3IgPSByZXF1aXJlKCcuL2dldFRleHRDb250ZW50QWNjZXNzb3InKTtcblxuLyoqXG4gKiBUaGlzIGhlbHBlciBjbGFzcyBzdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgdGV4dCBjb250ZW50IG9mIGEgdGFyZ2V0IG5vZGUsXG4gKiBhbGxvd2luZyBjb21wYXJpc29uIG9mIGNvbnRlbnQgYmVmb3JlIGFuZCBhZnRlciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIElkZW50aWZ5IHRoZSBub2RlIHdoZXJlIHNlbGVjdGlvbiBjdXJyZW50bHkgYmVnaW5zLCB0aGVuIG9ic2VydmVcbiAqIGJvdGggaXRzIHRleHQgY29udGVudCBhbmQgaXRzIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIERPTS4gU2luY2UgdGhlXG4gKiBicm93c2VyIG1heSBuYXRpdmVseSByZXBsYWNlIHRoZSB0YXJnZXQgbm9kZSBkdXJpbmcgY29tcG9zaXRpb24sIHdlIGNhblxuICogdXNlIGl0cyBwb3NpdGlvbiB0byBmaW5kIGl0cyByZXBsYWNlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSByb290XG4gKi9cbmZ1bmN0aW9uIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZShyb290KSB7XG4gIHRoaXMuX3Jvb3QgPSByb290O1xuICB0aGlzLl9zdGFydFRleHQgPSB0aGlzLmdldFRleHQoKTtcbiAgdGhpcy5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbn1cblxuYXNzaWduKEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5wcm90b3R5cGUsIHtcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgIHRoaXMuX3N0YXJ0VGV4dCA9IG51bGw7XG4gICAgdGhpcy5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgdGV4dCBvZiBpbnB1dC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0VGV4dDogZnVuY3Rpb24gKCkge1xuICAgIGlmICgndmFsdWUnIGluIHRoaXMuX3Jvb3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yb290LnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcm9vdFtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgdGhlIGRpZmZlcmluZyBzdWJzdHJpbmcgYmV0d2VlbiB0aGUgaW5pdGlhbGx5IHN0b3JlZFxuICAgKiB0ZXh0IGNvbnRlbnQgYW5kIHRoZSBjdXJyZW50IGNvbnRlbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fZmFsbGJhY2tUZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tUZXh0O1xuICAgIH1cblxuICAgIHZhciBzdGFydDtcbiAgICB2YXIgc3RhcnRWYWx1ZSA9IHRoaXMuX3N0YXJ0VGV4dDtcbiAgICB2YXIgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aDtcbiAgICB2YXIgZW5kO1xuICAgIHZhciBlbmRWYWx1ZSA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgIHZhciBlbmRMZW5ndGggPSBlbmRWYWx1ZS5sZW5ndGg7XG5cbiAgICBmb3IgKHN0YXJ0ID0gMDsgc3RhcnQgPCBzdGFydExlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRdICE9PSBlbmRWYWx1ZVtzdGFydF0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1pbkVuZCA9IHN0YXJ0TGVuZ3RoIC0gc3RhcnQ7XG4gICAgZm9yIChlbmQgPSAxOyBlbmQgPD0gbWluRW5kOyBlbmQrKykge1xuICAgICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRMZW5ndGggLSBlbmRdICE9PSBlbmRWYWx1ZVtlbmRMZW5ndGggLSBlbmRdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzbGljZVRhaWwgPSBlbmQgPiAxID8gMSAtIGVuZCA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mYWxsYmFja1RleHQgPSBlbmRWYWx1ZS5zbGljZShzdGFydCwgc2xpY2VUYWlsKTtcbiAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tUZXh0O1xuICB9XG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldFRleHRDb250ZW50QWNjZXNzb3JcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBjb250ZW50S2V5ID0gbnVsbDtcblxuLyoqXG4gKiBHZXRzIHRoZSBrZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50IG9uIGEgRE9NIG5vZGUuXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gS2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRUZXh0Q29udGVudEFjY2Vzc29yKCkge1xuICBpZiAoIWNvbnRlbnRLZXkgJiYgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gICAgLy8gUHJlZmVyIHRleHRDb250ZW50IHRvIGlubmVyVGV4dCBiZWNhdXNlIG1hbnkgYnJvd3NlcnMgc3VwcG9ydCBib3RoIGJ1dFxuICAgIC8vIFNWRyA8dGV4dD4gZWxlbWVudHMgZG9uJ3Qgc3VwcG9ydCBpbm5lclRleHQgZXZlbiB3aGVuIDxkaXY+IGRvZXMuXG4gICAgY29udGVudEtleSA9ICd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gJ3RleHRDb250ZW50JyA6ICdpbm5lclRleHQnO1xuICB9XG4gIHJldHVybiBjb250ZW50S2V5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFRleHRDb250ZW50QWNjZXNzb3I7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9nZXRUZXh0Q29udGVudEFjY2Vzc29yLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1jb21wb3NpdGlvbmV2ZW50c1xuICovXG52YXIgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ29tcG9zaXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQsIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0V2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHR5cGU6IG51bGwsXG4gIHRhcmdldDogbnVsbCxcbiAgLy8gY3VycmVudFRhcmdldCBpcyBzZXQgd2hlbiBkaXNwYXRjaGluZzsgbm8gdXNlIGluIGNvcHlpbmcgaXQgaGVyZVxuICBjdXJyZW50VGFyZ2V0OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCxcbiAgZXZlbnRQaGFzZTogbnVsbCxcbiAgYnViYmxlczogbnVsbCxcbiAgY2FuY2VsYWJsZTogbnVsbCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IG51bGwsXG4gIGlzVHJ1c3RlZDogbnVsbFxufTtcblxuLyoqXG4gKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gKlxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHRoaXMuZGlzcGF0Y2hDb25maWcgPSBkaXNwYXRjaENvbmZpZztcbiAgdGhpcy5kaXNwYXRjaE1hcmtlciA9IGRpc3BhdGNoTWFya2VyO1xuICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG5cbiAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICBpZiAoIUludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplID0gSW50ZXJmYWNlW3Byb3BOYW1lXTtcbiAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG5vcm1hbGl6ZShuYXRpdmVFdmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ3RhcmdldCcpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbcHJvcE5hbWVdID0gbmF0aXZlRXZlbnRbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBkZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID8gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6IG5hdGl2ZUV2ZW50LnJldHVyblZhbHVlID09PSBmYWxzZTtcbiAgaWYgKGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xuICB9XG4gIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG59XG5cbmFzc2lnbihTeW50aGV0aWNFdmVudC5wcm90b3R5cGUsIHtcblxuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZXZlbnQsICdUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdVxcJ3JlICcgKyAnc2VlaW5nIHRoaXMsIHlvdVxcJ3JlIGNhbGxpbmcgYHByZXZlbnREZWZhdWx0YCBvbiBhICcgKyAncmVsZWFzZWQvbnVsbGlmaWVkIHN5bnRoZXRpYyBldmVudC4gVGhpcyBpcyBhIG5vLW9wLiBTZWUgJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZXZlbnQsICdUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdVxcJ3JlICcgKyAnc2VlaW5nIHRoaXMsIHlvdVxcJ3JlIGNhbGxpbmcgYHN0b3BQcm9wYWdhdGlvbmAgb24gYSAnICsgJ3JlbGVhc2VkL251bGxpZmllZCBzeW50aGV0aWMgZXZlbnQuIFRoaXMgaXMgYSBuby1vcC4gU2VlICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1ldmVudC1wb29saW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogV2UgcmVsZWFzZSBhbGwgZGlzcGF0Y2hlZCBgU3ludGhldGljRXZlbnRgcyBhZnRlciBlYWNoIGV2ZW50IGxvb3AsIGFkZGluZ1xuICAgKiB0aGVtIGJhY2sgaW50byB0aGUgcG9vbC4gVGhpcyBhbGxvd3MgYSB3YXkgdG8gaG9sZCBvbnRvIGEgcmVmZXJlbmNlIHRoYXRcbiAgICogd29uJ3QgYmUgYWRkZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKi9cbiAgcGVyc2lzdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNQZXJzaXN0ZW50ID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhpcyBzaG91bGQgbm90IGJlIHJlbGVhc2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc1BlcnNpc3RlbnQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgYGRlc3RydWN0b3JgIG9uIGVhY2ggaW5zdGFuY2UgaXQgcmVsZWFzZXMuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgICAgdGhpc1twcm9wTmFtZV0gPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoQ29uZmlnID0gbnVsbDtcbiAgICB0aGlzLmRpc3BhdGNoTWFya2VyID0gbnVsbDtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbnVsbDtcbiAgfVxuXG59KTtcblxuU3ludGhldGljRXZlbnQuSW50ZXJmYWNlID0gRXZlbnRJbnRlcmZhY2U7XG5cbi8qKlxuICogSGVscGVyIHRvIHJlZHVjZSBib2lsZXJwbGF0ZSB3aGVuIGNyZWF0aW5nIHN1YmNsYXNzZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3NcbiAqIEBwYXJhbSB7P29iamVjdH0gSW50ZXJmYWNlXG4gKi9cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyA9IGZ1bmN0aW9uIChDbGFzcywgSW50ZXJmYWNlKSB7XG4gIHZhciBTdXBlciA9IHRoaXM7XG5cbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgYXNzaWduKHByb3RvdHlwZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgQ2xhc3MucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDbGFzcztcblxuICBDbGFzcy5JbnRlcmZhY2UgPSBhc3NpZ24oe30sIFN1cGVyLkludGVyZmFjZSwgSW50ZXJmYWNlKTtcbiAgQ2xhc3MuYXVnbWVudENsYXNzID0gU3VwZXIuYXVnbWVudENsYXNzO1xuXG4gIFBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhDbGFzcywgUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyKTtcbn07XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhTeW50aGV0aWNFdmVudCwgUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNFdmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0V2ZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0lucHV0RXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNVxuICogICAgICAvI2V2ZW50cy1pbnB1dGV2ZW50c1xuICovXG52YXIgSW5wdXRFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljSW5wdXRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0lucHV0RXZlbnQsIElucHV0RXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0lucHV0RXZlbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNJbnB1dEV2ZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGtleU9mXG4gKi9cblxuLyoqXG4gKiBBbGxvd3MgZXh0cmFjdGlvbiBvZiBhIG1pbmlmaWVkIGtleS4gTGV0J3MgdGhlIGJ1aWxkIHN5c3RlbSBtaW5pZnkga2V5c1xuICogd2l0aG91dCBsb3NpbmcgdGhlIGFiaWxpdHkgdG8gZHluYW1pY2FsbHkgdXNlIGtleSBzdHJpbmdzIGFzIHZhbHVlc1xuICogdGhlbXNlbHZlcy4gUGFzcyBpbiBhbiBvYmplY3Qgd2l0aCBhIHNpbmdsZSBrZXkvdmFsIHBhaXIgYW5kIGl0IHdpbGwgcmV0dXJuXG4gKiB5b3UgdGhlIHN0cmluZyBrZXkgb2YgdGhhdCBzaW5nbGUgcmVjb3JkLiBTdXBwb3NlIHlvdSB3YW50IHRvIGdyYWIgdGhlXG4gKiB2YWx1ZSBmb3IgYSBrZXkgJ2NsYXNzTmFtZScgaW5zaWRlIG9mIGFuIG9iamVjdC4gS2V5L3ZhbCBtaW5pZmljYXRpb24gbWF5XG4gKiBoYXZlIGFsaWFzZWQgdGhhdCBrZXkgdG8gYmUgJ3hhMTInLiBrZXlPZih7Y2xhc3NOYW1lOiBudWxsfSkgd2lsbCByZXR1cm5cbiAqICd4YTEyJyBpbiB0aGF0IGNhc2UuIFJlc29sdmUga2V5cyB5b3Ugd2FudCB0byB1c2Ugb25jZSBhdCBzdGFydHVwIHRpbWUsIHRoZW5cbiAqIHJldXNlIHRob3NlIHJlc29sdXRpb25zLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGtleU9mID0gZnVuY3Rpb24gKG9uZUtleU9iaikge1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBvbmVLZXlPYmopIHtcbiAgICBpZiAoIW9uZUtleU9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5T2Y7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2tleU9mLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENoYW5nZUV2ZW50UGx1Z2luXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2dldEV2ZW50VGFyZ2V0Jyk7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xudmFyIGlzVGV4dElucHV0RWxlbWVudCA9IHJlcXVpcmUoJy4vaXNUZXh0SW5wdXRFbGVtZW50Jyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBjaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNoYW5nZTogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ2hhbmdlQ2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENoYW5nZSwgdG9wTGV2ZWxUeXBlcy50b3BDbGljaywgdG9wTGV2ZWxUeXBlcy50b3BGb2N1cywgdG9wTGV2ZWxUeXBlcy50b3BJbnB1dCwgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLCB0b3BMZXZlbFR5cGVzLnRvcEtleVVwLCB0b3BMZXZlbFR5cGVzLnRvcFNlbGVjdGlvbkNoYW5nZV1cbiAgfVxufTtcblxuLyoqXG4gKiBGb3IgSUUgc2hpbXNcbiAqL1xudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJRCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudFZhbHVlID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gbnVsbDtcblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNoYW5nZWAgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJztcbn1cblxudmFyIGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSA9IGZhbHNlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBTZWUgYGhhbmRsZUNoYW5nZWAgY29tbWVudCBiZWxvd1xuICBkb2VzQ2hhbmdlRXZlbnRCdWJibGUgPSBpc0V2ZW50U3VwcG9ydGVkKCdjaGFuZ2UnKSAmJiAoISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gOCk7XG59XG5cbmZ1bmN0aW9uIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGV2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuY2hhbmdlLCBhY3RpdmVFbGVtZW50SUQsIG5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkpO1xuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuXG4gIC8vIElmIGNoYW5nZSBhbmQgcHJvcGVydHljaGFuZ2UgYnViYmxlZCwgd2UnZCBqdXN0IGJpbmQgdG8gaXQgbGlrZSBhbGwgdGhlXG4gIC8vIG90aGVyIGV2ZW50cyBhbmQgaGF2ZSBpdCBnbyB0aHJvdWdoIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci4gU2luY2UgaXRcbiAgLy8gZG9lc24ndCwgd2UgbWFudWFsbHkgbGlzdGVuIGZvciB0aGUgZXZlbnRzIGFuZCBzbyB3ZSBoYXZlIHRvIGVucXVldWUgYW5kXG4gIC8vIHByb2Nlc3MgdGhlIGFic3RyYWN0IGV2ZW50IG1hbnVhbGx5LlxuICAvL1xuICAvLyBCYXRjaGluZyBpcyBuZWNlc3NhcnkgaGVyZSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBhbGwgZXZlbnQgaGFuZGxlcnMgcnVuXG4gIC8vIGJlZm9yZSB0aGUgbmV4dCByZXJlbmRlciAoaW5jbHVkaW5nIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIHRvIGFuY2VzdG9yXG4gIC8vIGVsZW1lbnRzIGluc3RlYWQgb2YgZGlyZWN0bHkgb24gdGhlIGlucHV0KS4gV2l0aG91dCB0aGlzLCBjb250cm9sbGVkXG4gIC8vIGNvbXBvbmVudHMgZG9uJ3Qgd29yayBwcm9wZXJseSBpbiBjb25qdW5jdGlvbiB3aXRoIGV2ZW50IGJ1YmJsaW5nIGJlY2F1c2VcbiAgLy8gdGhlIGNvbXBvbmVudCBpcyByZXJlbmRlcmVkIGFuZCB0aGUgdmFsdWUgcmV2ZXJ0ZWQgYmVmb3JlIGFsbCB0aGUgZXZlbnRcbiAgLy8gaGFuZGxlcnMgY2FuIHJ1bi4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzA4LlxuICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMocnVuRXZlbnRJbkJhdGNoLCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50SW5CYXRjaChldmVudCkge1xuICBFdmVudFBsdWdpbkh1Yi5lbnF1ZXVlRXZlbnRzKGV2ZW50KTtcbiAgRXZlbnRQbHVnaW5IdWIucHJvY2Vzc0V2ZW50UXVldWUoZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgodGFyZ2V0LCB0YXJnZXRJRCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SUQgPSB0YXJnZXRJRDtcbiAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25jaGFuZ2UnLCBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KTtcbn1cblxuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbmNoYW5nZScsIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQpO1xuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudElEID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SURGb3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQ2hhbmdlKSB7XG4gICAgcmV0dXJuIHRvcExldmVsVGFyZ2V0SUQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvckNoYW5nZUV2ZW50SUU4KHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BGb2N1cykge1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgodG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BCbHVyKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKTtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgaW5wdXRgIGV2ZW50XG4gKi9cbnZhciBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBmYWxzZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gSUU5IGNsYWltcyB0byBzdXBwb3J0IHRoZSBpbnB1dCBldmVudCBidXQgZmFpbHMgdG8gdHJpZ2dlciBpdCB3aGVuXG4gIC8vIGRlbGV0aW5nIHRleHQsIHNvIHdlIGlnbm9yZSBpdHMgaW5wdXQgZXZlbnRzXG4gIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGlzRXZlbnRTdXBwb3J0ZWQoJ2lucHV0JykgJiYgKCEoJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDkpO1xufVxuXG4vKipcbiAqIChGb3Igb2xkIElFLikgUmVwbGFjZW1lbnQgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGB2YWx1ZWAgcHJvcGVydHkgdGhhdCBnZXRzXG4gKiBzZXQgb24gdGhlIGFjdGl2ZSBlbGVtZW50LlxuICovXG52YXIgbmV3VmFsdWVQcm9wID0ge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYWN0aXZlRWxlbWVudFZhbHVlUHJvcC5nZXQuY2FsbCh0aGlzKTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgLy8gQ2FzdCB0byBhIHN0cmluZyBzbyB3ZSBjYW4gZG8gZXF1YWxpdHkgY2hlY2tzLlxuICAgIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9ICcnICsgdmFsO1xuICAgIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3Auc2V0LmNhbGwodGhpcywgdmFsKTtcbiAgfVxufTtcblxuLyoqXG4gKiAoRm9yIG9sZCBJRS4pIFN0YXJ0cyB0cmFja2luZyBwcm9wZXJ0eWNoYW5nZSBldmVudHMgb24gdGhlIHBhc3NlZC1pbiBlbGVtZW50XG4gKiBhbmQgb3ZlcnJpZGUgdGhlIHZhbHVlIHByb3BlcnR5IHNvIHRoYXQgd2UgY2FuIGRpc3Rpbmd1aXNoIHVzZXIgZXZlbnRzIGZyb21cbiAqIHZhbHVlIGNoYW5nZXMgaW4gSlMuXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldElEKSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJRCA9IHRhcmdldElEO1xuICBhY3RpdmVFbGVtZW50VmFsdWUgPSB0YXJnZXQudmFsdWU7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsICd2YWx1ZScpO1xuXG4gIC8vIE5vdCBndWFyZGVkIGluIGEgY2FuRGVmaW5lUHJvcGVydHkgY2hlY2s6IElFOCBzdXBwb3J0cyBkZWZpbmVQcm9wZXJ0eSBvbmx5XG4gIC8vIG9uIERPTSBlbGVtZW50c1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYWN0aXZlRWxlbWVudCwgJ3ZhbHVlJywgbmV3VmFsdWVQcm9wKTtcbiAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbn1cblxuLyoqXG4gKiAoRm9yIG9sZCBJRS4pIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBjdXJyZW50bHktdHJhY2tlZCBlbGVtZW50LFxuICogaWYgYW55IGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGRlbGV0ZSByZXN0b3JlcyB0aGUgb3JpZ2luYWwgcHJvcGVydHkgZGVmaW5pdGlvblxuICBkZWxldGUgYWN0aXZlRWxlbWVudC52YWx1ZTtcbiAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcblxuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudElEID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudFZhbHVlUHJvcCA9IG51bGw7XG59XG5cbi8qKlxuICogKEZvciBvbGQgSUUuKSBIYW5kbGVzIGEgcHJvcGVydHljaGFuZ2UgZXZlbnQsIHNlbmRpbmcgYSBgY2hhbmdlYCBldmVudCBpZlxuICogdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmUgZWxlbWVudCBoYXMgY2hhbmdlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3ZhbHVlJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdmFsdWUgPSBuYXRpdmVFdmVudC5zcmNFbGVtZW50LnZhbHVlO1xuICBpZiAodmFsdWUgPT09IGFjdGl2ZUVsZW1lbnRWYWx1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50VmFsdWUgPSB2YWx1ZTtcblxuICBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KTtcbn1cblxuLyoqXG4gKiBJZiBhIGBjaGFuZ2VgIGV2ZW50IHNob3VsZCBiZSBmaXJlZCwgcmV0dXJucyB0aGUgdGFyZ2V0J3MgSUQuXG4gKi9cbmZ1bmN0aW9uIGdldFRhcmdldElERm9ySW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wSW5wdXQpIHtcbiAgICAvLyBJbiBtb2Rlcm4gYnJvd3NlcnMgKGkuZS4sIG5vdCBJRTggb3IgSUU5KSwgdGhlIGlucHV0IGV2ZW50IGlzIGV4YWN0bHlcbiAgICAvLyB3aGF0IHdlIHdhbnQgc28gZmFsbCB0aHJvdWdoIGhlcmUgYW5kIHRyaWdnZXIgYW4gYWJzdHJhY3QgZXZlbnRcbiAgICByZXR1cm4gdG9wTGV2ZWxUYXJnZXRJRDtcbiAgfVxufVxuXG4vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50SUUodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzKSB7XG4gICAgLy8gSW4gSUU4LCB3ZSBjYW4gY2FwdHVyZSBhbG1vc3QgYWxsIC52YWx1ZSBjaGFuZ2VzIGJ5IGFkZGluZyBhXG4gICAgLy8gcHJvcGVydHljaGFuZ2UgaGFuZGxlciBhbmQgbG9va2luZyBmb3IgZXZlbnRzIHdpdGggcHJvcGVydHlOYW1lXG4gICAgLy8gZXF1YWwgdG8gJ3ZhbHVlJ1xuICAgIC8vIEluIElFOSwgcHJvcGVydHljaGFuZ2UgZmlyZXMgZm9yIG1vc3QgaW5wdXQgZXZlbnRzIGJ1dCBpcyBidWdneSBhbmRcbiAgICAvLyBkb2Vzbid0IGZpcmUgd2hlbiB0ZXh0IGlzIGRlbGV0ZWQsIGJ1dCBjb252ZW5pZW50bHksIHNlbGVjdGlvbmNoYW5nZVxuICAgIC8vIGFwcGVhcnMgdG8gZmlyZSBpbiBhbGwgb2YgdGhlIHJlbWFpbmluZyBjYXNlcyBzbyB3ZSBjYXRjaCB0aG9zZSBhbmRcbiAgICAvLyBmb3J3YXJkIHRoZSBldmVudCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAvLyBJbiBlaXRoZXIgY2FzZSwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIHRoZSBldmVudCBoYW5kbGVyIGlmIHRoZSB2YWx1ZVxuICAgIC8vIGlzIGNoYW5nZWQgZnJvbSBKUyBzbyB3ZSByZWRlZmluZSBhIHNldHRlciBmb3IgYC52YWx1ZWAgdGhhdCB1cGRhdGVzXG4gICAgLy8gb3VyIGFjdGl2ZUVsZW1lbnRWYWx1ZSB2YXJpYWJsZSwgYWxsb3dpbmcgdXMgdG8gaWdub3JlIHRob3NlIGNoYW5nZXNcbiAgICAvL1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BCbHVyKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgfVxufVxuXG4vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBnZXRUYXJnZXRJREZvcklucHV0RXZlbnRJRSh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wS2V5RG93bikge1xuICAgIC8vIE9uIHRoZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQsIHRoZSB0YXJnZXQgaXMganVzdCBkb2N1bWVudCB3aGljaCBpc24ndFxuICAgIC8vIGhlbHBmdWwgZm9yIHVzIHNvIGp1c3QgY2hlY2sgYWN0aXZlRWxlbWVudCBpbnN0ZWFkLlxuICAgIC8vXG4gICAgLy8gOTklIG9mIHRoZSB0aW1lLCBrZXlkb3duIGFuZCBrZXl1cCBhcmVuJ3QgbmVjZXNzYXJ5LiBJRTggZmFpbHMgdG8gZmlyZVxuICAgIC8vIHByb3BlcnR5Y2hhbmdlIG9uIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhZnRlciBzZXR0aW5nIGB2YWx1ZWAgZnJvbSBhXG4gICAgLy8gc2NyaXB0IGFuZCBmaXJlcyBvbmx5IGtleWRvd24sIGtleXByZXNzLCBrZXl1cC4gQ2F0Y2hpbmcga2V5dXAgdXN1YWxseVxuICAgIC8vIGdldHMgaXQgYW5kIGNhdGNoaW5nIGtleWRvd24gbGV0cyB1cyBmaXJlIGFuIGV2ZW50IGZvciB0aGUgZmlyc3RcbiAgICAvLyBrZXlzdHJva2UgaWYgdXNlciBkb2VzIGEga2V5IHJlcGVhdCAoaXQnbGwgYmUgYSBsaXR0bGUgZGVsYXllZDogcmlnaHRcbiAgICAvLyBiZWZvcmUgdGhlIHNlY29uZCBrZXlzdHJva2UpLiBPdGhlciBpbnB1dCBtZXRob2RzIChlLmcuLCBwYXN0ZSkgc2VlbSB0b1xuICAgIC8vIGZpcmUgc2VsZWN0aW9uY2hhbmdlIG5vcm1hbGx5LlxuICAgIGlmIChhY3RpdmVFbGVtZW50ICYmIGFjdGl2ZUVsZW1lbnQudmFsdWUgIT09IGFjdGl2ZUVsZW1lbnRWYWx1ZSkge1xuICAgICAgYWN0aXZlRWxlbWVudFZhbHVlID0gYWN0aXZlRWxlbWVudC52YWx1ZTtcbiAgICAgIHJldHVybiBhY3RpdmVFbGVtZW50SUQ7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjbGlja2AgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2xpY2tFdmVudChlbGVtKSB7XG4gIC8vIFVzZSB0aGUgYGNsaWNrYCBldmVudCB0byBkZXRlY3QgY2hhbmdlcyB0byBjaGVja2JveCBhbmQgcmFkaW8gaW5wdXRzLlxuICAvLyBUaGlzIGFwcHJvYWNoIHdvcmtzIGFjcm9zcyBhbGwgYnJvd3NlcnMsIHdoZXJlYXMgYGNoYW5nZWAgZG9lcyBub3QgZmlyZVxuICAvLyB1bnRpbCBgYmx1cmAgaW4gSUU4LlxuICByZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKGVsZW0udHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBlbGVtLnR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJREZvckNsaWNrRXZlbnQodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcENsaWNrKSB7XG4gICAgcmV0dXJuIHRvcExldmVsVGFyZ2V0SUQ7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvbkNoYW5nZWAgZXZlbnQgdGhhdCBub3JtYWxpemVzIGNoYW5nZSBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLiBUaGlzIGV2ZW50IGZpcmVzIGF0IGEgdGltZSB3aGVuIGl0J3MgcG9zc2libGUgdG9cbiAqIGNoYW5nZSB0aGUgZWxlbWVudCdzIHZhbHVlIHdpdGhvdXQgc2VlaW5nIGEgZmxpY2tlci5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBzZWxlY3RcbiAqL1xudmFyIENoYW5nZUV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzfVxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuXG4gICAgdmFyIGdldFRhcmdldElERnVuYywgaGFuZGxlRXZlbnRGdW5jO1xuICAgIGlmIChzaG91bGRVc2VDaGFuZ2VFdmVudCh0b3BMZXZlbFRhcmdldCkpIHtcbiAgICAgIGlmIChkb2VzQ2hhbmdlRXZlbnRCdWJibGUpIHtcbiAgICAgICAgZ2V0VGFyZ2V0SURGdW5jID0gZ2V0VGFyZ2V0SURGb3JDaGFuZ2VFdmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvckNoYW5nZUV2ZW50SUU4O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRvcExldmVsVGFyZ2V0KSkge1xuICAgICAgaWYgKGlzSW5wdXRFdmVudFN1cHBvcnRlZCkge1xuICAgICAgICBnZXRUYXJnZXRJREZ1bmMgPSBnZXRUYXJnZXRJREZvcklucHV0RXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZXRUYXJnZXRJREZ1bmMgPSBnZXRUYXJnZXRJREZvcklucHV0RXZlbnRJRTtcbiAgICAgICAgaGFuZGxlRXZlbnRGdW5jID0gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudElFO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2hvdWxkVXNlQ2xpY2tFdmVudCh0b3BMZXZlbFRhcmdldCkpIHtcbiAgICAgIGdldFRhcmdldElERnVuYyA9IGdldFRhcmdldElERm9yQ2xpY2tFdmVudDtcbiAgICB9XG5cbiAgICBpZiAoZ2V0VGFyZ2V0SURGdW5jKSB7XG4gICAgICB2YXIgdGFyZ2V0SUQgPSBnZXRUYXJnZXRJREZ1bmModG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCk7XG4gICAgICBpZiAodGFyZ2V0SUQpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuY2hhbmdlLCB0YXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgZXZlbnQudHlwZSA9ICdjaGFuZ2UnO1xuICAgICAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZUV2ZW50RnVuYykge1xuICAgICAgaGFuZGxlRXZlbnRGdW5jKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYW5nZUV2ZW50UGx1Z2luO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvQ2hhbmdlRXZlbnRQbHVnaW4uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RXZlbnRUYXJnZXRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdldHMgdGhlIHRhcmdldCBub2RlIGZyb20gYSBuYXRpdmUgYnJvd3NlciBldmVudCBieSBhY2NvdW50aW5nIGZvclxuICogaW5jb25zaXN0ZW5jaWVzIGluIGJyb3dzZXIgRE9NIEFQSXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IFRhcmdldCBub2RlLlxuICovXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkge1xuICB2YXIgdGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgfHwgd2luZG93O1xuICAvLyBTYWZhcmkgbWF5IGZpcmUgZXZlbnRzIG9uIHRleHQgbm9kZXMgKE5vZGUuVEVYVF9OT0RFIGlzIDMpLlxuICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuICByZXR1cm4gdGFyZ2V0Lm5vZGVUeXBlID09PSAzID8gdGFyZ2V0LnBhcmVudE5vZGUgOiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRUYXJnZXQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9nZXRFdmVudFRhcmdldC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpc1RleHRJbnB1dEVsZW1lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtaW5wdXQtZWxlbWVudC5odG1sI2lucHV0LXR5cGUtYXR0ci1zdW1tYXJ5XG4gKi9cbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzID0ge1xuICAnY29sb3InOiB0cnVlLFxuICAnZGF0ZSc6IHRydWUsXG4gICdkYXRldGltZSc6IHRydWUsXG4gICdkYXRldGltZS1sb2NhbCc6IHRydWUsXG4gICdlbWFpbCc6IHRydWUsXG4gICdtb250aCc6IHRydWUsXG4gICdudW1iZXInOiB0cnVlLFxuICAncGFzc3dvcmQnOiB0cnVlLFxuICAncmFuZ2UnOiB0cnVlLFxuICAnc2VhcmNoJzogdHJ1ZSxcbiAgJ3RlbCc6IHRydWUsXG4gICd0ZXh0JzogdHJ1ZSxcbiAgJ3RpbWUnOiB0cnVlLFxuICAndXJsJzogdHJ1ZSxcbiAgJ3dlZWsnOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIHN1cHBvcnRlZElucHV0VHlwZXNbZWxlbS50eXBlXSB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUZXh0SW5wdXRFbGVtZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvaXNUZXh0SW5wdXRFbGVtZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENsaWVudFJlYWN0Um9vdEluZGV4XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG5leHRSZWFjdFJvb3RJbmRleCA9IDA7XG5cbnZhciBDbGllbnRSZWFjdFJvb3RJbmRleCA9IHtcbiAgY3JlYXRlUmVhY3RSb290SW5kZXg6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV4dFJlYWN0Um9vdEluZGV4Kys7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xpZW50UmVhY3RSb290SW5kZXg7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9DbGllbnRSZWFjdFJvb3RJbmRleC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxuLyoqXG4gKiBNb2R1bGUgdGhhdCBpcyBpbmplY3RhYmxlIGludG8gYEV2ZW50UGx1Z2luSHViYCwgdGhhdCBzcGVjaWZpZXMgYVxuICogZGV0ZXJtaW5pc3RpYyBvcmRlcmluZyBvZiBgRXZlbnRQbHVnaW5gcy4gQSBjb252ZW5pZW50IHdheSB0byByZWFzb24gYWJvdXRcbiAqIHBsdWdpbnMsIHdpdGhvdXQgaGF2aW5nIHRvIHBhY2thZ2UgZXZlcnkgb25lIG9mIHRoZW0uIFRoaXMgaXMgYmV0dGVyIHRoYW5cbiAqIGhhdmluZyBwbHVnaW5zIGJlIG9yZGVyZWQgaW4gdGhlIHNhbWUgb3JkZXIgdGhhdCB0aGV5IGFyZSBpbmplY3RlZCBiZWNhdXNlXG4gKiB0aGF0IG9yZGVyaW5nIHdvdWxkIGJlIGluZmx1ZW5jZWQgYnkgdGhlIHBhY2thZ2luZyBvcmRlci5cbiAqIGBSZXNwb25kZXJFdmVudFBsdWdpbmAgbXVzdCBvY2N1ciBiZWZvcmUgYFNpbXBsZUV2ZW50UGx1Z2luYCBzbyB0aGF0XG4gKiBwcmV2ZW50aW5nIGRlZmF1bHQgb24gZXZlbnRzIGlzIGNvbnZlbmllbnQgaW4gYFNpbXBsZUV2ZW50UGx1Z2luYCBoYW5kbGVycy5cbiAqL1xudmFyIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyID0gW2tleU9mKHsgUmVzcG9uZGVyRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgU2ltcGxlRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgVGFwRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IENoYW5nZUV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IFNlbGVjdEV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IG51bGwgfSldO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlZmF1bHRFdmVudFBsdWdpbk9yZGVyO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG5cbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG52YXIgZ2V0Rmlyc3RSZWFjdERPTSA9IFJlYWN0TW91bnQuZ2V0Rmlyc3RSZWFjdERPTTtcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIG1vdXNlRW50ZXI6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiBrZXlPZih7IG9uTW91c2VFbnRlcjogbnVsbCB9KSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3V0LCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3Zlcl1cbiAgfSxcbiAgbW91c2VMZWF2ZToge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IGtleU9mKHsgb25Nb3VzZUxlYXZlOiBudWxsIH0pLFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wTW91c2VPdXQsIHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyXVxuICB9XG59O1xuXG52YXIgZXh0cmFjdGVkRXZlbnRzID0gW251bGwsIG51bGxdO1xuXG52YXIgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIEZvciBhbG1vc3QgZXZlcnkgaW50ZXJhY3Rpb24gd2UgY2FyZSBhYm91dCwgdGhlcmUgd2lsbCBiZSBib3RoIGEgdG9wLWxldmVsXG4gICAqIGBtb3VzZW92ZXJgIGFuZCBgbW91c2VvdXRgIGV2ZW50IHRoYXQgb2NjdXJzLiBPbmx5IHVzZSBgbW91c2VvdXRgIHNvIHRoYXRcbiAgICogd2UgZG8gbm90IGV4dHJhY3QgZHVwbGljYXRlIGV2ZW50cy4gSG93ZXZlciwgbW92aW5nIHRoZSBtb3VzZSBpbnRvIHRoZVxuICAgKiBicm93c2VyIGZyb20gb3V0c2lkZSB3aWxsIG5vdCBmaXJlIGEgYG1vdXNlb3V0YCBldmVudC4gSW4gdGhpcyBjYXNlLCB3ZSB1c2VcbiAgICogdGhlIGBtb3VzZW92ZXJgIHRvcC1sZXZlbCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHN9XG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXIgJiYgKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQuZnJvbUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRvcExldmVsVHlwZSAhPT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCAmJiB0b3BMZXZlbFR5cGUgIT09IHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyKSB7XG4gICAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIGluIG9yIG1vdXNlIG91dCAtIGlnbm9yaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHdpbjtcbiAgICBpZiAodG9wTGV2ZWxUYXJnZXQud2luZG93ID09PSB0b3BMZXZlbFRhcmdldCkge1xuICAgICAgLy8gYHRvcExldmVsVGFyZ2V0YCBpcyBwcm9iYWJseSBhIHdpbmRvdyBvYmplY3QuXG4gICAgICB3aW4gPSB0b3BMZXZlbFRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgICAgdmFyIGRvYyA9IHRvcExldmVsVGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luID0gd2luZG93O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmcm9tO1xuICAgIHZhciB0bztcbiAgICB2YXIgZnJvbUlEID0gJyc7XG4gICAgdmFyIHRvSUQgPSAnJztcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3V0KSB7XG4gICAgICBmcm9tID0gdG9wTGV2ZWxUYXJnZXQ7XG4gICAgICBmcm9tSUQgPSB0b3BMZXZlbFRhcmdldElEO1xuICAgICAgdG8gPSBnZXRGaXJzdFJlYWN0RE9NKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQudG9FbGVtZW50KTtcbiAgICAgIGlmICh0bykge1xuICAgICAgICB0b0lEID0gUmVhY3RNb3VudC5nZXRJRCh0byk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0byA9IHdpbjtcbiAgICAgIH1cbiAgICAgIHRvID0gdG8gfHwgd2luO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcm9tID0gd2luO1xuICAgICAgdG8gPSB0b3BMZXZlbFRhcmdldDtcbiAgICAgIHRvSUQgPSB0b3BMZXZlbFRhcmdldElEO1xuICAgIH1cblxuICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgLy8gTm90aGluZyBwZXJ0YWlucyB0byBvdXIgbWFuYWdlZCBjb21wb25lbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxlYXZlID0gU3ludGhldGljTW91c2VFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5tb3VzZUxlYXZlLCBmcm9tSUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgbGVhdmUudHlwZSA9ICdtb3VzZWxlYXZlJztcbiAgICBsZWF2ZS50YXJnZXQgPSBmcm9tO1xuICAgIGxlYXZlLnJlbGF0ZWRUYXJnZXQgPSB0bztcblxuICAgIHZhciBlbnRlciA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMubW91c2VFbnRlciwgdG9JRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBlbnRlci50eXBlID0gJ21vdXNlZW50ZXInO1xuICAgIGVudGVyLnRhcmdldCA9IHRvO1xuICAgIGVudGVyLnJlbGF0ZWRUYXJnZXQgPSBmcm9tO1xuXG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tSUQsIHRvSUQpO1xuXG4gICAgZXh0cmFjdGVkRXZlbnRzWzBdID0gbGVhdmU7XG4gICAgZXh0cmFjdGVkRXZlbnRzWzFdID0gZW50ZXI7XG5cbiAgICByZXR1cm4gZXh0cmFjdGVkRXZlbnRzO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRW50ZXJMZWF2ZUV2ZW50UGx1Z2luO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY01vdXNlRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xudmFyIFZpZXdwb3J0TWV0cmljcyA9IHJlcXVpcmUoJy4vVmlld3BvcnRNZXRyaWNzJyk7XG5cbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKCcuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZScpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgTW91c2VFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBNb3VzZUV2ZW50SW50ZXJmYWNlID0ge1xuICBzY3JlZW5YOiBudWxsLFxuICBzY3JlZW5ZOiBudWxsLFxuICBjbGllbnRYOiBudWxsLFxuICBjbGllbnRZOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIGJ1dHRvbjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gV2Via2l0LCBGaXJlZm94LCBJRTkrXG4gICAgLy8gd2hpY2g6ICAxIDIgM1xuICAgIC8vIGJ1dHRvbjogMCAxIDIgKHN0YW5kYXJkKVxuICAgIHZhciBidXR0b24gPSBldmVudC5idXR0b247XG4gICAgaWYgKCd3aGljaCcgaW4gZXZlbnQpIHtcbiAgICAgIHJldHVybiBidXR0b247XG4gICAgfVxuICAgIC8vIElFPDlcbiAgICAvLyB3aGljaDogIHVuZGVmaW5lZFxuICAgIC8vIGJ1dHRvbjogMCAwIDBcbiAgICAvLyBidXR0b246IDEgNCAyIChvbm1vdXNldXApXG4gICAgcmV0dXJuIGJ1dHRvbiA9PT0gMiA/IDIgOiBidXR0b24gPT09IDQgPyAxIDogMDtcbiAgfSxcbiAgYnV0dG9uczogbnVsbCxcbiAgcmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgKGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQpO1xuICB9LFxuICAvLyBcIlByb3ByaWV0YXJ5XCIgSW50ZXJmYWNlLlxuICBwYWdlWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdwYWdlWCcgaW4gZXZlbnQgPyBldmVudC5wYWdlWCA6IGV2ZW50LmNsaWVudFggKyBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbExlZnQ7XG4gIH0sXG4gIHBhZ2VZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ3BhZ2VZJyBpbiBldmVudCA/IGV2ZW50LnBhZ2VZIDogZXZlbnQuY2xpZW50WSArIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsVG9wO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNNb3VzZUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY01vdXNlRXZlbnQsIE1vdXNlRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNNb3VzZUV2ZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY1VJRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRUYXJnZXQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFVJRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgVUlFdmVudEludGVyZmFjZSA9IHtcbiAgdmlldzogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnZpZXcpIHtcbiAgICAgIHJldHVybiBldmVudC52aWV3O1xuICAgIH1cblxuICAgIHZhciB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XG4gICAgaWYgKHRhcmdldCAhPSBudWxsICYmIHRhcmdldC53aW5kb3cgPT09IHRhcmdldCkge1xuICAgICAgLy8gdGFyZ2V0IGlzIGEgd2luZG93IG9iamVjdFxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICB2YXIgZG9jID0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgIGlmIChkb2MpIHtcbiAgICAgIHJldHVybiBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gIH0sXG4gIGRldGFpbDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LmRldGFpbCB8fCAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVUlFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1VJRXZlbnQsIFVJRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1VJRXZlbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNVSUV2ZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50TW9kaWZpZXJTdGF0ZVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBtb2RpZmllciBrZXkgdG8gdGhlIGFzc29jaWF0ZWQgcHJvcGVydHkgaW4gdGhlIGV2ZW50LlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2tleXMtTW9kaWZpZXJzXG4gKi9cblxudmFyIG1vZGlmaWVyS2V5VG9Qcm9wID0ge1xuICAnQWx0JzogJ2FsdEtleScsXG4gICdDb250cm9sJzogJ2N0cmxLZXknLFxuICAnTWV0YSc6ICdtZXRhS2V5JyxcbiAgJ1NoaWZ0JzogJ3NoaWZ0S2V5J1xufTtcblxuLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBnZXRNb2RpZmllclN0YXRlIHNvIHdlIHNpbXBseSBtYXAgaXQgdG8gdGhlIG9ubHlcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQgaXRzZWxmLCBkb2VzIG5vdCBzdXBwb3J0IExvY2sta2V5cy5cbi8vIEN1cnJlbnRseSwgYWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBDaHJvbWUgc2VlbXMgdG8gc3VwcG9ydCBMb2NrLWtleXMuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcbiAgaWYgKG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUpIHtcbiAgICByZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXlBcmcpO1xuICB9XG4gIHZhciBrZXlQcm9wID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXTtcbiAgcmV0dXJuIGtleVByb3AgPyAhIW5hdGl2ZUV2ZW50W2tleVByb3BdIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudE1vZGlmaWVyU3RhdGU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9nZXRFdmVudE1vZGlmaWVyU3RhdGUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgSFRNTERPTVByb3BlcnR5Q29uZmlnXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgTVVTVF9VU0VfQVRUUklCVVRFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLk1VU1RfVVNFX0FUVFJJQlVURTtcbnZhciBNVVNUX1VTRV9QUk9QRVJUWSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5NVVNUX1VTRV9QUk9QRVJUWTtcbnZhciBIQVNfQk9PTEVBTl9WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRTtcbnZhciBIQVNfU0lERV9FRkZFQ1RTID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19TSURFX0VGRkVDVFM7XG52YXIgSEFTX05VTUVSSUNfVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUU7XG52YXIgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUU7XG52YXIgSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFO1xuXG52YXIgaGFzU1ZHO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICB2YXIgaW1wbGVtZW50YXRpb24gPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbjtcbiAgaGFzU1ZHID0gaW1wbGVtZW50YXRpb24gJiYgaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSAmJiBpbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0Jhc2ljU3RydWN0dXJlJywgJzEuMScpO1xufVxuXG52YXIgSFRNTERPTVByb3BlcnR5Q29uZmlnID0ge1xuICBpc0N1c3RvbUF0dHJpYnV0ZTogUmVnRXhwLnByb3RvdHlwZS50ZXN0LmJpbmQoL14oZGF0YXxhcmlhKS1bYS16X11bYS16XFxkXy5cXC1dKiQvKSxcbiAgUHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIFN0YW5kYXJkIFByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBhY2NlcHQ6IG51bGwsXG4gICAgYWNjZXB0Q2hhcnNldDogbnVsbCxcbiAgICBhY2Nlc3NLZXk6IG51bGwsXG4gICAgYWN0aW9uOiBudWxsLFxuICAgIGFsbG93RnVsbFNjcmVlbjogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYWxsb3dUcmFuc3BhcmVuY3k6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBhbHQ6IG51bGwsXG4gICAgYXN5bmM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9Db21wbGV0ZTogbnVsbCxcbiAgICAvLyBhdXRvRm9jdXMgaXMgcG9seWZpbGxlZC9ub3JtYWxpemVkIGJ5IEF1dG9Gb2N1c1V0aWxzXG4gICAgLy8gYXV0b0ZvY3VzOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhdXRvUGxheTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2FwdHVyZTogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2VsbFBhZGRpbmc6IG51bGwsXG4gICAgY2VsbFNwYWNpbmc6IG51bGwsXG4gICAgY2hhclNldDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGNoYWxsZW5nZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGNoZWNrZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2xhc3NJRDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIC8vIFRvIHNldCBjbGFzc05hbWUgb24gU1ZHIGVsZW1lbnRzLCBpdCdzIG5lY2Vzc2FyeSB0byB1c2UgLnNldEF0dHJpYnV0ZTtcbiAgICAvLyB0aGlzIHdvcmtzIG9uIEhUTUwgZWxlbWVudHMgdG9vIGluIGFsbCBicm93c2VycyBleGNlcHQgSUU4LiBDb252ZW5pZW50bHksXG4gICAgLy8gSUU4IGRvZXNuJ3Qgc3VwcG9ydCBTVkcgYW5kIHNvIHdlIGNhbiBzaW1wbHkgdXNlIHRoZSBhdHRyaWJ1dGUgaW5cbiAgICAvLyBicm93c2VycyB0aGF0IHN1cHBvcnQgU1ZHIGFuZCB0aGUgcHJvcGVydHkgaW4gYnJvd3NlcnMgdGhhdCBkb24ndCxcbiAgICAvLyByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgSFRNTCBvciBTVkcuXG4gICAgY2xhc3NOYW1lOiBoYXNTVkcgPyBNVVNUX1VTRV9BVFRSSUJVVEUgOiBNVVNUX1VTRV9QUk9QRVJUWSxcbiAgICBjb2xzOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBjb2xTcGFuOiBudWxsLFxuICAgIGNvbnRlbnQ6IG51bGwsXG4gICAgY29udGVudEVkaXRhYmxlOiBudWxsLFxuICAgIGNvbnRleHRNZW51OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgY29udHJvbHM6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY29vcmRzOiBudWxsLFxuICAgIGNyb3NzT3JpZ2luOiBudWxsLFxuICAgIGRhdGE6IG51bGwsIC8vIEZvciBgPG9iamVjdCAvPmAgYWN0cyBhcyBgc3JjYC5cbiAgICBkYXRlVGltZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgICdkZWZhdWx0JzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGVmZXI6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRpcjogbnVsbCxcbiAgICBkaXNhYmxlZDogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZG93bmxvYWQ6IEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUsXG4gICAgZHJhZ2dhYmxlOiBudWxsLFxuICAgIGVuY1R5cGU6IG51bGwsXG4gICAgZm9ybTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvcm1BY3Rpb246IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmb3JtRW5jVHlwZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvcm1NZXRob2Q6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmb3JtTm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZm9ybVRhcmdldDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZyYW1lQm9yZGVyOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgaGVhZGVyczogbnVsbCxcbiAgICBoZWlnaHQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBoaWRkZW46IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGhpZ2g6IG51bGwsXG4gICAgaHJlZjogbnVsbCxcbiAgICBocmVmTGFuZzogbnVsbCxcbiAgICBodG1sRm9yOiBudWxsLFxuICAgIGh0dHBFcXVpdjogbnVsbCxcbiAgICBpY29uOiBudWxsLFxuICAgIGlkOiBNVVNUX1VTRV9QUk9QRVJUWSxcbiAgICBpbnB1dE1vZGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBpbnRlZ3JpdHk6IG51bGwsXG4gICAgaXM6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBrZXlQYXJhbXM6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBrZXlUeXBlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAga2luZDogbnVsbCxcbiAgICBsYWJlbDogbnVsbCxcbiAgICBsYW5nOiBudWxsLFxuICAgIGxpc3Q6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBsb29wOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGxvdzogbnVsbCxcbiAgICBtYW5pZmVzdDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG1hcmdpbkhlaWdodDogbnVsbCxcbiAgICBtYXJnaW5XaWR0aDogbnVsbCxcbiAgICBtYXg6IG51bGwsXG4gICAgbWF4TGVuZ3RoOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbWVkaWE6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtZWRpYUdyb3VwOiBudWxsLFxuICAgIG1ldGhvZDogbnVsbCxcbiAgICBtaW46IG51bGwsXG4gICAgbWluTGVuZ3RoOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbXVsdGlwbGU6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbXV0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbmFtZTogbnVsbCxcbiAgICBub25jZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG5vVmFsaWRhdGU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG9wZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG9wdGltdW06IG51bGwsXG4gICAgcGF0dGVybjogbnVsbCxcbiAgICBwbGFjZWhvbGRlcjogbnVsbCxcbiAgICBwb3N0ZXI6IG51bGwsXG4gICAgcHJlbG9hZDogbnVsbCxcbiAgICByYWRpb0dyb3VwOiBudWxsLFxuICAgIHJlYWRPbmx5OiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJlbDogbnVsbCxcbiAgICByZXF1aXJlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmV2ZXJzZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJvbGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICByb3dzOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICByb3dTcGFuOiBudWxsLFxuICAgIHNhbmRib3g6IG51bGwsXG4gICAgc2NvcGU6IG51bGwsXG4gICAgc2NvcGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzY3JvbGxpbmc6IG51bGwsXG4gICAgc2VhbWxlc3M6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNlbGVjdGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNoYXBlOiBudWxsLFxuICAgIHNpemU6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHNpemVzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3BhbjogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc3BlbGxDaGVjazogbnVsbCxcbiAgICBzcmM6IG51bGwsXG4gICAgc3JjRG9jOiBNVVNUX1VTRV9QUk9QRVJUWSxcbiAgICBzcmNMYW5nOiBudWxsLFxuICAgIHNyY1NldDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0YXJ0OiBIQVNfTlVNRVJJQ19WQUxVRSxcbiAgICBzdGVwOiBudWxsLFxuICAgIHN0eWxlOiBudWxsLFxuICAgIHN1bW1hcnk6IG51bGwsXG4gICAgdGFiSW5kZXg6IG51bGwsXG4gICAgdGFyZ2V0OiBudWxsLFxuICAgIHRpdGxlOiBudWxsLFxuICAgIHR5cGU6IG51bGwsXG4gICAgdXNlTWFwOiBudWxsLFxuICAgIHZhbHVlOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19TSURFX0VGRkVDVFMsXG4gICAgd2lkdGg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB3bW9kZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHdyYXA6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBSREZhIFByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBhYm91dDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGRhdGF0eXBlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgaW5saXN0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcHJlZml4OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgLy8gcHJvcGVydHkgaXMgYWxzbyBzdXBwb3J0ZWQgZm9yIE9wZW5HcmFwaCBpbiBtZXRhIHRhZ3MuXG4gICAgcHJvcGVydHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICByZXNvdXJjZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgICd0eXBlb2YnOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgdm9jYWI6IE1VU1RfVVNFX0FUVFJJQlVURSxcblxuICAgIC8qKlxuICAgICAqIE5vbi1zdGFuZGFyZCBQcm9wZXJ0aWVzXG4gICAgICovXG4gICAgLy8gYXV0b0NhcGl0YWxpemUgYW5kIGF1dG9Db3JyZWN0IGFyZSBzdXBwb3J0ZWQgaW4gTW9iaWxlIFNhZmFyaSBmb3JcbiAgICAvLyBrZXlib2FyZCBoaW50cy5cbiAgICBhdXRvQ2FwaXRhbGl6ZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGF1dG9Db3JyZWN0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgLy8gYXV0b1NhdmUgYWxsb3dzIFdlYktpdC9CbGluayB0byBwZXJzaXN0IHZhbHVlcyBvZiBpbnB1dCBmaWVsZHMgb24gcGFnZSByZWxvYWRzXG4gICAgYXV0b1NhdmU6IG51bGwsXG4gICAgLy8gY29sb3IgaXMgZm9yIFNhZmFyaSBtYXNrLWljb24gbGlua1xuICAgIGNvbG9yOiBudWxsLFxuICAgIC8vIGl0ZW1Qcm9wLCBpdGVtU2NvcGUsIGl0ZW1UeXBlIGFyZSBmb3JcbiAgICAvLyBNaWNyb2RhdGEgc3VwcG9ydC4gU2VlIGh0dHA6Ly9zY2hlbWEub3JnL2RvY3MvZ3MuaHRtbFxuICAgIGl0ZW1Qcm9wOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgaXRlbVNjb3BlOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBpdGVtVHlwZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIC8vIGl0ZW1JRCBhbmQgaXRlbVJlZiBhcmUgZm9yIE1pY3JvZGF0YSBzdXBwb3J0IGFzIHdlbGwgYnV0XG4gICAgLy8gb25seSBzcGVjaWZpZWQgaW4gdGhlIHRoZSBXSEFUV0cgc3BlYyBkb2N1bWVudC4gU2VlXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvbWljcm9kYXRhLmh0bWwjbWljcm9kYXRhLWRvbS1hcGlcbiAgICBpdGVtSUQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBpdGVtUmVmOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgLy8gcmVzdWx0cyBzaG93IGxvb2tpbmcgZ2xhc3MgaWNvbiBhbmQgcmVjZW50IHNlYXJjaGVzIG9uIGlucHV0XG4gICAgLy8gc2VhcmNoIGZpZWxkcyBpbiBXZWJLaXQvQmxpbmtcbiAgICByZXN1bHRzOiBudWxsLFxuICAgIC8vIElFLW9ubHkgYXR0cmlidXRlIHRoYXQgc3BlY2lmaWVzIHNlY3VyaXR5IHJlc3RyaWN0aW9ucyBvbiBhbiBpZnJhbWVcbiAgICAvLyBhcyBhbiBhbHRlcm5hdGl2ZSB0byB0aGUgc2FuZGJveCBhdHRyaWJ1dGUgb24gSUU8MTBcbiAgICBzZWN1cml0eTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIC8vIElFLW9ubHkgYXR0cmlidXRlIHRoYXQgY29udHJvbHMgZm9jdXMgYmVoYXZpb3JcbiAgICB1bnNlbGVjdGFibGU6IE1VU1RfVVNFX0FUVFJJQlVURVxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge1xuICAgIGFjY2VwdENoYXJzZXQ6ICdhY2NlcHQtY2hhcnNldCcsXG4gICAgY2xhc3NOYW1lOiAnY2xhc3MnLFxuICAgIGh0bWxGb3I6ICdmb3InLFxuICAgIGh0dHBFcXVpdjogJ2h0dHAtZXF1aXYnXG4gIH0sXG4gIERPTVByb3BlcnR5TmFtZXM6IHtcbiAgICBhdXRvQ29tcGxldGU6ICdhdXRvY29tcGxldGUnLFxuICAgIGF1dG9Gb2N1czogJ2F1dG9mb2N1cycsXG4gICAgYXV0b1BsYXk6ICdhdXRvcGxheScsXG4gICAgYXV0b1NhdmU6ICdhdXRvc2F2ZScsXG4gICAgLy8gYGVuY29kaW5nYCBpcyBlcXVpdmFsZW50IHRvIGBlbmN0eXBlYCwgSUU4IGxhY2tzIGFuIGBlbmN0eXBlYCBzZXR0ZXIuXG4gICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCNkb20tZnMtZW5jb2RpbmdcbiAgICBlbmNUeXBlOiAnZW5jb2RpbmcnLFxuICAgIGhyZWZMYW5nOiAnaHJlZmxhbmcnLFxuICAgIHJhZGlvR3JvdXA6ICdyYWRpb2dyb3VwJyxcbiAgICBzcGVsbENoZWNrOiAnc3BlbGxjaGVjaycsXG4gICAgc3JjRG9jOiAnc3JjZG9jJyxcbiAgICBzcmNTZXQ6ICdzcmNzZXQnXG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSFRNTERPTVByb3BlcnR5Q29uZmlnO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvSFRNTERPTVByb3BlcnR5Q29uZmlnLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xuXG52YXIgZmluZERPTU5vZGUgPSByZXF1aXJlKCcuL2ZpbmRET01Ob2RlJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5LZXkgPSAnX2dldERPTU5vZGVEaWRXYXJuJztcblxudmFyIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluID0ge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgRE9NIG5vZGUgcmVuZGVyZWQgYnkgdGhpcyBjb21wb25lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IFRoZSByb290IG5vZGUgb2YgdGhpcyBjb21wb25lbnQuXG4gICAqIEBmaW5hbFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRET01Ob2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodGhpcy5jb25zdHJ1Y3RvcltkaWRXYXJuS2V5XSwgJyVzLmdldERPTU5vZGUoLi4uKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlICcgKyAnUmVhY3RET00uZmluZERPTU5vZGUoaW5zdGFuY2UpIGluc3RlYWQuJywgUmVhY3RJbnN0YW5jZU1hcC5nZXQodGhpcykuZ2V0TmFtZSgpIHx8IHRoaXMudGFnTmFtZSB8fCAnVW5rbm93bicpIDogdW5kZWZpbmVkO1xuICAgIHRoaXMuY29uc3RydWN0b3JbZGlkV2FybktleV0gPSB0cnVlO1xuICAgIHJldHVybiBmaW5kRE9NTm9kZSh0aGlzKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGZpbmRET01Ob2RlXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIERPTSBub2RlIHJlbmRlcmVkIGJ5IHRoaXMgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fERPTUVsZW1lbnR9IGNvbXBvbmVudE9yRWxlbWVudFxuICogQHJldHVybiB7P0RPTUVsZW1lbnR9IFRoZSByb290IG5vZGUgb2YgdGhpcyBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBmaW5kRE9NTm9kZShjb21wb25lbnRPckVsZW1lbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIGlmIChvd25lciAhPT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcob3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGdldERPTU5vZGUgb3IgZmluZERPTU5vZGUgaW5zaWRlIGl0cyByZW5kZXIoKS4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgIG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChjb21wb25lbnRPckVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChjb21wb25lbnRPckVsZW1lbnQubm9kZVR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gY29tcG9uZW50T3JFbGVtZW50O1xuICB9XG4gIGlmIChSZWFjdEluc3RhbmNlTWFwLmhhcyhjb21wb25lbnRPckVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuZ2V0Tm9kZUZyb21JbnN0YW5jZShjb21wb25lbnRPckVsZW1lbnQpO1xuICB9XG4gICEoY29tcG9uZW50T3JFbGVtZW50LnJlbmRlciA9PSBudWxsIHx8IHR5cGVvZiBjb21wb25lbnRPckVsZW1lbnQucmVuZGVyICE9PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdmaW5kRE9NTm9kZSB3YXMgY2FsbGVkIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCBhcHBlYXJzIHRvIGJlIG5laXRoZXIgUmVhY3RDb21wb25lbnQgbm9yIERPTU5vZGUgKGtleXM6ICVzKScsIE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kRE9NTm9kZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2ZpbmRET01Ob2RlLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcblxudmFyIFJFU0VUX0JBVENIRURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZW1wdHlGdW5jdGlvbixcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG4gIH1cbn07XG5cbnZhciBGTFVTSF9CQVRDSEVEX1VQREFURVMgPSB7XG4gIGluaXRpYWxpemU6IGVtcHR5RnVuY3Rpb24sXG4gIGNsb3NlOiBSZWFjdFVwZGF0ZXMuZmx1c2hCYXRjaGVkVXBkYXRlcy5iaW5kKFJlYWN0VXBkYXRlcylcbn07XG5cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtGTFVTSF9CQVRDSEVEX1VQREFURVMsIFJFU0VUX0JBVENIRURfVVBEQVRFU107XG5cbmZ1bmN0aW9uIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbigpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xufVxuXG5hc3NpZ24oUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24uTWl4aW4sIHtcbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfVxufSk7XG5cbnZhciB0cmFuc2FjdGlvbiA9IG5ldyBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24oKTtcblxudmFyIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kgPSB7XG4gIGlzQmF0Y2hpbmdVcGRhdGVzOiBmYWxzZSxcblxuICAvKipcbiAgICogQ2FsbCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gaW4gYSBjb250ZXh0IHdpdGhpbiB3aGljaCBjYWxscyB0byBgc2V0U3RhdGVgXG4gICAqIGFuZCBmcmllbmRzIGFyZSBiYXRjaGVkIHN1Y2ggdGhhdCBjb21wb25lbnRzIGFyZW4ndCB1cGRhdGVkIHVubmVjZXNzYXJpbHkuXG4gICAqL1xuICBiYXRjaGVkVXBkYXRlczogZnVuY3Rpb24gKGNhbGxiYWNrLCBhLCBiLCBjLCBkLCBlKSB7XG4gICAgdmFyIGFscmVhZHlCYXRjaGluZ1VwZGF0ZXMgPSBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzO1xuXG4gICAgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG5cbiAgICAvLyBUaGUgY29kZSBpcyB3cml0dGVuIHRoaXMgd2F5IHRvIGF2b2lkIGV4dHJhIGFsbG9jYXRpb25zXG4gICAgaWYgKGFscmVhZHlCYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICAgIGNhbGxiYWNrKGEsIGIsIGMsIGQsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2FjdGlvbi5wZXJmb3JtKGNhbGxiYWNrLCBudWxsLCBhLCBiLCBjLCBkLCBlKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01Db21wb25lbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuLyogZ2xvYmFsIGhhc093blByb3BlcnR5OnRydWUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQXV0b0ZvY3VzVXRpbHMgPSByZXF1aXJlKCcuL0F1dG9Gb2N1c1V0aWxzJyk7XG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RET01CdXR0b24gPSByZXF1aXJlKCcuL1JlYWN0RE9NQnV0dG9uJyk7XG52YXIgUmVhY3RET01JbnB1dCA9IHJlcXVpcmUoJy4vUmVhY3RET01JbnB1dCcpO1xudmFyIFJlYWN0RE9NT3B0aW9uID0gcmVxdWlyZSgnLi9SZWFjdERPTU9wdGlvbicpO1xudmFyIFJlYWN0RE9NU2VsZWN0ID0gcmVxdWlyZSgnLi9SZWFjdERPTVNlbGVjdCcpO1xudmFyIFJlYWN0RE9NVGV4dGFyZWEgPSByZXF1aXJlKCcuL1JlYWN0RE9NVGV4dGFyZWEnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG52YXIgUmVhY3RNdWx0aUNoaWxkID0gcmVxdWlyZSgnLi9SZWFjdE11bHRpQ2hpbGQnKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xudmFyIFJlYWN0VXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlUXVldWUnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xudmFyIHNldFRleHRDb250ZW50ID0gcmVxdWlyZSgnLi9zZXRUZXh0Q29udGVudCcpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IHJlcXVpcmUoJy4vdmFsaWRhdGVET01OZXN0aW5nJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRlbGV0ZUxpc3RlbmVyID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmRlbGV0ZUxpc3RlbmVyO1xudmFyIGxpc3RlblRvID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmxpc3RlblRvO1xudmFyIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzO1xuXG4vLyBGb3IgcXVpY2tseSBtYXRjaGluZyBjaGlsZHJlbiB0eXBlLCB0byB0ZXN0IGlmIGNhbiBiZSB0cmVhdGVkIGFzIGNvbnRlbnQuXG52YXIgQ09OVEVOVF9UWVBFUyA9IHsgJ3N0cmluZyc6IHRydWUsICdudW1iZXInOiB0cnVlIH07XG5cbnZhciBDSElMRFJFTiA9IGtleU9mKHsgY2hpbGRyZW46IG51bGwgfSk7XG52YXIgU1RZTEUgPSBrZXlPZih7IHN0eWxlOiBudWxsIH0pO1xudmFyIEhUTUwgPSBrZXlPZih7IF9faHRtbDogbnVsbCB9KTtcblxudmFyIEVMRU1FTlRfTk9ERV9UWVBFID0gMTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGludGVybmFsSW5zdGFuY2UpIHtcbiAgaWYgKGludGVybmFsSW5zdGFuY2UpIHtcbiAgICB2YXIgb3duZXIgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXIgfHwgbnVsbDtcbiAgICBpZiAob3duZXIpIHtcbiAgICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICcgVGhpcyBET00gbm9kZSB3YXMgcmVuZGVyZWQgYnkgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgbGVnYWN5UHJvcHNEZXNjcmlwdG9yO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgbGVnYWN5UHJvcHNEZXNjcmlwdG9yID0ge1xuICAgIHByb3BzOiB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5fcmVhY3RJbnRlcm5hbENvbXBvbmVudDtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdERPTUNvbXBvbmVudDogRG8gbm90IGFjY2VzcyAucHJvcHMgb2YgYSBET00gbm9kZTsgaW5zdGVhZCwgJyArICdyZWNyZWF0ZSB0aGUgcHJvcHMgYXMgYHJlbmRlcmAgZGlkIG9yaWdpbmFsbHkgb3IgcmVhZCB0aGUgRE9NICcgKyAncHJvcGVydGllcy9hdHRyaWJ1dGVzIGRpcmVjdGx5IGZyb20gdGhpcyBub2RlIChlLmcuLCAnICsgJ3RoaXMucmVmcy5ib3guY2xhc3NOYW1lKS4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBsZWdhY3lHZXRET01Ob2RlKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBjb21wb25lbnQgPSB0aGlzLl9yZWFjdEludGVybmFsQ29tcG9uZW50O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3RET01Db21wb25lbnQ6IERvIG5vdCBhY2Nlc3MgLmdldERPTU5vZGUoKSBvZiBhIERPTSBub2RlOyAnICsgJ2luc3RlYWQsIHVzZSB0aGUgbm9kZSBkaXJlY3RseS4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gbGVnYWN5SXNNb3VudGVkKCkge1xuICB2YXIgY29tcG9uZW50ID0gdGhpcy5fcmVhY3RJbnRlcm5hbENvbXBvbmVudDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0RE9NQ29tcG9uZW50OiBEbyBub3QgYWNjZXNzIC5pc01vdW50ZWQoKSBvZiBhIERPTSBub2RlLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiAhIWNvbXBvbmVudDtcbn1cblxuZnVuY3Rpb24gbGVnYWN5U2V0U3RhdGVFdGMoKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuX3JlYWN0SW50ZXJuYWxDb21wb25lbnQ7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdERPTUNvbXBvbmVudDogRG8gbm90IGFjY2VzcyAuc2V0U3RhdGUoKSwgLnJlcGxhY2VTdGF0ZSgpLCBvciAnICsgJy5mb3JjZVVwZGF0ZSgpIG9mIGEgRE9NIG5vZGUuIFRoaXMgaXMgYSBuby1vcC4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWdhY3lTZXRQcm9wcyhwYXJ0aWFsUHJvcHMsIGNhbGxiYWNrKSB7XG4gIHZhciBjb21wb25lbnQgPSB0aGlzLl9yZWFjdEludGVybmFsQ29tcG9uZW50O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3RET01Db21wb25lbnQ6IERvIG5vdCBhY2Nlc3MgLnNldFByb3BzKCkgb2YgYSBET00gbm9kZS4gJyArICdJbnN0ZWFkLCBjYWxsIFJlYWN0RE9NLnJlbmRlciBhZ2FpbiBhdCB0aGUgdG9wIGxldmVsLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogdW5kZWZpbmVkO1xuICB9XG4gIGlmICghY29tcG9uZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZVNldFByb3BzSW50ZXJuYWwoY29tcG9uZW50LCBwYXJ0aWFsUHJvcHMpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVDYWxsYmFja0ludGVybmFsKGNvbXBvbmVudCwgY2FsbGJhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlZ2FjeVJlcGxhY2VQcm9wcyhwYXJ0aWFsUHJvcHMsIGNhbGxiYWNrKSB7XG4gIHZhciBjb21wb25lbnQgPSB0aGlzLl9yZWFjdEludGVybmFsQ29tcG9uZW50O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3RET01Db21wb25lbnQ6IERvIG5vdCBhY2Nlc3MgLnJlcGxhY2VQcm9wcygpIG9mIGEgRE9NIG5vZGUuICcgKyAnSW5zdGVhZCwgY2FsbCBSZWFjdERPTS5yZW5kZXIgYWdhaW4gYXQgdGhlIHRvcCBsZXZlbC4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoIWNvbXBvbmVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVSZXBsYWNlUHJvcHNJbnRlcm5hbChjb21wb25lbnQsIHBhcnRpYWxQcm9wcyk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUNhbGxiYWNrSW50ZXJuYWwoY29tcG9uZW50LCBjYWxsYmFjayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZnJpZW5kbHlTdHJpbmdpZnkob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIHJldHVybiAnWycgKyBvYmoubWFwKGZyaWVuZGx5U3RyaW5naWZ5KS5qb2luKCcsICcpICsgJ10nO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFpcnMgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICB2YXIga2V5RXNjYXBlZCA9IC9eW2EteiRfXVtcXHckX10qJC9pLnRlc3Qoa2V5KSA/IGtleSA6IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gICAgICAgICAgcGFpcnMucHVzaChrZXlFc2NhcGVkICsgJzogJyArIGZyaWVuZGx5U3RyaW5naWZ5KG9ialtrZXldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAneycgKyBwYWlycy5qb2luKCcsICcpICsgJ30nO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gJ1tmdW5jdGlvbiBvYmplY3RdJztcbiAgfVxuICAvLyBEaWZmZXJzIGZyb20gSlNPTi5zdHJpbmdpZnkgaW4gdGhhdCB1bmRlZmluZWQgYmVjYXVzZXMgdW5kZWZpbmVkIGFuZCB0aGF0XG4gIC8vIGluZiBhbmQgbmFuIGRvbid0IGJlY29tZSBudWxsXG4gIHJldHVybiBTdHJpbmcob2JqKTtcbn1cblxudmFyIHN0eWxlTXV0YXRpb25XYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGNoZWNrQW5kV2FybkZvck11dGF0ZWRTdHlsZShzdHlsZTEsIHN0eWxlMiwgY29tcG9uZW50KSB7XG4gIGlmIChzdHlsZTEgPT0gbnVsbCB8fCBzdHlsZTIgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc2hhbGxvd0VxdWFsKHN0eWxlMSwgc3R5bGUyKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50Ll90YWc7XG4gIHZhciBvd25lciA9IGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICB2YXIgb3duZXJOYW1lO1xuICBpZiAob3duZXIpIHtcbiAgICBvd25lck5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gIH1cblxuICB2YXIgaGFzaCA9IG93bmVyTmFtZSArICd8JyArIGNvbXBvbmVudE5hbWU7XG5cbiAgaWYgKHN0eWxlTXV0YXRpb25XYXJuaW5nLmhhc093blByb3BlcnR5KGhhc2gpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3R5bGVNdXRhdGlvbldhcm5pbmdbaGFzaF0gPSB0cnVlO1xuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYCVzYCB3YXMgcGFzc2VkIGEgc3R5bGUgb2JqZWN0IHRoYXQgaGFzIHByZXZpb3VzbHkgYmVlbiBtdXRhdGVkLiAnICsgJ011dGF0aW5nIGBzdHlsZWAgaXMgZGVwcmVjYXRlZC4gQ29uc2lkZXIgY2xvbmluZyBpdCBiZWZvcmVoYW5kLiBDaGVjayAnICsgJ3RoZSBgcmVuZGVyYCAlcy4gUHJldmlvdXMgc3R5bGU6ICVzLiBNdXRhdGVkIHN0eWxlOiAlcy4nLCBjb21wb25lbnROYW1lLCBvd25lciA/ICdvZiBgJyArIG93bmVyTmFtZSArICdgJyA6ICd1c2luZyA8JyArIGNvbXBvbmVudE5hbWUgKyAnPicsIGZyaWVuZGx5U3RyaW5naWZ5KHN0eWxlMSksIGZyaWVuZGx5U3RyaW5naWZ5KHN0eWxlMikpIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gcHJvcHNcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyhjb21wb25lbnQsIHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gTm90ZSB0aGUgdXNlIG9mIGA9PWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAodm9pZEVsZW1lbnRUYWdzW2NvbXBvbmVudC5fdGFnXSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsLCAnJXMgaXMgYSB2b2lkIGVsZW1lbnQgdGFnIGFuZCBtdXN0IG5vdCBoYXZlIGBjaGlsZHJlbmAgb3IgJyArICd1c2UgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4lcycsIGNvbXBvbmVudC5fdGFnLCBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lciA/ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJyArIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyLmdldE5hbWUoKSArICcuJyA6ICcnKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgaWYgKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAhKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgSFRNTCBpbiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gJyArICdQbGVhc2UgdmlzaXQgaHR0cHM6Ly9mYi5tZS9yZWFjdC1pbnZhcmlhbnQtZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgJyArICdmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5pbm5lckhUTUwgPT0gbnVsbCwgJ0RpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IHVuZGVmaW5lZDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghcHJvcHMuY29udGVudEVkaXRhYmxlIHx8IHByb3BzLmNoaWxkcmVuID09IG51bGwsICdBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5ICcgKyAnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJyArICd0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgJyArICdwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuJykgOiB1bmRlZmluZWQ7XG4gIH1cbiAgIShwcm9wcy5zdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wcy5zdHlsZSA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgJyArICdub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgXFwnZW1cXCd9fSB3aGVuICcgKyAndXNpbmcgSlNYLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZVB1dExpc3RlbmVyKGlkLCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lciwgdHJhbnNhY3Rpb24pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBJRTggaGFzIG5vIEFQSSBmb3IgZXZlbnQgY2FwdHVyaW5nIGFuZCB0aGUgYG9uU2Nyb2xsYCBldmVudCBkb2Vzbid0XG4gICAgLy8gYnViYmxlLlxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHJlZ2lzdHJhdGlvbk5hbWUgIT09ICdvblNjcm9sbCcgfHwgaXNFdmVudFN1cHBvcnRlZCgnc2Nyb2xsJywgdHJ1ZSksICdUaGlzIGJyb3dzZXIgZG9lc25cXCd0IHN1cHBvcnQgdGhlIGBvblNjcm9sbGAgZXZlbnQnKSA6IHVuZGVmaW5lZDtcbiAgfVxuICB2YXIgY29udGFpbmVyID0gUmVhY3RNb3VudC5maW5kUmVhY3RDb250YWluZXJGb3JJRChpZCk7XG4gIGlmIChjb250YWluZXIpIHtcbiAgICB2YXIgZG9jID0gY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSA/IGNvbnRhaW5lci5vd25lckRvY3VtZW50IDogY29udGFpbmVyO1xuICAgIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIGRvYyk7XG4gIH1cbiAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShwdXRMaXN0ZW5lciwge1xuICAgIGlkOiBpZCxcbiAgICByZWdpc3RyYXRpb25OYW1lOiByZWdpc3RyYXRpb25OYW1lLFxuICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxuICB9KTtcbn1cblxuZnVuY3Rpb24gcHV0TGlzdGVuZXIoKSB7XG4gIHZhciBsaXN0ZW5lclRvUHV0ID0gdGhpcztcbiAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnB1dExpc3RlbmVyKGxpc3RlbmVyVG9QdXQuaWQsIGxpc3RlbmVyVG9QdXQucmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXJUb1B1dC5saXN0ZW5lcik7XG59XG5cbi8vIFRoZXJlIGFyZSBzbyBtYW55IG1lZGlhIGV2ZW50cywgaXQgbWFrZXMgc2Vuc2UgdG8ganVzdFxuLy8gbWFpbnRhaW4gYSBsaXN0IHJhdGhlciB0aGFuIGNyZWF0ZSBhIGB0cmFwQnViYmxlZEV2ZW50YCBmb3IgZWFjaFxudmFyIG1lZGlhRXZlbnRzID0ge1xuICB0b3BBYm9ydDogJ2Fib3J0JyxcbiAgdG9wQ2FuUGxheTogJ2NhbnBsYXknLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiAnbG9hZGVkbWV0YWRhdGEnLFxuICB0b3BMb2FkU3RhcnQ6ICdsb2Fkc3RhcnQnLFxuICB0b3BQYXVzZTogJ3BhdXNlJyxcbiAgdG9wUGxheTogJ3BsYXknLFxuICB0b3BQbGF5aW5nOiAncGxheWluZycsXG4gIHRvcFByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXG4gIHRvcFNlZWtlZDogJ3NlZWtlZCcsXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcbiAgdG9wU3RhbGxlZDogJ3N0YWxsZWQnLFxuICB0b3BTdXNwZW5kOiAnc3VzcGVuZCcsXG4gIHRvcFRpbWVVcGRhdGU6ICd0aW1ldXBkYXRlJyxcbiAgdG9wVm9sdW1lQ2hhbmdlOiAndm9sdW1lY2hhbmdlJyxcbiAgdG9wV2FpdGluZzogJ3dhaXRpbmcnXG59O1xuXG5mdW5jdGlvbiB0cmFwQnViYmxlZEV2ZW50c0xvY2FsKCkge1xuICB2YXIgaW5zdCA9IHRoaXM7XG4gIC8vIElmIGEgY29tcG9uZW50IHJlbmRlcnMgdG8gbnVsbCBvciBpZiBhbm90aGVyIGNvbXBvbmVudCBmYXRhbHMgYW5kIGNhdXNlc1xuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHRyZWUgdG8gYmUgY29ycnVwdGVkLCBgbm9kZWAgaGVyZSBjYW4gYmUgbnVsbC5cbiAgIWluc3QuX3Jvb3ROb2RlSUQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTXVzdCBiZSBtb3VudGVkIHRvIHRyYXAgZXZlbnRzJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZShpbnN0Ll9yb290Tm9kZUlEKTtcbiAgIW5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndHJhcEJ1YmJsZWRFdmVudCguLi4pOiBSZXF1aXJlcyBub2RlIHRvIGJlIHJlbmRlcmVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICBzd2l0Y2ggKGluc3QuX3RhZykge1xuICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wTG9hZCwgJ2xvYWQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuXG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW107XG4gICAgICAvLyBjcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAodmFyIGV2ZW50IGluIG1lZGlhRXZlbnRzKSB7XG4gICAgICAgIGlmIChtZWRpYUV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcbiAgICAgICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzLnB1c2goUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlc1tldmVudF0sIG1lZGlhRXZlbnRzW2V2ZW50XSwgbm9kZSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wRXJyb3IsICdlcnJvcicsIG5vZGUpLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcExvYWQsICdsb2FkJywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wUmVzZXQsICdyZXNldCcsIG5vZGUpLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcFN1Ym1pdCwgJ3N1Ym1pdCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50UmVhZHlJbnB1dFdyYXBwZXIoKSB7XG4gIFJlYWN0RE9NSW5wdXQubW91bnRSZWFkeVdyYXBwZXIodGhpcyk7XG59XG5cbmZ1bmN0aW9uIHBvc3RVcGRhdGVTZWxlY3RXcmFwcGVyKCkge1xuICBSZWFjdERPTVNlbGVjdC5wb3N0VXBkYXRlV3JhcHBlcih0aGlzKTtcbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSB3aGl0ZWxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsIGNhc2VkIHRhZ3MuXG5cbnZhciBvbWl0dGVkQ2xvc2VUYWdzID0ge1xuICAnYXJlYSc6IHRydWUsXG4gICdiYXNlJzogdHJ1ZSxcbiAgJ2JyJzogdHJ1ZSxcbiAgJ2NvbCc6IHRydWUsXG4gICdlbWJlZCc6IHRydWUsXG4gICdocic6IHRydWUsXG4gICdpbWcnOiB0cnVlLFxuICAnaW5wdXQnOiB0cnVlLFxuICAna2V5Z2VuJzogdHJ1ZSxcbiAgJ2xpbmsnOiB0cnVlLFxuICAnbWV0YSc6IHRydWUsXG4gICdwYXJhbSc6IHRydWUsXG4gICdzb3VyY2UnOiB0cnVlLFxuICAndHJhY2snOiB0cnVlLFxuICAnd2JyJzogdHJ1ZVxufTtcblxuLy8gTk9URTogbWVudWl0ZW0ncyBjbG9zZSB0YWcgc2hvdWxkIGJlIG9taXR0ZWQsIGJ1dCB0aGF0IGNhdXNlcyBwcm9ibGVtcy5cbnZhciBuZXdsaW5lRWF0aW5nVGFncyA9IHtcbiAgJ2xpc3RpbmcnOiB0cnVlLFxuICAncHJlJzogdHJ1ZSxcbiAgJ3RleHRhcmVhJzogdHJ1ZVxufTtcblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBjYW5ub3QgaGF2ZSBjaGlsZHJlbi4gVGhpcyBoYXMgdGhlIHNhbWUgcHVycG9zZSBhc1xuLy8gYG9taXR0ZWRDbG9zZVRhZ3NgIGV4Y2VwdCB0aGF0IGBtZW51aXRlbWAgc2hvdWxkIHN0aWxsIGhhdmUgaXRzIGNsb3NpbmcgdGFnLlxuXG52YXIgdm9pZEVsZW1lbnRUYWdzID0gYXNzaWduKHtcbiAgJ21lbnVpdGVtJzogdHJ1ZVxufSwgb21pdHRlZENsb3NlVGFncyk7XG5cbi8vIFdlIGFjY2VwdCBhbnkgdGFnIHRvIGJlIHJlbmRlcmVkIGJ1dCBzaW5jZSB0aGlzIGdldHMgaW5qZWN0ZWQgaW50byBhcmJpdHJhcnlcbi8vIEhUTUwsIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgaXQncyBhIHNhZmUgdGFnLlxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZVxuXG52YXIgVkFMSURfVEFHX1JFR0VYID0gL15bYS16QS1aXVthLXpBLVo6X1xcLlxcLVxcZF0qJC87IC8vIFNpbXBsaWZpZWQgc3Vic2V0XG52YXIgdmFsaWRhdGVkVGFnQ2FjaGUgPSB7fTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9ICh7fSkuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGFuZ2Vyb3VzVGFnKHRhZykge1xuICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwodmFsaWRhdGVkVGFnQ2FjaGUsIHRhZykpIHtcbiAgICAhVkFMSURfVEFHX1JFR0VYLnRlc3QodGFnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIHRhZzogJXMnLCB0YWcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB2YWxpZGF0ZWRUYWdDYWNoZVt0YWddID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ2hpbGRDb250ZXh0RGV2KGNvbnRleHQsIGluc3QpIHtcbiAgLy8gUGFzcyBkb3duIG91ciB0YWcgbmFtZSB0byBjaGlsZCBjb21wb25lbnRzIGZvciB2YWxpZGF0aW9uIHB1cnBvc2VzXG4gIGNvbnRleHQgPSBhc3NpZ24oe30sIGNvbnRleHQpO1xuICB2YXIgaW5mbyA9IGNvbnRleHRbdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXldO1xuICBjb250ZXh0W3ZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5XSA9IHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvKGluZm8sIGluc3QuX3RhZywgaW5zdCk7XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUNvbXBvbmVudCh0YWdOYW1lLCBwcm9wcykge1xuICByZXR1cm4gdGFnTmFtZS5pbmRleE9mKCctJykgPj0gMCB8fCBwcm9wcy5pcyAhPSBudWxsO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgUmVhY3QgY2xhc3MgdGhhdCBpcyBpZGVtcG90ZW50IGFuZCBjYXBhYmxlIG9mIGNvbnRhaW5pbmcgb3RoZXJcbiAqIFJlYWN0IGNvbXBvbmVudHMuIEl0IGFjY2VwdHMgZXZlbnQgbGlzdGVuZXJzIGFuZCBET00gcHJvcGVydGllcyB0aGF0IGFyZVxuICogdmFsaWQgYWNjb3JkaW5nIHRvIGBET01Qcm9wZXJ0eWAuXG4gKlxuICogIC0gRXZlbnQgbGlzdGVuZXJzOiBgb25DbGlja2AsIGBvbk1vdXNlRG93bmAsIGV0Yy5cbiAqICAtIERPTSBwcm9wZXJ0aWVzOiBgY2xhc3NOYW1lYCwgYG5hbWVgLCBgdGl0bGVgLCBldGMuXG4gKlxuICogVGhlIGBzdHlsZWAgcHJvcGVydHkgZnVuY3Rpb25zIGRpZmZlcmVudGx5IGZyb20gdGhlIERPTSBBUEkuIEl0IGFjY2VwdHMgYW5cbiAqIG9iamVjdCBtYXBwaW5nIG9mIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBSZWFjdERPTUNvbXBvbmVudFxuICogQGV4dGVuZHMgUmVhY3RNdWx0aUNoaWxkXG4gKi9cbmZ1bmN0aW9uIFJlYWN0RE9NQ29tcG9uZW50KHRhZykge1xuICB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpO1xuICB0aGlzLl90YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG51bGw7XG4gIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBudWxsO1xuICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gIHRoaXMuX3Jvb3ROb2RlSUQgPSBudWxsO1xuICB0aGlzLl93cmFwcGVyU3RhdGUgPSBudWxsO1xuICB0aGlzLl90b3BMZXZlbFdyYXBwZXIgPSBudWxsO1xuICB0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMgPSBudWxsO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHRoaXMuX3VucHJvY2Vzc2VkQ29udGV4dERldiA9IG51bGw7XG4gICAgdGhpcy5fcHJvY2Vzc2VkQ29udGV4dERldiA9IG51bGw7XG4gIH1cbn1cblxuUmVhY3RET01Db21wb25lbnQuZGlzcGxheU5hbWUgPSAnUmVhY3RET01Db21wb25lbnQnO1xuXG5SZWFjdERPTUNvbXBvbmVudC5NaXhpbiA9IHtcblxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgcm9vdCB0YWcgbWFya3VwIHRoZW4gcmVjdXJzZXMuIFRoaXMgbWV0aG9kIGhhcyBzaWRlIGVmZmVjdHMgYW5kXG4gICAqIGlzIG5vdCBpZGVtcG90ZW50LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBUaGUgcm9vdCBET00gSUQgZm9yIHRoaXMgbm9kZS5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNvbXB1dGVkIG1hcmt1cC5cbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAocm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSByb290SUQ7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdpZnJhbWUnOlxuICAgICAgY2FzZSAnaW1nJzpcbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgY2FzZSAnYXVkaW8nOlxuICAgICAgICB0aGlzLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgICAgICAgbGlzdGVuZXJzOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTUJ1dHRvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICBSZWFjdERPTUlucHV0Lm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01JbnB1dC5nZXROYXRpdmVQcm9wcyh0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgUmVhY3RET01PcHRpb24ubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgUmVhY3RET01TZWxlY3QubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTVNlbGVjdC5nZXROYXRpdmVQcm9wcyh0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIGNvbnRleHQgPSBSZWFjdERPTVNlbGVjdC5wcm9jZXNzQ2hpbGRDb250ZXh0KHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIFJlYWN0RE9NVGV4dGFyZWEubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldE5hdGl2ZVByb3BzKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgYXNzZXJ0VmFsaWRQcm9wcyh0aGlzLCBwcm9wcyk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjb250ZXh0W3ZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5XSkge1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmcodGhpcy5fdGFnLCB0aGlzLCBjb250ZXh0W3ZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRoaXMuX3VucHJvY2Vzc2VkQ29udGV4dERldiA9IGNvbnRleHQ7XG4gICAgICB0aGlzLl9wcm9jZXNzZWRDb250ZXh0RGV2ID0gcHJvY2Vzc0NoaWxkQ29udGV4dERldihjb250ZXh0LCB0aGlzKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzLl9wcm9jZXNzZWRDb250ZXh0RGV2O1xuICAgIH1cblxuICAgIHZhciBtb3VudEltYWdlO1xuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGNvbnRleHRbUmVhY3RNb3VudC5vd25lckRvY3VtZW50Q29udGV4dEtleV07XG4gICAgICB2YXIgZWwgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSk7XG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0QXR0cmlidXRlRm9ySUQoZWwsIHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgICAgLy8gUG9wdWxhdGUgbm9kZSBjYWNoZVxuICAgICAgUmVhY3RNb3VudC5nZXRJRChlbCk7XG4gICAgICB0aGlzLl91cGRhdGVET01Qcm9wZXJ0aWVzKHt9LCBwcm9wcywgdHJhbnNhY3Rpb24sIGVsKTtcbiAgICAgIHRoaXMuX2NyZWF0ZUluaXRpYWxDaGlsZHJlbih0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQsIGVsKTtcbiAgICAgIG1vdW50SW1hZ2UgPSBlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRhZ09wZW4gPSB0aGlzLl9jcmVhdGVPcGVuVGFnTWFya3VwQW5kUHV0TGlzdGVuZXJzKHRyYW5zYWN0aW9uLCBwcm9wcyk7XG4gICAgICB2YXIgdGFnQ29udGVudCA9IHRoaXMuX2NyZWF0ZUNvbnRlbnRNYXJrdXAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0KTtcbiAgICAgIGlmICghdGFnQ29udGVudCAmJiBvbWl0dGVkQ2xvc2VUYWdzW3RoaXMuX3RhZ10pIHtcbiAgICAgICAgbW91bnRJbWFnZSA9IHRhZ09wZW4gKyAnLz4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW91bnRJbWFnZSA9IHRhZ09wZW4gKyAnPicgKyB0YWdDb250ZW50ICsgJzwvJyArIHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUgKyAnPic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShtb3VudFJlYWR5SW5wdXRXcmFwcGVyLCB0aGlzKTtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vdW50SW1hZ2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgb3BlbiB0YWcgYW5kIGFsbCBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBoYXMgc2lkZSBlZmZlY3RzIGJlY2F1c2UgZXZlbnRzIGdldCByZWdpc3RlcmVkLlxuICAgKlxuICAgKiBJdGVyYXRpbmcgb3ZlciBvYmplY3QgcHJvcGVydGllcyBpcyBmYXN0ZXIgdGhhbiBpdGVyYXRpbmcgb3ZlciBhcnJheXMuXG4gICAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vb2JqLXZzLWFyci1pdGVyYXRpb25cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBvZiBvcGVuaW5nIHRhZy5cbiAgICovXG4gIF9jcmVhdGVPcGVuVGFnTWFya3VwQW5kUHV0TGlzdGVuZXJzOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzKSB7XG4gICAgdmFyIHJldCA9ICc8JyArIHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG5cbiAgICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUpIHtcbiAgICAgICAgICBlbnF1ZXVlUHV0TGlzdGVuZXIodGhpcy5fcm9vdE5vZGVJRCwgcHJvcEtleSwgcHJvcFZhbHVlLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICAgIGlmIChwcm9wVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIC8vIFNlZSBgX3VwZGF0ZURPTVByb3BlcnRpZXNgLiBzdHlsZSBibG9ja1xuICAgICAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcFZhbHVlID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBhc3NpZ24oe30sIHByb3BzLnN0eWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvcFZhbHVlID0gQ1NTUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclN0eWxlcyhwcm9wVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXJrdXAgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fdGFnICE9IG51bGwgJiYgaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBwcm9wcykpIHtcbiAgICAgICAgICBpZiAocHJvcEtleSAhPT0gQ0hJTERSRU4pIHtcbiAgICAgICAgICAgIG1hcmt1cCA9IERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGUocHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFya3VwID0gRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclByb3BlcnR5KHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmt1cCkge1xuICAgICAgICAgIHJldCArPSAnICcgKyBtYXJrdXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGb3Igc3RhdGljIHBhZ2VzLCBubyBuZWVkIHRvIHB1dCBSZWFjdCBJRCBhbmQgY2hlY2tzdW0uIFNhdmVzIGxvdHMgb2ZcbiAgICAvLyBieXRlcy5cbiAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgdmFyIG1hcmt1cEZvcklEID0gRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvcklEKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgIHJldHVybiByZXQgKyAnICcgKyBtYXJrdXBGb3JJRDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBjb250ZW50IGJldHdlZW4gdGhlIHRhZ3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7c3RyaW5nfSBDb250ZW50IG1hcmt1cC5cbiAgICovXG4gIF9jcmVhdGVDb250ZW50TWFya3VwOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIHJldCA9ICcnO1xuXG4gICAgLy8gSW50ZW50aW9uYWwgdXNlIG9mICE9IHRvIGF2b2lkIGNhdGNoaW5nIHplcm8vZmFsc2UuXG4gICAgdmFyIGlubmVySFRNTCA9IHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuICAgIGlmIChpbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICAgaWYgKGlubmVySFRNTC5fX2h0bWwgIT0gbnVsbCkge1xuICAgICAgICByZXQgPSBpbm5lckhUTUwuX19odG1sO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29udGVudFRvVXNlID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgcHJvcHMuY2hpbGRyZW5dID8gcHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgICAgdmFyIGNoaWxkcmVuVG9Vc2UgPSBjb250ZW50VG9Vc2UgIT0gbnVsbCA/IG51bGwgOiBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChjb250ZW50VG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBWYWxpZGF0ZSB0aGF0IHRleHQgaXMgYWxsb3dlZCBhcyBhIGNoaWxkIG9mIHRoaXMgbm9kZVxuICAgICAgICByZXQgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIoY29udGVudFRvVXNlKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5Ub1VzZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBtb3VudEltYWdlcyA9IHRoaXMubW91bnRDaGlsZHJlbihjaGlsZHJlblRvVXNlLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIHJldCA9IG1vdW50SW1hZ2VzLmpvaW4oJycpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV3bGluZUVhdGluZ1RhZ3NbdGhpcy5fdGFnXSAmJiByZXQuY2hhckF0KDApID09PSAnXFxuJykge1xuICAgICAgLy8gdGV4dC9odG1sIGlnbm9yZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGVzZSB0YWdzIGlmIGl0J3MgYSBuZXdsaW5lXG4gICAgICAvLyBQcmVmZXIgdG8gYnJlYWsgYXBwbGljYXRpb24veG1sIG92ZXIgdGV4dC9odG1sIChmb3Igbm93KSBieSBhZGRpbmdcbiAgICAgIC8vIGEgbmV3bGluZSBzcGVjaWZpY2FsbHkgdG8gZ2V0IGVhdGVuIGJ5IHRoZSBwYXJzZXIuIChBbHRlcm5hdGVseSBmb3JcbiAgICAgIC8vIHRleHRhcmVhcywgcmVwbGFjaW5nIFwiXlxcblwiIHdpdGggXCJcXHJcXG5cIiBkb2Vzbid0IGdldCBlYXRlbiwgYW5kIHRoZSBmaXJzdFxuICAgICAgLy8gXFxyIGlzIG5vcm1hbGl6ZWQgb3V0IGJ5IEhUTUxUZXh0QXJlYUVsZW1lbnQjdmFsdWUuKVxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbC1wb2x5Z2xvdC8jbmV3bGluZXMtaW4tdGV4dGFyZWEtYW5kLXByZT5cbiAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI2VsZW1lbnQtcmVzdHJpY3Rpb25zPlxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjbmV3bGluZXM+XG4gICAgICAvLyBTZWU6IFBhcnNpbmcgb2YgXCJ0ZXh0YXJlYVwiIFwibGlzdGluZ1wiIGFuZCBcInByZVwiIGVsZW1lbnRzXG4gICAgICAvLyAgZnJvbSA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keT5cbiAgICAgIHJldHVybiAnXFxuJyArIHJldDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sXG5cbiAgX2NyZWF0ZUluaXRpYWxDaGlsZHJlbjogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCwgZWwpIHtcbiAgICAvLyBJbnRlbnRpb25hbCB1c2Ugb2YgIT0gdG8gYXZvaWQgY2F0Y2hpbmcgemVyby9mYWxzZS5cbiAgICB2YXIgaW5uZXJIVE1MID0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG4gICAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgICBpZiAoaW5uZXJIVE1MLl9faHRtbCAhPSBudWxsKSB7XG4gICAgICAgIHNldElubmVySFRNTChlbCwgaW5uZXJIVE1MLl9faHRtbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250ZW50VG9Vc2UgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBwcm9wcy5jaGlsZHJlbl0gPyBwcm9wcy5jaGlsZHJlbiA6IG51bGw7XG4gICAgICB2YXIgY2hpbGRyZW5Ub1VzZSA9IGNvbnRlbnRUb1VzZSAhPSBudWxsID8gbnVsbCA6IHByb3BzLmNoaWxkcmVuO1xuICAgICAgaWYgKGNvbnRlbnRUb1VzZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFZhbGlkYXRlIHRoYXQgdGV4dCBpcyBhbGxvd2VkIGFzIGEgY2hpbGQgb2YgdGhpcyBub2RlXG4gICAgICAgIHNldFRleHRDb250ZW50KGVsLCBjb250ZW50VG9Vc2UpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZHJlblRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG1vdW50SW1hZ2VzID0gdGhpcy5tb3VudENoaWxkcmVuKGNoaWxkcmVuVG9Vc2UsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb3VudEltYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGVsLmFwcGVuZENoaWxkKG1vdW50SW1hZ2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjZWl2ZXMgYSBuZXh0IGVsZW1lbnQgYW5kIHVwZGF0ZXMgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICovXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudDtcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCBwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIGNvbnRleHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgbmF0aXZlIERPTSBjb21wb25lbnQgYWZ0ZXIgaXQgaGFzIGFscmVhZHkgYmVlbiBhbGxvY2F0ZWQgYW5kXG4gICAqIGF0dGFjaGVkIHRvIHRoZSBET00uIFJlY29uY2lsZXMgdGhlIHJvb3QgRE9NIG5vZGUsIHRoZW4gcmVjdXJzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IHByZXZFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBjb250ZXh0KSB7XG4gICAgdmFyIGxhc3RQcm9wcyA9IHByZXZFbGVtZW50LnByb3BzO1xuICAgIHZhciBuZXh0UHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTUJ1dHRvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTUJ1dHRvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgUmVhY3RET01JbnB1dC51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTUlucHV0LmdldE5hdGl2ZVByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NSW5wdXQuZ2V0TmF0aXZlUHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldE5hdGl2ZVByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldE5hdGl2ZVByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBSZWFjdERPTVRleHRhcmVhLnVwZGF0ZVdyYXBwZXIodGhpcyk7XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NVGV4dGFyZWEuZ2V0TmF0aXZlUHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01UZXh0YXJlYS5nZXROYXRpdmVQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gSWYgdGhlIGNvbnRleHQgaXMgcmVmZXJlbmNlLWVxdWFsIHRvIHRoZSBvbGQgb25lLCBwYXNzIGRvd24gdGhlIHNhbWVcbiAgICAgIC8vIHByb2Nlc3NlZCBvYmplY3Qgc28gdGhlIHVwZGF0ZSBiYWlsb3V0IGluIFJlYWN0UmVjb25jaWxlciBiZWhhdmVzXG4gICAgICAvLyBjb3JyZWN0bHkgKGFuZCBpZGVudGljYWxseSBpbiBkZXYgYW5kIHByb2QpLiBTZWUgIzUwMDUuXG4gICAgICBpZiAodGhpcy5fdW5wcm9jZXNzZWRDb250ZXh0RGV2ICE9PSBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX3VucHJvY2Vzc2VkQ29udGV4dERldiA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NlZENvbnRleHREZXYgPSBwcm9jZXNzQ2hpbGRDb250ZXh0RGV2KGNvbnRleHQsIHRoaXMpO1xuICAgICAgfVxuICAgICAgY29udGV4dCA9IHRoaXMuX3Byb2Nlc3NlZENvbnRleHREZXY7XG4gICAgfVxuXG4gICAgYXNzZXJ0VmFsaWRQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgIHRoaXMuX3VwZGF0ZURPTVByb3BlcnRpZXMobGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uLCBudWxsKTtcbiAgICB0aGlzLl91cGRhdGVET01DaGlsZHJlbihsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuXG4gICAgaWYgKCFjYW5EZWZpbmVQcm9wZXJ0eSAmJiB0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMuX25vZGVXaXRoTGVnYWN5UHJvcGVydGllcy5wcm9wcyA9IG5leHRQcm9wcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgLy8gPHNlbGVjdD4gdmFsdWUgdXBkYXRlIG5lZWRzIHRvIG9jY3VyIGFmdGVyIDxvcHRpb24+IGNoaWxkcmVuXG4gICAgICAvLyByZWNvbmNpbGlhdGlvblxuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShwb3N0VXBkYXRlU2VsZWN0V3JhcHBlciwgdGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNvbmNpbGVzIHRoZSBwcm9wZXJ0aWVzIGJ5IGRldGVjdGluZyBkaWZmZXJlbmNlcyBpbiBwcm9wZXJ0eSB2YWx1ZXMgYW5kXG4gICAqIHVwZGF0aW5nIHRoZSBET00gYXMgbmVjZXNzYXJ5LiBUaGlzIGZ1bmN0aW9uIGlzIHByb2JhYmx5IHRoZSBzaW5nbGUgbW9zdFxuICAgKiBjcml0aWNhbCBwYXRoIGZvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXG4gICAqXG4gICAqIFRPRE86IEJlbmNobWFyayB3aGV0aGVyIGNoZWNraW5nIGZvciBjaGFuZ2VkIHZhbHVlcyBpbiBtZW1vcnkgYWN0dWFsbHlcbiAgICogICAgICAgaW1wcm92ZXMgcGVyZm9ybWFuY2UgKGVzcGVjaWFsbHkgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnRzKS5cbiAgICogVE9ETzogQmVuY2htYXJrIHRoZSBlZmZlY3RzIG9mIHB1dHRpbmcgdGhpcyBhdCB0aGUgdG9wIHNpbmNlIDk5JSBvZiBwcm9wc1xuICAgKiAgICAgICBkbyBub3QgY2hhbmdlIGZvciBhIGdpdmVuIHJlY29uY2lsaWF0aW9uLlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgYXJlYXMgdGhhdCBjYW4gYmUgaW1wcm92ZWQgd2l0aCBjYWNoaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gbGFzdFByb3BzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlXG4gICAqL1xuICBfdXBkYXRlRE9NUHJvcGVydGllczogZnVuY3Rpb24gKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbiwgbm9kZSkge1xuICAgIHZhciBwcm9wS2V5O1xuICAgIHZhciBzdHlsZU5hbWU7XG4gICAgdmFyIHN0eWxlVXBkYXRlcztcbiAgICBmb3IgKHByb3BLZXkgaW4gbGFzdFByb3BzKSB7XG4gICAgICBpZiAobmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8ICFsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgdmFyIGxhc3RTdHlsZSA9IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5O1xuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0U3R5bGUpIHtcbiAgICAgICAgICBpZiAobGFzdFN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKGxhc3RQcm9wc1twcm9wS2V5XSkge1xuICAgICAgICAgIC8vIE9ubHkgY2FsbCBkZWxldGVMaXN0ZW5lciBpZiB0aGVyZSB3YXMgYSBsaXN0ZW5lciBwcmV2aW91c2x5IG9yXG4gICAgICAgICAgLy8gZWxzZSB3aWxsRGVsZXRlTGlzdGVuZXIgZ2V0cyBjYWxsZWQgd2hlbiB0aGVyZSB3YXNuJ3QgYWN0dWFsbHkgYVxuICAgICAgICAgIC8vIGxpc3RlbmVyIChlLmcuLCBvbkNsaWNrPXtudWxsfSlcbiAgICAgICAgICBkZWxldGVMaXN0ZW5lcih0aGlzLl9yb290Tm9kZUlELCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BLZXldIHx8IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKHByb3BLZXkpKSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgICAgIH1cbiAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAocHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICAgIHZhciBsYXN0UHJvcCA9IHByb3BLZXkgPT09IFNUWUxFID8gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgOiBsYXN0UHJvcHNbcHJvcEtleV07XG4gICAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBuZXh0UHJvcCA9PT0gbGFzdFByb3ApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGNoZWNrQW5kV2FybkZvck11dGF0ZWRTdHlsZSh0aGlzLl9wcmV2aW91c1N0eWxlQ29weSwgdGhpcy5fcHJldmlvdXNTdHlsZSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlID0gbmV4dFByb3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHRQcm9wID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBhc3NpZ24oe30sIG5leHRQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgICAgLy8gVW5zZXQgc3R5bGVzIG9uIGBsYXN0UHJvcGAgYnV0IG5vdCBvbiBgbmV4dFByb3BgLlxuICAgICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RQcm9wKSB7XG4gICAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFVwZGF0ZSBzdHlsZXMgdGhhdCBjaGFuZ2VkIHNpbmNlIGBsYXN0UHJvcGAuXG4gICAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbmV4dFByb3ApIHtcbiAgICAgICAgICAgIGlmIChuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmIGxhc3RQcm9wW3N0eWxlTmFtZV0gIT09IG5leHRQcm9wW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9IG5leHRQcm9wW3N0eWxlTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IG5leHRQcm9wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIGVucXVldWVQdXRMaXN0ZW5lcih0aGlzLl9yb290Tm9kZUlELCBwcm9wS2V5LCBuZXh0UHJvcCwgdHJhbnNhY3Rpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgICAgZGVsZXRlTGlzdGVuZXIodGhpcy5fcm9vdE5vZGVJRCwgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBuZXh0UHJvcHMpKSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICAgICAgbmV4dFByb3AgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcEtleV0gfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSdyZSB1cGRhdGluZyB0byBudWxsIG9yIHVuZGVmaW5lZCwgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAgICAgICAgLy8gZnJvbSB0aGUgRE9NIG5vZGUgaW5zdGVhZCBvZiBpbmFkdmVydGFudGx5IHNldHRpbmcgdG8gYSBzdHJpbmcuIFRoaXNcbiAgICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3R5bGVVcGRhdGVzKSB7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICAgIH1cbiAgICAgIENTU1Byb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclN0eWxlcyhub2RlLCBzdHlsZVVwZGF0ZXMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjb25jaWxlcyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgdmFyaW91cyBwcm9wZXJ0aWVzIHRoYXQgYWZmZWN0IHRoZVxuICAgKiBjaGlsZHJlbiBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbGFzdFByb3BzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKi9cbiAgX3VwZGF0ZURPTUNoaWxkcmVuOiBmdW5jdGlvbiAobGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIGxhc3RDb250ZW50ID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgbGFzdFByb3BzLmNoaWxkcmVuXSA/IGxhc3RQcm9wcy5jaGlsZHJlbiA6IG51bGw7XG4gICAgdmFyIG5leHRDb250ZW50ID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgbmV4dFByb3BzLmNoaWxkcmVuXSA/IG5leHRQcm9wcy5jaGlsZHJlbiA6IG51bGw7XG5cbiAgICB2YXIgbGFzdEh0bWwgPSBsYXN0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgJiYgbGFzdFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbDtcbiAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgJiYgbmV4dFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbDtcblxuICAgIC8vIE5vdGUgdGhlIHVzZSBvZiBgIT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG4gICAgdmFyIGxhc3RDaGlsZHJlbiA9IGxhc3RDb250ZW50ICE9IG51bGwgPyBudWxsIDogbGFzdFByb3BzLmNoaWxkcmVuO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0Q29udGVudCAhPSBudWxsID8gbnVsbCA6IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGNoaWxkcmVuIHRvIGNvbnRlbnQvaHRtbCBvciB2aWNlIHZlcnNhLCByZW1vdmVcbiAgICAvLyB0aGUgb2xkIGNvbnRlbnRcbiAgICB2YXIgbGFzdEhhc0NvbnRlbnRPckh0bWwgPSBsYXN0Q29udGVudCAhPSBudWxsIHx8IGxhc3RIdG1sICE9IG51bGw7XG4gICAgdmFyIG5leHRIYXNDb250ZW50T3JIdG1sID0gbmV4dENvbnRlbnQgIT0gbnVsbCB8fCBuZXh0SHRtbCAhPSBudWxsO1xuICAgIGlmIChsYXN0Q2hpbGRyZW4gIT0gbnVsbCAmJiBuZXh0Q2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbihudWxsLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChsYXN0SGFzQ29udGVudE9ySHRtbCAmJiAhbmV4dEhhc0NvbnRlbnRPckh0bWwpIHtcbiAgICAgIHRoaXMudXBkYXRlVGV4dENvbnRlbnQoJycpO1xuICAgIH1cblxuICAgIGlmIChuZXh0Q29udGVudCAhPSBudWxsKSB7XG4gICAgICBpZiAobGFzdENvbnRlbnQgIT09IG5leHRDb250ZW50KSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGV4dENvbnRlbnQoJycgKyBuZXh0Q29udGVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICBpZiAobGFzdEh0bWwgIT09IG5leHRIdG1sKSB7XG4gICAgICAgIHRoaXMudXBkYXRlTWFya3VwKCcnICsgbmV4dEh0bWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4obmV4dENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyBhbGwgZXZlbnQgcmVnaXN0cmF0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZS4gRG9lcyBub3QgcmVtb3ZlIGZyb21cbiAgICogdGhlIERPTS4gVGhhdCBtdXN0IGJlIGRvbmUgYnkgdGhlIHBhcmVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgICBjYXNlICdpbWcnOlxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICBjYXNlICd2aWRlbyc6XG4gICAgICBjYXNlICdhdWRpbyc6XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl93cmFwcGVyU3RhdGUubGlzdGVuZXJzO1xuICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIFJlYWN0RE9NSW5wdXQudW5tb3VudFdyYXBwZXIodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcG9uZW50cyBsaWtlIDxodG1sPiA8aGVhZD4gYW5kIDxib2R5PiBjYW4ndCBiZSByZW1vdmVkIG9yIGFkZGVkXG4gICAgICAgICAqIGVhc2lseSBpbiBhIGNyb3NzLWJyb3dzZXIgd2F5LCBob3dldmVyIGl0J3MgdmFsdWFibGUgdG8gYmUgYWJsZSB0b1xuICAgICAgICAgKiB0YWtlIGFkdmFudGFnZSBvZiBSZWFjdCdzIHJlY29uY2lsaWF0aW9uIGZvciBzdHlsaW5nIGFuZCA8dGl0bGU+XG4gICAgICAgICAqIG1hbmFnZW1lbnQuIFNvIHdlIGp1c3QgZG9jdW1lbnQgaXQgYW5kIHRocm93IGluIGRhbmdlcm91cyBjYXNlcy5cbiAgICAgICAgICovXG4gICAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICc8JXM+IHRyaWVkIHRvIHVubW91bnQuIEJlY2F1c2Ugb2YgY3Jvc3MtYnJvd3NlciBxdWlya3MgaXQgaXMgJyArICdpbXBvc3NpYmxlIHRvIHVubW91bnQgc29tZSB0b3AtbGV2ZWwgY29tcG9uZW50cyAoZWcgPGh0bWw+LCAnICsgJzxoZWFkPiwgYW5kIDxib2R5PikgcmVsaWFibHkgYW5kIGVmZmljaWVudGx5LiBUbyBmaXggdGhpcywgaGF2ZSBhICcgKyAnc2luZ2xlIHRvcC1sZXZlbCBjb21wb25lbnQgdGhhdCBuZXZlciB1bm1vdW50cyByZW5kZXIgdGhlc2UgJyArICdlbGVtZW50cy4nLCB0aGlzLl90YWcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy51bm1vdW50Q2hpbGRyZW4oKTtcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuZGVsZXRlQWxsTGlzdGVuZXJzKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LnVubW91bnRJREZyb21FbnZpcm9ubWVudCh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gbnVsbDtcbiAgICB0aGlzLl93cmFwcGVyU3RhdGUgPSBudWxsO1xuICAgIGlmICh0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5fbm9kZVdpdGhMZWdhY3lQcm9wZXJ0aWVzO1xuICAgICAgbm9kZS5fcmVhY3RJbnRlcm5hbENvbXBvbmVudCA9IG51bGw7XG4gICAgICB0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICBnZXRQdWJsaWNJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fbm9kZVdpdGhMZWdhY3lQcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKTtcblxuICAgICAgbm9kZS5fcmVhY3RJbnRlcm5hbENvbXBvbmVudCA9IHRoaXM7XG4gICAgICBub2RlLmdldERPTU5vZGUgPSBsZWdhY3lHZXRET01Ob2RlO1xuICAgICAgbm9kZS5pc01vdW50ZWQgPSBsZWdhY3lJc01vdW50ZWQ7XG4gICAgICBub2RlLnNldFN0YXRlID0gbGVnYWN5U2V0U3RhdGVFdGM7XG4gICAgICBub2RlLnJlcGxhY2VTdGF0ZSA9IGxlZ2FjeVNldFN0YXRlRXRjO1xuICAgICAgbm9kZS5mb3JjZVVwZGF0ZSA9IGxlZ2FjeVNldFN0YXRlRXRjO1xuICAgICAgbm9kZS5zZXRQcm9wcyA9IGxlZ2FjeVNldFByb3BzO1xuICAgICAgbm9kZS5yZXBsYWNlUHJvcHMgPSBsZWdhY3lSZXBsYWNlUHJvcHM7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG5vZGUsIGxlZ2FjeVByb3BzRGVzY3JpcHRvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXBkYXRlQ29tcG9uZW50IHdpbGwgdXBkYXRlIHRoaXMgcHJvcGVydHkgb24gc3Vic2VxdWVudCByZW5kZXJzXG4gICAgICAgICAgbm9kZS5wcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1cGRhdGVDb21wb25lbnQgd2lsbCB1cGRhdGUgdGhpcyBwcm9wZXJ0eSBvbiBzdWJzZXF1ZW50IHJlbmRlcnNcbiAgICAgICAgbm9kZS5wcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMgPSBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbm9kZVdpdGhMZWdhY3lQcm9wZXJ0aWVzO1xuICB9XG5cbn07XG5cblJlYWN0UGVyZi5tZWFzdXJlTWV0aG9kcyhSZWFjdERPTUNvbXBvbmVudCwgJ1JlYWN0RE9NQ29tcG9uZW50Jywge1xuICBtb3VudENvbXBvbmVudDogJ21vdW50Q29tcG9uZW50JyxcbiAgdXBkYXRlQ29tcG9uZW50OiAndXBkYXRlQ29tcG9uZW50J1xufSk7XG5cbmFzc2lnbihSZWFjdERPTUNvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0RE9NQ29tcG9uZW50Lk1peGluLCBSZWFjdE11bHRpQ2hpbGQuTWl4aW4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29tcG9uZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01Db21wb25lbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQXV0b0ZvY3VzVXRpbHNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xuXG52YXIgZmluZERPTU5vZGUgPSByZXF1aXJlKCcuL2ZpbmRET01Ob2RlJyk7XG52YXIgZm9jdXNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvZm9jdXNOb2RlJyk7XG5cbnZhciBNaXhpbiA9IHtcbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5hdXRvRm9jdXMpIHtcbiAgICAgIGZvY3VzTm9kZShmaW5kRE9NTm9kZSh0aGlzKSk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgQXV0b0ZvY3VzVXRpbHMgPSB7XG4gIE1peGluOiBNaXhpbixcblxuICBmb2N1c0RPTUNvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIGZvY3VzTm9kZShSZWFjdE1vdW50LmdldE5vZGUodGhpcy5fcm9vdE5vZGVJRCkpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF1dG9Gb2N1c1V0aWxzO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvQXV0b0ZvY3VzVXRpbHMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZm9jdXNOb2RlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSBpbnB1dC90ZXh0YXJlYSB0byBmb2N1c1xuICovXG5mdW5jdGlvbiBmb2N1c05vZGUobm9kZSkge1xuICAvLyBJRTggY2FuIHRocm93IFwiQ2FuJ3QgbW92ZSBmb2N1cyB0byB0aGUgY29udHJvbCBiZWNhdXNlIGl0IGlzIGludmlzaWJsZSxcbiAgLy8gbm90IGVuYWJsZWQsIG9yIG9mIGEgdHlwZSB0aGF0IGRvZXMgbm90IGFjY2VwdCB0aGUgZm9jdXMuXCIgZm9yIGFsbCBraW5kcyBvZlxuICAvLyByZWFzb25zIHRoYXQgYXJlIHRvbyBleHBlbnNpdmUgYW5kIGZyYWdpbGUgdG8gdGVzdC5cbiAgdHJ5IHtcbiAgICBub2RlLmZvY3VzKCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9jdXNOb2RlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9mb2N1c05vZGUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ1NTUHJvcGVydHlPcGVyYXRpb25zXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENTU1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eScpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xuXG52YXIgY2FtZWxpemVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZScpO1xudmFyIGRhbmdlcm91c1N0eWxlVmFsdWUgPSByZXF1aXJlKCcuL2Rhbmdlcm91c1N0eWxlVmFsdWUnKTtcbnZhciBoeXBoZW5hdGVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUnKTtcbnZhciBtZW1vaXplU3RyaW5nT25seSA9IHJlcXVpcmUoJ2ZianMvbGliL21lbW9pemVTdHJpbmdPbmx5Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIHByb2Nlc3NTdHlsZU5hbWUgPSBtZW1vaXplU3RyaW5nT25seShmdW5jdGlvbiAoc3R5bGVOYW1lKSB7XG4gIHJldHVybiBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKTtcbn0pO1xuXG52YXIgaGFzU2hvcnRoYW5kUHJvcGVydHlCdWcgPSBmYWxzZTtcbnZhciBzdHlsZUZsb2F0QWNjZXNzb3IgPSAnY3NzRmxvYXQnO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICB2YXIgdGVtcFN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHRyeSB7XG4gICAgLy8gSUU4IHRocm93cyBcIkludmFsaWQgYXJndW1lbnQuXCIgaWYgcmVzZXR0aW5nIHNob3J0aGFuZCBzdHlsZSBwcm9wZXJ0aWVzLlxuICAgIHRlbXBTdHlsZS5mb250ID0gJyc7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyA9IHRydWU7XG4gIH1cbiAgLy8gSUU4IG9ubHkgc3VwcG9ydHMgYWNjZXNzaW5nIGNzc0Zsb2F0IChzdGFuZGFyZCkgYXMgc3R5bGVGbG9hdFxuICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLmNzc0Zsb2F0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdHlsZUZsb2F0QWNjZXNzb3IgPSAnc3R5bGVGbG9hdCc7XG4gIH1cbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gJ21zVHJhbnNmb3JtJyBpcyBjb3JyZWN0LCBidXQgdGhlIG90aGVyIHByZWZpeGVzIHNob3VsZCBiZSBjYXBpdGFsaXplZFxuICB2YXIgYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuID0gL14oPzp3ZWJraXR8bW96fG8pW0EtWl0vO1xuXG4gIC8vIHN0eWxlIHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvblxuICB2YXIgYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuID0gLztcXHMqJC87XG5cbiAgdmFyIHdhcm5lZFN0eWxlTmFtZXMgPSB7fTtcbiAgdmFyIHdhcm5lZFN0eWxlVmFsdWVzID0ge307XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPycsIG5hbWUsIGNhbWVsaXplU3R5bGVOYW1lKG5hbWUpKSA6IHVuZGVmaW5lZDtcbiAgfTtcblxuICB2YXIgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCB2ZW5kb3ItcHJlZml4ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSkgOiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiYgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1N0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuXFwndCBjb250YWluIGEgc2VtaWNvbG9uLiAnICsgJ1RyeSBcIiVzOiAlc1wiIGluc3RlYWQuJywgbmFtZSwgdmFsdWUucmVwbGFjZShiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sICcnKSkgOiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIHZhciB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChuYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqL1xudmFyIENTU1Byb3BlcnR5T3BlcmF0aW9ucyA9IHtcblxuICAvKipcbiAgICogU2VyaWFsaXplcyBhIG1hcHBpbmcgb2Ygc3R5bGUgcHJvcGVydGllcyBmb3IgdXNlIGFzIGlubGluZSBzdHlsZXM6XG4gICAqXG4gICAqICAgPiBjcmVhdGVNYXJrdXBGb3JTdHlsZXMoe3dpZHRoOiAnMjAwcHgnLCBoZWlnaHQ6IDB9KVxuICAgKiAgIFwid2lkdGg6MjAwcHg7aGVpZ2h0OjA7XCJcbiAgICpcbiAgICogVW5kZWZpbmVkIHZhbHVlcyBhcmUgaWdub3JlZCBzbyB0aGF0IGRlY2xhcmF0aXZlIHByb2dyYW1taW5nIGlzIGVhc2llci5cbiAgICogVGhlIHJlc3VsdCBzaG91bGQgYmUgSFRNTC1lc2NhcGVkIGJlZm9yZSBpbnNlcnRpb24gaW50byB0aGUgRE9NLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gICAqIEByZXR1cm4gez9zdHJpbmd9XG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JTdHlsZXM6IGZ1bmN0aW9uIChzdHlsZXMpIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9ICcnO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgc2VyaWFsaXplZCArPSBwcm9jZXNzU3R5bGVOYW1lKHN0eWxlTmFtZSkgKyAnOic7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpICsgJzsnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZCB8fCBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBmb3IgbXVsdGlwbGUgc3R5bGVzIG9uIGEgbm9kZS4gIElmIGEgdmFsdWUgaXMgc3BlY2lmaWVkIGFzXG4gICAqICcnIChlbXB0eSBzdHJpbmcpLCB0aGUgY29ycmVzcG9uZGluZyBzdHlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVuc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0eWxlc1xuICAgKi9cbiAgc2V0VmFsdWVGb3JTdHlsZXM6IGZ1bmN0aW9uIChub2RlLCBzdHlsZXMpIHtcbiAgICB2YXIgc3R5bGUgPSBub2RlLnN0eWxlO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdKTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZVZhbHVlID0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdKTtcbiAgICAgIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcpIHtcbiAgICAgICAgc3R5bGVOYW1lID0gc3R5bGVGbG9hdEFjY2Vzc29yO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlVmFsdWUpIHtcbiAgICAgICAgc3R5bGVbc3R5bGVOYW1lXSA9IHN0eWxlVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXhwYW5zaW9uID0gaGFzU2hvcnRoYW5kUHJvcGVydHlCdWcgJiYgQ1NTUHJvcGVydHkuc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zW3N0eWxlTmFtZV07XG4gICAgICAgIGlmIChleHBhbnNpb24pIHtcbiAgICAgICAgICAvLyBTaG9ydGhhbmQgcHJvcGVydHkgdGhhdCBJRTggd29uJ3QgbGlrZSB1bnNldHRpbmcsIHNvIHVuc2V0IGVhY2hcbiAgICAgICAgICAvLyBjb21wb25lbnQgdG8gcGxhY2F0ZSBpdFxuICAgICAgICAgIGZvciAodmFyIGluZGl2aWR1YWxTdHlsZU5hbWUgaW4gZXhwYW5zaW9uKSB7XG4gICAgICAgICAgICBzdHlsZVtpbmRpdmlkdWFsU3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHlsZVtzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxuUmVhY3RQZXJmLm1lYXN1cmVNZXRob2RzKENTU1Byb3BlcnR5T3BlcmF0aW9ucywgJ0NTU1Byb3BlcnR5T3BlcmF0aW9ucycsIHtcbiAgc2V0VmFsdWVGb3JTdHlsZXM6ICdzZXRWYWx1ZUZvclN0eWxlcydcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU1Byb3BlcnR5T3BlcmF0aW9ucztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0NTU1Byb3BlcnR5T3BlcmF0aW9ucy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDU1NQcm9wZXJ0eVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZm9udFdlaWdodDogdHJ1ZSxcbiAgbGluZUNsYW1wOiB0cnVlLFxuICBsaW5lSGVpZ2h0OiB0cnVlLFxuICBvcGFjaXR5OiB0cnVlLFxuICBvcmRlcjogdHJ1ZSxcbiAgb3JwaGFuczogdHJ1ZSxcbiAgdGFiU2l6ZTogdHJ1ZSxcbiAgd2lkb3dzOiB0cnVlLFxuICB6SW5kZXg6IHRydWUsXG4gIHpvb206IHRydWUsXG5cbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgc3RvcE9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IHRydWUsXG4gIHN0cm9rZU9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZVdpZHRoOiB0cnVlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggdmVuZG9yLXNwZWNpZmljIHByZWZpeCwgZWc6IFdlYmtpdFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBzdHlsZSBuYW1lLCBlZzogdHJhbnNpdGlvbkR1cmF0aW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHN0eWxlIG5hbWUgcHJlZml4ZWQgd2l0aCBgcHJlZml4YCwgcHJvcGVybHkgY2FtZWxDYXNlZCwgZWc6XG4gKiBXZWJraXRUcmFuc2l0aW9uRHVyYXRpb25cbiAqL1xuZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCwga2V5KSB7XG4gIHJldHVybiBwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgc3R5bGUgbmFtZXMgdGhhdCBtYXkgY29tZSBwYXNzZWQgaW4gcHJlZml4ZWQgYnkgYWRkaW5nIHBlcm11dGF0aW9uc1xuICogb2YgdmVuZG9yIHByZWZpeGVzLlxuICovXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdtcycsICdNb3onLCAnTyddO1xuXG4vLyBVc2luZyBPYmplY3Qua2V5cyBoZXJlLCBvciBlbHNlIHRoZSB2YW5pbGxhIGZvci1pbiBsb29wIG1ha2VzIElFOCBnbyBpbnRvIGFuXG4vLyBpbmZpbml0ZSBsb29wLCBiZWNhdXNlIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIG5ld2x5IGFkZGVkIHByb3BzIHRvby5cbk9iamVjdC5rZXlzKGlzVW5pdGxlc3NOdW1iZXIpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgcHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgaXNVbml0bGVzc051bWJlcltwcmVmaXhLZXkocHJlZml4LCBwcm9wKV0gPSBpc1VuaXRsZXNzTnVtYmVyW3Byb3BdO1xuICB9KTtcbn0pO1xuXG4vKipcbiAqIE1vc3Qgc3R5bGUgcHJvcGVydGllcyBjYW4gYmUgdW5zZXQgYnkgZG9pbmcgLnN0eWxlW3Byb3BdID0gJycgYnV0IElFOFxuICogZG9lc24ndCBsaWtlIGRvaW5nIHRoYXQgd2l0aCBzaG9ydGhhbmQgcHJvcGVydGllcyBzbyBmb3IgdGhlIHByb3BlcnRpZXMgdGhhdFxuICogSUU4IGJyZWFrcyBvbiwgd2hpY2ggYXJlIGxpc3RlZCBoZXJlLCB3ZSBpbnN0ZWFkIHVuc2V0IGVhY2ggb2YgdGhlXG4gKiBpbmRpdmlkdWFsIHByb3BlcnRpZXMuIFNlZSBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM4NS5cbiAqIFRoZSA0LXZhbHVlICdjbG9jaycgcHJvcGVydGllcyBsaWtlIG1hcmdpbiwgcGFkZGluZywgYm9yZGVyLXdpZHRoIHNlZW0gdG9cbiAqIGJlaGF2ZSB3aXRob3V0IGFueSBwcm9ibGVtcy4gQ3VyaW91c2x5LCBsaXN0LXN0eWxlIHdvcmtzIHRvbyB3aXRob3V0IGFueVxuICogc3BlY2lhbCBwcm9kZGluZy5cbiAqL1xudmFyIHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9ucyA9IHtcbiAgYmFja2dyb3VuZDoge1xuICAgIGJhY2tncm91bmRBdHRhY2htZW50OiB0cnVlLFxuICAgIGJhY2tncm91bmRDb2xvcjogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25ZOiB0cnVlLFxuICAgIGJhY2tncm91bmRSZXBlYXQ6IHRydWVcbiAgfSxcbiAgYmFja2dyb3VuZFBvc2l0aW9uOiB7XG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25ZOiB0cnVlXG4gIH0sXG4gIGJvcmRlcjoge1xuICAgIGJvcmRlcldpZHRoOiB0cnVlLFxuICAgIGJvcmRlclN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckNvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlckJvdHRvbToge1xuICAgIGJvcmRlckJvdHRvbVdpZHRoOiB0cnVlLFxuICAgIGJvcmRlckJvdHRvbVN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckJvdHRvbUNvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlckxlZnQ6IHtcbiAgICBib3JkZXJMZWZ0V2lkdGg6IHRydWUsXG4gICAgYm9yZGVyTGVmdFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckxlZnRDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJSaWdodDoge1xuICAgIGJvcmRlclJpZ2h0V2lkdGg6IHRydWUsXG4gICAgYm9yZGVyUmlnaHRTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJSaWdodENvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlclRvcDoge1xuICAgIGJvcmRlclRvcFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlclRvcFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlclRvcENvbG9yOiB0cnVlXG4gIH0sXG4gIGZvbnQ6IHtcbiAgICBmb250U3R5bGU6IHRydWUsXG4gICAgZm9udFZhcmlhbnQ6IHRydWUsXG4gICAgZm9udFdlaWdodDogdHJ1ZSxcbiAgICBmb250U2l6ZTogdHJ1ZSxcbiAgICBsaW5lSGVpZ2h0OiB0cnVlLFxuICAgIGZvbnRGYW1pbHk6IHRydWVcbiAgfSxcbiAgb3V0bGluZToge1xuICAgIG91dGxpbmVXaWR0aDogdHJ1ZSxcbiAgICBvdXRsaW5lU3R5bGU6IHRydWUsXG4gICAgb3V0bGluZUNvbG9yOiB0cnVlXG4gIH1cbn07XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHtcbiAgaXNVbml0bGVzc051bWJlcjogaXNVbml0bGVzc051bWJlcixcbiAgc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zOiBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1NTUHJvcGVydHk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9DU1NQcm9wZXJ0eS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjYW1lbGl6ZVN0eWxlTmFtZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW1lbGl6ZSA9IHJlcXVpcmUoJy4vY2FtZWxpemUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9eLW1zLS87XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCctbW96LXRyYW5zaXRpb24nKVxuICogICA8IFwiTW96VHJhbnNpdGlvblwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tcy10cmFuc2l0aW9uJylcbiAqICAgPCBcIm1zVHJhbnNpdGlvblwiXG4gKlxuICogQXMgQW5kaSBTbWl0aCBzdWdnZXN0c1xuICogKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGxvd2VyY2FzZSBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBjYW1lbGl6ZShzdHJpbmcucmVwbGFjZShtc1BhdHRlcm4sICdtcy0nKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemVTdHlsZU5hbWU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNhbWVsaXplXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX2h5cGhlblBhdHRlcm4gPSAvLSguKS9nO1xuXG4vKipcbiAqIENhbWVsY2FzZXMgYSBoeXBoZW5hdGVkIHN0cmluZywgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF9oeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoXywgY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvY2FtZWxpemUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZGFuZ2Vyb3VzU3R5bGVWYWx1ZVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vQ1NTUHJvcGVydHknKTtcblxudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyO1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIHRoZSBwcm9wZXIgY3NzIHdyaXRhYmxlIHZhbHVlLiBUaGUgc3R5bGUgbmFtZSBgbmFtZWBcbiAqIHNob3VsZCBiZSBsb2dpY2FsIChubyBoeXBoZW5zKSwgYXMgc3BlY2lmaWVkXG4gKiBpbiBgQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcmAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ1NTIHByb3BlcnR5IG5hbWUgc3VjaCBhcyBgdG9wTWFyZ2luYC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQ1NTIHByb3BlcnR5IHZhbHVlIHN1Y2ggYXMgYDEwcHhgLlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIHN0eWxlIHZhbHVlIHdpdGggZGltZW5zaW9ucyBhcHBsaWVkLlxuICovXG5mdW5jdGlvbiBkYW5nZXJvdXNTdHlsZVZhbHVlKG5hbWUsIHZhbHVlKSB7XG4gIC8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbiAgLy8gd2hvbGUgc3RyaW5nIHdpbGwgYmUgZXNjYXBlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgaW5qZWN0ZWQgaW50b1xuICAvLyB0aGUgbWFya3VwLiBJZiB5b3UgcHJvdmlkZSB1bnNhZmUgdXNlciBkYXRhIGhlcmUgdGhleSBjYW4gaW5qZWN0XG4gIC8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAvLyBodHRwOi8vd3d3LnRoZXNwYW5uZXIuY28udWsvMjAwNy8xMS8yNi91bHRpbWF0ZS14c3MtY3NzLWluamVjdGlvbi9cbiAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgLy8gdHJ1c3QgVVJMcyBtb3ZpbmcgZm9yd2FyZC4gU2VlICMyMTE1OTAxXG5cbiAgdmFyIGlzRW1wdHkgPSB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJztcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgaXNOb25OdW1lcmljID0gaXNOYU4odmFsdWUpO1xuICBpZiAoaXNOb25OdW1lcmljIHx8IHZhbHVlID09PSAwIHx8IGlzVW5pdGxlc3NOdW1iZXIuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgaXNVbml0bGVzc051bWJlcltuYW1lXSkge1xuICAgIHJldHVybiAnJyArIHZhbHVlOyAvLyBjYXN0IHRvIHN0cmluZ1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfVxuICByZXR1cm4gdmFsdWUgKyAncHgnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRhbmdlcm91c1N0eWxlVmFsdWU7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9kYW5nZXJvdXNTdHlsZVZhbHVlLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGh5cGhlbmF0ZVN0eWxlTmFtZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoeXBoZW5hdGUgPSByZXF1aXJlKCcuL2h5cGhlbmF0ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZShzdHJpbmcpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZVN0eWxlTmFtZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGh5cGhlbmF0ZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKlxuICogRm9yIENTUyBzdHlsZSBuYW1lcywgdXNlIGBoeXBoZW5hdGVTdHlsZU5hbWVgIGluc3RlYWQgd2hpY2ggd29ya3MgcHJvcGVybHlcbiAqIHdpdGggYWxsIHZlbmRvciBwcmVmaXhlcywgaW5jbHVkaW5nIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfdXBwZXJjYXNlUGF0dGVybiwgJy0kMScpLnRvTG93ZXJDYXNlKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9oeXBoZW5hdGUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgbWVtb2l6ZVN0cmluZ09ubHlcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1lbW9pemVzIHRoZSByZXR1cm4gdmFsdWUgb2YgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgb25lIHN0cmluZyBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVTdHJpbmdPbmx5KGNhbGxiYWNrKSB7XG4gIHZhciBjYWNoZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIGlmICghY2FjaGUuaGFzT3duUHJvcGVydHkoc3RyaW5nKSkge1xuICAgICAgY2FjaGVbc3RyaW5nXSA9IGNhbGxiYWNrLmNhbGwodGhpcywgc3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlW3N0cmluZ107XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZVN0cmluZ09ubHk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL21lbW9pemVTdHJpbmdPbmx5LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NQnV0dG9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbW91c2VMaXN0ZW5lck5hbWVzID0ge1xuICBvbkNsaWNrOiB0cnVlLFxuICBvbkRvdWJsZUNsaWNrOiB0cnVlLFxuICBvbk1vdXNlRG93bjogdHJ1ZSxcbiAgb25Nb3VzZU1vdmU6IHRydWUsXG4gIG9uTW91c2VVcDogdHJ1ZSxcblxuICBvbkNsaWNrQ2FwdHVyZTogdHJ1ZSxcbiAgb25Eb3VibGVDbGlja0NhcHR1cmU6IHRydWUsXG4gIG9uTW91c2VEb3duQ2FwdHVyZTogdHJ1ZSxcbiAgb25Nb3VzZU1vdmVDYXB0dXJlOiB0cnVlLFxuICBvbk1vdXNlVXBDYXB0dXJlOiB0cnVlXG59O1xuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8YnV0dG9uPiBuYXRpdmUgY29tcG9uZW50IHRoYXQgZG9lcyBub3QgcmVjZWl2ZSBtb3VzZSBldmVudHNcbiAqIHdoZW4gYGRpc2FibGVkYCBpcyBzZXQuXG4gKi9cbnZhciBSZWFjdERPTUJ1dHRvbiA9IHtcbiAgZ2V0TmF0aXZlUHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcywgY29udGV4dCkge1xuICAgIGlmICghcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBwcm9wcztcbiAgICB9XG5cbiAgICAvLyBDb3B5IHRoZSBwcm9wcywgZXhjZXB0IHRoZSBtb3VzZSBsaXN0ZW5lcnNcbiAgICB2YXIgbmF0aXZlUHJvcHMgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICFtb3VzZUxpc3RlbmVyTmFtZXNba2V5XSkge1xuICAgICAgICBuYXRpdmVQcm9wc1trZXldID0gcHJvcHNba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmF0aXZlUHJvcHM7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01CdXR0b247XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUJ1dHRvbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUlucHV0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0RE9NSURPcGVyYXRpb25zJyk7XG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBpbnN0YW5jZXNCeVJlYWN0SUQgPSB7fTtcblxuZnVuY3Rpb24gZm9yY2VVcGRhdGVJZk1vdW50ZWQoKSB7XG4gIGlmICh0aGlzLl9yb290Tm9kZUlEKSB7XG4gICAgLy8gRE9NIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkOyB1cGRhdGVcbiAgICBSZWFjdERPTUlucHV0LnVwZGF0ZVdyYXBwZXIodGhpcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxpbnB1dD4gbmF0aXZlIGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovXG52YXIgUmVhY3RET01JbnB1dCA9IHtcbiAgZ2V0TmF0aXZlUHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcywgY29udGV4dCkge1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIHZhciBjaGVja2VkID0gTGlua2VkVmFsdWVVdGlscy5nZXRDaGVja2VkKHByb3BzKTtcblxuICAgIHZhciBuYXRpdmVQcm9wcyA9IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgIGRlZmF1bHRDaGVja2VkOiB1bmRlZmluZWQsXG4gICAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIHZhbHVlOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLFxuICAgICAgY2hlY2tlZDogY2hlY2tlZCAhPSBudWxsID8gY2hlY2tlZCA6IGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZCxcbiAgICAgIG9uQ2hhbmdlOiBpbnN0Ll93cmFwcGVyU3RhdGUub25DaGFuZ2VcbiAgICB9KTtcblxuICAgIHJldHVybiBuYXRpdmVQcm9wcztcbiAgfSxcblxuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBMaW5rZWRWYWx1ZVV0aWxzLmNoZWNrUHJvcFR5cGVzKCdpbnB1dCcsIHByb3BzLCBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXIpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgaW5pdGlhbENoZWNrZWQ6IHByb3BzLmRlZmF1bHRDaGVja2VkIHx8IGZhbHNlLFxuICAgICAgaW5pdGlhbFZhbHVlOiBkZWZhdWx0VmFsdWUgIT0gbnVsbCA/IGRlZmF1bHRWYWx1ZSA6IG51bGwsXG4gICAgICBvbkNoYW5nZTogX2hhbmRsZUNoYW5nZS5iaW5kKGluc3QpXG4gICAgfTtcbiAgfSxcblxuICBtb3VudFJlYWR5V3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICAvLyBDYW4ndCBiZSBpbiBtb3VudFdyYXBwZXIgb3IgZWxzZSBzZXJ2ZXIgcmVuZGVyaW5nIGxlYWtzLlxuICAgIGluc3RhbmNlc0J5UmVhY3RJRFtpbnN0Ll9yb290Tm9kZUlEXSA9IGluc3Q7XG4gIH0sXG5cbiAgdW5tb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgZGVsZXRlIGluc3RhbmNlc0J5UmVhY3RJRFtpbnN0Ll9yb290Tm9kZUlEXTtcbiAgfSxcblxuICB1cGRhdGVXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgLy8gVE9ETzogU2hvdWxkbid0IHRoaXMgYmUgZ2V0Q2hlY2tlZChwcm9wcyk/XG4gICAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuICAgIGlmIChjaGVja2VkICE9IG51bGwpIHtcbiAgICAgIFJlYWN0RE9NSURPcGVyYXRpb25zLnVwZGF0ZVByb3BlcnR5QnlJRChpbnN0Ll9yb290Tm9kZUlELCAnY2hlY2tlZCcsIGNoZWNrZWQgfHwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgUmVhY3RET01JRE9wZXJhdGlvbnMudXBkYXRlUHJvcGVydHlCeUlEKGluc3QuX3Jvb3ROb2RlSUQsICd2YWx1ZScsICcnICsgdmFsdWUpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShldmVudCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xuXG4gIC8vIEhlcmUgd2UgdXNlIGFzYXAgdG8gd2FpdCB1bnRpbCBhbGwgdXBkYXRlcyBoYXZlIHByb3BhZ2F0ZWQsIHdoaWNoXG4gIC8vIGlzIGltcG9ydGFudCB3aGVuIHVzaW5nIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3aXRoaW4gbGF5ZXJzOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2OThcbiAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIHRoaXMpO1xuXG4gIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgaWYgKHByb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmFtZSAhPSBudWxsKSB7XG4gICAgdmFyIHJvb3ROb2RlID0gUmVhY3RNb3VudC5nZXROb2RlKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgIHZhciBxdWVyeVJvb3QgPSByb290Tm9kZTtcblxuICAgIHdoaWxlIChxdWVyeVJvb3QucGFyZW50Tm9kZSkge1xuICAgICAgcXVlcnlSb290ID0gcXVlcnlSb290LnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgLy8gSWYgYHJvb3ROb2RlLmZvcm1gIHdhcyBub24tbnVsbCwgdGhlbiB3ZSBjb3VsZCB0cnkgYGZvcm0uZWxlbWVudHNgLFxuICAgIC8vIGJ1dCB0aGF0IHNvbWV0aW1lcyBiZWhhdmVzIHN0cmFuZ2VseSBpbiBJRTguIFdlIGNvdWxkIGFsc28gdHJ5IHVzaW5nXG4gICAgLy8gYGZvcm0uZ2V0RWxlbWVudHNCeU5hbWVgLCBidXQgdGhhdCB3aWxsIG9ubHkgcmV0dXJuIGRpcmVjdCBjaGlsZHJlblxuICAgIC8vIGFuZCB3b24ndCBpbmNsdWRlIGlucHV0cyB0aGF0IHVzZSB0aGUgSFRNTDUgYGZvcm09YCBhdHRyaWJ1dGUuIFNpbmNlXG4gICAgLy8gdGhlIGlucHV0IG1pZ2h0IG5vdCBldmVuIGJlIGluIGEgZm9ybSwgbGV0J3MganVzdCB1c2UgdGhlIGdsb2JhbFxuICAgIC8vIGBxdWVyeVNlbGVjdG9yQWxsYCB0byBlbnN1cmUgd2UgZG9uJ3QgbWlzcyBhbnl0aGluZy5cbiAgICB2YXIgZ3JvdXAgPSBxdWVyeVJvb3QucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbbmFtZT0nICsgSlNPTi5zdHJpbmdpZnkoJycgKyBuYW1lKSArICddW3R5cGU9XCJyYWRpb1wiXScpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG90aGVyTm9kZSA9IGdyb3VwW2ldO1xuICAgICAgaWYgKG90aGVyTm9kZSA9PT0gcm9vdE5vZGUgfHwgb3RoZXJOb2RlLmZvcm0gIT09IHJvb3ROb2RlLmZvcm0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgcmFkaW8gYnV0dG9ucyByZW5kZXJlZCBieSBkaWZmZXJlbnQgY29waWVzIG9mIFJlYWN0XG4gICAgICAvLyBhbmQgdGhlIHNhbWUgbmFtZSBhcmUgcmVuZGVyZWQgaW50byB0aGUgc2FtZSBmb3JtIChzYW1lIGFzICMxOTM5KS5cbiAgICAgIC8vIFRoYXQncyBwcm9iYWJseSBva2F5OyB3ZSBkb24ndCBzdXBwb3J0IGl0IGp1c3QgYXMgd2UgZG9uJ3Qgc3VwcG9ydFxuICAgICAgLy8gbWl4aW5nIFJlYWN0IHdpdGggbm9uLVJlYWN0LlxuICAgICAgdmFyIG90aGVySUQgPSBSZWFjdE1vdW50LmdldElEKG90aGVyTm9kZSk7XG4gICAgICAhb3RoZXJJRCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTUlucHV0OiBNaXhpbmcgUmVhY3QgYW5kIG5vbi1SZWFjdCByYWRpbyBpbnB1dHMgd2l0aCB0aGUgJyArICdzYW1lIGBuYW1lYCBpcyBub3Qgc3VwcG9ydGVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBvdGhlckluc3RhbmNlID0gaW5zdGFuY2VzQnlSZWFjdElEW290aGVySURdO1xuICAgICAgIW90aGVySW5zdGFuY2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET01JbnB1dDogVW5rbm93biByYWRpbyBidXR0b24gSUQgJXMuJywgb3RoZXJJRCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgcmFkaW8gYnV0dG9uIGdyb3VwLCBmb3JjaW5nIHRoZSBpbnB1dCB0aGF0XG4gICAgICAvLyB3YXMgcHJldmlvdXNseSBjaGVja2VkIHRvIHVwZGF0ZSB3aWxsIGNhdXNlIGl0IHRvIGJlIGNvbWUgcmUtY2hlY2tlZFxuICAgICAgLy8gYXMgYXBwcm9wcmlhdGUuXG4gICAgICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgb3RoZXJJbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSW5wdXQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUlucHV0LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIExpbmtlZFZhbHVlVXRpbHNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVzJyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9ucycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gICdidXR0b24nOiB0cnVlLFxuICAnY2hlY2tib3gnOiB0cnVlLFxuICAnaW1hZ2UnOiB0cnVlLFxuICAnaGlkZGVuJzogdHJ1ZSxcbiAgJ3JhZGlvJzogdHJ1ZSxcbiAgJ3Jlc2V0JzogdHJ1ZSxcbiAgJ3N1Ym1pdCc6IHRydWVcbn07XG5cbmZ1bmN0aW9uIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpIHtcbiAgIShpbnB1dFByb3BzLmNoZWNrZWRMaW5rID09IG51bGwgfHwgaW5wdXRQcm9wcy52YWx1ZUxpbmsgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSBjaGVja2VkTGluayBhbmQgYSB2YWx1ZUxpbmsuIElmIHlvdSB3YW50IHRvIHVzZSAnICsgJ2NoZWNrZWRMaW5rLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvIHVzZSB2YWx1ZUxpbmsgYW5kIHZpY2UgdmVyc2EuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gX2Fzc2VydFZhbHVlTGluayhpbnB1dFByb3BzKSB7XG4gIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpO1xuICAhKGlucHV0UHJvcHMudmFsdWUgPT0gbnVsbCAmJiBpbnB1dFByb3BzLm9uQ2hhbmdlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBwcm92aWRlIGEgdmFsdWVMaW5rIGFuZCBhIHZhbHVlIG9yIG9uQ2hhbmdlIGV2ZW50LiBJZiB5b3Ugd2FudCAnICsgJ3RvIHVzZSB2YWx1ZSBvciBvbkNoYW5nZSwgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgdmFsdWVMaW5rLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0UHJvcHMpIHtcbiAgX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXRQcm9wcyk7XG4gICEoaW5wdXRQcm9wcy5jaGVja2VkID09IG51bGwgJiYgaW5wdXRQcm9wcy5vbkNoYW5nZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcHJvdmlkZSBhIGNoZWNrZWRMaW5rIGFuZCBhIGNoZWNrZWQgcHJvcGVydHkgb3Igb25DaGFuZ2UgZXZlbnQuICcgKyAnSWYgeW91IHdhbnQgdG8gdXNlIGNoZWNrZWQgb3Igb25DaGFuZ2UsIHlvdSBwcm9iYWJseSBkb25cXCd0IHdhbnQgdG8gJyArICd1c2UgY2hlY2tlZExpbmsnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG59XG5cbnZhciBwcm9wVHlwZXMgPSB7XG4gIHZhbHVlOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gIH0sXG4gIGNoZWNrZWQ6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGBjaGVja2VkYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICB9LFxuICBvbkNoYW5nZTogUmVhY3RQcm9wVHlwZXMuZnVuY1xufTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSB7XG4gIGlmIChvd25lcikge1xuICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogUHJvdmlkZSBhIGxpbmtlZCBgdmFsdWVgIGF0dHJpYnV0ZSBmb3IgY29udHJvbGxlZCBmb3Jtcy4gWW91IHNob3VsZCBub3QgdXNlXG4gKiB0aGlzIG91dHNpZGUgb2YgdGhlIFJlYWN0RE9NIGNvbnRyb2xsZWQgZm9ybSBjb21wb25lbnRzLlxuICovXG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHtcbiAgY2hlY2tQcm9wVHlwZXM6IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wcywgb3duZXIpIHtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wVHlwZXMpIHtcbiAgICAgIGlmIChwcm9wVHlwZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHByb3BUeXBlc1twcm9wTmFtZV0ocHJvcHMsIHByb3BOYW1lLCB0YWdOYW1lLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLnByb3ApO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGFkZGVuZHVtID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgZm9ybSBwcm9wVHlwZTogJXMlcycsIGVycm9yLm1lc3NhZ2UsIGFkZGVuZHVtKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFByb3BzIFByb3BzIGZvciBmb3JtIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHsqfSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dCBlaXRoZXIgZnJvbSB2YWx1ZSBwcm9wIG9yIGxpbmsuXG4gICAqL1xuICBnZXRWYWx1ZTogZnVuY3Rpb24gKGlucHV0UHJvcHMpIHtcbiAgICBpZiAoaW5wdXRQcm9wcy52YWx1ZUxpbmspIHtcbiAgICAgIF9hc3NlcnRWYWx1ZUxpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy52YWx1ZUxpbmsudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dFByb3BzLnZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXRQcm9wcyBQcm9wcyBmb3IgZm9ybSBjb21wb25lbnRcbiAgICogQHJldHVybiB7Kn0gY3VycmVudCBjaGVja2VkIHN0YXR1cyBvZiB0aGUgaW5wdXQgZWl0aGVyIGZyb20gY2hlY2tlZCBwcm9wXG4gICAqICAgICAgICAgICAgIG9yIGxpbmsuXG4gICAqL1xuICBnZXRDaGVja2VkOiBmdW5jdGlvbiAoaW5wdXRQcm9wcykge1xuICAgIGlmIChpbnB1dFByb3BzLmNoZWNrZWRMaW5rKSB7XG4gICAgICBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy5jaGVja2VkTGluay52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0UHJvcHMuY2hlY2tlZDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XG4gICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IGNoYW5nZSBldmVudCB0byBoYW5kbGVcbiAgICovXG4gIGV4ZWN1dGVPbkNoYW5nZTogZnVuY3Rpb24gKGlucHV0UHJvcHMsIGV2ZW50KSB7XG4gICAgaWYgKGlucHV0UHJvcHMudmFsdWVMaW5rKSB7XG4gICAgICBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWVMaW5rLnJlcXVlc3RDaGFuZ2UoZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0UHJvcHMuY2hlY2tlZExpbmspIHtcbiAgICAgIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLmNoZWNrZWRMaW5rLnJlcXVlc3RDaGFuZ2UoZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRQcm9wcy5vbkNoYW5nZSkge1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMub25DaGFuZ2UuY2FsbCh1bmRlZmluZWQsIGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGlua2VkVmFsdWVVdGlscztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL0xpbmtlZFZhbHVlVXRpbHMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQcm9wVHlwZXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBnZXRJdGVyYXRvckZuID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvckZuJyk7XG5cbi8qKlxuICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gKlxuICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIHByb3BUeXBlczoge1xuICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAqXG4gKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gKlxuICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gKiAgICAgfSxcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICogICB9KTtcbiAqXG4gKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gKlxuICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAqXG4gKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gKlxuICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICBwcm9wVHlwZXM6IHtcbiAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAqICAgICAgICAgICk7XG4gKiAgICAgICAgfVxuICogICAgICB9XG4gKiAgICB9LFxuICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gKiAgfSk7XG4gKlxuICogQGludGVybmFsXG4gKi9cblxudmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxudmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuXG4gIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXJcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1JlcXVpcmVkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agd2FzIG5vdCBzcGVjaWZpZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zKG51bGwpKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nKTtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAoIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocHJvcFZhbHVlID09PSBleHBlY3RlZFZhbHVlc1tpXSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgaWYgKHByb3BWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJyk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXkpO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG5mdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgIHJldHVybiAnYXJyYXknO1xuICB9XG4gIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgcmV0dXJuICdvYmplY3QnO1xuICB9XG4gIHJldHVybiBwcm9wVHlwZTtcbn1cblxuLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG5mdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gJ2RhdGUnO1xuICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wVHlwZTtcbn1cblxuLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbmZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgcmV0dXJuICc8PGFub255bW91cz4+JztcbiAgfVxuICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlcy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRJdGVyYXRvckZuXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIFN5bWJvbCAqL1xudmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICpcbiAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICpcbiAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAqICAgICAgIC4uLlxuICogICAgIH1cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpdGVyYXRvckZuO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0SXRlcmF0b3JGbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2dldEl0ZXJhdG9yRm4uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01PcHRpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdENoaWxkcmVuID0gcmVxdWlyZSgnLi9SZWFjdENoaWxkcmVuJyk7XG52YXIgUmVhY3RET01TZWxlY3QgPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0Jyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgdmFsdWVDb250ZXh0S2V5ID0gUmVhY3RET01TZWxlY3QudmFsdWVDb250ZXh0S2V5O1xuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPG9wdGlvbj4gbmF0aXZlIGNvbXBvbmVudCB0aGF0IHdhcm5zIHdoZW4gYHNlbGVjdGVkYCBpcyBzZXQuXG4gKi9cbnZhciBSZWFjdERPTU9wdGlvbiA9IHtcbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMuc2VsZWN0ZWQgPT0gbnVsbCwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgKyAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIExvb2sgdXAgd2hldGhlciB0aGlzIG9wdGlvbiBpcyAnc2VsZWN0ZWQnIHZpYSBjb250ZXh0XG4gICAgdmFyIHNlbGVjdFZhbHVlID0gY29udGV4dFt2YWx1ZUNvbnRleHRLZXldO1xuXG4gICAgLy8gSWYgY29udGV4dCBrZXkgaXMgbnVsbCAoZS5nLiwgbm8gc3BlY2lmaWVkIHZhbHVlIG9yIGFmdGVyIGluaXRpYWwgbW91bnQpXG4gICAgLy8gb3IgbWlzc2luZyAoZS5nLiwgZm9yIDxkYXRhbGlzdD4pLCB3ZSBkb24ndCBjaGFuZ2UgcHJvcHMuc2VsZWN0ZWRcbiAgICB2YXIgc2VsZWN0ZWQgPSBudWxsO1xuICAgIGlmIChzZWxlY3RWYWx1ZSAhPSBudWxsKSB7XG4gICAgICBzZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZWN0VmFsdWUpKSB7XG4gICAgICAgIC8vIG11bHRpcGxlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0VmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoJycgKyBzZWxlY3RWYWx1ZVtpXSA9PT0gJycgKyBwcm9wcy52YWx1ZSkge1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RlZCA9ICcnICsgc2VsZWN0VmFsdWUgPT09ICcnICsgcHJvcHMudmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0geyBzZWxlY3RlZDogc2VsZWN0ZWQgfTtcbiAgfSxcblxuICBnZXROYXRpdmVQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIG5hdGl2ZVByb3BzID0gYXNzaWduKHsgc2VsZWN0ZWQ6IHVuZGVmaW5lZCwgY2hpbGRyZW46IHVuZGVmaW5lZCB9LCBwcm9wcyk7XG5cbiAgICAvLyBSZWFkIHN0YXRlIG9ubHkgZnJvbSBpbml0aWFsIG1vdW50IGJlY2F1c2UgPHNlbGVjdD4gdXBkYXRlcyB2YWx1ZVxuICAgIC8vIG1hbnVhbGx5OyB3ZSBuZWVkIHRoZSBpbml0aWFsIHN0YXRlIG9ubHkgZm9yIHNlcnZlciByZW5kZXJpbmdcbiAgICBpZiAoaW5zdC5fd3JhcHBlclN0YXRlLnNlbGVjdGVkICE9IG51bGwpIHtcbiAgICAgIG5hdGl2ZVByb3BzLnNlbGVjdGVkID0gaW5zdC5fd3JhcHBlclN0YXRlLnNlbGVjdGVkO1xuICAgIH1cblxuICAgIHZhciBjb250ZW50ID0gJyc7XG5cbiAgICAvLyBGbGF0dGVuIGNoaWxkcmVuIGFuZCB3YXJuIGlmIHRoZXkgYXJlbid0IHN0cmluZ3Mgb3IgbnVtYmVycztcbiAgICAvLyBpbnZhbGlkIHR5cGVzIGFyZSBpZ25vcmVkLlxuICAgIFJlYWN0Q2hpbGRyZW4uZm9yRWFjaChwcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gY2hpbGQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ09ubHkgc3RyaW5ncyBhbmQgbnVtYmVycyBhcmUgc3VwcG9ydGVkIGFzIDxvcHRpb24+IGNoaWxkcmVuLicpIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgIG5hdGl2ZVByb3BzLmNoaWxkcmVuID0gY29udGVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmF0aXZlUHJvcHM7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTU9wdGlvbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NT3B0aW9uLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q2hpbGRyZW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XG5cbnZhciB0d29Bcmd1bWVudFBvb2xlciA9IFBvb2xlZENsYXNzLnR3b0FyZ3VtZW50UG9vbGVyO1xudmFyIGZvdXJBcmd1bWVudFBvb2xlciA9IFBvb2xlZENsYXNzLmZvdXJBcmd1bWVudFBvb2xlcjtcblxudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLyg/IVxcLykvZztcbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiAoJycgKyB0ZXh0KS5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnLy8nKTtcbn1cblxuLyoqXG4gKiBQb29sZWRDbGFzcyByZXByZXNlbnRpbmcgdGhlIGJvb2trZWVwaW5nIGFzc29jaWF0ZWQgd2l0aCBwZXJmb3JtaW5nIGEgY2hpbGRcbiAqIHRyYXZlcnNhbC4gQWxsb3dzIGF2b2lkaW5nIGJpbmRpbmcgY2FsbGJhY2tzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBGb3JFYWNoQm9va0tlZXBpbmdcbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBmb3JFYWNoRnVuY3Rpb24gRnVuY3Rpb24gdG8gcGVyZm9ybSB0cmF2ZXJzYWwgd2l0aC5cbiAqIEBwYXJhbSB7Pyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgdG8gcGVyZm9ybSBjb250ZXh0IHdpdGguXG4gKi9cbmZ1bmN0aW9uIEZvckVhY2hCb29rS2VlcGluZyhmb3JFYWNoRnVuY3Rpb24sIGZvckVhY2hDb250ZXh0KSB7XG4gIHRoaXMuZnVuYyA9IGZvckVhY2hGdW5jdGlvbjtcbiAgdGhpcy5jb250ZXh0ID0gZm9yRWFjaENvbnRleHQ7XG4gIHRoaXMuY291bnQgPSAwO1xufVxuRm9yRWFjaEJvb2tLZWVwaW5nLnByb3RvdHlwZS5kZXN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmZ1bmMgPSBudWxsO1xuICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICB0aGlzLmNvdW50ID0gMDtcbn07XG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oRm9yRWFjaEJvb2tLZWVwaW5nLCB0d29Bcmd1bWVudFBvb2xlcik7XG5cbmZ1bmN0aW9uIGZvckVhY2hTaW5nbGVDaGlsZChib29rS2VlcGluZywgY2hpbGQsIG5hbWUpIHtcbiAgdmFyIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jO1xuICB2YXIgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cbiAgZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmNcbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBGb3JFYWNoQm9va0tlZXBpbmcuZ2V0UG9vbGVkKGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgRm9yRWFjaEJvb2tLZWVwaW5nLnJlbGVhc2UodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBQb29sZWRDbGFzcyByZXByZXNlbnRpbmcgdGhlIGJvb2trZWVwaW5nIGFzc29jaWF0ZWQgd2l0aCBwZXJmb3JtaW5nIGEgY2hpbGRcbiAqIG1hcHBpbmcuIEFsbG93cyBhdm9pZGluZyBiaW5kaW5nIGNhbGxiYWNrcy5cbiAqXG4gKiBAY29uc3RydWN0b3IgTWFwQm9va0tlZXBpbmdcbiAqIEBwYXJhbSB7ISp9IG1hcFJlc3VsdCBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBtYXBGdW5jdGlvbiBGdW5jdGlvbiB0byBwZXJmb3JtIG1hcHBpbmcgd2l0aC5cbiAqIEBwYXJhbSB7Pyp9IG1hcENvbnRleHQgQ29udGV4dCB0byBwZXJmb3JtIG1hcHBpbmcgd2l0aC5cbiAqL1xuZnVuY3Rpb24gTWFwQm9va0tlZXBpbmcobWFwUmVzdWx0LCBrZXlQcmVmaXgsIG1hcEZ1bmN0aW9uLCBtYXBDb250ZXh0KSB7XG4gIHRoaXMucmVzdWx0ID0gbWFwUmVzdWx0O1xuICB0aGlzLmtleVByZWZpeCA9IGtleVByZWZpeDtcbiAgdGhpcy5mdW5jID0gbWFwRnVuY3Rpb247XG4gIHRoaXMuY29udGV4dCA9IG1hcENvbnRleHQ7XG4gIHRoaXMuY291bnQgPSAwO1xufVxuTWFwQm9va0tlZXBpbmcucHJvdG90eXBlLmRlc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVzdWx0ID0gbnVsbDtcbiAgdGhpcy5rZXlQcmVmaXggPSBudWxsO1xuICB0aGlzLmZ1bmMgPSBudWxsO1xuICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICB0aGlzLmNvdW50ID0gMDtcbn07XG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oTWFwQm9va0tlZXBpbmcsIGZvdXJBcmd1bWVudFBvb2xlcik7XG5cbmZ1bmN0aW9uIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQoYm9va0tlZXBpbmcsIGNoaWxkLCBjaGlsZEtleSkge1xuICB2YXIgcmVzdWx0ID0gYm9va0tlZXBpbmcucmVzdWx0O1xuICB2YXIga2V5UHJlZml4ID0gYm9va0tlZXBpbmcua2V5UHJlZml4O1xuICB2YXIgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmM7XG4gIHZhciBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuICB2YXIgbWFwcGVkQ2hpbGQgPSBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xuICBpZiAoQXJyYXkuaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcbiAgICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKG1hcHBlZENoaWxkLCByZXN1bHQsIGNoaWxkS2V5LCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgbWFwcGVkQ2hpbGQgPSBSZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLFxuICAgICAgLy8gS2VlcCBib3RoIHRoZSAobWFwcGVkKSBhbmQgb2xkIGtleXMgaWYgdGhleSBkaWZmZXIsIGp1c3QgYXNcbiAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAga2V5UHJlZml4ICsgKG1hcHBlZENoaWxkICE9PSBjaGlsZCA/IGVzY2FwZVVzZXJQcm92aWRlZEtleShtYXBwZWRDaGlsZC5rZXkgfHwgJycpICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaChtYXBwZWRDaGlsZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgYXJyYXksIHByZWZpeCwgZnVuYywgY29udGV4dCkge1xuICB2YXIgZXNjYXBlZFByZWZpeCA9ICcnO1xuICBpZiAocHJlZml4ICE9IG51bGwpIHtcbiAgICBlc2NhcGVkUHJlZml4ID0gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHByZWZpeCkgKyAnLyc7XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IE1hcEJvb2tLZWVwaW5nLmdldFBvb2xlZChhcnJheSwgZXNjYXBlZFByZWZpeCwgZnVuYywgY29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIE1hcEJvb2tLZWVwaW5nLnJlbGVhc2UodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBNYXBzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGtleSwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZnVuYywgY29udGV4dCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTaW5nbGVDaGlsZER1bW15KHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gKiBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICovXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuLCBjb250ZXh0KSB7XG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGREdW1teSwgbnVsbCk7XG59XG5cbi8qKlxuICogRmxhdHRlbiBhIGNoaWxkcmVuIG9iamVjdCAodHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gKSBhbmRcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGFwcHJvcHJpYXRlbHkgcmUta2V5ZWQgY2hpbGRyZW4uXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBSZWFjdENoaWxkcmVuID0ge1xuICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gIG1hcDogbWFwQ2hpbGRyZW4sXG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWw6IG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwsXG4gIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICB0b0FycmF5OiB0b0FycmF5XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2hpbGRyZW47XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdENoaWxkcmVuLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHRyYXZlcnNlQWxsQ2hpbGRyZW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlSGFuZGxlcycpO1xuXG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBTRVBBUkFUT1IgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5TRVBBUkFUT1I7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuXG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlckxvb2t1cCA9IHtcbiAgJz0nOiAnPTAnLFxuICAnLic6ICc9MScsXG4gICc6JzogJz0yJ1xufTtcblxudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1s9LjpdL2c7XG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHVzZXJQcm92aWRlZEtleUVzY2FwZXIobWF0Y2gpIHtcbiAgcmV0dXJuIHVzZXJQcm92aWRlZEtleUVzY2FwZXJMb29rdXBbbWF0Y2hdO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XG4gIGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIHdyYXBVc2VyUHJvdmlkZWRLZXkoY29tcG9uZW50LmtleSk7XG4gIH1cbiAgLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuLyoqXG4gKiBFc2NhcGUgYSBjb21wb25lbnQga2V5IHNvIHRoYXQgaXQgaXMgc2FmZSB0byB1c2UgaW4gYSByZWFjdGlkLlxuICpcbiAqIEBwYXJhbSB7Kn0gdGV4dCBDb21wb25lbnQga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgdXNlclByb3ZpZGVkS2V5RXNjYXBlcik7XG59XG5cbi8qKlxuICogV3JhcCBhIGBrZXlgIHZhbHVlIGV4cGxpY2l0bHkgcHJvdmlkZWQgYnkgdGhlIHVzZXIgdG8gZGlzdGluZ3Vpc2ggaXQgZnJvbVxuICogaW1wbGljaXRseS1nZW5lcmF0ZWQga2V5cyBnZW5lcmF0ZWQgYnkgYSBjb21wb25lbnQncyBpbmRleCBpbiBpdHMgcGFyZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVmFsdWUgb2YgYSB1c2VyLXByb3ZpZGVkIGBrZXlgIGF0dHJpYnV0ZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB3cmFwVXNlclByb3ZpZGVkS2V5KGtleSkge1xuICByZXR1cm4gJyQnICsgZXNjYXBlVXNlclByb3ZpZGVkS2V5KGtleSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVTb0ZhciBOYW1lIG9mIHRoZSBrZXkgcGF0aCBzbyBmYXIuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZWFjaCBjaGlsZCBmb3VuZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBVc2VkIHRvIHBhc3MgaW5mb3JtYXRpb24gdGhyb3VnaG91dCB0aGUgdHJhdmVyc2FsXG4gKiBwcm9jZXNzLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCBuYW1lU29GYXIsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCB8fCB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAgY2FsbGJhY2sodHJhdmVyc2VDb250ZXh0LCBjaGlsZHJlbixcbiAgICAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3MuXG4gICAgbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZHJlbiwgMCkgOiBuYW1lU29GYXIpO1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGNoaWxkO1xuICB2YXIgbmV4dE5hbWU7XG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpKTtcbiAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gY2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICB2YXIgaWkgPSAwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZFdhcm5BYm91dE1hcHMsICdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCB5ZXQgZnVsbHkgc3VwcG9ydGVkLiBJdCBpcyBhbiAnICsgJ2V4cGVyaW1lbnRhbCBmZWF0dXJlIHRoYXQgbWlnaHQgYmUgcmVtb3ZlZC4gQ29udmVydCBpdCB0byBhICcgKyAnc2VxdWVuY2UgLyBpdGVyYWJsZSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJykgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgY2hpbGQgPSBlbnRyeVsxXTtcbiAgICAgICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyB3cmFwVXNlclByb3ZpZGVkS2V5KGVudHJ5WzBdKSArIFNVQlNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZCwgMCk7XG4gICAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZCBvciB3cmFwIHRoZSBvYmplY3QgdXNpbmcgY3JlYXRlRnJhZ21lbnQob2JqZWN0KSBmcm9tIHRoZSAnICsgJ1JlYWN0IGFkZC1vbnMuJztcbiAgICAgICAgaWYgKGNoaWxkcmVuLl9pc1JlYWN0RWxlbWVudCkge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBJdCBsb29rcyBsaWtlIHlvdVxcJ3JlIHVzaW5nIGFuIGVsZW1lbnQgY3JlYXRlZCBieSBhIGRpZmZlcmVudCAnICsgJ3ZlcnNpb24gb2YgUmVhY3QuIE1ha2Ugc3VyZSB0byB1c2Ugb25seSBvbmUgY29weSBvZiBSZWFjdC4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgYWRkZW5kdW0gKz0gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAsIGJ1dFxuICogbWlnaHQgYWxzbyBiZSBzcGVjaWZpZWQgdGhyb3VnaCBhdHRyaWJ1dGVzOlxuICpcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbiwgLi4uKWBcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5sZWZ0UGFuZWxDaGlsZHJlbiwgLi4uKWBcbiAqXG4gKiBUaGUgYHRyYXZlcnNlQ29udGV4dGAgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGVcbiAqIGVudGlyZSB0cmF2ZXJzYWwuIEl0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFjY3VtdWxhdGlvbnMgb3IgYW55dGhpbmcgZWxzZSB0aGF0XG4gKiB0aGUgY2FsbGJhY2sgbWlnaHQgZmluZCByZWxldmFudC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIG9iamVjdC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBUbyBpbnZva2UgdXBvbiB0cmF2ZXJzaW5nIGVhY2ggY2hpbGQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBmb3IgdHJhdmVyc2FsLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYXZlcnNlQWxsQ2hpbGRyZW47XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi90cmF2ZXJzZUFsbENoaWxkcmVuLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NU2VsZWN0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIHZhbHVlQ29udGV4dEtleSA9ICdfX1JlYWN0RE9NU2VsZWN0X3ZhbHVlJCcgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcblxuZnVuY3Rpb24gdXBkYXRlT3B0aW9uc0lmUGVuZGluZ1VwZGF0ZUFuZE1vdW50ZWQoKSB7XG4gIGlmICh0aGlzLl9yb290Tm9kZUlEICYmIHRoaXMuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlKSB7XG4gICAgdGhpcy5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUgPSBmYWxzZTtcblxuICAgIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHVwZGF0ZU9wdGlvbnModGhpcywgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSB7XG4gIGlmIChvd25lcikge1xuICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbnZhciB2YWx1ZVByb3BOYW1lcyA9IFsndmFsdWUnLCAnZGVmYXVsdFZhbHVlJ107XG5cbi8qKlxuICogVmFsaWRhdGlvbiBmdW5jdGlvbiBmb3IgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhpbnN0LCBwcm9wcykge1xuICB2YXIgb3duZXIgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ3NlbGVjdCcsIHByb3BzLCBvd25lcik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wTmFtZSA9IHZhbHVlUHJvcE5hbWVzW2ldO1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmICcgKyAnYG11bHRpcGxlYCBpcyB0cnVlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikpIDogdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGEgc2NhbGFyICcgKyAndmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBpbnN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGxlXG4gKiBAcGFyYW0geyp9IHByb3BWYWx1ZSBBIHN0cmluZ2FibGUgKHdpdGggYG11bHRpcGxlYCwgYSBsaXN0IG9mIHN0cmluZ2FibGVzKS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMoaW5zdCwgbXVsdGlwbGUsIHByb3BWYWx1ZSkge1xuICB2YXIgc2VsZWN0ZWRWYWx1ZSwgaTtcbiAgdmFyIG9wdGlvbnMgPSBSZWFjdE1vdW50LmdldE5vZGUoaW5zdC5fcm9vdE5vZGVJRCkub3B0aW9ucztcblxuICBpZiAobXVsdGlwbGUpIHtcbiAgICBzZWxlY3RlZFZhbHVlID0ge307XG4gICAgZm9yIChpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgc2VsZWN0ZWRWYWx1ZVsnJyArIHByb3BWYWx1ZVtpXV0gPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlbGVjdGVkID0gc2VsZWN0ZWRWYWx1ZS5oYXNPd25Qcm9wZXJ0eShvcHRpb25zW2ldLnZhbHVlKTtcbiAgICAgIGlmIChvcHRpb25zW2ldLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb25zW2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBzZXQgYHNlbGVjdC52YWx1ZWAgYXMgZXhhY3QgYmVoYXZpb3IgaXNuJ3QgY29uc2lzdGVudCBhY3Jvc3MgYWxsXG4gICAgLy8gYnJvd3NlcnMgZm9yIGFsbCBjYXNlcy5cbiAgICBzZWxlY3RlZFZhbHVlID0gJycgKyBwcm9wVmFsdWU7XG4gICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChvcHRpb25zW2ldLnZhbHVlID09PSBzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgIG9wdGlvbnNbaV0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxlbmd0aCkge1xuICAgICAgb3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDxzZWxlY3Q+IG5hdGl2ZSBjb21wb25lbnQgdGhhdCBhbGxvd3Mgb3B0aW9uYWxseSBzZXR0aW5nIHRoZVxuICogcHJvcHMgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuIElmIGBtdWx0aXBsZWAgaXMgZmFsc2UsIHRoZSBwcm9wIG11c3QgYmUgYVxuICogc3RyaW5nYWJsZS4gSWYgYG11bHRpcGxlYCBpcyB0cnVlLCB0aGUgcHJvcCBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ2FibGVzLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGNoYW5nZSB0aGVcbiAqIHNlbGVjdGVkIG9wdGlvbiB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAqXG4gKiBJZiBpdCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBvcHRpb25zIHdpbGwgbm90XG4gKiB1cGRhdGUgaW4gcmVzcG9uc2UgdG8gdXNlciBhY3Rpb25zLiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIG9wdGlvbnMgdG8gdXBkYXRlLlxuICpcbiAqIElmIGBkZWZhdWx0VmFsdWVgIGlzIHByb3ZpZGVkLCBhbnkgb3B0aW9ucyB3aXRoIHRoZSBzdXBwbGllZCB2YWx1ZXMgd2lsbCBiZVxuICogc2VsZWN0ZWQuXG4gKi9cbnZhciBSZWFjdERPTVNlbGVjdCA9IHtcbiAgdmFsdWVDb250ZXh0S2V5OiB2YWx1ZUNvbnRleHRLZXksXG5cbiAgZ2V0TmF0aXZlUHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcywgY29udGV4dCkge1xuICAgIHJldHVybiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlLFxuICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrU2VsZWN0UHJvcFR5cGVzKGluc3QsIHByb3BzKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7XG4gICAgICBwZW5kaW5nVXBkYXRlOiBmYWxzZSxcbiAgICAgIGluaXRpYWxWYWx1ZTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgb25DaGFuZ2U6IF9oYW5kbGVDaGFuZ2UuYmluZChpbnN0KSxcbiAgICAgIHdhc011bHRpcGxlOiBCb29sZWFuKHByb3BzLm11bHRpcGxlKVxuICAgIH07XG4gIH0sXG5cbiAgcHJvY2Vzc0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKGluc3QsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgLy8gUGFzcyBkb3duIGluaXRpYWwgdmFsdWUgc28gaW5pdGlhbCBnZW5lcmF0ZWQgbWFya3VwIGhhcyBjb3JyZWN0XG4gICAgLy8gYHNlbGVjdGVkYCBhdHRyaWJ1dGVzXG4gICAgdmFyIGNoaWxkQ29udGV4dCA9IGFzc2lnbih7fSwgY29udGV4dCk7XG4gICAgY2hpbGRDb250ZXh0W3ZhbHVlQ29udGV4dEtleV0gPSBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlO1xuICAgIHJldHVybiBjaGlsZENvbnRleHQ7XG4gIH0sXG5cbiAgcG9zdFVwZGF0ZVdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICAvLyBBZnRlciB0aGUgaW5pdGlhbCBtb3VudCwgd2UgY29udHJvbCBzZWxlY3RlZC1uZXNzIG1hbnVhbGx5IHNvIGRvbid0IHBhc3NcbiAgICAvLyB0aGUgY29udGV4dCB2YWx1ZSBkb3duXG4gICAgaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSA9IHVuZGVmaW5lZDtcblxuICAgIHZhciB3YXNNdWx0aXBsZSA9IGluc3QuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZTtcbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGUgPSBCb29sZWFuKHByb3BzLm11bHRpcGxlKTtcblxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgdXBkYXRlT3B0aW9ucyhpbnN0LCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAod2FzTXVsdGlwbGUgIT09IEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpKSB7XG4gICAgICAvLyBGb3Igc2ltcGxpY2l0eSwgcmVhcHBseSBgZGVmYXVsdFZhbHVlYCBpZiBgbXVsdGlwbGVgIGlzIHRvZ2dsZWQuXG4gICAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlT3B0aW9ucyhpbnN0LCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgcHJvcHMuZGVmYXVsdFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJldmVydCB0aGUgc2VsZWN0IGJhY2sgdG8gaXRzIGRlZmF1bHQgdW5zZWxlY3RlZCBzdGF0ZS5cbiAgICAgICAgdXBkYXRlT3B0aW9ucyhpbnN0LCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgcHJvcHMubXVsdGlwbGUgPyBbXSA6ICcnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9oYW5kbGVDaGFuZ2UoZXZlbnQpIHtcbiAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gIHZhciByZXR1cm5WYWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZXhlY3V0ZU9uQ2hhbmdlKHByb3BzLCBldmVudCk7XG5cbiAgdGhpcy5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUgPSB0cnVlO1xuICBSZWFjdFVwZGF0ZXMuYXNhcCh1cGRhdGVPcHRpb25zSWZQZW5kaW5nVXBkYXRlQW5kTW91bnRlZCwgdGhpcyk7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVNlbGVjdDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NU2VsZWN0LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NVGV4dGFyZWFcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZSgnLi9MaW5rZWRWYWx1ZVV0aWxzJyk7XG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0RE9NSURPcGVyYXRpb25zJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGZvcmNlVXBkYXRlSWZNb3VudGVkKCkge1xuICBpZiAodGhpcy5fcm9vdE5vZGVJRCkge1xuICAgIC8vIERPTSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZDsgdXBkYXRlXG4gICAgUmVhY3RET01UZXh0YXJlYS51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDx0ZXh0YXJlYT4gbmF0aXZlIGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIGB2YWx1ZWAsIGFuZFxuICogYGRlZmF1bHRWYWx1ZWAuIFRoaXMgZGlmZmVycyBmcm9tIHRoZSB0cmFkaXRpb25hbCBET00gQVBJIGJlY2F1c2UgdmFsdWUgaXNcbiAqIHVzdWFsbHkgc2V0IGFzIFBDREFUQSBjaGlsZHJlbi5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBhZmZlY3QgdGhlXG4gKiB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbFxuICogbm90IHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIGFuIGVtcHR5IHZhbHVlLCB0aGUgcHJvcFxuICogYGRlZmF1bHRWYWx1ZWAgaWYgc3BlY2lmaWVkLCBvciB0aGUgY2hpbGRyZW4gY29udGVudCAoZGVwcmVjYXRlZCkuXG4gKi9cbnZhciBSZWFjdERPTVRleHRhcmVhID0ge1xuICBnZXROYXRpdmVQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgIShwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBBbHdheXMgc2V0IGNoaWxkcmVuIHRvIHRoZSBzYW1lIHRoaW5nLiBJbiBJRTksIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbFxuICAgIC8vIGdldCByZXNldCBpZiBgdGV4dENvbnRlbnRgIGlzIG11dGF0ZWQuXG4gICAgdmFyIG5hdGl2ZVByb3BzID0gYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgY2hpbGRyZW46IGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUsXG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmF0aXZlUHJvcHM7XG4gIH0sXG5cbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgTGlua2VkVmFsdWVVdGlscy5jaGVja1Byb3BUeXBlcygndGV4dGFyZWEnLCBwcm9wcywgaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBjaGlsZHJlbiBjb250ZW50IGluIDx0ZXh0YXJlYT4uXG4gICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJykgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICAhKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdJZiB5b3Ugc3VwcGx5IGBkZWZhdWx0VmFsdWVgIG9uIGEgPHRleHRhcmVhPiwgZG8gbm90IHBhc3MgY2hpbGRyZW4uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICEoY2hpbGRyZW4ubGVuZ3RoIDw9IDEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW5bMF07XG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnICsgY2hpbGRyZW47XG4gICAgfVxuICAgIGlmIChkZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdFZhbHVlID0gJyc7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuXG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgLy8gV2Ugc2F2ZSB0aGUgaW5pdGlhbCB2YWx1ZSBzbyB0aGF0IGBSZWFjdERPTUNvbXBvbmVudGAgZG9lc24ndCB1cGRhdGVcbiAgICAgIC8vIGB0ZXh0Q29udGVudGAgKHVubmVjZXNzYXJ5IHNpbmNlIHdlIHVwZGF0ZSB2YWx1ZSkuXG4gICAgICAvLyBUaGUgaW5pdGlhbCB2YWx1ZSBjYW4gYmUgYSBib29sZWFuIG9yIG9iamVjdCBzbyB0aGF0J3Mgd2h5IGl0J3NcbiAgICAgIC8vIGZvcmNlZCB0byBiZSBhIHN0cmluZy5cbiAgICAgIGluaXRpYWxWYWx1ZTogJycgKyAodmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogZGVmYXVsdFZhbHVlKSxcbiAgICAgIG9uQ2hhbmdlOiBfaGFuZGxlQ2hhbmdlLmJpbmQoaW5zdClcbiAgICB9O1xuICB9LFxuXG4gIHVwZGF0ZVdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICBSZWFjdERPTUlET3BlcmF0aW9ucy51cGRhdGVQcm9wZXJ0eUJ5SUQoaW5zdC5fcm9vdE5vZGVJRCwgJ3ZhbHVlJywgJycgKyB2YWx1ZSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xuICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgdGhpcyk7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVRleHRhcmVhO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RET01UZXh0YXJlYS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE11bHRpQ2hpbGRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcycpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBSZWFjdENoaWxkUmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RDaGlsZFJlY29uY2lsZXInKTtcblxudmFyIGZsYXR0ZW5DaGlsZHJlbiA9IHJlcXVpcmUoJy4vZmxhdHRlbkNoaWxkcmVuJyk7XG5cbi8qKlxuICogVXBkYXRpbmcgY2hpbGRyZW4gb2YgYSBjb21wb25lbnQgbWF5IHRyaWdnZXIgcmVjdXJzaXZlIHVwZGF0ZXMuIFRoZSBkZXB0aCBpc1xuICogdXNlZCB0byBiYXRjaCByZWN1cnNpdmUgdXBkYXRlcyB0byByZW5kZXIgbWFya3VwIG1vcmUgZWZmaWNpZW50bHkuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciB1cGRhdGVEZXB0aCA9IDA7XG5cbi8qKlxuICogUXVldWUgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb24gb2JqZWN0cy5cbiAqXG4gKiBFYWNoIG9iamVjdCBoYXMgYSBgdHlwZWAgcHJvcGVydHkgdGhhdCBpcyBpbiBgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXNgLlxuICpcbiAqIEB0eXBlIHthcnJheTxvYmplY3Q+fVxuICogQHByaXZhdGVcbiAqL1xudmFyIHVwZGF0ZVF1ZXVlID0gW107XG5cbi8qKlxuICogUXVldWUgb2YgbWFya3VwIHRvIGJlIHJlbmRlcmVkLlxuICpcbiAqIEB0eXBlIHthcnJheTxzdHJpbmc+fVxuICogQHByaXZhdGVcbiAqL1xudmFyIG1hcmt1cFF1ZXVlID0gW107XG5cbi8qKlxuICogRW5xdWV1ZXMgbWFya3VwIHRvIGJlIHJlbmRlcmVkIGFuZCBpbnNlcnRlZCBhdCBhIHN1cHBsaWVkIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRJRCBJRCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRoYXQgcmVuZGVycyBpbnRvIGFuIGVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVJbnNlcnRNYXJrdXAocGFyZW50SUQsIG1hcmt1cCwgdG9JbmRleCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHVwZGF0ZVF1ZXVlLnB1c2goe1xuICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICBwYXJlbnROb2RlOiBudWxsLFxuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLklOU0VSVF9NQVJLVVAsXG4gICAgbWFya3VwSW5kZXg6IG1hcmt1cFF1ZXVlLnB1c2gobWFya3VwKSAtIDEsXG4gICAgY29udGVudDogbnVsbCxcbiAgICBmcm9tSW5kZXg6IG51bGwsXG4gICAgdG9JbmRleDogdG9JbmRleFxuICB9KTtcbn1cblxuLyoqXG4gKiBFbnF1ZXVlcyBtb3ZpbmcgYW4gZXhpc3RpbmcgZWxlbWVudCB0byBhbm90aGVyIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRJRCBJRCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggU291cmNlIGluZGV4IG9mIHRoZSBleGlzdGluZyBlbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXggb2YgdGhlIGVsZW1lbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbnF1ZXVlTW92ZShwYXJlbnRJRCwgZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgdXBkYXRlUXVldWUucHVzaCh7XG4gICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgIHBhcmVudE5vZGU6IG51bGwsXG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuTU9WRV9FWElTVElORyxcbiAgICBtYXJrdXBJbmRleDogbnVsbCxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGZyb21JbmRleDogZnJvbUluZGV4LFxuICAgIHRvSW5kZXg6IHRvSW5kZXhcbiAgfSk7XG59XG5cbi8qKlxuICogRW5xdWV1ZXMgcmVtb3ZpbmcgYW4gZWxlbWVudCBhdCBhbiBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50SUQgSUQgb2YgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IEluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVSZW1vdmUocGFyZW50SUQsIGZyb21JbmRleCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHVwZGF0ZVF1ZXVlLnB1c2goe1xuICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICBwYXJlbnROb2RlOiBudWxsLFxuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlJFTU9WRV9OT0RFLFxuICAgIG1hcmt1cEluZGV4OiBudWxsLFxuICAgIGNvbnRlbnQ6IG51bGwsXG4gICAgZnJvbUluZGV4OiBmcm9tSW5kZXgsXG4gICAgdG9JbmRleDogbnVsbFxuICB9KTtcbn1cblxuLyoqXG4gKiBFbnF1ZXVlcyBzZXR0aW5nIHRoZSBtYXJrdXAgb2YgYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRJRCBJRCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRoYXQgcmVuZGVycyBpbnRvIGFuIGVsZW1lbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbnF1ZXVlU2V0TWFya3VwKHBhcmVudElELCBtYXJrdXApIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICB1cGRhdGVRdWV1ZS5wdXNoKHtcbiAgICBwYXJlbnRJRDogcGFyZW50SUQsXG4gICAgcGFyZW50Tm9kZTogbnVsbCxcbiAgICB0eXBlOiBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5TRVRfTUFSS1VQLFxuICAgIG1hcmt1cEluZGV4OiBudWxsLFxuICAgIGNvbnRlbnQ6IG1hcmt1cCxcbiAgICBmcm9tSW5kZXg6IG51bGwsXG4gICAgdG9JbmRleDogbnVsbFxuICB9KTtcbn1cblxuLyoqXG4gKiBFbnF1ZXVlcyBzZXR0aW5nIHRoZSB0ZXh0IGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudElEIElEIG9mIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRDb250ZW50IFRleHQgY29udGVudCB0byBzZXQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbnF1ZXVlVGV4dENvbnRlbnQocGFyZW50SUQsIHRleHRDb250ZW50KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgdXBkYXRlUXVldWUucHVzaCh7XG4gICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgIHBhcmVudE5vZGU6IG51bGwsXG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuVEVYVF9DT05URU5ULFxuICAgIG1hcmt1cEluZGV4OiBudWxsLFxuICAgIGNvbnRlbnQ6IHRleHRDb250ZW50LFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICB0b0luZGV4OiBudWxsXG4gIH0pO1xufVxuXG4vKipcbiAqIFByb2Nlc3NlcyBhbnkgZW5xdWV1ZWQgdXBkYXRlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwcm9jZXNzUXVldWUoKSB7XG4gIGlmICh1cGRhdGVRdWV1ZS5sZW5ndGgpIHtcbiAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnByb2Nlc3NDaGlsZHJlblVwZGF0ZXModXBkYXRlUXVldWUsIG1hcmt1cFF1ZXVlKTtcbiAgICBjbGVhclF1ZXVlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDbGVhcnMgYW55IGVucXVldWVkIHVwZGF0ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJRdWV1ZSgpIHtcbiAgdXBkYXRlUXVldWUubGVuZ3RoID0gMDtcbiAgbWFya3VwUXVldWUubGVuZ3RoID0gMDtcbn1cblxuLyoqXG4gKiBSZWFjdE11bHRpQ2hpbGQgYXJlIGNhcGFibGUgb2YgcmVjb25jaWxpbmcgbXVsdGlwbGUgY2hpbGRyZW4uXG4gKlxuICogQGNsYXNzIFJlYWN0TXVsdGlDaGlsZFxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdE11bHRpQ2hpbGQgPSB7XG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGNvbW1vbiBmdW5jdGlvbmFsaXR5IGZvciBjb21wb25lbnRzIHRoYXQgbXVzdCByZWNvbmNpbGUgbXVsdGlwbGVcbiAgICogY2hpbGRyZW4uIFRoaXMgaXMgdXNlZCBieSBgUmVhY3RET01Db21wb25lbnRgIHRvIG1vdW50LCB1cGRhdGUsIGFuZFxuICAgKiB1bm1vdW50IGNoaWxkIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIEBsZW5kcyB7UmVhY3RNdWx0aUNoaWxkLnByb3RvdHlwZX1cbiAgICovXG4gIE1peGluOiB7XG5cbiAgICBfcmVjb25jaWxlckluc3RhbnRpYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLmluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY3RDaGlsZFJlY29uY2lsZXIuaW5zdGFudGlhdGVDaGlsZHJlbihuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBfcmVjb25jaWxlclVwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAocHJldkNoaWxkcmVuLCBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHZhciBuZXh0Q2hpbGRyZW47XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgIG5leHRDaGlsZHJlbiA9IGZsYXR0ZW5DaGlsZHJlbihuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cyk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gUmVhY3RDaGlsZFJlY29uY2lsZXIudXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV4dENoaWxkcmVuID0gZmxhdHRlbkNoaWxkcmVuKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzKTtcbiAgICAgIHJldHVybiBSZWFjdENoaWxkUmVjb25jaWxlci51cGRhdGVDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBcIm1vdW50IGltYWdlXCIgZm9yIGVhY2ggb2YgdGhlIHN1cHBsaWVkIGNoaWxkcmVuLiBJbiB0aGUgY2FzZVxuICAgICAqIG9mIGBSZWFjdERPTUNvbXBvbmVudGAsIGEgbW91bnQgaW1hZ2UgaXMgYSBzdHJpbmcgb2YgbWFya3VwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXN0ZWRDaGlsZHJlbiBOZXN0ZWQgY2hpbGQgbWFwcy5cbiAgICAgKiBAcmV0dXJuIHthcnJheX0gQW4gYXJyYXkgb2YgbW91bnRlZCByZXByZXNlbnRhdGlvbnMuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgbW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fcmVjb25jaWxlckluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgIHZhciBtb3VudEltYWdlcyA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5bbmFtZV07XG4gICAgICAgICAgLy8gSW5saW5lZCBmb3IgcGVyZm9ybWFuY2UsIHNlZSBgUmVhY3RJbnN0YW5jZUhhbmRsZXMuY3JlYXRlUmVhY3RJRGAuXG4gICAgICAgICAgdmFyIHJvb3RJRCA9IHRoaXMuX3Jvb3ROb2RlSUQgKyBuYW1lO1xuICAgICAgICAgIHZhciBtb3VudEltYWdlID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KGNoaWxkLCByb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgICBjaGlsZC5fbW91bnRJbmRleCA9IGluZGV4Kys7XG4gICAgICAgICAgbW91bnRJbWFnZXMucHVzaChtb3VudEltYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1vdW50SW1hZ2VzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbnkgcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIHRleHQgY29udGVudCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV4dENvbnRlbnQgU3RyaW5nIG9mIGNvbnRlbnQuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdXBkYXRlVGV4dENvbnRlbnQ6IGZ1bmN0aW9uIChuZXh0Q29udGVudCkge1xuICAgICAgdXBkYXRlRGVwdGgrKztcbiAgICAgIHZhciBlcnJvclRocm93biA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgICAgLy8gUmVtb3ZlIGFueSByZW5kZXJlZCBjaGlsZHJlbi5cbiAgICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudW5tb3VudENoaWxkcmVuKHByZXZDaGlsZHJlbik7XG4gICAgICAgIC8vIFRPRE86IFRoZSBzZXRUZXh0Q29udGVudCBvcGVyYXRpb24gc2hvdWxkIGJlIGVub3VnaFxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3VubW91bnRDaGlsZChwcmV2Q2hpbGRyZW5bbmFtZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgbmV3IHRleHQgY29udGVudC5cbiAgICAgICAgdGhpcy5zZXRUZXh0Q29udGVudChuZXh0Q29udGVudCk7XG4gICAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1cGRhdGVEZXB0aC0tO1xuICAgICAgICBpZiAoIXVwZGF0ZURlcHRoKSB7XG4gICAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgICBjbGVhclF1ZXVlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb2Nlc3NRdWV1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbnkgcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIG1hcmt1cCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV4dE1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZU1hcmt1cDogZnVuY3Rpb24gKG5leHRNYXJrdXApIHtcbiAgICAgIHVwZGF0ZURlcHRoKys7XG4gICAgICB2YXIgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICAgIC8vIFJlbW92ZSBhbnkgcmVuZGVyZWQgY2hpbGRyZW4uXG4gICAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihwcmV2Q2hpbGRyZW4pO1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3VubW91bnRDaGlsZEJ5TmFtZShwcmV2Q2hpbGRyZW5bbmFtZV0sIG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldE1hcmt1cChuZXh0TWFya3VwKTtcbiAgICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVwZGF0ZURlcHRoLS07XG4gICAgICAgIGlmICghdXBkYXRlRGVwdGgpIHtcbiAgICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgIGNsZWFyUXVldWUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvY2Vzc1F1ZXVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggbmV3IGNoaWxkcmVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cyBOZXN0ZWQgY2hpbGQgZWxlbWVudCBtYXBzLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgdXBkYXRlRGVwdGgrKztcbiAgICAgIHZhciBlcnJvclRocm93biA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl91cGRhdGVDaGlsZHJlbihuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdXBkYXRlRGVwdGgtLTtcbiAgICAgICAgaWYgKCF1cGRhdGVEZXB0aCkge1xuICAgICAgICAgIGlmIChlcnJvclRocm93bikge1xuICAgICAgICAgICAgY2xlYXJRdWV1ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzUXVldWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW1wcm92ZSBwZXJmb3JtYW5jZSBieSBpc29sYXRpbmcgdGhpcyBob3QgY29kZSBwYXRoIGZyb20gdGhlIHRyeS9jYXRjaFxuICAgICAqIGJsb2NrIGluIGB1cGRhdGVDaGlsZHJlbmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzIE5lc3RlZCBjaGlsZCBlbGVtZW50IG1hcHMuXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBmaW5hbFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgdmFyIG5leHRDaGlsZHJlbiA9IHRoaXMuX3JlY29uY2lsZXJVcGRhdGVDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbmV4dENoaWxkcmVuO1xuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4gJiYgIXByZXZDaGlsZHJlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbmFtZTtcbiAgICAgIC8vIGBuZXh0SW5kZXhgIHdpbGwgaW5jcmVtZW50IGZvciBlYWNoIGNoaWxkIGluIGBuZXh0Q2hpbGRyZW5gLCBidXRcbiAgICAgIC8vIGBsYXN0SW5kZXhgIHdpbGwgYmUgdGhlIGxhc3QgaW5kZXggdmlzaXRlZCBpbiBgcHJldkNoaWxkcmVuYC5cbiAgICAgIHZhciBsYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIG5leHRJbmRleCA9IDA7XG4gICAgICBmb3IgKG5hbWUgaW4gbmV4dENoaWxkcmVuKSB7XG4gICAgICAgIGlmICghbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZDaGlsZCA9IHByZXZDaGlsZHJlbiAmJiBwcmV2Q2hpbGRyZW5bbmFtZV07XG4gICAgICAgIHZhciBuZXh0Q2hpbGQgPSBuZXh0Q2hpbGRyZW5bbmFtZV07XG4gICAgICAgIGlmIChwcmV2Q2hpbGQgPT09IG5leHRDaGlsZCkge1xuICAgICAgICAgIHRoaXMubW92ZUNoaWxkKHByZXZDaGlsZCwgbmV4dEluZGV4LCBsYXN0SW5kZXgpO1xuICAgICAgICAgIGxhc3RJbmRleCA9IE1hdGgubWF4KHByZXZDaGlsZC5fbW91bnRJbmRleCwgbGFzdEluZGV4KTtcbiAgICAgICAgICBwcmV2Q2hpbGQuX21vdW50SW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHByZXZDaGlsZCkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGBsYXN0SW5kZXhgIGJlZm9yZSBgX21vdW50SW5kZXhgIGdldHMgdW5zZXQgYnkgdW5tb3VudGluZy5cbiAgICAgICAgICAgIGxhc3RJbmRleCA9IE1hdGgubWF4KHByZXZDaGlsZC5fbW91bnRJbmRleCwgbGFzdEluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuX3VubW91bnRDaGlsZChwcmV2Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUaGUgY2hpbGQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgYmVmb3JlIGl0J3MgbW91bnRlZC5cbiAgICAgICAgICB0aGlzLl9tb3VudENoaWxkQnlOYW1lQXRJbmRleChuZXh0Q2hpbGQsIG5hbWUsIG5leHRJbmRleCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIG5leHRJbmRleCsrO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGNoaWxkcmVuIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LlxuICAgICAgZm9yIChuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpICYmICEobmV4dENoaWxkcmVuICYmIG5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkpIHtcbiAgICAgICAgICB0aGlzLl91bm1vdW50Q2hpbGQocHJldkNoaWxkcmVuW25hbWVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbm1vdW50cyBhbGwgcmVuZGVyZWQgY2hpbGRyZW4uIFRoaXMgc2hvdWxkIGJlIHVzZWQgdG8gY2xlYW4gdXAgY2hpbGRyZW5cbiAgICAgKiB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVubW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlbmRlcmVkQ2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudW5tb3VudENoaWxkcmVuKHJlbmRlcmVkQ2hpbGRyZW4pO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGEgY2hpbGQgY29tcG9uZW50IHRvIHRoZSBzdXBwbGllZCBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBtb3ZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4IG9mIHRoZSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXN0SW5kZXggTGFzdCBpbmRleCB2aXNpdGVkIG9mIHRoZSBzaWJsaW5ncyBvZiBgY2hpbGRgLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgdG9JbmRleCwgbGFzdEluZGV4KSB7XG4gICAgICAvLyBJZiB0aGUgaW5kZXggb2YgYGNoaWxkYCBpcyBsZXNzIHRoYW4gYGxhc3RJbmRleGAsIHRoZW4gaXQgbmVlZHMgdG9cbiAgICAgIC8vIGJlIG1vdmVkLiBPdGhlcndpc2UsIHdlIGRvIG5vdCBuZWVkIHRvIG1vdmUgaXQgYmVjYXVzZSBhIGNoaWxkIHdpbGwgYmVcbiAgICAgIC8vIGluc2VydGVkIG9yIG1vdmVkIGJlZm9yZSBgY2hpbGRgLlxuICAgICAgaWYgKGNoaWxkLl9tb3VudEluZGV4IDwgbGFzdEluZGV4KSB7XG4gICAgICAgIGVucXVldWVNb3ZlKHRoaXMuX3Jvb3ROb2RlSUQsIGNoaWxkLl9tb3VudEluZGV4LCB0b0luZGV4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNoaWxkIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBjcmVhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vdW50SW1hZ2UgTWFya3VwIHRvIGluc2VydC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgbW91bnRJbWFnZSkge1xuICAgICAgZW5xdWV1ZUluc2VydE1hcmt1cCh0aGlzLl9yb290Tm9kZUlELCBtb3VudEltYWdlLCBjaGlsZC5fbW91bnRJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjaGlsZCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDaGlsZCB0byByZW1vdmUuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlbW92ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIGVucXVldWVSZW1vdmUodGhpcy5fcm9vdE5vZGVJRCwgY2hpbGQuX21vdW50SW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoaXMgdGV4dCBjb250ZW50IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0Q29udGVudCBUZXh0IGNvbnRlbnQgdG8gc2V0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZXRUZXh0Q29udGVudDogZnVuY3Rpb24gKHRleHRDb250ZW50KSB7XG4gICAgICBlbnF1ZXVlVGV4dENvbnRlbnQodGhpcy5fcm9vdE5vZGVJRCwgdGV4dENvbnRlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoaXMgbWFya3VwIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRvIHNldC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2V0TWFya3VwOiBmdW5jdGlvbiAobWFya3VwKSB7XG4gICAgICBlbnF1ZXVlU2V0TWFya3VwKHRoaXMuX3Jvb3ROb2RlSUQsIG1hcmt1cCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdW50cyBhIGNoaWxkIHdpdGggdGhlIHN1cHBsaWVkIG5hbWUuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGlzIHBhcnQgb2YgYHVwZGF0ZUNoaWxkcmVuYCBhbmQgaXMgaGVyZSBmb3IgcmVhZGFiaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gbW91bnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgY2hpbGQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgY2hpbGQuXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21vdW50Q2hpbGRCeU5hbWVBdEluZGV4OiBmdW5jdGlvbiAoY2hpbGQsIG5hbWUsIGluZGV4LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgLy8gSW5saW5lZCBmb3IgcGVyZm9ybWFuY2UsIHNlZSBgUmVhY3RJbnN0YW5jZUhhbmRsZXMuY3JlYXRlUmVhY3RJRGAuXG4gICAgICB2YXIgcm9vdElEID0gdGhpcy5fcm9vdE5vZGVJRCArIG5hbWU7XG4gICAgICB2YXIgbW91bnRJbWFnZSA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjaGlsZCwgcm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICBjaGlsZC5fbW91bnRJbmRleCA9IGluZGV4O1xuICAgICAgdGhpcy5jcmVhdGVDaGlsZChjaGlsZCwgbW91bnRJbWFnZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVubW91bnRzIGEgcmVuZGVyZWQgY2hpbGQuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGlzIHBhcnQgb2YgYHVwZGF0ZUNoaWxkcmVuYCBhbmQgaXMgaGVyZSBmb3IgcmVhZGFiaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gdW5tb3VudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91bm1vdW50Q2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgdGhpcy5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICBjaGlsZC5fbW91bnRJbmRleCA9IG51bGw7XG4gICAgfVxuXG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE11bHRpQ2hpbGQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdE11bHRpQ2hpbGQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDaGlsZFJlY29uY2lsZXJcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcblxudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gaW5zdGFudGlhdGVDaGlsZChjaGlsZEluc3RhbmNlcywgY2hpbGQsIG5hbWUpIHtcbiAgLy8gV2UgZm91bmQgYSBjb21wb25lbnQgaW5zdGFuY2UuXG4gIHZhciBrZXlVbmlxdWUgPSBjaGlsZEluc3RhbmNlc1tuYW1lXSA9PT0gdW5kZWZpbmVkO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGtleVVuaXF1ZSwgJ2ZsYXR0ZW5DaGlsZHJlbiguLi4pOiBFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksICcgKyAnYCVzYC4gQ2hpbGQga2V5cyBtdXN0IGJlIHVuaXF1ZTsgd2hlbiB0d28gY2hpbGRyZW4gc2hhcmUgYSBrZXksIG9ubHkgJyArICd0aGUgZmlyc3QgY2hpbGQgd2lsbCBiZSB1c2VkLicsIG5hbWUpIDogdW5kZWZpbmVkO1xuICB9XG4gIGlmIChjaGlsZCAhPSBudWxsICYmIGtleVVuaXF1ZSkge1xuICAgIGNoaWxkSW5zdGFuY2VzW25hbWVdID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChjaGlsZCwgbnVsbCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZWFjdENoaWxkUmVjb25jaWxlciBwcm92aWRlcyBoZWxwZXJzIGZvciBpbml0aWFsaXppbmcgb3IgdXBkYXRpbmcgYSBzZXQgb2ZcbiAqIGNoaWxkcmVuLiBJdHMgb3V0cHV0IGlzIHN1aXRhYmxlIGZvciBwYXNzaW5nIGl0IG9udG8gUmVhY3RNdWx0aUNoaWxkIHdoaWNoXG4gKiBkb2VzIGRpZmZlZCByZW9yZGVyaW5nIGFuZCBpbnNlcnRpb24uXG4gKi9cbnZhciBSZWFjdENoaWxkUmVjb25jaWxlciA9IHtcbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIFwibW91bnQgaW1hZ2VcIiBmb3IgZWFjaCBvZiB0aGUgc3VwcGxpZWQgY2hpbGRyZW4uIEluIHRoZSBjYXNlXG4gICAqIG9mIGBSZWFjdERPTUNvbXBvbmVudGAsIGEgbW91bnQgaW1hZ2UgaXMgYSBzdHJpbmcgb2YgbWFya3VwLlxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5lc3RlZENoaWxkTm9kZXMgTmVzdGVkIGNoaWxkIG1hcHMuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IEEgc2V0IG9mIGNoaWxkIGluc3RhbmNlcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBpbnN0YW50aWF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmVzdGVkQ2hpbGROb2RlcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICBpZiAobmVzdGVkQ2hpbGROb2RlcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGNoaWxkSW5zdGFuY2VzID0ge307XG4gICAgdHJhdmVyc2VBbGxDaGlsZHJlbihuZXN0ZWRDaGlsZE5vZGVzLCBpbnN0YW50aWF0ZUNoaWxkLCBjaGlsZEluc3RhbmNlcyk7XG4gICAgcmV0dXJuIGNoaWxkSW5zdGFuY2VzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSByZW5kZXJlZCBjaGlsZHJlbiBhbmQgcmV0dXJucyBhIG5ldyBzZXQgb2YgY2hpbGRyZW4uXG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldkNoaWxkcmVuIFByZXZpb3VzbHkgaW5pdGlhbGl6ZWQgc2V0IG9mIGNoaWxkcmVuLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDaGlsZHJlbiBGbGF0IGNoaWxkIGVsZW1lbnQgbWFwcy5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBIG5ldyBzZXQgb2YgY2hpbGQgaW5zdGFuY2VzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAocHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgLy8gV2UgY3VycmVudGx5IGRvbid0IGhhdmUgYSB3YXkgdG8gdHJhY2sgbW92ZXMgaGVyZSBidXQgaWYgd2UgdXNlIGl0ZXJhdG9yc1xuICAgIC8vIGluc3RlYWQgb2YgZm9yLi5pbiB3ZSBjYW4gemlwIHRoZSBpdGVyYXRvcnMgYW5kIGNoZWNrIGlmIGFuIGl0ZW0gaGFzXG4gICAgLy8gbW92ZWQuXG4gICAgLy8gVE9ETzogSWYgbm90aGluZyBoYXMgY2hhbmdlZCwgcmV0dXJuIHRoZSBwcmV2Q2hpbGRyZW4gb2JqZWN0IHNvIHRoYXQgd2VcbiAgICAvLyBjYW4gcXVpY2tseSBiYWlsb3V0IGlmIG5vdGhpbmcgaGFzIGNoYW5nZWQuXG4gICAgaWYgKCFuZXh0Q2hpbGRyZW4gJiYgIXByZXZDaGlsZHJlbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBuYW1lO1xuICAgIGZvciAobmFtZSBpbiBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgIGlmICghbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHByZXZDaGlsZCA9IHByZXZDaGlsZHJlbiAmJiBwcmV2Q2hpbGRyZW5bbmFtZV07XG4gICAgICB2YXIgcHJldkVsZW1lbnQgPSBwcmV2Q2hpbGQgJiYgcHJldkNoaWxkLl9jdXJyZW50RWxlbWVudDtcbiAgICAgIHZhciBuZXh0RWxlbWVudCA9IG5leHRDaGlsZHJlbltuYW1lXTtcbiAgICAgIGlmIChwcmV2Q2hpbGQgIT0gbnVsbCAmJiBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpKSB7XG4gICAgICAgIFJlYWN0UmVjb25jaWxlci5yZWNlaXZlQ29tcG9uZW50KHByZXZDaGlsZCwgbmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgbmV4dENoaWxkcmVuW25hbWVdID0gcHJldkNoaWxkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByZXZDaGlsZCkge1xuICAgICAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHByZXZDaGlsZCwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGNoaWxkIG11c3QgYmUgaW5zdGFudGlhdGVkIGJlZm9yZSBpdCdzIG1vdW50ZWQuXG4gICAgICAgIHZhciBuZXh0Q2hpbGRJbnN0YW5jZSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobmV4dEVsZW1lbnQsIG51bGwpO1xuICAgICAgICBuZXh0Q2hpbGRyZW5bbmFtZV0gPSBuZXh0Q2hpbGRJbnN0YW5jZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gVW5tb3VudCBjaGlsZHJlbiB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudC5cbiAgICBmb3IgKG5hbWUgaW4gcHJldkNoaWxkcmVuKSB7XG4gICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpICYmICEobmV4dENoaWxkcmVuICYmIG5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkpIHtcbiAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNoaWxkcmVuW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5leHRDaGlsZHJlbjtcbiAgfSxcblxuICAvKipcbiAgICogVW5tb3VudHMgYWxsIHJlbmRlcmVkIGNoaWxkcmVuLiBUaGlzIHNob3VsZCBiZSB1c2VkIHRvIGNsZWFuIHVwIGNoaWxkcmVuXG4gICAqIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgdW5tb3VudGVkLlxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IHJlbmRlcmVkQ2hpbGRyZW4gUHJldmlvdXNseSBpbml0aWFsaXplZCBzZXQgb2YgY2hpbGRyZW4uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENoaWxkcmVuOiBmdW5jdGlvbiAocmVuZGVyZWRDaGlsZHJlbikge1xuICAgIGZvciAodmFyIG5hbWUgaW4gcmVuZGVyZWRDaGlsZHJlbikge1xuICAgICAgaWYgKHJlbmRlcmVkQ2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVkQ2hpbGQgPSByZW5kZXJlZENoaWxkcmVuW25hbWVdO1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChyZW5kZXJlZENoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENoaWxkUmVjb25jaWxlcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q2hpbGRSZWNvbmNpbGVyLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGZsYXR0ZW5DaGlsZHJlblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHRyYXZlcnNlQWxsQ2hpbGRyZW4gPSByZXF1aXJlKCcuL3RyYXZlcnNlQWxsQ2hpbGRyZW4nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IHBhc3NlZCB0aHJvdWdoIHRyYXZlcnNhbC5cbiAqIEBwYXJhbSB7P1JlYWN0Q29tcG9uZW50fSBjaGlsZCBSZWFjdCBjaGlsZCBjb21wb25lbnQuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWUgU3RyaW5nIG5hbWUgb2Yga2V5IHBhdGggdG8gY2hpbGQuXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5TaW5nbGVDaGlsZEludG9Db250ZXh0KHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUpIHtcbiAgLy8gV2UgZm91bmQgYSBjb21wb25lbnQgaW5zdGFuY2UuXG4gIHZhciByZXN1bHQgPSB0cmF2ZXJzZUNvbnRleHQ7XG4gIHZhciBrZXlVbmlxdWUgPSByZXN1bHRbbmFtZV0gPT09IHVuZGVmaW5lZDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhrZXlVbmlxdWUsICdmbGF0dGVuQ2hpbGRyZW4oLi4uKTogRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCAnICsgJ2Alc2AuIENoaWxkIGtleXMgbXVzdCBiZSB1bmlxdWU7IHdoZW4gdHdvIGNoaWxkcmVuIHNoYXJlIGEga2V5LCBvbmx5ICcgKyAndGhlIGZpcnN0IGNoaWxkIHdpbGwgYmUgdXNlZC4nLCBuYW1lKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoa2V5VW5pcXVlICYmIGNoaWxkICE9IG51bGwpIHtcbiAgICByZXN1bHRbbmFtZV0gPSBjaGlsZDtcbiAgfVxufVxuXG4vKipcbiAqIEZsYXR0ZW5zIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC4gQW55IG51bGxcbiAqIGNoaWxkcmVuIHdpbGwgbm90IGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHRpbmcgb2JqZWN0LlxuICogQHJldHVybiB7IW9iamVjdH0gZmxhdHRlbmVkIGNoaWxkcmVuIGtleWVkIGJ5IG5hbWUuXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5DaGlsZHJlbihjaGlsZHJlbikge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgcmVzdWx0ID0ge307XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZsYXR0ZW5TaW5nbGVDaGlsZEludG9Db250ZXh0LCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW5DaGlsZHJlbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2ZsYXR0ZW5DaGlsZHJlbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBzaGFsbG93RXF1YWxcbiAqIEB0eXBlY2hlY2tzXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqL1xuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKG9iakEgPT09IG9iakIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuICB2YXIgYkhhc093blByb3BlcnR5ID0gaGFzT3duUHJvcGVydHkuYmluZChvYmpCKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghYkhhc093blByb3BlcnR5KGtleXNBW2ldKSB8fCBvYmpBW2tleXNBW2ldXSAhPT0gb2JqQltrZXlzQVtpXV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaGFsbG93RXF1YWw7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL3NoYWxsb3dFcXVhbC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEV2ZW50TGlzdGVuZXJcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ2ZianMvbGliL0V2ZW50TGlzdGVuZXInKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VIYW5kbGVzJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRUYXJnZXQnKTtcbnZhciBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uJyk7XG5cbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUgPSAxMTtcblxuLyoqXG4gKiBGaW5kcyB0aGUgcGFyZW50IFJlYWN0IGNvbXBvbmVudCBvZiBgbm9kZWAuXG4gKlxuICogQHBhcmFtIHsqfSBub2RlXG4gKiBAcmV0dXJuIHs/RE9NRXZlbnRUYXJnZXR9IFBhcmVudCBjb250YWluZXIsIG9yIGBudWxsYCBpZiB0aGUgc3BlY2lmaWVkIG5vZGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgbm90IG5lc3RlZC5cbiAqL1xuZnVuY3Rpb24gZmluZFBhcmVudChub2RlKSB7XG4gIC8vIFRPRE86IEl0IG1heSBiZSBhIGdvb2QgaWRlYSB0byBjYWNoZSB0aGlzIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgRE9NXG4gIC8vIHRyYXZlcnNhbCwgYnV0IGNhY2hpbmcgaXMgZGlmZmljdWx0IHRvIGRvIGNvcnJlY3RseSB3aXRob3V0IHVzaW5nIGFcbiAgLy8gbXV0YXRpb24gb2JzZXJ2ZXIgdG8gbGlzdGVuIGZvciBhbGwgRE9NIGNoYW5nZXMuXG4gIHZhciBub2RlSUQgPSBSZWFjdE1vdW50LmdldElEKG5vZGUpO1xuICB2YXIgcm9vdElEID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEKG5vZGVJRCk7XG4gIHZhciBjb250YWluZXIgPSBSZWFjdE1vdW50LmZpbmRSZWFjdENvbnRhaW5lckZvcklEKHJvb3RJRCk7XG4gIHZhciBwYXJlbnQgPSBSZWFjdE1vdW50LmdldEZpcnN0UmVhY3RET00oY29udGFpbmVyKTtcbiAgcmV0dXJuIHBhcmVudDtcbn1cblxuLy8gVXNlZCB0byBzdG9yZSBhbmNlc3RvciBoaWVyYXJjaHkgaW4gdG9wIGxldmVsIGNhbGxiYWNrXG5mdW5jdGlvbiBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICB0aGlzLnRvcExldmVsVHlwZSA9IHRvcExldmVsVHlwZTtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICB0aGlzLmFuY2VzdG9ycyA9IFtdO1xufVxuYXNzaWduKFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5wcm90b3R5cGUsIHtcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudG9wTGV2ZWxUeXBlID0gbnVsbDtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmFuY2VzdG9ycy5sZW5ndGggPSAwO1xuICB9XG59KTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcsIFBvb2xlZENsYXNzLnR3b0FyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWxJbXBsKGJvb2tLZWVwaW5nKSB7XG4gIC8vIFRPRE86IFJlLWVuYWJsZSBldmVudC5wYXRoIGhhbmRsaW5nXG4gIC8vXG4gIC8vIGlmIChib29rS2VlcGluZy5uYXRpdmVFdmVudC5wYXRoICYmIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LnBhdGgubGVuZ3RoID4gMSkge1xuICAvLyAgIC8vIE5ldyBicm93c2VycyBoYXZlIGEgcGF0aCBhdHRyaWJ1dGUgb24gbmF0aXZlIGV2ZW50c1xuICAvLyAgIGhhbmRsZVRvcExldmVsV2l0aFBhdGgoYm9va0tlZXBpbmcpO1xuICAvLyB9IGVsc2Uge1xuICAvLyAgIC8vIExlZ2FjeSBicm93c2VycyBkb24ndCBoYXZlIGEgcGF0aCBhdHRyaWJ1dGUgb24gbmF0aXZlIGV2ZW50c1xuICAvLyAgIGhhbmRsZVRvcExldmVsV2l0aG91dFBhdGgoYm9va0tlZXBpbmcpO1xuICAvLyB9XG5cbiAgdm9pZCBoYW5kbGVUb3BMZXZlbFdpdGhQYXRoOyAvLyB0ZW1wb3JhcmlseSB1bnVzZWRcbiAgaGFuZGxlVG9wTGV2ZWxXaXRob3V0UGF0aChib29rS2VlcGluZyk7XG59XG5cbi8vIExlZ2FjeSBicm93c2VycyBkb24ndCBoYXZlIGEgcGF0aCBhdHRyaWJ1dGUgb24gbmF0aXZlIGV2ZW50c1xuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWxXaXRob3V0UGF0aChib29rS2VlcGluZykge1xuICB2YXIgdG9wTGV2ZWxUYXJnZXQgPSBSZWFjdE1vdW50LmdldEZpcnN0UmVhY3RET00oZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKSB8fCB3aW5kb3c7XG5cbiAgLy8gTG9vcCB0aHJvdWdoIHRoZSBoaWVyYXJjaHksIGluIGNhc2UgdGhlcmUncyBhbnkgbmVzdGVkIGNvbXBvbmVudHMuXG4gIC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgd2UgYnVpbGQgdGhlIGFycmF5IG9mIGFuY2VzdG9ycyBiZWZvcmUgY2FsbGluZyBhbnlcbiAgLy8gZXZlbnQgaGFuZGxlcnMsIGJlY2F1c2UgZXZlbnQgaGFuZGxlcnMgY2FuIG1vZGlmeSB0aGUgRE9NLCBsZWFkaW5nIHRvXG4gIC8vIGluY29uc2lzdGVuY2llcyB3aXRoIFJlYWN0TW91bnQncyBub2RlIGNhY2hlLiBTZWUgIzExMDUuXG4gIHZhciBhbmNlc3RvciA9IHRvcExldmVsVGFyZ2V0O1xuICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgYW5jZXN0b3IgPSBmaW5kUGFyZW50KGFuY2VzdG9yKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYm9va0tlZXBpbmcuYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdG9wTGV2ZWxUYXJnZXQgPSBib29rS2VlcGluZy5hbmNlc3RvcnNbaV07XG4gICAgdmFyIHRvcExldmVsVGFyZ2V0SUQgPSBSZWFjdE1vdW50LmdldElEKHRvcExldmVsVGFyZ2V0KSB8fCAnJztcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsKGJvb2tLZWVwaW5nLnRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCkpO1xuICB9XG59XG5cbi8vIE5ldyBicm93c2VycyBoYXZlIGEgcGF0aCBhdHRyaWJ1dGUgb24gbmF0aXZlIGV2ZW50c1xuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWxXaXRoUGF0aChib29rS2VlcGluZykge1xuICB2YXIgcGF0aCA9IGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LnBhdGg7XG4gIHZhciBjdXJyZW50TmF0aXZlVGFyZ2V0ID0gcGF0aFswXTtcbiAgdmFyIGV2ZW50c0ZpcmVkID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGN1cnJlbnRQYXRoRWxlbWVudCA9IHBhdGhbaV07XG4gICAgaWYgKGN1cnJlbnRQYXRoRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFKSB7XG4gICAgICBjdXJyZW50TmF0aXZlVGFyZ2V0ID0gcGF0aFtpICsgMV07XG4gICAgfVxuICAgIC8vIFRPRE86IHNsb3dcbiAgICB2YXIgcmVhY3RQYXJlbnQgPSBSZWFjdE1vdW50LmdldEZpcnN0UmVhY3RET00oY3VycmVudFBhdGhFbGVtZW50KTtcbiAgICBpZiAocmVhY3RQYXJlbnQgPT09IGN1cnJlbnRQYXRoRWxlbWVudCkge1xuICAgICAgdmFyIGN1cnJlbnRQYXRoRWxlbWVudElEID0gUmVhY3RNb3VudC5nZXRJRChjdXJyZW50UGF0aEVsZW1lbnQpO1xuICAgICAgdmFyIG5ld1Jvb3RJRCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmdldFJlYWN0Um9vdElERnJvbU5vZGVJRChjdXJyZW50UGF0aEVsZW1lbnRJRCk7XG4gICAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChjdXJyZW50UGF0aEVsZW1lbnQpO1xuXG4gICAgICB2YXIgdG9wTGV2ZWxUYXJnZXRJRCA9IFJlYWN0TW91bnQuZ2V0SUQoY3VycmVudFBhdGhFbGVtZW50KSB8fCAnJztcbiAgICAgIGV2ZW50c0ZpcmVkKys7XG4gICAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsKGJvb2tLZWVwaW5nLnRvcExldmVsVHlwZSwgY3VycmVudFBhdGhFbGVtZW50LCB0b3BMZXZlbFRhcmdldElELCBib29rS2VlcGluZy5uYXRpdmVFdmVudCwgY3VycmVudE5hdGl2ZVRhcmdldCk7XG5cbiAgICAgIC8vIEp1bXAgdG8gdGhlIHJvb3Qgb2YgdGhpcyBSZWFjdCByZW5kZXIgdHJlZVxuICAgICAgd2hpbGUgKGN1cnJlbnRQYXRoRWxlbWVudElEICE9PSBuZXdSb290SUQpIHtcbiAgICAgICAgaSsrO1xuICAgICAgICBjdXJyZW50UGF0aEVsZW1lbnQgPSBwYXRoW2ldO1xuICAgICAgICBjdXJyZW50UGF0aEVsZW1lbnRJRCA9IFJlYWN0TW91bnQuZ2V0SUQoY3VycmVudFBhdGhFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGV2ZW50c0ZpcmVkID09PSAwKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbChib29rS2VlcGluZy50b3BMZXZlbFR5cGUsIHdpbmRvdywgJycsIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjcm9sbFZhbHVlTW9uaXRvcihjYikge1xuICB2YXIgc2Nyb2xsUG9zaXRpb24gPSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbih3aW5kb3cpO1xuICBjYihzY3JvbGxQb3NpdGlvbik7XG59XG5cbnZhciBSZWFjdEV2ZW50TGlzdGVuZXIgPSB7XG4gIF9lbmFibGVkOiB0cnVlLFxuICBfaGFuZGxlVG9wTGV2ZWw6IG51bGwsXG5cbiAgV0lORE9XX0hBTkRMRTogRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gd2luZG93IDogbnVsbCxcblxuICBzZXRIYW5kbGVUb3BMZXZlbDogZnVuY3Rpb24gKGhhbmRsZVRvcExldmVsKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbCA9IGhhbmRsZVRvcExldmVsO1xuICB9LFxuXG4gIHNldEVuYWJsZWQ6IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkID0gISFlbmFibGVkO1xuICB9LFxuXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXBzIHRvcC1sZXZlbCBldmVudHMgYnkgdXNpbmcgZXZlbnQgYnViYmxpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBoYW5kbGUgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICAgKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhcEJ1YmJsZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICB2YXIgZWxlbWVudCA9IGhhbmRsZTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gRXZlbnRMaXN0ZW5lci5saXN0ZW4oZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBSZWFjdEV2ZW50TGlzdGVuZXIuZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFwcyBhIHRvcC1sZXZlbCBldmVudCBieSB1c2luZyBldmVudCBjYXB0dXJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBoYW5kbGUgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICAgKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhcENhcHR1cmVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBoYW5kbGU7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEV2ZW50TGlzdGVuZXIuY2FwdHVyZShlbGVtZW50LCBoYW5kbGVyQmFzZU5hbWUsIFJlYWN0RXZlbnRMaXN0ZW5lci5kaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG4gIH0sXG5cbiAgbW9uaXRvclNjcm9sbFZhbHVlOiBmdW5jdGlvbiAocmVmcmVzaCkge1xuICAgIHZhciBjYWxsYmFjayA9IHNjcm9sbFZhbHVlTW9uaXRvci5iaW5kKG51bGwsIHJlZnJlc2gpO1xuICAgIEV2ZW50TGlzdGVuZXIubGlzdGVuKHdpbmRvdywgJ3Njcm9sbCcsIGNhbGxiYWNrKTtcbiAgfSxcblxuICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICAgIGlmICghUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJvb2tLZWVwaW5nID0gVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLmdldFBvb2xlZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgICB0cnkge1xuICAgICAgLy8gRXZlbnQgcXVldWUgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZSBzYW1lIGN5Y2xlIGFsbG93c1xuICAgICAgLy8gYHByZXZlbnREZWZhdWx0YC5cbiAgICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhoYW5kbGVUb3BMZXZlbEltcGwsIGJvb2tLZWVwaW5nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLnJlbGVhc2UoYm9va0tlZXBpbmcpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEV2ZW50TGlzdGVuZXI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEV2ZW50TGlzdGVuZXIuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50TGlzdGVuZXJcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIFVwc3RyZWFtIHZlcnNpb24gb2YgZXZlbnQgbGlzdGVuZXIuIERvZXMgbm90IHRha2UgaW50byBhY2NvdW50IHNwZWNpZmljXG4gKiBuYXR1cmUgb2YgcGxhdGZvcm0uXG4gKi9cbnZhciBFdmVudExpc3RlbmVyID0ge1xuICAvKipcbiAgICogTGlzdGVuIHRvIERPTSBldmVudHMgZHVyaW5nIHRoZSBidWJibGUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgbGlzdGVuOiBmdW5jdGlvbiAodGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0YXJnZXQuYXR0YWNoRXZlbnQpIHtcbiAgICAgIHRhcmdldC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0YXJnZXQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTGlzdGVuIHRvIERPTSBldmVudHMgZHVyaW5nIHRoZSBjYXB0dXJlIHBoYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cbiAgICovXG4gIGNhcHR1cmU6IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F0dGVtcHRlZCB0byBsaXN0ZW4gdG8gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZSBvbiBhICcgKyAnYnJvd3NlciB0aGF0IGRvZXMgbm90IHN1cHBvcnQgdGhlIGNhcHR1cmUgcGhhc2UuIFlvdXIgYXBwbGljYXRpb24gJyArICd3aWxsIG5vdCByZWNlaXZlIHNvbWUgZXZlbnRzLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBlbXB0eUZ1bmN0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICByZWdpc3RlckRlZmF1bHQ6IGZ1bmN0aW9uICgpIHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50TGlzdGVuZXI7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL0V2ZW50TGlzdGVuZXIuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb25cbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdldHMgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgc3VwcGxpZWQgZWxlbWVudCBvciB3aW5kb3cuXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZXMgYXJlIHVuYm91bmRlZCwgdW5saWtlIGBnZXRTY3JvbGxQb3NpdGlvbmAuIFRoaXMgbWVhbnMgdGhleVxuICogbWF5IGJlIG5lZ2F0aXZlIG9yIGV4Y2VlZCB0aGUgZWxlbWVudCBib3VuZGFyaWVzICh3aGljaCBpcyBwb3NzaWJsZSB1c2luZ1xuICogaW5lcnRpYWwgc2Nyb2xsaW5nKS5cbiAqXG4gKiBAcGFyYW0ge0RPTVdpbmRvd3xET01FbGVtZW50fSBzY3JvbGxhYmxlXG4gKiBAcmV0dXJuIHtvYmplY3R9IE1hcCB3aXRoIGB4YCBhbmQgYHlgIGtleXMuXG4gKi9cbmZ1bmN0aW9uIGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uKHNjcm9sbGFibGUpIHtcbiAgaWYgKHNjcm9sbGFibGUgPT09IHdpbmRvdykge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG4gICAgICB5OiB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBzY3JvbGxhYmxlLnNjcm9sbExlZnQsXG4gICAgeTogc2Nyb2xsYWJsZS5zY3JvbGxUb3BcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbmplY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RDbGFzcyA9IHJlcXVpcmUoJy4vUmVhY3RDbGFzcycpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RW1wdHlDb21wb25lbnQnKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xudmFyIFJlYWN0TmF0aXZlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdE5hdGl2ZUNvbXBvbmVudCcpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG52YXIgUmVhY3RSb290SW5kZXggPSByZXF1aXJlKCcuL1JlYWN0Um9vdEluZGV4Jyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIFJlYWN0SW5qZWN0aW9uID0ge1xuICBDb21wb25lbnQ6IFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQuaW5qZWN0aW9uLFxuICBDbGFzczogUmVhY3RDbGFzcy5pbmplY3Rpb24sXG4gIERPTVByb3BlcnR5OiBET01Qcm9wZXJ0eS5pbmplY3Rpb24sXG4gIEVtcHR5Q29tcG9uZW50OiBSZWFjdEVtcHR5Q29tcG9uZW50LmluamVjdGlvbixcbiAgRXZlbnRQbHVnaW5IdWI6IEV2ZW50UGx1Z2luSHViLmluamVjdGlvbixcbiAgRXZlbnRFbWl0dGVyOiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaW5qZWN0aW9uLFxuICBOYXRpdmVDb21wb25lbnQ6IFJlYWN0TmF0aXZlQ29tcG9uZW50LmluamVjdGlvbixcbiAgUGVyZjogUmVhY3RQZXJmLmluamVjdGlvbixcbiAgUm9vdEluZGV4OiBSZWFjdFJvb3RJbmRleC5pbmplY3Rpb24sXG4gIFVwZGF0ZXM6IFJlYWN0VXBkYXRlcy5pbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbmplY3Rpb247XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdEluamVjdGlvbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENsYXNzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25zJyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIga2V5TWlycm9yID0gcmVxdWlyZSgnZmJqcy9saWIva2V5TWlycm9yJyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBNSVhJTlNfS0VZID0ga2V5T2YoeyBtaXhpbnM6IG51bGwgfSk7XG5cbi8qKlxuICogUG9saWNpZXMgdGhhdCBkZXNjcmliZSBtZXRob2RzIGluIGBSZWFjdENsYXNzSW50ZXJmYWNlYC5cbiAqL1xudmFyIFNwZWNQb2xpY3kgPSBrZXlNaXJyb3Ioe1xuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBtYXkgYmUgZGVmaW5lZCBvbmx5IG9uY2UgYnkgdGhlIGNsYXNzIHNwZWNpZmljYXRpb24gb3IgbWl4aW4uXG4gICAqL1xuICBERUZJTkVfT05DRTogbnVsbCxcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgbWF5IGJlIGRlZmluZWQgYnkgYm90aCB0aGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBhbmQgbWl4aW5zLlxuICAgKiBTdWJzZXF1ZW50IGRlZmluaXRpb25zIHdpbGwgYmUgY2hhaW5lZC4gVGhlc2UgbWV0aG9kcyBtdXN0IHJldHVybiB2b2lkLlxuICAgKi9cbiAgREVGSU5FX01BTlk6IG51bGwsXG4gIC8qKlxuICAgKiBUaGVzZSBtZXRob2RzIGFyZSBvdmVycmlkaW5nIHRoZSBiYXNlIGNsYXNzLlxuICAgKi9cbiAgT1ZFUlJJREVfQkFTRTogbnVsbCxcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgYXJlIHNpbWlsYXIgdG8gREVGSU5FX01BTlksIGV4Y2VwdCB3ZSBhc3N1bWUgdGhleSByZXR1cm5cbiAgICogb2JqZWN0cy4gV2UgdHJ5IHRvIG1lcmdlIHRoZSBrZXlzIG9mIHRoZSByZXR1cm4gdmFsdWVzIG9mIGFsbCB0aGUgbWl4ZWQgaW5cbiAgICogZnVuY3Rpb25zLiBJZiB0aGVyZSBpcyBhIGtleSBjb25mbGljdCB3ZSB0aHJvdy5cbiAgICovXG4gIERFRklORV9NQU5ZX01FUkdFRDogbnVsbFxufSk7XG5cbnZhciBpbmplY3RlZE1peGlucyA9IFtdO1xuXG52YXIgd2FybmVkU2V0UHJvcHMgPSBmYWxzZTtcbmZ1bmN0aW9uIHdhcm5TZXRQcm9wcygpIHtcbiAgaWYgKCF3YXJuZWRTZXRQcm9wcykge1xuICAgIHdhcm5lZFNldFByb3BzID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ3NldFByb3BzKC4uLikgYW5kIHJlcGxhY2VQcm9wcyguLi4pIGFyZSBkZXByZWNhdGVkLiAnICsgJ0luc3RlYWQsIGNhbGwgcmVuZGVyIGFnYWluIGF0IHRoZSB0b3AgbGV2ZWwuJykgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBDb21wb3NpdGUgY29tcG9uZW50cyBhcmUgaGlnaGVyLWxldmVsIGNvbXBvbmVudHMgdGhhdCBjb21wb3NlIG90aGVyIGNvbXBvc2l0ZVxuICogb3IgbmF0aXZlIGNvbXBvbmVudHMuXG4gKlxuICogVG8gY3JlYXRlIGEgbmV3IHR5cGUgb2YgYFJlYWN0Q2xhc3NgLCBwYXNzIGEgc3BlY2lmaWNhdGlvbiBvZlxuICogeW91ciBuZXcgY2xhc3MgdG8gYFJlYWN0LmNyZWF0ZUNsYXNzYC4gVGhlIG9ubHkgcmVxdWlyZW1lbnQgb2YgeW91ciBjbGFzc1xuICogc3BlY2lmaWNhdGlvbiBpcyB0aGF0IHlvdSBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuXG4gKlxuICogICB2YXIgTXlDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiA8ZGl2PkhlbGxvIFdvcmxkPC9kaXY+O1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogVGhlIGNsYXNzIHNwZWNpZmljYXRpb24gc3VwcG9ydHMgYSBzcGVjaWZpYyBwcm90b2NvbCBvZiBtZXRob2RzIHRoYXQgaGF2ZVxuICogc3BlY2lhbCBtZWFuaW5nIChlLmcuIGByZW5kZXJgKS4gU2VlIGBSZWFjdENsYXNzSW50ZXJmYWNlYCBmb3JcbiAqIG1vcmUgdGhlIGNvbXByZWhlbnNpdmUgcHJvdG9jb2wuIEFueSBvdGhlciBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGluIHRoZVxuICogY2xhc3Mgc3BlY2lmaWNhdGlvbiB3aWxsIGJlIGF2YWlsYWJsZSBvbiB0aGUgcHJvdG90eXBlLlxuICpcbiAqIEBpbnRlcmZhY2UgUmVhY3RDbGFzc0ludGVyZmFjZVxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdENsYXNzSW50ZXJmYWNlID0ge1xuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBNaXhpbiBvYmplY3RzIHRvIGluY2x1ZGUgd2hlbiBkZWZpbmluZyB5b3VyIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge2FycmF5fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIG1peGluczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyBhbmQgbWV0aG9kcyB0aGF0IHNob3VsZCBiZSBkZWZpbmVkIG9uXG4gICAqIHRoZSBjb21wb25lbnQncyBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIGl0cyBwcm90b3R5cGUgKHN0YXRpYyBtZXRob2RzKS5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBzdGF0aWNzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIHByb3AgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHByb3BUeXBlczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb250ZXh0VHlwZXM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgY29udGV4dCB0eXBlcyB0aGlzIGNvbXBvbmVudCBzZXRzIGZvciBpdHMgY2hpbGRyZW4uXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY2hpbGRDb250ZXh0VHlwZXM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLy8gPT09PSBEZWZpbml0aW9uIG1ldGhvZHMgPT09PVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBWYWx1ZXMgaW4gdGhlIG1hcHBpbmcgd2lsbCBiZSBzZXQgb25cbiAgICogYHRoaXMucHJvcHNgIGlmIHRoYXQgcHJvcCBpcyBub3Qgc3BlY2lmaWVkIChpLmUuIHVzaW5nIGFuIGBpbmAgY2hlY2spLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIGJlZm9yZSBgZ2V0SW5pdGlhbFN0YXRlYCBhbmQgdGhlcmVmb3JlIGNhbm5vdCByZWx5XG4gICAqIG9uIGB0aGlzLnN0YXRlYCBvciB1c2UgYHRoaXMuc2V0U3RhdGVgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgZ2V0RGVmYXVsdFByb3BzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCxcblxuICAvKipcbiAgICogSW52b2tlZCBvbmNlIGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkXG4gICAqIGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIGB0aGlzLnN0YXRlYC5cbiAgICpcbiAgICogICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgcmV0dXJuIHtcbiAgICogICAgICAgaXNPbjogZmFsc2UsXG4gICAqICAgICAgIGZvb0JhejogbmV3IEJhekZvbygpXG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgZ2V0SW5pdGlhbFN0YXRlOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldENoaWxkQ29udGV4dDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQsXG5cbiAgLyoqXG4gICAqIFVzZXMgcHJvcHMgZnJvbSBgdGhpcy5wcm9wc2AgYW5kIHN0YXRlIGZyb20gYHRoaXMuc3RhdGVgIHRvIHJlbmRlciB0aGVcbiAgICogc3RydWN0dXJlIG9mIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIE5vIGd1YXJhbnRlZXMgYXJlIG1hZGUgYWJvdXQgd2hlbiBvciBob3cgb2Z0ZW4gdGhpcyBtZXRob2QgaXMgaW52b2tlZCwgc29cbiAgICogaXQgbXVzdCBub3QgaGF2ZSBzaWRlIGVmZmVjdHMuXG4gICAqXG4gICAqICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICogICAgIHZhciBuYW1lID0gdGhpcy5wcm9wcy5uYW1lO1xuICAgKiAgICAgcmV0dXJuIDxkaXY+SGVsbG8sIHtuYW1lfSE8L2Rpdj47XG4gICAqICAgfVxuICAgKlxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH1cbiAgICogQG5vc2lkZWVmZmVjdHNcbiAgICogQHJlcXVpcmVkXG4gICAqL1xuICByZW5kZXI6IFNwZWNQb2xpY3kuREVGSU5FX09OQ0UsXG5cbiAgLy8gPT09PSBEZWxlZ2F0ZSBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgaW5pdGlhbGx5IGNyZWF0ZWQgYW5kIGFib3V0IHRvIGJlIG1vdW50ZWQuXG4gICAqIFRoaXMgbWF5IGhhdmUgc2lkZSBlZmZlY3RzLCBidXQgYW55IGV4dGVybmFsIHN1YnNjcmlwdGlvbnMgb3IgZGF0YSBjcmVhdGVkXG4gICAqIGJ5IHRoaXMgbWV0aG9kIG11c3QgYmUgY2xlYW5lZCB1cCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgLlxuICAgKlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxNb3VudDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCBhbmQgaGFzIGEgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgKiBIb3dldmVyLCB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgRE9NIG5vZGUgaXMgaW4gdGhlIGRvY3VtZW50LlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBvcGVyYXRlIG9uIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGhhc1xuICAgKiBiZWVuIG1vdW50ZWQgKGluaXRpYWxpemVkIGFuZCByZW5kZXJlZCkgZm9yIHRoZSBmaXJzdCB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3ROb2RlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50LlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIGJlZm9yZSB0aGUgY29tcG9uZW50IHJlY2VpdmVzIG5ldyBwcm9wcy5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcmVhY3QgdG8gYSBwcm9wIHRyYW5zaXRpb24gYnkgdXBkYXRpbmcgdGhlXG4gICAqIHN0YXRlIHVzaW5nIGB0aGlzLnNldFN0YXRlYC4gQ3VycmVudCBwcm9wcyBhcmUgYWNjZXNzZWQgdmlhIGB0aGlzLnByb3BzYC5cbiAgICpcbiAgICogICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gICAqICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICogICAgICAgbGlrZXNJbmNyZWFzaW5nOiBuZXh0UHJvcHMubGlrZUNvdW50ID4gdGhpcy5wcm9wcy5saWtlQ291bnRcbiAgICogICAgIH0pO1xuICAgKiAgIH1cbiAgICpcbiAgICogTk9URTogVGhlcmUgaXMgbm8gZXF1aXZhbGVudCBgY29tcG9uZW50V2lsbFJlY2VpdmVTdGF0ZWAuIEFuIGluY29taW5nIHByb3BcbiAgICogdHJhbnNpdGlvbiBtYXkgY2F1c2UgYSBzdGF0ZSBjaGFuZ2UsIGJ1dCB0aGUgb3Bwb3NpdGUgaXMgbm90IHRydWUuIElmIHlvdVxuICAgKiBuZWVkIGl0LCB5b3UgYXJlIHByb2JhYmx5IGxvb2tpbmcgZm9yIGBjb21wb25lbnRXaWxsVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hpbGUgZGVjaWRpbmcgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgdXBkYXRlZCBhcyBhIHJlc3VsdCBvZlxuICAgKiByZWNlaXZpbmcgbmV3IHByb3BzLCBzdGF0ZSBhbmQvb3IgY29udGV4dC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gYHJldHVybiBmYWxzZWAgd2hlbiB5b3UncmUgY2VydGFpbiB0aGF0IHRoZVxuICAgKiB0cmFuc2l0aW9uIHRvIHRoZSBuZXcgcHJvcHMvc3RhdGUvY29udGV4dCB3aWxsIG5vdCByZXF1aXJlIGEgY29tcG9uZW50XG4gICAqIHVwZGF0ZS5cbiAgICpcbiAgICogICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCkge1xuICAgKiAgICAgcmV0dXJuICFlcXVhbChuZXh0UHJvcHMsIHRoaXMucHJvcHMpIHx8XG4gICAqICAgICAgICFlcXVhbChuZXh0U3RhdGUsIHRoaXMuc3RhdGUpIHx8XG4gICAqICAgICAgICFlcXVhbChuZXh0Q29udGV4dCwgdGhpcy5jb250ZXh0KTtcbiAgICogICB9XG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIHVwZGF0ZS5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBzaG91bGRDb21wb25lbnRVcGRhdGU6IFNwZWNQb2xpY3kuREVGSU5FX09OQ0UsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIHVwZGF0ZSBkdWUgdG8gYSB0cmFuc2l0aW9uIGZyb21cbiAgICogYHRoaXMucHJvcHNgLCBgdGhpcy5zdGF0ZWAgYW5kIGB0aGlzLmNvbnRleHRgIHRvIGBuZXh0UHJvcHNgLCBgbmV4dFN0YXRlYFxuICAgKiBhbmQgYG5leHRDb250ZXh0YC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcGVyZm9ybSBwcmVwYXJhdGlvbiBiZWZvcmUgYW4gdXBkYXRlIG9jY3Vycy5cbiAgICpcbiAgICogTk9URTogWW91ICoqY2Fubm90KiogdXNlIGB0aGlzLnNldFN0YXRlKClgIGluIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxVcGRhdGU6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50J3MgRE9NIHJlcHJlc2VudGF0aW9uIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIG9wZXJhdGUgb24gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaGFzXG4gICAqIGJlZW4gdXBkYXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHByZXZQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZDb250ZXh0XG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdE5vZGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50RGlkVXBkYXRlOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhYm91dCB0byBiZSByZW1vdmVkIGZyb20gaXRzIHBhcmVudCBhbmQgaGF2ZVxuICAgKiBpdHMgRE9NIHJlcHJlc2VudGF0aW9uIGRlc3Ryb3llZC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gZGVhbGxvY2F0ZSBhbnkgZXh0ZXJuYWwgcmVzb3VyY2VzLlxuICAgKlxuICAgKiBOT1RFOiBUaGVyZSBpcyBubyBgY29tcG9uZW50RGlkVW5tb3VudGAgc2luY2UgeW91ciBjb21wb25lbnQgd2lsbCBoYXZlIGJlZW5cbiAgICogZGVzdHJveWVkIGJ5IHRoYXQgcG9pbnQuXG4gICAqXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLy8gPT09PSBBZHZhbmNlZCBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY29tcG9uZW50J3MgY3VycmVudGx5IG1vdW50ZWQgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqIEBvdmVycmlkYWJsZVxuICAgKi9cbiAgdXBkYXRlQ29tcG9uZW50OiBTcGVjUG9saWN5Lk9WRVJSSURFX0JBU0VcblxufTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gY2xhc3Mgc3BlY2lmaWNhdGlvbiBrZXlzIHRvIHNwZWNpYWwgcHJvY2Vzc2luZyBmdW5jdGlvbnMuXG4gKlxuICogQWx0aG91Z2ggdGhlc2UgYXJlIGRlY2xhcmVkIGxpa2UgaW5zdGFuY2UgcHJvcGVydGllcyBpbiB0aGUgc3BlY2lmaWNhdGlvblxuICogd2hlbiBkZWZpbmluZyBjbGFzc2VzIHVzaW5nIGBSZWFjdC5jcmVhdGVDbGFzc2AsIHRoZXkgYXJlIGFjdHVhbGx5IHN0YXRpY1xuICogYW5kIGFyZSBhY2Nlc3NpYmxlIG9uIHRoZSBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIHRoZSBwcm90b3R5cGUuIERlc3BpdGVcbiAqIGJlaW5nIHN0YXRpYywgdGhleSBtdXN0IGJlIGRlZmluZWQgb3V0c2lkZSBvZiB0aGUgXCJzdGF0aWNzXCIga2V5IHVuZGVyXG4gKiB3aGljaCBhbGwgb3RoZXIgc3RhdGljIG1ldGhvZHMgYXJlIGRlZmluZWQuXG4gKi9cbnZhciBSRVNFUlZFRF9TUEVDX0tFWVMgPSB7XG4gIGRpc3BsYXlOYW1lOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGRpc3BsYXlOYW1lKSB7XG4gICAgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgfSxcbiAgbWl4aW5zOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIG1peGlucykge1xuICAgIGlmIChtaXhpbnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWl4aW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBtaXhpbnNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY2hpbGRDb250ZXh0VHlwZXM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgY2hpbGRDb250ZXh0VHlwZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jaGlsZENvbnRleHQpO1xuICAgIH1cbiAgICBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcyA9IGFzc2lnbih7fSwgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dFR5cGVzKTtcbiAgfSxcbiAgY29udGV4dFR5cGVzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGNvbnRleHRUeXBlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIGNvbnRleHRUeXBlcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jb250ZXh0KTtcbiAgICB9XG4gICAgQ29uc3RydWN0b3IuY29udGV4dFR5cGVzID0gYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMsIGNvbnRleHRUeXBlcyk7XG4gIH0sXG4gIC8qKlxuICAgKiBTcGVjaWFsIGNhc2UgZ2V0RGVmYXVsdFByb3BzIHdoaWNoIHNob3VsZCBtb3ZlIGludG8gc3RhdGljcyBidXQgcmVxdWlyZXNcbiAgICogYXV0b21hdGljIG1lcmdpbmcuXG4gICAqL1xuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24oQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzLCBnZXREZWZhdWx0UHJvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBnZXREZWZhdWx0UHJvcHM7XG4gICAgfVxuICB9LFxuICBwcm9wVHlwZXM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvcFR5cGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgcHJvcFR5cGVzLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLnByb3ApO1xuICAgIH1cbiAgICBDb25zdHJ1Y3Rvci5wcm9wVHlwZXMgPSBhc3NpZ24oe30sIENvbnN0cnVjdG9yLnByb3BUeXBlcywgcHJvcFR5cGVzKTtcbiAgfSxcbiAgc3RhdGljczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBzdGF0aWNzKSB7XG4gICAgbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpO1xuICB9LFxuICBhdXRvYmluZDogZnVuY3Rpb24gKCkge30gfTtcblxuLy8gbm9vcFxuZnVuY3Rpb24gdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCB0eXBlRGVmLCBsb2NhdGlvbikge1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiB0eXBlRGVmKSB7XG4gICAgaWYgKHR5cGVEZWYuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAvLyB1c2UgYSB3YXJuaW5nIGluc3RlYWQgb2YgYW4gaW52YXJpYW50IHNvIGNvbXBvbmVudHNcbiAgICAgIC8vIGRvbid0IHNob3cgdXAgaW4gcHJvZCBidXQgbm90IGluIF9fREVWX19cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiB0eXBlRGVmW3Byb3BOYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICdSZWFjdC5Qcm9wVHlwZXMuJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHByb3BOYW1lKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVNZXRob2RPdmVycmlkZShwcm90bywgbmFtZSkge1xuICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSkgPyBSZWFjdENsYXNzSW50ZXJmYWNlW25hbWVdIDogbnVsbDtcblxuICAvLyBEaXNhbGxvdyBvdmVycmlkaW5nIG9mIGJhc2UgY2xhc3MgbWV0aG9kcyB1bmxlc3MgZXhwbGljaXRseSBhbGxvd2VkLlxuICBpZiAoUmVhY3RDbGFzc01peGluLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgIShzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5Lk9WRVJSSURFX0JBU0UpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3NJbnRlcmZhY2U6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBvdmVycmlkZSAnICsgJ2Alc2AgZnJvbSB5b3VyIGNsYXNzIHNwZWNpZmljYXRpb24uIEVuc3VyZSB0aGF0IHlvdXIgbWV0aG9kIG5hbWVzICcgKyAnZG8gbm90IG92ZXJsYXAgd2l0aCBSZWFjdCBtZXRob2RzLicsIG5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIERpc2FsbG93IGRlZmluaW5nIG1ldGhvZHMgbW9yZSB0aGFuIG9uY2UgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgIShzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZIHx8IHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VEKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lICcgKyAnYCVzYCBvbiB5b3VyIGNvbXBvbmVudCBtb3JlIHRoYW4gb25jZS4gVGhpcyBjb25mbGljdCBtYXkgYmUgZHVlICcgKyAndG8gYSBtaXhpbi4nLCBuYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBNaXhpbiBoZWxwZXIgd2hpY2ggaGFuZGxlcyBwb2xpY3kgdmFsaWRhdGlvbiBhbmQgcmVzZXJ2ZWRcbiAqIHNwZWNpZmljYXRpb24ga2V5cyB3aGVuIGJ1aWxkaW5nIFJlYWN0IGNsYXNzc2VzLlxuICovXG5mdW5jdGlvbiBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYykge1xuICBpZiAoIXNwZWMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAhKHR5cGVvZiBzcGVjICE9PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3VcXCdyZSBhdHRlbXB0aW5nIHRvICcgKyAndXNlIGEgY29tcG9uZW50IGNsYXNzIGFzIGEgbWl4aW4uIEluc3RlYWQsIGp1c3QgdXNlIGEgcmVndWxhciBvYmplY3QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAhIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChzcGVjKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3VcXCdyZSBhdHRlbXB0aW5nIHRvICcgKyAndXNlIGEgY29tcG9uZW50IGFzIGEgbWl4aW4uIEluc3RlYWQsIGp1c3QgdXNlIGEgcmVndWxhciBvYmplY3QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIHZhciBwcm90byA9IENvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxuICAvLyBCeSBoYW5kbGluZyBtaXhpbnMgYmVmb3JlIGFueSBvdGhlciBwcm9wZXJ0aWVzLCB3ZSBlbnN1cmUgdGhlIHNhbWVcbiAgLy8gY2hhaW5pbmcgb3JkZXIgaXMgYXBwbGllZCB0byBtZXRob2RzIHdpdGggREVGSU5FX01BTlkgcG9saWN5LCB3aGV0aGVyXG4gIC8vIG1peGlucyBhcmUgbGlzdGVkIGJlZm9yZSBvciBhZnRlciB0aGVzZSBtZXRob2RzIGluIHRoZSBzcGVjLlxuICBpZiAoc3BlYy5oYXNPd25Qcm9wZXJ0eShNSVhJTlNfS0VZKSkge1xuICAgIFJFU0VSVkVEX1NQRUNfS0VZUy5taXhpbnMoQ29uc3RydWN0b3IsIHNwZWMubWl4aW5zKTtcbiAgfVxuXG4gIGZvciAodmFyIG5hbWUgaW4gc3BlYykge1xuICAgIGlmICghc3BlYy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09IE1JWElOU19LRVkpIHtcbiAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkIG1peGlucyBpbiBhIHNwZWNpYWwgY2FzZSBhYm92ZS5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wZXJ0eSA9IHNwZWNbbmFtZV07XG4gICAgdmFsaWRhdGVNZXRob2RPdmVycmlkZShwcm90bywgbmFtZSk7XG5cbiAgICBpZiAoUkVTRVJWRURfU1BFQ19LRVlTLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBSRVNFUlZFRF9TUEVDX0tFWVNbbmFtZV0oQ29uc3RydWN0b3IsIHByb3BlcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2V0dXAgbWV0aG9kcyBvbiBwcm90b3R5cGU6XG4gICAgICAvLyBUaGUgZm9sbG93aW5nIG1lbWJlciBtZXRob2RzIHNob3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBib3VuZDpcbiAgICAgIC8vIDEuIEV4cGVjdGVkIFJlYWN0Q2xhc3MgbWV0aG9kcyAoaW4gdGhlIFwiaW50ZXJmYWNlXCIpLlxuICAgICAgLy8gMi4gT3ZlcnJpZGRlbiBtZXRob2RzICh0aGF0IHdlcmUgbWl4ZWQgaW4pLlxuICAgICAgdmFyIGlzUmVhY3RDbGFzc01ldGhvZCA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gICAgICB2YXIgaXNBbHJlYWR5RGVmaW5lZCA9IHByb3RvLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgICAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgcHJvcGVydHkgPT09ICdmdW5jdGlvbic7XG4gICAgICB2YXIgc2hvdWxkQXV0b0JpbmQgPSBpc0Z1bmN0aW9uICYmICFpc1JlYWN0Q2xhc3NNZXRob2QgJiYgIWlzQWxyZWFkeURlZmluZWQgJiYgc3BlYy5hdXRvYmluZCAhPT0gZmFsc2U7XG5cbiAgICAgIGlmIChzaG91bGRBdXRvQmluZCkge1xuICAgICAgICBpZiAoIXByb3RvLl9fcmVhY3RBdXRvQmluZE1hcCkge1xuICAgICAgICAgIHByb3RvLl9fcmVhY3RBdXRvQmluZE1hcCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHByb3RvLl9fcmVhY3RBdXRvQmluZE1hcFtuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcbiAgICAgICAgICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV07XG5cbiAgICAgICAgICAvLyBUaGVzZSBjYXNlcyBzaG91bGQgYWxyZWFkeSBiZSBjYXVnaHQgYnkgdmFsaWRhdGVNZXRob2RPdmVycmlkZS5cbiAgICAgICAgICAhKGlzUmVhY3RDbGFzc01ldGhvZCAmJiAoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQgfHwgc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFVuZXhwZWN0ZWQgc3BlYyBwb2xpY3kgJXMgZm9yIGtleSAlcyAnICsgJ3doZW4gbWl4aW5nIGluIGNvbXBvbmVudCBzcGVjcy4nLCBzcGVjUG9saWN5LCBuYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAvLyBGb3IgbWV0aG9kcyB3aGljaCBhcmUgZGVmaW5lZCBtb3JlIHRoYW4gb25jZSwgY2FsbCB0aGUgZXhpc3RpbmdcbiAgICAgICAgICAvLyBtZXRob2RzIGJlZm9yZSBjYWxsaW5nIHRoZSBuZXcgcHJvcGVydHksIG1lcmdpbmcgaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgICAgaWYgKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VEKSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKHByb3RvW25hbWVdLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZKSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZUNoYWluZWRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBBZGQgdmVyYm9zZSBkaXNwbGF5TmFtZSB0byB0aGUgZnVuY3Rpb24sIHdoaWNoIGhlbHBzIHdoZW4gbG9va2luZ1xuICAgICAgICAgICAgLy8gYXQgcHJvZmlsaW5nIHRvb2xzLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJyAmJiBzcGVjLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICAgIHByb3RvW25hbWVdLmRpc3BsYXlOYW1lID0gc3BlYy5kaXNwbGF5TmFtZSArICdfJyArIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKSB7XG4gIGlmICghc3RhdGljcykge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBuYW1lIGluIHN0YXRpY3MpIHtcbiAgICB2YXIgcHJvcGVydHkgPSBzdGF0aWNzW25hbWVdO1xuICAgIGlmICghc3RhdGljcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGlzUmVzZXJ2ZWQgPSAobmFtZSBpbiBSRVNFUlZFRF9TUEVDX0tFWVMpO1xuICAgICEhaXNSZXNlcnZlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lIGEgcmVzZXJ2ZWQgJyArICdwcm9wZXJ0eSwgYCVzYCwgdGhhdCBzaG91bGRuXFwndCBiZSBvbiB0aGUgXCJzdGF0aWNzXCIga2V5LiBEZWZpbmUgaXQgJyArICdhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBpbnN0ZWFkOyBpdCB3aWxsIHN0aWxsIGJlIGFjY2Vzc2libGUgb24gdGhlICcgKyAnY29uc3RydWN0b3IuJywgbmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGlzSW5oZXJpdGVkID0gKG5hbWUgaW4gQ29uc3RydWN0b3IpO1xuICAgICEhaXNJbmhlcml0ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSAnICsgJ2Alc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgY29uZmxpY3QgbWF5IGJlICcgKyAnZHVlIHRvIGEgbWl4aW4uJywgbmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIENvbnN0cnVjdG9yW25hbWVdID0gcHJvcGVydHk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb2JqZWN0cywgYnV0IHRocm93IGlmIGJvdGggY29udGFpbiB0aGUgc2FtZSBrZXkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9uZSBUaGUgZmlyc3Qgb2JqZWN0LCB3aGljaCBpcyBtdXRhdGVkLlxuICogQHBhcmFtIHtvYmplY3R9IHR3byBUaGUgc2Vjb25kIG9iamVjdFxuICogQHJldHVybiB7b2JqZWN0fSBvbmUgYWZ0ZXIgaXQgaGFzIGJlZW4gbXV0YXRlZCB0byBjb250YWluIGV2ZXJ5dGhpbmcgaW4gdHdvLlxuICovXG5mdW5jdGlvbiBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKG9uZSwgdHdvKSB7XG4gICEob25lICYmIHR3byAmJiB0eXBlb2Ygb25lID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdHdvID09PSAnb2JqZWN0JykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cygpOiBDYW5ub3QgbWVyZ2Ugbm9uLW9iamVjdHMuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIGZvciAodmFyIGtleSBpbiB0d28pIHtcbiAgICBpZiAodHdvLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICEob25lW2tleV0gPT09IHVuZGVmaW5lZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cygpOiAnICsgJ1RyaWVkIHRvIG1lcmdlIHR3byBvYmplY3RzIHdpdGggdGhlIHNhbWUga2V5OiBgJXNgLiBUaGlzIGNvbmZsaWN0ICcgKyAnbWF5IGJlIGR1ZSB0byBhIG1peGluOyBpbiBwYXJ0aWN1bGFyLCB0aGlzIG1heSBiZSBjYXVzZWQgYnkgdHdvICcgKyAnZ2V0SW5pdGlhbFN0YXRlKCkgb3IgZ2V0RGVmYXVsdFByb3BzKCkgbWV0aG9kcyByZXR1cm5pbmcgb2JqZWN0cyAnICsgJ3dpdGggY2xhc2hpbmcga2V5cy4nLCBrZXkpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIG9uZVtrZXldID0gdHdvW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvbmU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0d28gZnVuY3Rpb25zIGFuZCBtZXJnZXMgdGhlaXIgcmV0dXJuIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHdvIEZ1bmN0aW9uIHRvIGludm9rZSBzZWNvbmQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZFJlc3VsdCgpIHtcbiAgICB2YXIgYSA9IG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHZhciBiID0gdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGEgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfSBlbHNlIGlmIChiID09IG51bGwpIHtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICB2YXIgYyA9IHt9O1xuICAgIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoYywgYSk7XG4gICAgbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhjLCBiKTtcbiAgICByZXR1cm4gYztcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIGlnbm9yZXMgdGhlaXIgcmV0dXJuIHZhbGVzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHR3byBhcmd1bWVudCBmdW5jdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNoYWluZWRGdW5jdGlvbigpIHtcbiAgICBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBCaW5kcyBhIG1ldGhvZCB0byB0aGUgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnQgQ29tcG9uZW50IHdob3NlIG1ldGhvZCBpcyBnb2luZyB0byBiZSBib3VuZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZXRob2QgdG8gYmUgYm91bmQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGJvdW5kIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKSB7XG4gIHZhciBib3VuZE1ldGhvZCA9IG1ldGhvZC5iaW5kKGNvbXBvbmVudCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQXJndW1lbnRzID0gbnVsbDtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZTtcbiAgICB2YXIgX2JpbmQgPSBib3VuZE1ldGhvZC5iaW5kO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIGJsb2NrLXNjb3BlZC12YXIsIG5vLXVuZGVmICovXG4gICAgYm91bmRNZXRob2QuYmluZCA9IGZ1bmN0aW9uIChuZXdUaGlzKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZXIgaXMgdHJ5aW5nIHRvIGJpbmQoKSBhbiBhdXRvYm91bmQgbWV0aG9kOyB3ZSBlZmZlY3RpdmVseSB3aWxsXG4gICAgICAvLyBpZ25vcmUgdGhlIHZhbHVlIG9mIFwidGhpc1wiIHRoYXQgdGhlIHVzZXIgaXMgdHJ5aW5nIHRvIHVzZSwgc29cbiAgICAgIC8vIGxldCdzIHdhcm4uXG4gICAgICBpZiAobmV3VGhpcyAhPT0gY29tcG9uZW50ICYmIG5ld1RoaXMgIT09IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdiaW5kKCk6IFJlYWN0IGNvbXBvbmVudCBtZXRob2RzIG1heSBvbmx5IGJlIGJvdW5kIHRvIHRoZSAnICsgJ2NvbXBvbmVudCBpbnN0YW5jZS4gU2VlICVzJywgY29tcG9uZW50TmFtZSkgOiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2UgaWYgKCFhcmdzLmxlbmd0aCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2JpbmQoKTogWW91IGFyZSBiaW5kaW5nIGEgY29tcG9uZW50IG1ldGhvZCB0byB0aGUgY29tcG9uZW50LiAnICsgJ1JlYWN0IGRvZXMgdGhpcyBmb3IgeW91IGF1dG9tYXRpY2FsbHkgaW4gYSBoaWdoLXBlcmZvcm1hbmNlICcgKyAnd2F5LCBzbyB5b3UgY2FuIHNhZmVseSByZW1vdmUgdGhpcyBjYWxsLiBTZWUgJXMnLCBjb21wb25lbnROYW1lKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGJvdW5kTWV0aG9kO1xuICAgICAgfVxuICAgICAgdmFyIHJlYm91bmRNZXRob2QgPSBfYmluZC5hcHBseShib3VuZE1ldGhvZCwgYXJndW1lbnRzKTtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kTWV0aG9kID0gbWV0aG9kO1xuICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBhcmdzO1xuICAgICAgcmV0dXJuIHJlYm91bmRNZXRob2Q7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG4gICAgfTtcbiAgfVxuICByZXR1cm4gYm91bmRNZXRob2Q7XG59XG5cbi8qKlxuICogQmluZHMgYWxsIGF1dG8tYm91bmQgbWV0aG9kcyBpbiBhIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCB3aG9zZSBtZXRob2QgaXMgZ29pbmcgdG8gYmUgYm91bmQuXG4gKi9cbmZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZHMoY29tcG9uZW50KSB7XG4gIGZvciAodmFyIGF1dG9CaW5kS2V5IGluIGNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRNYXApIHtcbiAgICBpZiAoY29tcG9uZW50Ll9fcmVhY3RBdXRvQmluZE1hcC5oYXNPd25Qcm9wZXJ0eShhdXRvQmluZEtleSkpIHtcbiAgICAgIHZhciBtZXRob2QgPSBjb21wb25lbnQuX19yZWFjdEF1dG9CaW5kTWFwW2F1dG9CaW5kS2V5XTtcbiAgICAgIGNvbXBvbmVudFthdXRvQmluZEtleV0gPSBiaW5kQXV0b0JpbmRNZXRob2QoY29tcG9uZW50LCBtZXRob2QpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFkZCBtb3JlIHRvIHRoZSBSZWFjdENsYXNzIGJhc2UgY2xhc3MuIFRoZXNlIGFyZSBhbGwgbGVnYWN5IGZlYXR1cmVzIGFuZFxuICogdGhlcmVmb3JlIG5vdCBhbHJlYWR5IHBhcnQgb2YgdGhlIG1vZGVybiBSZWFjdENvbXBvbmVudC5cbiAqL1xudmFyIFJlYWN0Q2xhc3NNaXhpbiA9IHtcblxuICAvKipcbiAgICogVE9ETzogVGhpcyB3aWxsIGJlIGRlcHJlY2F0ZWQgYmVjYXVzZSBzdGF0ZSBzaG91bGQgYWx3YXlzIGtlZXAgYSBjb25zaXN0ZW50XG4gICAqIHR5cGUgc2lnbmF0dXJlIGFuZCB0aGUgb25seSB1c2UgY2FzZSBmb3IgdGhpcywgaXMgdG8gYXZvaWQgdGhhdC5cbiAgICovXG4gIHJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKG5ld1N0YXRlLCBjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKHRoaXMsIG5ld1N0YXRlKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2spO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZXIuaXNNb3VudGVkKHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBwcm9wcy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxQcm9wcyBTdWJzZXQgb2YgdGhlIG5leHQgcHJvcHMuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgcHJvcHMgYXJlIHVwZGF0ZWQuXG4gICAqIEBmaW5hbFxuICAgKiBAcHVibGljXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBzZXRQcm9wczogZnVuY3Rpb24gKHBhcnRpYWxQcm9wcywgY2FsbGJhY2spIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FyblNldFByb3BzKCk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0UHJvcHModGhpcywgcGFydGlhbFByb3BzKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2spO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZSBhbGwgdGhlIHByb3BzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV3UHJvcHMgU3Vic2V0IG9mIHRoZSBuZXh0IHByb3BzLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHByb3BzIGFyZSB1cGRhdGVkLlxuICAgKiBAZmluYWxcbiAgICogQHB1YmxpY1xuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgcmVwbGFjZVByb3BzOiBmdW5jdGlvbiAobmV3UHJvcHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm5TZXRQcm9wcygpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VQcm9wcyh0aGlzLCBuZXdQcm9wcyk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBSZWFjdENsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge307XG5hc3NpZ24oUmVhY3RDbGFzc0NvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RDbGFzc01peGluKTtcblxuLyoqXG4gKiBNb2R1bGUgZm9yIGNyZWF0aW5nIGNvbXBvc2l0ZSBjb21wb25lbnRzLlxuICpcbiAqIEBjbGFzcyBSZWFjdENsYXNzXG4gKi9cbnZhciBSZWFjdENsYXNzID0ge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY29tcG9zaXRlIGNvbXBvbmVudCBjbGFzcyBnaXZlbiBhIGNsYXNzIHNwZWNpZmljYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzcGVjIENsYXNzIHNwZWNpZmljYXRpb24gKHdoaWNoIG11c3QgZGVmaW5lIGByZW5kZXJgKS5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IENvbXBvbmVudCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY3JlYXRlQ2xhc3M6IGZ1bmN0aW9uIChzcGVjKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gICAgICAvLyBUaGlzIGNvbnN0cnVjdG9yIGlzIG92ZXJyaWRkZW4gYnkgbW9ja3MuIFRoZSBhcmd1bWVudCBpcyB1c2VkXG4gICAgICAvLyBieSBtb2NrcyB0byBhc3NlcnQgb24gd2hhdCBnZXRzIG1vdW50ZWQuXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHRoaXMgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvciwgJ1NvbWV0aGluZyBpcyBjYWxsaW5nIGEgUmVhY3QgY29tcG9uZW50IGRpcmVjdGx5LiBVc2UgYSBmYWN0b3J5IG9yICcgKyAnSlNYIGluc3RlYWQuIFNlZTogaHR0cHM6Ly9mYi5tZS9yZWFjdC1sZWdhY3lmYWN0b3J5JykgOiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIFdpcmUgdXAgYXV0by1iaW5kaW5nXG4gICAgICBpZiAodGhpcy5fX3JlYWN0QXV0b0JpbmRNYXApIHtcbiAgICAgICAgYmluZEF1dG9CaW5kTWV0aG9kcyh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcblxuICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG5cbiAgICAgIC8vIFJlYWN0Q2xhc3NlcyBkb2Vzbid0IGhhdmUgY29uc3RydWN0b3JzLiBJbnN0ZWFkLCB0aGV5IHVzZSB0aGVcbiAgICAgIC8vIGdldEluaXRpYWxTdGF0ZSBhbmQgY29tcG9uZW50V2lsbE1vdW50IG1ldGhvZHMgZm9yIGluaXRpYWxpemF0aW9uLlxuXG4gICAgICB2YXIgaW5pdGlhbFN0YXRlID0gdGhpcy5nZXRJbml0aWFsU3RhdGUgPyB0aGlzLmdldEluaXRpYWxTdGF0ZSgpIDogbnVsbDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgICBpZiAodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5nZXRJbml0aWFsU3RhdGUuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBiYWQgcHJhY3RpY2UuIENvbnNpZGVyIHdhcm5pbmcgaGVyZSBhbmRcbiAgICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxuICAgICAgICAgIGluaXRpYWxTdGF0ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICEodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5pdGlhbFN0YXRlKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0SW5pdGlhbFN0YXRlKCk6IG11c3QgcmV0dXJuIGFuIG9iamVjdCBvciBudWxsJywgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgIH07XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gbmV3IFJlYWN0Q2xhc3NDb21wb25lbnQoKTtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcblxuICAgIGluamVjdGVkTWl4aW5zLmZvckVhY2gobWl4U3BlY0ludG9Db21wb25lbnQuYmluZChudWxsLCBDb25zdHJ1Y3RvcikpO1xuXG4gICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgZGVmYXVsdFByb3BzIHByb3BlcnR5IGFmdGVyIGFsbCBtaXhpbnMgaGF2ZSBiZWVuIG1lcmdlZC5cbiAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICBDb25zdHJ1Y3Rvci5kZWZhdWx0UHJvcHMgPSBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMoKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gVGhpcyBpcyBhIHRhZyB0byBpbmRpY2F0ZSB0aGF0IHRoZSB1c2Ugb2YgdGhlc2UgbWV0aG9kIG5hbWVzIGlzIG9rLFxuICAgICAgLy8gc2luY2UgaXQncyB1c2VkIHdpdGggY3JlYXRlQ2xhc3MuIElmIGl0J3Mgbm90LCB0aGVuIGl0J3MgbGlrZWx5IGFcbiAgICAgIC8vIG1pc3Rha2Ugc28gd2UnbGwgd2FybiB5b3UgdG8gdXNlIHRoZSBzdGF0aWMgcHJvcGVydHksIHByb3BlcnR5XG4gICAgICAvLyBpbml0aWFsaXplciBvciBjb25zdHJ1Y3RvciByZXNwZWN0aXZlbHkuXG4gICAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKENvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGUpIHtcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCA9IHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgICFDb25zdHJ1Y3Rvci5wcm90b3R5cGUucmVuZGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZUNsYXNzKC4uLik6IENsYXNzIHNwZWNpZmljYXRpb24gbXVzdCBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcG9uZW50U2hvdWxkVXBkYXRlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/Jywgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBSZWR1Y2UgdGltZSBzcGVudCBkb2luZyBsb29rdXBzIGJ5IHNldHRpbmcgdGhlc2Ugb24gdGhlIHByb3RvdHlwZS5cbiAgICBmb3IgKHZhciBtZXRob2ROYW1lIGluIFJlYWN0Q2xhc3NJbnRlcmZhY2UpIHtcbiAgICAgIGlmICghQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9LFxuXG4gIGluamVjdGlvbjoge1xuICAgIGluamVjdE1peGluOiBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICAgIGluamVjdGVkTWl4aW5zLnB1c2gobWl4aW4pO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2xhc3M7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdENsYXNzLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gUmVhY3RDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAhKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3NldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgJyArICdmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHBhcnRpYWxTdGF0ZSAhPSBudWxsLCAnc2V0U3RhdGUoLi4uKTogWW91IHBhc3NlZCBhbiB1bmRlZmluZWQgb3IgbnVsbCBzdGF0ZSBvYmplY3Q7ICcgKyAnaW5zdGVhZCwgdXNlIGZvcmNlVXBkYXRlKCkuJykgOiB1bmRlZmluZWQ7XG4gIH1cbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBnZXRET01Ob2RlOiBbJ2dldERPTU5vZGUnLCAnVXNlIFJlYWN0RE9NLmZpbmRET01Ob2RlKGNvbXBvbmVudCkgaW5zdGVhZC4nXSxcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVByb3BzOiBbJ3JlcGxhY2VQcm9wcycsICdJbnN0ZWFkLCBjYWxsIHJlbmRlciBhZ2FpbiBhdCB0aGUgdG9wIGxldmVsLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddLFxuICAgIHNldFByb3BzOiBbJ3NldFByb3BzJywgJ0luc3RlYWQsIGNhbGwgcmVuZGVyIGFnYWluIGF0IHRoZSB0b3AgbGV2ZWwuJ11cbiAgfTtcbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhY3RDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXMnLCBpbmZvWzBdLCBpbmZvWzFdKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE5vb3BVcGRhdGVRdWV1ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIHdhcm5URFoocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gJyArICdUaGlzIGlzIGEgbm8tb3AuIFBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvciAmJiBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnJykgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBhbGwgdGhlIHBlbmRpbmcgdXBkYXRlc1xuICAgKiBoYXZlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gdXNlIGFzIGB0aGlzYCBjb250ZXh0LlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUNhbGxiYWNrOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrKSB7fSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHdhcm5URFoocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKSB7XG4gICAgd2FyblREWihwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSkge1xuICAgIHdhcm5URFoocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBwcm9wcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsUHJvcHMgU3Vic2V0IG9mIHRoZSBuZXh0IHByb3BzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRQcm9wczogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsUHJvcHMpIHtcbiAgICB3YXJuVERaKHB1YmxpY0luc3RhbmNlLCAnc2V0UHJvcHMnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBwcm9wcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBOZXcgcHJvcHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VQcm9wczogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwcm9wcykge1xuICAgIHdhcm5URFoocHVibGljSW5zdGFuY2UsICdyZXBsYWNlUHJvcHMnKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3ROb29wVXBkYXRlUXVldWUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvblxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZSgnLi9DYWxsYmFja1F1ZXVlJyk7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdERPTUZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RET01GZWF0dXJlRmxhZ3MnKTtcbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdElucHV0U2VsZWN0aW9uJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcblxuLyoqXG4gKiBFbnN1cmVzIHRoYXQsIHdoZW4gcG9zc2libGUsIHRoZSBzZWxlY3Rpb24gcmFuZ2UgKGN1cnJlbnRseSBzZWxlY3RlZCB0ZXh0XG4gKiBpbnB1dCkgaXMgbm90IGRpc3R1cmJlZCBieSBwZXJmb3JtaW5nIHRoZSB0cmFuc2FjdGlvbi5cbiAqL1xudmFyIFNFTEVDVElPTl9SRVNUT1JBVElPTiA9IHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge1NlbGVjdGlvbn0gU2VsZWN0aW9uIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5nZXRTZWxlY3Rpb25JbmZvcm1hdGlvbixcbiAgLyoqXG4gICAqIEBwYXJhbSB7U2VsZWN0aW9ufSBzZWwgU2VsZWN0aW9uIGluZm9ybWF0aW9uIHJldHVybmVkIGZyb20gYGluaXRpYWxpemVgLlxuICAgKi9cbiAgY2xvc2U6IFJlYWN0SW5wdXRTZWxlY3Rpb24ucmVzdG9yZVNlbGVjdGlvblxufTtcblxuLyoqXG4gKiBTdXBwcmVzc2VzIGV2ZW50cyAoYmx1ci9mb2N1cykgdGhhdCBjb3VsZCBiZSBpbmFkdmVydGVudGx5IGRpc3BhdGNoZWQgZHVlIHRvXG4gKiBoaWdoIGxldmVsIERPTSBtYW5pcHVsYXRpb25zIChsaWtlIHRlbXBvcmFyaWx5IHJlbW92aW5nIGEgdGV4dCBpbnB1dCBmcm9tIHRoZVxuICogRE9NKS5cbiAqL1xudmFyIEVWRU5UX1NVUFBSRVNTSU9OID0ge1xuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGVuYWJsZWQgc3RhdHVzIG9mIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGJlZm9yZVxuICAgKiB0aGUgcmVjb25jaWxpYXRpb24uXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN1cnJlbnRseUVuYWJsZWQgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaXNFbmFibGVkKCk7XG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnNldEVuYWJsZWQoZmFsc2UpO1xuICAgIHJldHVybiBjdXJyZW50bHlFbmFibGVkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByZXZpb3VzbHlFbmFibGVkIEVuYWJsZWQgc3RhdHVzIG9mXG4gICAqICAgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgYmVmb3JlIHRoZSByZWNvbmNpbGlhdGlvbiBvY2N1cnJlZC4gYGNsb3NlYFxuICAgKiAgIHJlc3RvcmVzIHRoZSBwcmV2aW91cyB2YWx1ZS5cbiAgICovXG4gIGNsb3NlOiBmdW5jdGlvbiAocHJldmlvdXNseUVuYWJsZWQpIHtcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuc2V0RW5hYmxlZChwcmV2aW91c2x5RW5hYmxlZCk7XG4gIH1cbn07XG5cbi8qKlxuICogUHJvdmlkZXMgYSBxdWV1ZSBmb3IgY29sbGVjdGluZyBgY29tcG9uZW50RGlkTW91bnRgIGFuZFxuICogYGNvbXBvbmVudERpZFVwZGF0ZWAgY2FsbGJhY2tzIGR1cmluZyB0aGUgdGhlIHRyYW5zYWN0aW9uLlxuICovXG52YXIgT05fRE9NX1JFQURZX1FVRVVFSU5HID0ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGludGVybmFsIGBvbkRPTVJlYWR5YCBxdWV1ZS5cbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5yZXNldCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZnRlciBET00gaXMgZmx1c2hlZCwgaW52b2tlIGFsbCByZWdpc3RlcmVkIGBvbkRPTVJlYWR5YCBjYWxsYmFja3MuXG4gICAqL1xuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5Lm5vdGlmeUFsbCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVkIHdpdGhpbiB0aGUgc2NvcGUgb2YgdGhlIGBUcmFuc2FjdGlvbmAgaW5zdGFuY2UuIENvbnNpZGVyIHRoZXNlIGFzXG4gKiBiZWluZyBtZW1iZXIgbWV0aG9kcywgYnV0IHdpdGggYW4gaW1wbGllZCBvcmRlcmluZyB3aGlsZSBiZWluZyBpc29sYXRlZCBmcm9tXG4gKiBlYWNoIG90aGVyLlxuICovXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbU0VMRUNUSU9OX1JFU1RPUkFUSU9OLCBFVkVOVF9TVVBQUkVTU0lPTiwgT05fRE9NX1JFQURZX1FVRVVFSU5HXTtcblxuLyoqXG4gKiBDdXJyZW50bHk6XG4gKiAtIFRoZSBvcmRlciB0aGF0IHRoZXNlIGFyZSBsaXN0ZWQgaW4gdGhlIHRyYW5zYWN0aW9uIGlzIGNyaXRpY2FsOlxuICogLSBTdXBwcmVzc2VzIGV2ZW50cy5cbiAqIC0gUmVzdG9yZXMgc2VsZWN0aW9uIHJhbmdlLlxuICpcbiAqIEZ1dHVyZTpcbiAqIC0gUmVzdG9yZSBkb2N1bWVudC9vdmVyZmxvdyBzY3JvbGwgcG9zaXRpb25zIHRoYXQgd2VyZSB1bmludGVudGlvbmFsbHlcbiAqICAgbW9kaWZpZWQgdmlhIERPTSBpbnNlcnRpb25zIGFib3ZlIHRoZSB0b3Agdmlld3BvcnQgYm91bmRhcnkuXG4gKiAtIEltcGxlbWVudC9pbnRlZ3JhdGUgd2l0aCBjdXN0b21pemVkIGNvbnN0cmFpbnQgYmFzZWQgbGF5b3V0IHN5c3RlbSBhbmQga2VlcFxuICogICB0cmFjayBvZiB3aGljaCBkaW1lbnNpb25zIG11c3QgYmUgcmVtZWFzdXJlZC5cbiAqXG4gKiBAY2xhc3MgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvblxuICovXG5mdW5jdGlvbiBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uKGZvcmNlSFRNTCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG4gIC8vIE9ubHkgc2VydmVyLXNpZGUgcmVuZGVyaW5nIHJlYWxseSBuZWVkcyB0aGlzIG9wdGlvbiAoc2VlXG4gIC8vIGBSZWFjdFNlcnZlclJlbmRlcmluZ2ApLCBidXQgc2VydmVyLXNpZGUgdXNlc1xuICAvLyBgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbmAgaW5zdGVhZC4gVGhpcyBvcHRpb24gaXMgaGVyZSBzbyB0aGF0IGl0J3NcbiAgLy8gYWNjZXNzaWJsZSBhbmQgZGVmYXVsdHMgdG8gZmFsc2Ugd2hlbiBgUmVhY3RET01Db21wb25lbnRgIGFuZFxuICAvLyBgUmVhY3RUZXh0Q29tcG9uZW50YCBjaGVja3MgaXQgaW4gYG1vdW50Q29tcG9uZW50YC5gXG4gIHRoaXMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSBmYWxzZTtcbiAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZChudWxsKTtcbiAgdGhpcy51c2VDcmVhdGVFbGVtZW50ID0gIWZvcmNlSFRNTCAmJiBSZWFjdERPTUZlYXR1cmVGbGFncy51c2VDcmVhdGVFbGVtZW50O1xufVxuXG52YXIgTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBAc2VlIFRyYW5zYWN0aW9uXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAZmluYWxcbiAgICogQHJldHVybiB7YXJyYXk8b2JqZWN0Pn0gTGlzdCBvZiBvcGVyYXRpb24gd3JhcCBwcm9jZWR1cmVzLlxuICAgKiAgIFRPRE86IGNvbnZlcnQgdG8gYXJyYXk8VHJhbnNhY3Rpb25XcmFwcGVyPlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBgb25ET01SZWFkeWAgY2FsbGJhY2tzIHdpdGguXG4gICAqL1xuICBnZXRSZWFjdE1vdW50UmVhZHk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFjdE1vdW50UmVhZHk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIHRoaXMsIGFuZCB3aWxsIGludm9rZSB0aGlzIGJlZm9yZSBhbGxvd2luZyB0aGlzXG4gICAqIGluc3RhbmNlIHRvIGJlIHJldXNlZC5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UodGhpcy5yZWFjdE1vdW50UmVhZHkpO1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5ID0gbnVsbDtcbiAgfVxufTtcblxuYXNzaWduKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbi5NaXhpbiwgTWl4aW4pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbnB1dFNlbGVjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NU2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdERPTVNlbGVjdGlvbicpO1xuXG52YXIgY29udGFpbnNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvY29udGFpbnNOb2RlJyk7XG52YXIgZm9jdXNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvZm9jdXNOb2RlJyk7XG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQnKTtcblxuZnVuY3Rpb24gaXNJbkRvY3VtZW50KG5vZGUpIHtcbiAgcmV0dXJuIGNvbnRhaW5zTm9kZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIG5vZGUpO1xufVxuXG4vKipcbiAqIEBSZWFjdElucHV0U2VsZWN0aW9uOiBSZWFjdCBpbnB1dCBzZWxlY3Rpb24gbW9kdWxlLiBCYXNlZCBvbiBTZWxlY3Rpb24uanMsXG4gKiBidXQgbW9kaWZpZWQgdG8gYmUgc3VpdGFibGUgZm9yIHJlYWN0IGFuZCBoYXMgYSBjb3VwbGUgb2YgYnVnIGZpeGVzIChkb2Vzbid0XG4gKiBhc3N1bWUgYnV0dG9ucyBoYXZlIHJhbmdlIHNlbGVjdGlvbnMgYWxsb3dlZCkuXG4gKiBJbnB1dCBzZWxlY3Rpb24gbW9kdWxlIGZvciBSZWFjdC5cbiAqL1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSB7XG5cbiAgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIG5vZGVOYW1lICYmIChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICd0ZXh0JyB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCBlbGVtLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKTtcbiAgfSxcblxuICBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBmb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgZm9jdXNlZEVsZW06IGZvY3VzZWRFbGVtLFxuICAgICAgc2VsZWN0aW9uUmFuZ2U6IFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGZvY3VzZWRFbGVtKSA/IFJlYWN0SW5wdXRTZWxlY3Rpb24uZ2V0U2VsZWN0aW9uKGZvY3VzZWRFbGVtKSA6IG51bGxcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcbiAgICogcmVzdG9yZSBpdC4gVGhpcyBpcyB1c2VmdWwgd2hlbiBwZXJmb3JtaW5nIG9wZXJhdGlvbnMgdGhhdCBjb3VsZCByZW1vdmUgZG9tXG4gICAqIG5vZGVzIGFuZCBwbGFjZSB0aGVtIGJhY2sgaW4sIHJlc3VsdGluZyBpbiBmb2N1cyBiZWluZyBsb3N0LlxuICAgKi9cbiAgcmVzdG9yZVNlbGVjdGlvbjogZnVuY3Rpb24gKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pIHtcbiAgICB2YXIgY3VyRm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gICAgdmFyIHByaW9yRm9jdXNlZEVsZW0gPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLmZvY3VzZWRFbGVtO1xuICAgIHZhciBwcmlvclNlbGVjdGlvblJhbmdlID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5zZWxlY3Rpb25SYW5nZTtcbiAgICBpZiAoY3VyRm9jdXNlZEVsZW0gIT09IHByaW9yRm9jdXNlZEVsZW0gJiYgaXNJbkRvY3VtZW50KHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgICBpZiAoUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgICAgUmVhY3RJbnB1dFNlbGVjdGlvbi5zZXRTZWxlY3Rpb24ocHJpb3JGb2N1c2VkRWxlbSwgcHJpb3JTZWxlY3Rpb25SYW5nZSk7XG4gICAgICB9XG4gICAgICBmb2N1c05vZGUocHJpb3JGb2N1c2VkRWxlbSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAZ2V0U2VsZWN0aW9uOiBHZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgZm9jdXNlZCB0ZXh0YXJlYSwgaW5wdXQgb3JcbiAgICogY29udGVudEVkaXRhYmxlIG5vZGUuXG4gICAqIC1AaW5wdXQ6IExvb2sgdXAgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0XG4gICAqIC1AcmV0dXJuIHtzdGFydDogc2VsZWN0aW9uU3RhcnQsIGVuZDogc2VsZWN0aW9uRW5kfVxuICAgKi9cbiAgZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICB2YXIgc2VsZWN0aW9uO1xuXG4gICAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICAgIC8vIE1vZGVybiBicm93c2VyIHdpdGggaW5wdXQgb3IgdGV4dGFyZWEuXG4gICAgICBzZWxlY3Rpb24gPSB7XG4gICAgICAgIHN0YXJ0OiBpbnB1dC5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgZW5kOiBpbnB1dC5zZWxlY3Rpb25FbmRcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24gJiYgKGlucHV0Lm5vZGVOYW1lICYmIGlucHV0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcpKSB7XG4gICAgICAvLyBJRTggaW5wdXQuXG4gICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgIC8vIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBzZWxlY3Rpb24gcGVyIGRvY3VtZW50IGluIElFLCBzbyBpdCBtdXN0XG4gICAgICAvLyBiZSBpbiBvdXIgZWxlbWVudC5cbiAgICAgIGlmIChyYW5nZS5wYXJlbnRFbGVtZW50KCkgPT09IGlucHV0KSB7XG4gICAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgICBzdGFydDogLXJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aCksXG4gICAgICAgICAgZW5kOiAtcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udGVudCBlZGl0YWJsZSBvciBvbGQgSUUgdGV4dGFyZWEuXG4gICAgICBzZWxlY3Rpb24gPSBSZWFjdERPTVNlbGVjdGlvbi5nZXRPZmZzZXRzKGlucHV0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZWN0aW9uIHx8IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAc2V0U2VsZWN0aW9uOiBTZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgdGV4dGFyZWEgb3IgaW5wdXQgYW5kIGZvY3VzZXNcbiAgICogdGhlIGlucHV0LlxuICAgKiAtQGlucHV0ICAgICBTZXQgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0IG9yIHRleHRhcmVhXG4gICAqIC1Ab2Zmc2V0cyAgIE9iamVjdCBvZiBzYW1lIGZvcm0gdGhhdCBpcyByZXR1cm5lZCBmcm9tIGdldCpcbiAgICovXG4gIHNldFNlbGVjdGlvbjogZnVuY3Rpb24gKGlucHV0LCBvZmZzZXRzKSB7XG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQ7XG4gICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbmQgPSBzdGFydDtcbiAgICB9XG5cbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiAoaW5wdXQubm9kZU5hbWUgJiYgaW5wdXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JykpIHtcbiAgICAgIHZhciByYW5nZSA9IGlucHV0LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHN0YXJ0KTtcbiAgICAgIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCAtIHN0YXJ0KTtcbiAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERPTVNlbGVjdGlvbi5zZXRPZmZzZXRzKGlucHV0LCBvZmZzZXRzKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbnB1dFNlbGVjdGlvbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0SW5wdXRTZWxlY3Rpb24uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01TZWxlY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0ID0gcmVxdWlyZSgnLi9nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0Jyk7XG52YXIgZ2V0VGV4dENvbnRlbnRBY2Nlc3NvciA9IHJlcXVpcmUoJy4vZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcicpO1xuXG4vKipcbiAqIFdoaWxlIGBpc0NvbGxhcHNlZGAgaXMgYXZhaWxhYmxlIG9uIHRoZSBTZWxlY3Rpb24gb2JqZWN0IGFuZCBgY29sbGFwc2VkYFxuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBSYW5nZSBvYmplY3QsIElFMTEgc29tZXRpbWVzIGdldHMgdGhlbSB3cm9uZy5cbiAqIElmIHRoZSBhbmNob3IvZm9jdXMgbm9kZXMgYW5kIG9mZnNldHMgYXJlIHRoZSBzYW1lLCB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkLlxuICovXG5mdW5jdGlvbiBpc0NvbGxhcHNlZChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpIHtcbiAgcmV0dXJuIGFuY2hvck5vZGUgPT09IGZvY3VzTm9kZSAmJiBhbmNob3JPZmZzZXQgPT09IGZvY3VzT2Zmc2V0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgYXBwcm9wcmlhdGUgYW5jaG9yIGFuZCBmb2N1cyBub2RlL29mZnNldCBwYWlycyBmb3IgSUUuXG4gKlxuICogVGhlIGNhdGNoIGhlcmUgaXMgdGhhdCBJRSdzIHNlbGVjdGlvbiBBUEkgZG9lc24ndCBwcm92aWRlIGluZm9ybWF0aW9uXG4gKiBhYm91dCB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgZm9yd2FyZCBvciBiYWNrd2FyZCwgc28gd2UgaGF2ZSB0b1xuICogYmVoYXZlIGFzIHRob3VnaCBpdCdzIGFsd2F5cyBmb3J3YXJkLlxuICpcbiAqIElFIHRleHQgZGlmZmVycyBmcm9tIG1vZGVybiBzZWxlY3Rpb24gaW4gdGhhdCBpdCBiZWhhdmVzIGFzIHRob3VnaFxuICogYmxvY2sgZWxlbWVudHMgZW5kIHdpdGggYSBuZXcgbGluZS4gVGhpcyBtZWFucyBjaGFyYWN0ZXIgb2Zmc2V0cyB3aWxsXG4gKiBkaWZmZXIgYmV0d2VlbiB0aGUgdHdvIEFQSXMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldElFT2Zmc2V0cyhub2RlKSB7XG4gIHZhciBzZWxlY3Rpb24gPSBkb2N1bWVudC5zZWxlY3Rpb247XG4gIHZhciBzZWxlY3RlZFJhbmdlID0gc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gIHZhciBzZWxlY3RlZExlbmd0aCA9IHNlbGVjdGVkUmFuZ2UudGV4dC5sZW5ndGg7XG5cbiAgLy8gRHVwbGljYXRlIHNlbGVjdGlvbiBzbyB3ZSBjYW4gbW92ZSByYW5nZSB3aXRob3V0IGJyZWFraW5nIHVzZXIgc2VsZWN0aW9uLlxuICB2YXIgZnJvbVN0YXJ0ID0gc2VsZWN0ZWRSYW5nZS5kdXBsaWNhdGUoKTtcbiAgZnJvbVN0YXJ0Lm1vdmVUb0VsZW1lbnRUZXh0KG5vZGUpO1xuICBmcm9tU3RhcnQuc2V0RW5kUG9pbnQoJ0VuZFRvU3RhcnQnLCBzZWxlY3RlZFJhbmdlKTtcblxuICB2YXIgc3RhcnRPZmZzZXQgPSBmcm9tU3RhcnQudGV4dC5sZW5ndGg7XG4gIHZhciBlbmRPZmZzZXQgPSBzdGFydE9mZnNldCArIHNlbGVjdGVkTGVuZ3RoO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0T2Zmc2V0LFxuICAgIGVuZDogZW5kT2Zmc2V0XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRNb2Rlcm5PZmZzZXRzKG5vZGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24gJiYgd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICB2YXIgYW5jaG9yT2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvck9mZnNldDtcbiAgdmFyIGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGU7XG4gIHZhciBmb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcblxuICB2YXIgY3VycmVudFJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG5cbiAgLy8gSW4gRmlyZWZveCwgcmFuZ2Uuc3RhcnRDb250YWluZXIgYW5kIHJhbmdlLmVuZENvbnRhaW5lciBjYW4gYmUgXCJhbm9ueW1vdXNcbiAgLy8gZGl2c1wiLCBlLmcuIHRoZSB1cC9kb3duIGJ1dHRvbnMgb24gYW4gPGlucHV0IHR5cGU9XCJudW1iZXJcIj4uIEFub255bW91c1xuICAvLyBkaXZzIGRvIG5vdCBzZWVtIHRvIGV4cG9zZSBwcm9wZXJ0aWVzLCB0cmlnZ2VyaW5nIGEgXCJQZXJtaXNzaW9uIGRlbmllZFxuICAvLyBlcnJvclwiIGlmIGFueSBvZiBpdHMgcHJvcGVydGllcyBhcmUgYWNjZXNzZWQuIFRoZSBvbmx5IHNlZW1pbmdseSBwb3NzaWJsZVxuICAvLyB3YXkgdG8gYXZvaWQgZXJyb3JpbmcgaXMgdG8gYWNjZXNzIGEgcHJvcGVydHkgdGhhdCB0eXBpY2FsbHkgd29ya3MgZm9yXG4gIC8vIG5vbi1hbm9ueW1vdXMgZGl2cyBhbmQgY2F0Y2ggYW55IGVycm9yIHRoYXQgbWF5IG90aGVyd2lzZSBhcmlzZS4gU2VlXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTIwODQyN1xuICB0cnkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgIGN1cnJlbnRSYW5nZS5zdGFydENvbnRhaW5lci5ub2RlVHlwZTtcbiAgICBjdXJyZW50UmFuZ2UuZW5kQ29udGFpbmVyLm5vZGVUeXBlO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIElmIHRoZSBub2RlIGFuZCBvZmZzZXQgdmFsdWVzIGFyZSB0aGUgc2FtZSwgdGhlIHNlbGVjdGlvbiBpcyBjb2xsYXBzZWQuXG4gIC8vIGBTZWxlY3Rpb24uaXNDb2xsYXBzZWRgIGlzIGF2YWlsYWJsZSBuYXRpdmVseSwgYnV0IElFIHNvbWV0aW1lcyBnZXRzXG4gIC8vIHRoaXMgdmFsdWUgd3JvbmcuXG4gIHZhciBpc1NlbGVjdGlvbkNvbGxhcHNlZCA9IGlzQ29sbGFwc2VkKHNlbGVjdGlvbi5hbmNob3JOb2RlLCBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LCBzZWxlY3Rpb24uZm9jdXNOb2RlLCBzZWxlY3Rpb24uZm9jdXNPZmZzZXQpO1xuXG4gIHZhciByYW5nZUxlbmd0aCA9IGlzU2VsZWN0aW9uQ29sbGFwc2VkID8gMCA6IGN1cnJlbnRSYW5nZS50b1N0cmluZygpLmxlbmd0aDtcblxuICB2YXIgdGVtcFJhbmdlID0gY3VycmVudFJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgdGVtcFJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhub2RlKTtcbiAgdGVtcFJhbmdlLnNldEVuZChjdXJyZW50UmFuZ2Uuc3RhcnRDb250YWluZXIsIGN1cnJlbnRSYW5nZS5zdGFydE9mZnNldCk7XG5cbiAgdmFyIGlzVGVtcFJhbmdlQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQodGVtcFJhbmdlLnN0YXJ0Q29udGFpbmVyLCB0ZW1wUmFuZ2Uuc3RhcnRPZmZzZXQsIHRlbXBSYW5nZS5lbmRDb250YWluZXIsIHRlbXBSYW5nZS5lbmRPZmZzZXQpO1xuXG4gIHZhciBzdGFydCA9IGlzVGVtcFJhbmdlQ29sbGFwc2VkID8gMCA6IHRlbXBSYW5nZS50b1N0cmluZygpLmxlbmd0aDtcbiAgdmFyIGVuZCA9IHN0YXJ0ICsgcmFuZ2VMZW5ndGg7XG5cbiAgLy8gRGV0ZWN0IHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBiYWNrd2FyZC5cbiAgdmFyIGRldGVjdGlvblJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgZGV0ZWN0aW9uUmFuZ2Uuc2V0U3RhcnQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KTtcbiAgZGV0ZWN0aW9uUmFuZ2Uuc2V0RW5kKGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpO1xuICB2YXIgaXNCYWNrd2FyZCA9IGRldGVjdGlvblJhbmdlLmNvbGxhcHNlZDtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBpc0JhY2t3YXJkID8gZW5kIDogc3RhcnQsXG4gICAgZW5kOiBpc0JhY2t3YXJkID8gc3RhcnQgOiBlbmRcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cbmZ1bmN0aW9uIHNldElFT2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLmR1cGxpY2F0ZSgpO1xuICB2YXIgc3RhcnQsIGVuZDtcblxuICBpZiAodHlwZW9mIG9mZnNldHMuZW5kID09PSAndW5kZWZpbmVkJykge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICBlbmQgPSBzdGFydDtcbiAgfSBlbHNlIGlmIChvZmZzZXRzLnN0YXJ0ID4gb2Zmc2V0cy5lbmQpIHtcbiAgICBzdGFydCA9IG9mZnNldHMuZW5kO1xuICAgIGVuZCA9IG9mZnNldHMuc3RhcnQ7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIGVuZCA9IG9mZnNldHMuZW5kO1xuICB9XG5cbiAgcmFuZ2UubW92ZVRvRWxlbWVudFRleHQobm9kZSk7XG4gIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xuICByYW5nZS5zZXRFbmRQb2ludCgnRW5kVG9TdGFydCcsIHJhbmdlKTtcbiAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kIC0gc3RhcnQpO1xuICByYW5nZS5zZWxlY3QoKTtcbn1cblxuLyoqXG4gKiBJbiBtb2Rlcm4gbm9uLUlFIGJyb3dzZXJzLCB3ZSBjYW4gc3VwcG9ydCBib3RoIGZvcndhcmQgYW5kIGJhY2t3YXJkXG4gKiBzZWxlY3Rpb25zLlxuICpcbiAqIE5vdGU6IElFMTArIHN1cHBvcnRzIHRoZSBTZWxlY3Rpb24gb2JqZWN0LCBidXQgaXQgZG9lcyBub3Qgc3VwcG9ydFxuICogdGhlIGBleHRlbmRgIG1ldGhvZCwgd2hpY2ggbWVhbnMgdGhhdCBldmVuIGluIG1vZGVybiBJRSwgaXQncyBub3QgcG9zc2libGVcbiAqIHRvIHByb2dyYW1hdGljYWxseSBjcmVhdGUgYSBiYWNrd2FyZCBzZWxlY3Rpb24uIFRodXMsIGZvciBhbGwgSUVcbiAqIHZlcnNpb25zLCB3ZSB1c2UgdGhlIG9sZCBJRSBBUEkgdG8gY3JlYXRlIG91ciBzZWxlY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0TW9kZXJuT2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIGlmICghd2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBsZW5ndGggPSBub2RlW2dldFRleHRDb250ZW50QWNjZXNzb3IoKV0ubGVuZ3RoO1xuICB2YXIgc3RhcnQgPSBNYXRoLm1pbihvZmZzZXRzLnN0YXJ0LCBsZW5ndGgpO1xuICB2YXIgZW5kID0gdHlwZW9mIG9mZnNldHMuZW5kID09PSAndW5kZWZpbmVkJyA/IHN0YXJ0IDogTWF0aC5taW4ob2Zmc2V0cy5lbmQsIGxlbmd0aCk7XG5cbiAgLy8gSUUgMTEgdXNlcyBtb2Rlcm4gc2VsZWN0aW9uLCBidXQgZG9lc24ndCBzdXBwb3J0IHRoZSBleHRlbmQgbWV0aG9kLlxuICAvLyBGbGlwIGJhY2t3YXJkIHNlbGVjdGlvbnMsIHNvIHdlIGNhbiBzZXQgd2l0aCBhIHNpbmdsZSByYW5nZS5cbiAgaWYgKCFzZWxlY3Rpb24uZXh0ZW5kICYmIHN0YXJ0ID4gZW5kKSB7XG4gICAgdmFyIHRlbXAgPSBlbmQ7XG4gICAgZW5kID0gc3RhcnQ7XG4gICAgc3RhcnQgPSB0ZW1wO1xuICB9XG5cbiAgdmFyIHN0YXJ0TWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBzdGFydCk7XG4gIHZhciBlbmRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIGVuZCk7XG5cbiAgaWYgKHN0YXJ0TWFya2VyICYmIGVuZE1hcmtlcikge1xuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnRNYXJrZXIubm9kZSwgc3RhcnRNYXJrZXIub2Zmc2V0KTtcbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICBzZWxlY3Rpb24uZXh0ZW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2Uuc2V0RW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciB1c2VJRU9mZnNldHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ3NlbGVjdGlvbicgaW4gZG9jdW1lbnQgJiYgISgnZ2V0U2VsZWN0aW9uJyBpbiB3aW5kb3cpO1xuXG52YXIgUmVhY3RET01TZWxlY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICovXG4gIGdldE9mZnNldHM6IHVzZUlFT2Zmc2V0cyA/IGdldElFT2Zmc2V0cyA6IGdldE1vZGVybk9mZnNldHMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICAgKi9cbiAgc2V0T2Zmc2V0czogdXNlSUVPZmZzZXRzID8gc2V0SUVPZmZzZXRzIDogc2V0TW9kZXJuT2Zmc2V0c1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVNlbGVjdGlvbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NU2VsZWN0aW9uLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2l2ZW4gYW55IG5vZGUgcmV0dXJuIHRoZSBmaXJzdCBsZWFmIG5vZGUgd2l0aG91dCBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldExlYWZOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUgJiYgbm9kZS5maXJzdENoaWxkKSB7XG4gICAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG5leHQgc2libGluZyB3aXRoaW4gYSBjb250YWluZXIuIFRoaXMgd2lsbCB3YWxrIHVwIHRoZVxuICogRE9NIGlmIGEgbm9kZSdzIHNpYmxpbmdzIGhhdmUgYmVlbiBleGhhdXN0ZWQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0U2libGluZ05vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICByZXR1cm4gbm9kZS5uZXh0U2libGluZztcbiAgICB9XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBvYmplY3QgZGVzY3JpYmluZyB0aGUgbm9kZXMgd2hpY2ggY29udGFpbiBjaGFyYWN0ZXJzIGF0IG9mZnNldC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IHJvb3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQocm9vdCwgb2Zmc2V0KSB7XG4gIHZhciBub2RlID0gZ2V0TGVhZk5vZGUocm9vdCk7XG4gIHZhciBub2RlU3RhcnQgPSAwO1xuICB2YXIgbm9kZUVuZCA9IDA7XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgbm9kZUVuZCA9IG5vZGVTdGFydCArIG5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuXG4gICAgICBpZiAobm9kZVN0YXJ0IDw9IG9mZnNldCAmJiBub2RlRW5kID49IG9mZnNldCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgLSBub2RlU3RhcnRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbm9kZVN0YXJ0ID0gbm9kZUVuZDtcbiAgICB9XG5cbiAgICBub2RlID0gZ2V0TGVhZk5vZGUoZ2V0U2libGluZ05vZGUobm9kZSkpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2dldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0QWN0aXZlRWxlbWVudFxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBmYi13d3cvdHlwZW9mLXVuZGVmaW5lZCAqL1xuXG4vKipcbiAqIFNhbWUgYXMgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBidXQgd3JhcHMgaW4gYSB0cnktY2F0Y2ggYmxvY2suIEluIElFIGl0IGlzXG4gKiBub3Qgc2FmZSB0byBjYWxsIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaWYgdGhlcmUgaXMgbm90aGluZyBmb2N1c2VkLlxuICpcbiAqIFRoZSBhY3RpdmVFbGVtZW50IHdpbGwgYmUgbnVsbCBvbmx5IGlmIHRoZSBkb2N1bWVudCBvciBkb2N1bWVudCBib2R5IGlzIG5vdFxuICogeWV0IGRlZmluZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudCgpIC8qP0RPTUVsZW1lbnQqL3tcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50IHx8IGRvY3VtZW50LmJvZHk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFjdGl2ZUVsZW1lbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU2VsZWN0RXZlbnRQbHVnaW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5wdXRTZWxlY3Rpb24nKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGdldEFjdGl2ZUVsZW1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50Jyk7XG52YXIgaXNUZXh0SW5wdXRFbGVtZW50ID0gcmVxdWlyZSgnLi9pc1RleHRJbnB1dEVsZW1lbnQnKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnZmJqcy9saWIvc2hhbGxvd0VxdWFsJyk7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxudmFyIHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPD0gMTE7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBzZWxlY3Q6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblNlbGVjdDogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU2VsZWN0Q2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENvbnRleHRNZW51LCB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXAsIHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlXVxuICB9XG59O1xuXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudElEID0gbnVsbDtcbnZhciBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbnZhciBtb3VzZURvd24gPSBmYWxzZTtcblxuLy8gVHJhY2sgd2hldGhlciBhIGxpc3RlbmVyIGV4aXN0cyBmb3IgdGhpcyBwbHVnaW4uIElmIG5vbmUgZXhpc3QsIHdlIGRvXG4vLyBub3QgZXh0cmFjdCBldmVudHMuXG52YXIgaGFzTGlzdGVuZXIgPSBmYWxzZTtcbnZhciBPTl9TRUxFQ1RfS0VZID0ga2V5T2YoeyBvblNlbGVjdDogbnVsbCB9KTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGlzIGEgdW5pcXVlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgbm90IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG5vZGVzIG9yIGJyb3dzZXJzLCBidXRcbiAqIHR3byBpZGVudGljYWwgc2VsZWN0aW9ucyBvbiB0aGUgc2FtZSBub2RlIHdpbGwgcmV0dXJuIGlkZW50aWNhbCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24obm9kZSkge1xuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBub2RlICYmIFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKSB7XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmVudEVsZW1lbnQ6IHJhbmdlLnBhcmVudEVsZW1lbnQoKSxcbiAgICAgIHRleHQ6IHJhbmdlLnRleHQsXG4gICAgICB0b3A6IHJhbmdlLmJvdW5kaW5nVG9wLFxuICAgICAgbGVmdDogcmFuZ2UuYm91bmRpbmdMZWZ0XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFBvbGwgc2VsZWN0aW9uIHRvIHNlZSB3aGV0aGVyIGl0J3MgY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9TeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIC8vIEVuc3VyZSB3ZSBoYXZlIHRoZSByaWdodCBlbGVtZW50LCBhbmQgdGhhdCB0aGUgdXNlciBpcyBub3QgZHJhZ2dpbmcgYVxuICAvLyBzZWxlY3Rpb24gKHRoaXMgbWF0Y2hlcyBuYXRpdmUgYHNlbGVjdGAgZXZlbnQgYmVoYXZpb3IpLiBJbiBIVE1MNSwgc2VsZWN0XG4gIC8vIGZpcmVzIG9ubHkgb24gaW5wdXQgYW5kIHRleHRhcmVhIHRodXMgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnQgd2VcbiAgLy8gd29uJ3QgZGlzcGF0Y2guXG4gIGlmIChtb3VzZURvd24gfHwgYWN0aXZlRWxlbWVudCA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQgIT09IGdldEFjdGl2ZUVsZW1lbnQoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihhY3RpdmVFbGVtZW50KTtcbiAgaWYgKCFsYXN0U2VsZWN0aW9uIHx8ICFzaGFsbG93RXF1YWwobGFzdFNlbGVjdGlvbiwgY3VycmVudFNlbGVjdGlvbikpIHtcbiAgICBsYXN0U2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbjtcblxuICAgIHZhciBzeW50aGV0aWNFdmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLnNlbGVjdCwgYWN0aXZlRWxlbWVudElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgc3ludGhldGljRXZlbnQudHlwZSA9ICdzZWxlY3QnO1xuICAgIHN5bnRoZXRpY0V2ZW50LnRhcmdldCA9IGFjdGl2ZUVsZW1lbnQ7XG5cbiAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoc3ludGhldGljRXZlbnQpO1xuXG4gICAgcmV0dXJuIHN5bnRoZXRpY0V2ZW50O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25TZWxlY3RgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBzZWxlY3QgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBjb250ZW50RWRpdGFibGVcbiAqXG4gKiBUaGlzIGRpZmZlcnMgZnJvbSBuYXRpdmUgYnJvd3NlciBpbXBsZW1lbnRhdGlvbnMgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICogLSBGaXJlcyBvbiBjb250ZW50RWRpdGFibGUgZmllbGRzIGFzIHdlbGwgYXMgaW5wdXRzLlxuICogLSBGaXJlcyBmb3IgY29sbGFwc2VkIHNlbGVjdGlvbi5cbiAqIC0gRmlyZXMgYWZ0ZXIgdXNlciBpbnB1dC5cbiAqL1xudmFyIFNlbGVjdEV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzfVxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIGlmICghaGFzTGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICAvLyBUcmFjayB0aGUgaW5wdXQgbm9kZSB0aGF0IGhhcyBmb2N1cy5cbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BGb2N1czpcbiAgICAgICAgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0b3BMZXZlbFRhcmdldCkgfHwgdG9wTGV2ZWxUYXJnZXQuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpIHtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50ID0gdG9wTGV2ZWxUYXJnZXQ7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudElEID0gdG9wTGV2ZWxUYXJnZXRJRDtcbiAgICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BCbHVyOlxuICAgICAgICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgYWN0aXZlRWxlbWVudElEID0gbnVsbDtcbiAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBEb24ndCBmaXJlIHRoZSBldmVudCB3aGlsZSB0aGUgdXNlciBpcyBkcmFnZ2luZy4gVGhpcyBtYXRjaGVzIHRoZVxuICAgICAgLy8gc2VtYW50aWNzIG9mIHRoZSBuYXRpdmUgc2VsZWN0IGV2ZW50LlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bjpcbiAgICAgICAgbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29udGV4dE1lbnU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VVcDpcbiAgICAgICAgbW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgICAvLyBDaHJvbWUgYW5kIElFIGZpcmUgbm9uLXN0YW5kYXJkIGV2ZW50IHdoZW4gc2VsZWN0aW9uIGlzIGNoYW5nZWQgKGFuZFxuICAgICAgLy8gc29tZXRpbWVzIHdoZW4gaXQgaGFzbid0KS4gSUUncyBldmVudCBmaXJlcyBvdXQgb2Ygb3JkZXIgd2l0aCByZXNwZWN0XG4gICAgICAvLyB0byBrZXkgYW5kIGlucHV0IGV2ZW50cyBvbiBkZWxldGlvbiwgc28gd2UgZGlzY2FyZCBpdC5cbiAgICAgIC8vXG4gICAgICAvLyBGaXJlZm94IGRvZXNuJ3Qgc3VwcG9ydCBzZWxlY3Rpb25jaGFuZ2UsIHNvIGNoZWNrIHNlbGVjdGlvbiBzdGF0dXNcbiAgICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4gICAgICAvLyBrZXl1cCwgYnV0IHdlIGNoZWNrIG9uIGtleWRvd24gYXMgd2VsbCBpbiB0aGUgY2FzZSBvZiBob2xkaW5nIGRvd24gYVxuICAgICAgLy8ga2V5LCB3aGVuIG11bHRpcGxlIGtleWRvd24gZXZlbnRzIGFyZSBmaXJlZCBidXQgb25seSBvbmUga2V5dXAgaXMuXG4gICAgICAvLyBUaGlzIGlzIGFsc28gb3VyIGFwcHJvYWNoIGZvciBJRSBoYW5kbGluZywgZm9yIHRoZSByZWFzb24gYWJvdmUuXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlOlxuICAgICAgICBpZiAoc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwOlxuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICBkaWRQdXRMaXN0ZW5lcjogZnVuY3Rpb24gKGlkLCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSBPTl9TRUxFQ1RfS0VZKSB7XG4gICAgICBoYXNMaXN0ZW5lciA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbGVjdEV2ZW50UGx1Z2luO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvU2VsZWN0RXZlbnRQbHVnaW4uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU2VydmVyUmVhY3RSb290SW5kZXhcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNpemUgb2YgdGhlIHJlYWN0Um9vdCBJRCBzcGFjZS4gV2UgZ2VuZXJhdGUgcmFuZG9tIG51bWJlcnMgZm9yIFJlYWN0IHJvb3RcbiAqIElEcyBhbmQgaWYgdGhlcmUncyBhIGNvbGxpc2lvbiB0aGUgZXZlbnRzIGFuZCBET00gdXBkYXRlIHN5c3RlbSB3aWxsXG4gKiBnZXQgY29uZnVzZWQuIEluIHRoZSBmdXR1cmUgd2UgbmVlZCBhIHdheSB0byBnZW5lcmF0ZSBHVUlEcyBidXQgZm9yXG4gKiBub3cgdGhpcyB3aWxsIHdvcmsgb24gYSBzbWFsbGVyIHNjYWxlLlxuICovXG52YXIgR0xPQkFMX01PVU5UX1BPSU5UX01BWCA9IE1hdGgucG93KDIsIDUzKTtcblxudmFyIFNlcnZlclJlYWN0Um9vdEluZGV4ID0ge1xuICBjcmVhdGVSZWFjdFJvb3RJbmRleDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwoTWF0aC5yYW5kb20oKSAqIEdMT0JBTF9NT1VOVF9QT0lOVF9NQVgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlcnZlclJlYWN0Um9vdEluZGV4O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvU2VydmVyUmVhY3RSb290SW5kZXguanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU2ltcGxlRXZlbnRQbHVnaW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudExpc3RlbmVyID0gcmVxdWlyZSgnZmJqcy9saWIvRXZlbnRMaXN0ZW5lcicpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG52YXIgU3ludGhldGljQ2xpcGJvYXJkRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0NsaXBib2FyZEV2ZW50Jyk7XG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG52YXIgU3ludGhldGljRm9jdXNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRm9jdXNFdmVudCcpO1xudmFyIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0tleWJvYXJkRXZlbnQnKTtcbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG52YXIgU3ludGhldGljRHJhZ0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNEcmFnRXZlbnQnKTtcbnZhciBTeW50aGV0aWNUb3VjaEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNUb3VjaEV2ZW50Jyk7XG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xudmFyIFN5bnRoZXRpY1doZWVsRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1doZWVsRXZlbnQnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgZ2V0RXZlbnRDaGFyQ29kZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRDaGFyQ29kZScpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgYWJvcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkFib3J0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25BYm9ydENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGJsdXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkJsdXI6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkJsdXJDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjYW5QbGF5OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25DYW5QbGF5OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DYW5QbGF5Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY2FuUGxheVRocm91Z2g6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNhblBsYXlUaHJvdWdoOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DYW5QbGF5VGhyb3VnaENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGNsaWNrOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25DbGljazogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ2xpY2tDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjb250ZXh0TWVudToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ29udGV4dE1lbnU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNvbnRleHRNZW51Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY29weToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ29weTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29weUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGN1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ3V0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DdXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkb3VibGVDbGljazoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRG91YmxlQ2xpY2s6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRvdWJsZUNsaWNrQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZzoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZzogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdFbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdFbmQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdFbmRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnRW50ZXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdFbnRlcjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ0VudGVyQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ0V4aXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdFeGl0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnRXhpdENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdMZWF2ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0xlYXZlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnTGVhdmVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnT3Zlcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ092ZXI6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdPdmVyQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ1N0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnU3RhcnQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdTdGFydENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyb3A6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyb3A6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyb3BDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkdXJhdGlvbkNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHVyYXRpb25DaGFuZ2U6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkR1cmF0aW9uQ2hhbmdlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZW1wdGllZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRW1wdGllZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRW1wdGllZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGVuY3J5cHRlZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRW5jcnlwdGVkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25FbmNyeXB0ZWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBlbmRlZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRW5kZWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkVuZGVkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZXJyb3I6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkVycm9yOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25FcnJvckNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGZvY3VzOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Gb2N1czogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRm9jdXNDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBpbnB1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uSW5wdXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbklucHV0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAga2V5RG93bjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uS2V5RG93bjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uS2V5RG93bkNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGtleVByZXNzOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25LZXlQcmVzczogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uS2V5UHJlc3NDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBrZXlVcDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uS2V5VXA6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbktleVVwQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbG9hZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTG9hZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTG9hZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGxvYWRlZERhdGE6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkxvYWRlZERhdGE6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkxvYWRlZERhdGFDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBsb2FkZWRNZXRhZGF0YToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTG9hZGVkTWV0YWRhdGE6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkxvYWRlZE1ldGFkYXRhQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbG9hZFN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Mb2FkU3RhcnQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkxvYWRTdGFydENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIC8vIE5vdGU6IFdlIGRvIG5vdCBhbGxvdyBsaXN0ZW5pbmcgdG8gbW91c2VPdmVyIGV2ZW50cy4gSW5zdGVhZCwgdXNlIHRoZVxuICAvLyBvbk1vdXNlRW50ZXIvb25Nb3VzZUxlYXZlIGNyZWF0ZWQgYnkgYEVudGVyTGVhdmVFdmVudFBsdWdpbmAuXG4gIG1vdXNlRG93bjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTW91c2VEb3duOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Nb3VzZURvd25DYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBtb3VzZU1vdmU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbk1vdXNlTW92ZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VNb3ZlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbW91c2VPdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbk1vdXNlT3V0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Nb3VzZU91dENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlT3Zlcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTW91c2VPdmVyOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Nb3VzZU92ZXJDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBtb3VzZVVwOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZVVwOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Nb3VzZVVwQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcGFzdGU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblBhc3RlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25QYXN0ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHBhdXNlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25QYXVzZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUGF1c2VDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwbGF5OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25QbGF5OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25QbGF5Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcGxheWluZzoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUGxheWluZzogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUGxheWluZ0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHByb2dyZXNzOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Qcm9ncmVzczogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUHJvZ3Jlc3NDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICByYXRlQ2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25SYXRlQ2hhbmdlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25SYXRlQ2hhbmdlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcmVzZXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblJlc2V0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25SZXNldENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHNjcm9sbDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU2Nyb2xsOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TY3JvbGxDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzZWVrZWQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblNlZWtlZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU2Vla2VkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc2Vla2luZzoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU2Vla2luZzogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU2Vla2luZ0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHN0YWxsZWQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblN0YWxsZWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblN0YWxsZWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzdWJtaXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblN1Ym1pdDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU3VibWl0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc3VzcGVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU3VzcGVuZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU3VzcGVuZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRpbWVVcGRhdGU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRpbWVVcGRhdGU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRpbWVVcGRhdGVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0b3VjaENhbmNlbDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVG91Y2hDYW5jZWw6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRvdWNoQ2FuY2VsQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdG91Y2hFbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRvdWNoRW5kOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Ub3VjaEVuZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRvdWNoTW92ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVG91Y2hNb3ZlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Ub3VjaE1vdmVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0b3VjaFN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Ub3VjaFN0YXJ0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Ub3VjaFN0YXJ0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdm9sdW1lQ2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Wb2x1bWVDaGFuZ2U6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblZvbHVtZUNoYW5nZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHdhaXRpbmc6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbldhaXRpbmc6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbldhaXRpbmdDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB3aGVlbDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uV2hlZWw6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbldoZWVsQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfVxufTtcblxudmFyIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZyA9IHtcbiAgdG9wQWJvcnQ6IGV2ZW50VHlwZXMuYWJvcnQsXG4gIHRvcEJsdXI6IGV2ZW50VHlwZXMuYmx1cixcbiAgdG9wQ2FuUGxheTogZXZlbnRUeXBlcy5jYW5QbGF5LFxuICB0b3BDYW5QbGF5VGhyb3VnaDogZXZlbnRUeXBlcy5jYW5QbGF5VGhyb3VnaCxcbiAgdG9wQ2xpY2s6IGV2ZW50VHlwZXMuY2xpY2ssXG4gIHRvcENvbnRleHRNZW51OiBldmVudFR5cGVzLmNvbnRleHRNZW51LFxuICB0b3BDb3B5OiBldmVudFR5cGVzLmNvcHksXG4gIHRvcEN1dDogZXZlbnRUeXBlcy5jdXQsXG4gIHRvcERvdWJsZUNsaWNrOiBldmVudFR5cGVzLmRvdWJsZUNsaWNrLFxuICB0b3BEcmFnOiBldmVudFR5cGVzLmRyYWcsXG4gIHRvcERyYWdFbmQ6IGV2ZW50VHlwZXMuZHJhZ0VuZCxcbiAgdG9wRHJhZ0VudGVyOiBldmVudFR5cGVzLmRyYWdFbnRlcixcbiAgdG9wRHJhZ0V4aXQ6IGV2ZW50VHlwZXMuZHJhZ0V4aXQsXG4gIHRvcERyYWdMZWF2ZTogZXZlbnRUeXBlcy5kcmFnTGVhdmUsXG4gIHRvcERyYWdPdmVyOiBldmVudFR5cGVzLmRyYWdPdmVyLFxuICB0b3BEcmFnU3RhcnQ6IGV2ZW50VHlwZXMuZHJhZ1N0YXJ0LFxuICB0b3BEcm9wOiBldmVudFR5cGVzLmRyb3AsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiBldmVudFR5cGVzLmR1cmF0aW9uQ2hhbmdlLFxuICB0b3BFbXB0aWVkOiBldmVudFR5cGVzLmVtcHRpZWQsXG4gIHRvcEVuY3J5cHRlZDogZXZlbnRUeXBlcy5lbmNyeXB0ZWQsXG4gIHRvcEVuZGVkOiBldmVudFR5cGVzLmVuZGVkLFxuICB0b3BFcnJvcjogZXZlbnRUeXBlcy5lcnJvcixcbiAgdG9wRm9jdXM6IGV2ZW50VHlwZXMuZm9jdXMsXG4gIHRvcElucHV0OiBldmVudFR5cGVzLmlucHV0LFxuICB0b3BLZXlEb3duOiBldmVudFR5cGVzLmtleURvd24sXG4gIHRvcEtleVByZXNzOiBldmVudFR5cGVzLmtleVByZXNzLFxuICB0b3BLZXlVcDogZXZlbnRUeXBlcy5rZXlVcCxcbiAgdG9wTG9hZDogZXZlbnRUeXBlcy5sb2FkLFxuICB0b3BMb2FkZWREYXRhOiBldmVudFR5cGVzLmxvYWRlZERhdGEsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiBldmVudFR5cGVzLmxvYWRlZE1ldGFkYXRhLFxuICB0b3BMb2FkU3RhcnQ6IGV2ZW50VHlwZXMubG9hZFN0YXJ0LFxuICB0b3BNb3VzZURvd246IGV2ZW50VHlwZXMubW91c2VEb3duLFxuICB0b3BNb3VzZU1vdmU6IGV2ZW50VHlwZXMubW91c2VNb3ZlLFxuICB0b3BNb3VzZU91dDogZXZlbnRUeXBlcy5tb3VzZU91dCxcbiAgdG9wTW91c2VPdmVyOiBldmVudFR5cGVzLm1vdXNlT3ZlcixcbiAgdG9wTW91c2VVcDogZXZlbnRUeXBlcy5tb3VzZVVwLFxuICB0b3BQYXN0ZTogZXZlbnRUeXBlcy5wYXN0ZSxcbiAgdG9wUGF1c2U6IGV2ZW50VHlwZXMucGF1c2UsXG4gIHRvcFBsYXk6IGV2ZW50VHlwZXMucGxheSxcbiAgdG9wUGxheWluZzogZXZlbnRUeXBlcy5wbGF5aW5nLFxuICB0b3BQcm9ncmVzczogZXZlbnRUeXBlcy5wcm9ncmVzcyxcbiAgdG9wUmF0ZUNoYW5nZTogZXZlbnRUeXBlcy5yYXRlQ2hhbmdlLFxuICB0b3BSZXNldDogZXZlbnRUeXBlcy5yZXNldCxcbiAgdG9wU2Nyb2xsOiBldmVudFR5cGVzLnNjcm9sbCxcbiAgdG9wU2Vla2VkOiBldmVudFR5cGVzLnNlZWtlZCxcbiAgdG9wU2Vla2luZzogZXZlbnRUeXBlcy5zZWVraW5nLFxuICB0b3BTdGFsbGVkOiBldmVudFR5cGVzLnN0YWxsZWQsXG4gIHRvcFN1Ym1pdDogZXZlbnRUeXBlcy5zdWJtaXQsXG4gIHRvcFN1c3BlbmQ6IGV2ZW50VHlwZXMuc3VzcGVuZCxcbiAgdG9wVGltZVVwZGF0ZTogZXZlbnRUeXBlcy50aW1lVXBkYXRlLFxuICB0b3BUb3VjaENhbmNlbDogZXZlbnRUeXBlcy50b3VjaENhbmNlbCxcbiAgdG9wVG91Y2hFbmQ6IGV2ZW50VHlwZXMudG91Y2hFbmQsXG4gIHRvcFRvdWNoTW92ZTogZXZlbnRUeXBlcy50b3VjaE1vdmUsXG4gIHRvcFRvdWNoU3RhcnQ6IGV2ZW50VHlwZXMudG91Y2hTdGFydCxcbiAgdG9wVm9sdW1lQ2hhbmdlOiBldmVudFR5cGVzLnZvbHVtZUNoYW5nZSxcbiAgdG9wV2FpdGluZzogZXZlbnRUeXBlcy53YWl0aW5nLFxuICB0b3BXaGVlbDogZXZlbnRUeXBlcy53aGVlbFxufTtcblxuZm9yICh2YXIgdHlwZSBpbiB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcpIHtcbiAgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3R5cGVdLmRlcGVuZGVuY2llcyA9IFt0eXBlXTtcbn1cblxudmFyIE9OX0NMSUNLX0tFWSA9IGtleU9mKHsgb25DbGljazogbnVsbCB9KTtcbnZhciBvbkNsaWNrTGlzdGVuZXJzID0ge307XG5cbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50c31cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wTGV2ZWxUeXBlXTtcbiAgICBpZiAoIWRpc3BhdGNoQ29uZmlnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIEV2ZW50Q29uc3RydWN0b3I7XG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BBYm9ydDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDYW5QbGF5OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENhblBsYXlUaHJvdWdoOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcER1cmF0aW9uQ2hhbmdlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEVtcHRpZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRW5jcnlwdGVkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEVuZGVkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEVycm9yOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcElucHV0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcExvYWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTG9hZGVkRGF0YTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BMb2FkZWRNZXRhZGF0YTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BMb2FkU3RhcnQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUGF1c2U6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUGxheTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQbGF5aW5nOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFByb2dyZXNzOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFJhdGVDaGFuZ2U6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUmVzZXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU2Vla2VkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFNlZWtpbmc6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU3RhbGxlZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTdWJtaXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU3VzcGVuZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUaW1lVXBkYXRlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFZvbHVtZUNoYW5nZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BXYWl0aW5nOlxuICAgICAgICAvLyBIVE1MIEV2ZW50c1xuICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZGV4Lmh0bWwjZXZlbnRzLTBcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICAgICAgLy8gRmlyZUZveCBjcmVhdGVzIGEga2V5cHJlc3MgZXZlbnQgZm9yIGZ1bmN0aW9uIGtleXMgdG9vLiBUaGlzIHJlbW92ZXNcbiAgICAgICAgLy8gdGhlIHVud2FudGVkIGtleXByZXNzIGV2ZW50cy4gRW50ZXIgaXMgaG93ZXZlciBib3RoIHByaW50YWJsZSBhbmRcbiAgICAgICAgLy8gbm9uLXByaW50YWJsZS4gT25lIHdvdWxkIGV4cGVjdCBUYWIgdG8gYmUgYXMgd2VsbCAoYnV0IGl0IGlzbid0KS5cbiAgICAgICAgaWYgKGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQmx1cjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BGb2N1czpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENsaWNrOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBjbGljayBldmVudCBvbiByaWdodCBtb3VzZSBjbGlja3MuIFRoaXMgcmVtb3ZlcyB0aGVcbiAgICAgICAgLy8gdW53YW50ZWQgY2xpY2sgZXZlbnRzLlxuICAgICAgICBpZiAobmF0aXZlRXZlbnQuYnV0dG9uID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb250ZXh0TWVudTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEb3VibGVDbGljazpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd246XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VNb3ZlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3V0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3ZlcjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZVVwOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljTW91c2VFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZzpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnRW5kOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdFbnRlcjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnRXhpdDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnTGVhdmU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ092ZXI6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ1N0YXJ0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyb3A6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNEcmFnRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoQ2FuY2VsOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoRW5kOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoTW92ZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaFN0YXJ0OlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVG91Y2hFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU2Nyb2xsOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVUlFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wV2hlZWw6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb3B5OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEN1dDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQYXN0ZTpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgIUV2ZW50Q29uc3RydWN0b3IgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnU2ltcGxlRXZlbnRQbHVnaW46IFVuaGFuZGxlZCBldmVudCB0eXBlLCBgJXNgLicsIHRvcExldmVsVHlwZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHZhciBldmVudCA9IEV2ZW50Q29uc3RydWN0b3IuZ2V0UG9vbGVkKGRpc3BhdGNoQ29uZmlnLCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9LFxuXG4gIGRpZFB1dExpc3RlbmVyOiBmdW5jdGlvbiAoaWQsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XG4gICAgLy8gTW9iaWxlIFNhZmFyaSBkb2VzIG5vdCBmaXJlIHByb3Blcmx5IGJ1YmJsZSBjbGljayBldmVudHMgb25cbiAgICAvLyBub24taW50ZXJhY3RpdmUgZWxlbWVudHMsIHdoaWNoIG1lYW5zIGRlbGVnYXRlZCBjbGljayBsaXN0ZW5lcnMgZG8gbm90XG4gICAgLy8gZmlyZS4gVGhlIHdvcmthcm91bmQgZm9yIHRoaXMgYnVnIGludm9sdmVzIGF0dGFjaGluZyBhbiBlbXB0eSBjbGlja1xuICAgIC8vIGxpc3RlbmVyIG9uIHRoZSB0YXJnZXQgbm9kZS5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gT05fQ0xJQ0tfS0VZKSB7XG4gICAgICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZShpZCk7XG4gICAgICBpZiAoIW9uQ2xpY2tMaXN0ZW5lcnNbaWRdKSB7XG4gICAgICAgIG9uQ2xpY2tMaXN0ZW5lcnNbaWRdID0gRXZlbnRMaXN0ZW5lci5saXN0ZW4obm9kZSwgJ2NsaWNrJywgZW1wdHlGdW5jdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHdpbGxEZWxldGVMaXN0ZW5lcjogZnVuY3Rpb24gKGlkLCByZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09IE9OX0NMSUNLX0tFWSkge1xuICAgICAgb25DbGlja0xpc3RlbmVyc1tpZF0ucmVtb3ZlKCk7XG4gICAgICBkZWxldGUgb25DbGlja0xpc3RlbmVyc1tpZF07XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2ltcGxlRXZlbnRQbHVnaW47XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9TaW1wbGVFdmVudFBsdWdpbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NsaXBib2FyZC1hcGlzL1xuICovXG52YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgPyBldmVudC5jbGlwYm9hcmREYXRhIDogd2luZG93LmNsaXBib2FyZERhdGE7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljQ2xpcGJvYXJkRXZlbnQsIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0NsaXBib2FyZEV2ZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0ZvY3VzRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRm9jdXNFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBGb2N1c0V2ZW50SW50ZXJmYWNlID0ge1xuICByZWxhdGVkVGFyZ2V0OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNGb2N1c0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0ZvY3VzRXZlbnQsIEZvY3VzRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNGb2N1c0V2ZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0tleWJvYXJkRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xuXG52YXIgZ2V0RXZlbnRDaGFyQ29kZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRDaGFyQ29kZScpO1xudmFyIGdldEV2ZW50S2V5ID0gcmVxdWlyZSgnLi9nZXRFdmVudEtleScpO1xudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRNb2RpZmllclN0YXRlJyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBLZXlib2FyZEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGtleTogZ2V0RXZlbnRLZXksXG4gIGxvY2F0aW9uOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICByZXBlYXQ6IG51bGwsXG4gIGxvY2FsZTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICAvLyBMZWdhY3kgSW50ZXJmYWNlXG4gIGNoYXJDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgY2hhckNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlQcmVzcyBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyB0aGUgYWN0dWFsIHByaW50YWJsZSBjaGFyYWN0ZXIuXG5cbiAgICAvLyBLZXlQcmVzcyBpcyBkZXByZWNhdGVkLCBidXQgaXRzIHJlcGxhY2VtZW50IGlzIG5vdCB5ZXQgZmluYWwgYW5kIG5vdFxuICAgIC8vIGltcGxlbWVudGVkIGluIGFueSBtYWpvciBicm93c2VyLiBPbmx5IEtleVByZXNzIGhhcyBjaGFyQ29kZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAga2V5Q29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGtleUNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlEb3duL1VwIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHBoeXNpY2FsIGtleWJvYXJkIGtleS5cblxuICAgIC8vIFRoZSBhY3R1YWwgbWVhbmluZyBvZiB0aGUgdmFsdWUgZGVwZW5kcyBvbiB0aGUgdXNlcnMnIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHdoaWNoIGNhbm5vdCBiZSBkZXRlY3RlZC4gQXNzdW1pbmcgdGhhdCBpdCBpcyBhIFVTIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHByb3ZpZGVzIGEgc3VycHJpc2luZ2x5IGFjY3VyYXRlIG1hcHBpbmcgZm9yIFVTIGFuZCBFdXJvcGVhbiB1c2Vycy5cbiAgICAvLyBEdWUgdG8gdGhpcywgaXQgaXMgbGVmdCB0byB0aGUgdXNlciB0byBpbXBsZW1lbnQgYXQgdGhpcyB0aW1lLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICB3aGljaDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYHdoaWNoYCBpcyBhbiBhbGlhcyBmb3IgZWl0aGVyIGBrZXlDb2RlYCBvciBgY2hhckNvZGVgIGRlcGVuZGluZyBvbiB0aGVcbiAgICAvLyB0eXBlIG9mIHRoZSBldmVudC5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljS2V5Ym9hcmRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNLZXlib2FyZEV2ZW50LCBLZXlib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvU3ludGhldGljS2V5Ym9hcmRFdmVudC5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRFdmVudENoYXJDb2RlXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBgY2hhckNvZGVgIHJlcHJlc2VudHMgdGhlIGFjdHVhbCBcImNoYXJhY3RlciBjb2RlXCIgYW5kIGlzIHNhZmUgdG8gdXNlIHdpdGhcbiAqIGBTdHJpbmcuZnJvbUNoYXJDb2RlYC4gQXMgc3VjaCwgb25seSBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBwcmludGFibGVcbiAqIGNoYXJhY3RlcnMgcHJvZHVjZSBhIHZhbGlkIGBjaGFyQ29kZWAsIHRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGlzIGlzIEVudGVyLlxuICogVGhlIFRhYi1rZXkgaXMgY29uc2lkZXJlZCBub24tcHJpbnRhYmxlIGFuZCBkb2VzIG5vdCBoYXZlIGEgYGNoYXJDb2RlYCxcbiAqIHByZXN1bWFibHkgYmVjYXVzZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgdGFiLWNoYXJhY3RlciBpbiBicm93c2Vycy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE5vcm1hbGl6ZWQgYGNoYXJDb2RlYCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkge1xuICB2YXIgY2hhckNvZGU7XG4gIHZhciBrZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuICBpZiAoJ2NoYXJDb2RlJyBpbiBuYXRpdmVFdmVudCkge1xuICAgIGNoYXJDb2RlID0gbmF0aXZlRXZlbnQuY2hhckNvZGU7XG5cbiAgICAvLyBGRiBkb2VzIG5vdCBzZXQgYGNoYXJDb2RlYCBmb3IgdGhlIEVudGVyLWtleSwgY2hlY2sgYWdhaW5zdCBga2V5Q29kZWAuXG4gICAgaWYgKGNoYXJDb2RlID09PSAwICYmIGtleUNvZGUgPT09IDEzKSB7XG4gICAgICBjaGFyQ29kZSA9IDEzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGBjaGFyQ29kZWAsIGJ1dCBga2V5Q29kZWAgaGFzIHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgIGNoYXJDb2RlID0ga2V5Q29kZTtcbiAgfVxuXG4gIC8vIFNvbWUgbm9uLXByaW50YWJsZSBrZXlzIGFyZSByZXBvcnRlZCBpbiBgY2hhckNvZGVgL2BrZXlDb2RlYCwgZGlzY2FyZCB0aGVtLlxuICAvLyBNdXN0IG5vdCBkaXNjYXJkIHRoZSAobm9uLSlwcmludGFibGUgRW50ZXIta2V5LlxuICBpZiAoY2hhckNvZGUgPj0gMzIgfHwgY2hhckNvZGUgPT09IDEzKSB7XG4gICAgcmV0dXJuIGNoYXJDb2RlO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRDaGFyQ29kZTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL2dldEV2ZW50Q2hhckNvZGUuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RXZlbnRLZXlcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0RXZlbnRDaGFyQ29kZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRDaGFyQ29kZScpO1xuXG4vKipcbiAqIE5vcm1hbGl6YXRpb24gb2YgZGVwcmVjYXRlZCBIVE1MNSBga2V5YCB2YWx1ZXNcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cbnZhciBub3JtYWxpemVLZXkgPSB7XG4gICdFc2MnOiAnRXNjYXBlJyxcbiAgJ1NwYWNlYmFyJzogJyAnLFxuICAnTGVmdCc6ICdBcnJvd0xlZnQnLFxuICAnVXAnOiAnQXJyb3dVcCcsXG4gICdSaWdodCc6ICdBcnJvd1JpZ2h0JyxcbiAgJ0Rvd24nOiAnQXJyb3dEb3duJyxcbiAgJ0RlbCc6ICdEZWxldGUnLFxuICAnV2luJzogJ09TJyxcbiAgJ01lbnUnOiAnQ29udGV4dE1lbnUnLFxuICAnQXBwcyc6ICdDb250ZXh0TWVudScsXG4gICdTY3JvbGwnOiAnU2Nyb2xsTG9jaycsXG4gICdNb3pQcmludGFibGVLZXknOiAnVW5pZGVudGlmaWVkJ1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIGxlZ2FjeSBga2V5Q29kZWAgdG8gSFRNTDUgYGtleWBcbiAqIE9ubHkgc3BlY2lhbCBrZXlzIHN1cHBvcnRlZCwgYWxsIG90aGVycyBkZXBlbmQgb24ga2V5Ym9hcmQgbGF5b3V0IG9yIGJyb3dzZXJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cbnZhciB0cmFuc2xhdGVUb0tleSA9IHtcbiAgODogJ0JhY2tzcGFjZScsXG4gIDk6ICdUYWInLFxuICAxMjogJ0NsZWFyJyxcbiAgMTM6ICdFbnRlcicsXG4gIDE2OiAnU2hpZnQnLFxuICAxNzogJ0NvbnRyb2wnLFxuICAxODogJ0FsdCcsXG4gIDE5OiAnUGF1c2UnLFxuICAyMDogJ0NhcHNMb2NrJyxcbiAgMjc6ICdFc2NhcGUnLFxuICAzMjogJyAnLFxuICAzMzogJ1BhZ2VVcCcsXG4gIDM0OiAnUGFnZURvd24nLFxuICAzNTogJ0VuZCcsXG4gIDM2OiAnSG9tZScsXG4gIDM3OiAnQXJyb3dMZWZ0JyxcbiAgMzg6ICdBcnJvd1VwJyxcbiAgMzk6ICdBcnJvd1JpZ2h0JyxcbiAgNDA6ICdBcnJvd0Rvd24nLFxuICA0NTogJ0luc2VydCcsXG4gIDQ2OiAnRGVsZXRlJyxcbiAgMTEyOiAnRjEnLCAxMTM6ICdGMicsIDExNDogJ0YzJywgMTE1OiAnRjQnLCAxMTY6ICdGNScsIDExNzogJ0Y2JyxcbiAgMTE4OiAnRjcnLCAxMTk6ICdGOCcsIDEyMDogJ0Y5JywgMTIxOiAnRjEwJywgMTIyOiAnRjExJywgMTIzOiAnRjEyJyxcbiAgMTQ0OiAnTnVtTG9jaycsXG4gIDE0NTogJ1Njcm9sbExvY2snLFxuICAyMjQ6ICdNZXRhJ1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgYGtleWAgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50S2V5KG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5rZXkpIHtcbiAgICAvLyBOb3JtYWxpemUgaW5jb25zaXN0ZW50IHZhbHVlcyByZXBvcnRlZCBieSBicm93c2VycyBkdWUgdG9cbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgb2YgYSB3b3JraW5nIGRyYWZ0IHNwZWNpZmljYXRpb24uXG5cbiAgICAvLyBGaXJlRm94IGltcGxlbWVudHMgYGtleWAgYnV0IHJldHVybnMgYE1velByaW50YWJsZUtleWAgZm9yIGFsbFxuICAgIC8vIHByaW50YWJsZSBjaGFyYWN0ZXJzIChub3JtYWxpemVkIHRvIGBVbmlkZW50aWZpZWRgKSwgaWdub3JlIGl0LlxuICAgIHZhciBrZXkgPSBub3JtYWxpemVLZXlbbmF0aXZlRXZlbnQua2V5XSB8fCBuYXRpdmVFdmVudC5rZXk7XG4gICAgaWYgKGtleSAhPT0gJ1VuaWRlbnRpZmllZCcpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICB9XG5cbiAgLy8gQnJvd3NlciBkb2VzIG5vdCBpbXBsZW1lbnQgYGtleWAsIHBvbHlmaWxsIGFzIG11Y2ggb2YgaXQgYXMgd2UgY2FuLlxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgIHZhciBjaGFyQ29kZSA9IGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpO1xuXG4gICAgLy8gVGhlIGVudGVyLWtleSBpcyB0ZWNobmljYWxseSBib3RoIHByaW50YWJsZSBhbmQgbm9uLXByaW50YWJsZSBhbmQgY2FuXG4gICAgLy8gdGh1cyBiZSBjYXB0dXJlZCBieSBga2V5cHJlc3NgLCBubyBvdGhlciBub24tcHJpbnRhYmxlIGtleSBzaG91bGQuXG4gICAgcmV0dXJuIGNoYXJDb2RlID09PSAxMyA/ICdFbnRlcicgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgfVxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAvLyBXaGlsZSB1c2VyIGtleWJvYXJkIGxheW91dCBkZXRlcm1pbmVzIHRoZSBhY3R1YWwgbWVhbmluZyBvZiBlYWNoXG4gICAgLy8gYGtleUNvZGVgIHZhbHVlLCBhbG1vc3QgYWxsIGZ1bmN0aW9uIGtleXMgaGF2ZSBhIHVuaXZlcnNhbCB2YWx1ZS5cbiAgICByZXR1cm4gdHJhbnNsYXRlVG9LZXlbbmF0aXZlRXZlbnQua2V5Q29kZV0gfHwgJ1VuaWRlbnRpZmllZCc7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50S2V5O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvZ2V0RXZlbnRLZXkuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljRHJhZ0V2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIERyYWdFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBEcmFnRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGFUcmFuc2ZlcjogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRHJhZ0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY01vdXNlRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0RyYWdFdmVudCwgRHJhZ0V2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNEcmFnRXZlbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNEcmFnRXZlbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljVG91Y2hFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG5cbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKCcuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZScpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVG91Y2hFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMvXG4gKi9cbnZhciBUb3VjaEV2ZW50SW50ZXJmYWNlID0ge1xuICB0b3VjaGVzOiBudWxsLFxuICB0YXJnZXRUb3VjaGVzOiBudWxsLFxuICBjaGFuZ2VkVG91Y2hlczogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNUb3VjaEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RvdWNoRXZlbnQsIFRvdWNoRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNUb3VjaEV2ZW50LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY1doZWVsRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgV2hlZWxFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBXaGVlbEV2ZW50SW50ZXJmYWNlID0ge1xuICBkZWx0YVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFYJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWCA6XG4gICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFYYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKHJpZ2h0IGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVgnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFYIDogMDtcbiAgfSxcbiAgZGVsdGFZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWScgaW4gZXZlbnQgPyBldmVudC5kZWx0YVkgOlxuICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWWAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVknIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFZIDpcbiAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YWAgZm9yIElFPDkgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGEnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGEgOiAwO1xuICB9LFxuICBkZWx0YVo6IG51bGwsXG5cbiAgLy8gQnJvd3NlcnMgd2l0aG91dCBcImRlbHRhTW9kZVwiIGlzIHJlcG9ydGluZyBpbiByYXcgd2hlZWwgZGVsdGEgd2hlcmUgb25lXG4gIC8vIG5vdGNoIG9uIHRoZSBzY3JvbGwgaXMgYWx3YXlzICsvLSAxMjAsIHJvdWdobHkgZXF1aXZhbGVudCB0byBwaXhlbHMuXG4gIC8vIEEgZ29vZCBhcHByb3hpbWF0aW9uIG9mIERPTV9ERUxUQV9MSU5FICgxKSBpcyA1JSBvZiB2aWV3cG9ydCBzaXplIG9yXG4gIC8vIH40MCBwaXhlbHMsIGZvciBET01fREVMVEFfU0NSRUVOICgyKSBpdCBpcyA4Ny41JSBvZiB2aWV3cG9ydCBzaXplLlxuICBkZWx0YU1vZGU6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY01vdXNlRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1doZWVsRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljV2hlZWxFdmVudCwgV2hlZWxFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljV2hlZWxFdmVudDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1N5bnRoZXRpY1doZWVsRXZlbnQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU1ZHRE9NUHJvcGVydHlDb25maWdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcblxudmFyIE1VU1RfVVNFX0FUVFJJQlVURSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5NVVNUX1VTRV9BVFRSSUJVVEU7XG5cbnZhciBOUyA9IHtcbiAgeGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgeG1sOiAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJ1xufTtcblxudmFyIFNWR0RPTVByb3BlcnR5Q29uZmlnID0ge1xuICBQcm9wZXJ0aWVzOiB7XG4gICAgY2xpcFBhdGg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBjeDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGN5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGR4OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmaWxsOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZmlsbE9wYWNpdHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmb250RmFtaWx5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZm9udFNpemU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmeDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZ5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZ3JhZGllbnRUcmFuc2Zvcm06IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBncmFkaWVudFVuaXRzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbWFya2VyRW5kOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbWFya2VyTWlkOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbWFya2VyU3RhcnQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBvZmZzZXQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBvcGFjaXR5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcGF0dGVybkNvbnRlbnRVbml0czogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHBhdHRlcm5Vbml0czogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHBvaW50czogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICByOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcng6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICByeTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHNwcmVhZE1ldGhvZDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0b3BDb2xvcjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0b3BPcGFjaXR5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3Ryb2tlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3Ryb2tlRGFzaGFycmF5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3Ryb2tlTGluZWNhcDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0cm9rZU9wYWNpdHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdHJva2VXaWR0aDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHRleHRBbmNob3I6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB0cmFuc2Zvcm06IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB2ZXJzaW9uOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgdmlld0JveDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHgxOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeDI6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeGxpbmtBY3R1YXRlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeGxpbmtBcmNyb2xlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeGxpbmtIcmVmOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeGxpbmtSb2xlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeGxpbmtTaG93OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeGxpbmtUaXRsZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHhsaW5rVHlwZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHhtbEJhc2U6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bWxMYW5nOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeG1sU3BhY2U6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB5MTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHkyOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeTogTVVTVF9VU0VfQVRUUklCVVRFXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IHtcbiAgICB4bGlua0FjdHVhdGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rQXJjcm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtIcmVmOiBOUy54bGluayxcbiAgICB4bGlua1JvbGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rU2hvdzogTlMueGxpbmssXG4gICAgeGxpbmtUaXRsZTogTlMueGxpbmssXG4gICAgeGxpbmtUeXBlOiBOUy54bGluayxcbiAgICB4bWxCYXNlOiBOUy54bWwsXG4gICAgeG1sTGFuZzogTlMueG1sLFxuICAgIHhtbFNwYWNlOiBOUy54bWxcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHtcbiAgICBjbGlwUGF0aDogJ2NsaXAtcGF0aCcsXG4gICAgZmlsbE9wYWNpdHk6ICdmaWxsLW9wYWNpdHknLFxuICAgIGZvbnRGYW1pbHk6ICdmb250LWZhbWlseScsXG4gICAgZm9udFNpemU6ICdmb250LXNpemUnLFxuICAgIGdyYWRpZW50VHJhbnNmb3JtOiAnZ3JhZGllbnRUcmFuc2Zvcm0nLFxuICAgIGdyYWRpZW50VW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgICBtYXJrZXJFbmQ6ICdtYXJrZXItZW5kJyxcbiAgICBtYXJrZXJNaWQ6ICdtYXJrZXItbWlkJyxcbiAgICBtYXJrZXJTdGFydDogJ21hcmtlci1zdGFydCcsXG4gICAgcGF0dGVybkNvbnRlbnRVbml0czogJ3BhdHRlcm5Db250ZW50VW5pdHMnLFxuICAgIHBhdHRlcm5Vbml0czogJ3BhdHRlcm5Vbml0cycsXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLFxuICAgIHNwcmVhZE1ldGhvZDogJ3NwcmVhZE1ldGhvZCcsXG4gICAgc3RvcENvbG9yOiAnc3RvcC1jb2xvcicsXG4gICAgc3RvcE9wYWNpdHk6ICdzdG9wLW9wYWNpdHknLFxuICAgIHN0cm9rZURhc2hhcnJheTogJ3N0cm9rZS1kYXNoYXJyYXknLFxuICAgIHN0cm9rZUxpbmVjYXA6ICdzdHJva2UtbGluZWNhcCcsXG4gICAgc3Ryb2tlT3BhY2l0eTogJ3N0cm9rZS1vcGFjaXR5JyxcbiAgICBzdHJva2VXaWR0aDogJ3N0cm9rZS13aWR0aCcsXG4gICAgdGV4dEFuY2hvcjogJ3RleHQtYW5jaG9yJyxcbiAgICB2aWV3Qm94OiAndmlld0JveCcsXG4gICAgeGxpbmtBY3R1YXRlOiAneGxpbms6YWN0dWF0ZScsXG4gICAgeGxpbmtBcmNyb2xlOiAneGxpbms6YXJjcm9sZScsXG4gICAgeGxpbmtIcmVmOiAneGxpbms6aHJlZicsXG4gICAgeGxpbmtSb2xlOiAneGxpbms6cm9sZScsXG4gICAgeGxpbmtTaG93OiAneGxpbms6c2hvdycsXG4gICAgeGxpbmtUaXRsZTogJ3hsaW5rOnRpdGxlJyxcbiAgICB4bGlua1R5cGU6ICd4bGluazp0eXBlJyxcbiAgICB4bWxCYXNlOiAneG1sOmJhc2UnLFxuICAgIHhtbExhbmc6ICd4bWw6bGFuZycsXG4gICAgeG1sU3BhY2U6ICd4bWw6c3BhY2UnXG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU1ZHRE9NUHJvcGVydHlDb25maWc7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9TVkdET01Qcm9wZXJ0eUNvbmZpZy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERlZmF1bHRQZXJmXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcyA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG5cbnZhciBwZXJmb3JtYW5jZU5vdyA9IHJlcXVpcmUoJ2ZianMvbGliL3BlcmZvcm1hbmNlTm93Jyk7XG5cbmZ1bmN0aW9uIHJvdW5kRmxvYXQodmFsKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKHZhbCAqIDEwMCkgLyAxMDA7XG59XG5cbmZ1bmN0aW9uIGFkZFZhbHVlKG9iaiwga2V5LCB2YWwpIHtcbiAgb2JqW2tleV0gPSAob2JqW2tleV0gfHwgMCkgKyB2YWw7XG59XG5cbnZhciBSZWFjdERlZmF1bHRQZXJmID0ge1xuICBfYWxsTWVhc3VyZW1lbnRzOiBbXSwgLy8gbGFzdCBpdGVtIGluIHRoZSBsaXN0IGlzIHRoZSBjdXJyZW50IG9uZVxuICBfbW91bnRTdGFjazogWzBdLFxuICBfaW5qZWN0ZWQ6IGZhbHNlLFxuXG4gIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFSZWFjdERlZmF1bHRQZXJmLl9pbmplY3RlZCkge1xuICAgICAgUmVhY3RQZXJmLmluamVjdGlvbi5pbmplY3RNZWFzdXJlKFJlYWN0RGVmYXVsdFBlcmYubWVhc3VyZSk7XG4gICAgfVxuXG4gICAgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgUmVhY3RQZXJmLmVuYWJsZU1lYXN1cmUgPSB0cnVlO1xuICB9LFxuXG4gIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICBSZWFjdFBlcmYuZW5hYmxlTWVhc3VyZSA9IGZhbHNlO1xuICB9LFxuXG4gIGdldExhc3RNZWFzdXJlbWVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICB9LFxuXG4gIHByaW50RXhjbHVzaXZlOiBmdW5jdGlvbiAobWVhc3VyZW1lbnRzKSB7XG4gICAgbWVhc3VyZW1lbnRzID0gbWVhc3VyZW1lbnRzIHx8IFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cztcbiAgICB2YXIgc3VtbWFyeSA9IFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRFeGNsdXNpdmVTdW1tYXJ5KG1lYXN1cmVtZW50cyk7XG4gICAgY29uc29sZS50YWJsZShzdW1tYXJ5Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ0NvbXBvbmVudCBjbGFzcyBuYW1lJzogaXRlbS5jb21wb25lbnROYW1lLFxuICAgICAgICAnVG90YWwgaW5jbHVzaXZlIHRpbWUgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS5pbmNsdXNpdmUpLFxuICAgICAgICAnRXhjbHVzaXZlIG1vdW50IHRpbWUgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS5leGNsdXNpdmUpLFxuICAgICAgICAnRXhjbHVzaXZlIHJlbmRlciB0aW1lIChtcyknOiByb3VuZEZsb2F0KGl0ZW0ucmVuZGVyKSxcbiAgICAgICAgJ01vdW50IHRpbWUgcGVyIGluc3RhbmNlIChtcyknOiByb3VuZEZsb2F0KGl0ZW0uZXhjbHVzaXZlIC8gaXRlbS5jb3VudCksXG4gICAgICAgICdSZW5kZXIgdGltZSBwZXIgaW5zdGFuY2UgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS5yZW5kZXIgLyBpdGVtLmNvdW50KSxcbiAgICAgICAgJ0luc3RhbmNlcyc6IGl0ZW0uY291bnRcbiAgICAgIH07XG4gICAgfSkpO1xuICAgIC8vIFRPRE86IFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRUb3RhbFRpbWUoKSBkb2VzIG5vdCByZXR1cm4gdGhlIGNvcnJlY3RcbiAgICAvLyBudW1iZXIuXG4gIH0sXG5cbiAgcHJpbnRJbmNsdXNpdmU6IGZ1bmN0aW9uIChtZWFzdXJlbWVudHMpIHtcbiAgICBtZWFzdXJlbWVudHMgPSBtZWFzdXJlbWVudHMgfHwgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICAgIHZhciBzdW1tYXJ5ID0gUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldEluY2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzKTtcbiAgICBjb25zb2xlLnRhYmxlKHN1bW1hcnkubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnT3duZXIgPiBjb21wb25lbnQnOiBpdGVtLmNvbXBvbmVudE5hbWUsXG4gICAgICAgICdJbmNsdXNpdmUgdGltZSAobXMpJzogcm91bmRGbG9hdChpdGVtLnRpbWUpLFxuICAgICAgICAnSW5zdGFuY2VzJzogaXRlbS5jb3VudFxuICAgICAgfTtcbiAgICB9KSk7XG4gICAgY29uc29sZS5sb2coJ1RvdGFsIHRpbWU6JywgUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldFRvdGFsVGltZShtZWFzdXJlbWVudHMpLnRvRml4ZWQoMikgKyAnIG1zJyk7XG4gIH0sXG5cbiAgZ2V0TWVhc3VyZW1lbnRzU3VtbWFyeU1hcDogZnVuY3Rpb24gKG1lYXN1cmVtZW50cykge1xuICAgIHZhciBzdW1tYXJ5ID0gUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldEluY2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzLCB0cnVlKTtcbiAgICByZXR1cm4gc3VtbWFyeS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdPd25lciA+IGNvbXBvbmVudCc6IGl0ZW0uY29tcG9uZW50TmFtZSxcbiAgICAgICAgJ1dhc3RlZCB0aW1lIChtcyknOiBpdGVtLnRpbWUsXG4gICAgICAgICdJbnN0YW5jZXMnOiBpdGVtLmNvdW50XG4gICAgICB9O1xuICAgIH0pO1xuICB9LFxuXG4gIHByaW50V2FzdGVkOiBmdW5jdGlvbiAobWVhc3VyZW1lbnRzKSB7XG4gICAgbWVhc3VyZW1lbnRzID0gbWVhc3VyZW1lbnRzIHx8IFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cztcbiAgICBjb25zb2xlLnRhYmxlKFJlYWN0RGVmYXVsdFBlcmYuZ2V0TWVhc3VyZW1lbnRzU3VtbWFyeU1hcChtZWFzdXJlbWVudHMpKTtcbiAgICBjb25zb2xlLmxvZygnVG90YWwgdGltZTonLCBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0VG90YWxUaW1lKG1lYXN1cmVtZW50cykudG9GaXhlZCgyKSArICcgbXMnKTtcbiAgfSxcblxuICBwcmludERPTTogZnVuY3Rpb24gKG1lYXN1cmVtZW50cykge1xuICAgIG1lYXN1cmVtZW50cyA9IG1lYXN1cmVtZW50cyB8fCBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHM7XG4gICAgdmFyIHN1bW1hcnkgPSBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0RE9NU3VtbWFyeShtZWFzdXJlbWVudHMpO1xuICAgIGNvbnNvbGUudGFibGUoc3VtbWFyeS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIHJlc3VsdFtET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRV0gPSBpdGVtLmlkO1xuICAgICAgcmVzdWx0LnR5cGUgPSBpdGVtLnR5cGU7XG4gICAgICByZXN1bHQuYXJncyA9IEpTT04uc3RyaW5naWZ5KGl0ZW0uYXJncyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pKTtcbiAgICBjb25zb2xlLmxvZygnVG90YWwgdGltZTonLCBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0VG90YWxUaW1lKG1lYXN1cmVtZW50cykudG9GaXhlZCgyKSArICcgbXMnKTtcbiAgfSxcblxuICBfcmVjb3JkV3JpdGU6IGZ1bmN0aW9uIChpZCwgZm5OYW1lLCB0b3RhbFRpbWUsIGFyZ3MpIHtcbiAgICAvLyBUT0RPOiB0b3RhbFRpbWUgaXNuJ3QgdGhhdCB1c2VmdWwgc2luY2UgaXQgZG9lc24ndCBjb3VudCBwYWludHMvcmVmbG93c1xuICAgIHZhciB3cml0ZXMgPSBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHNbUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzLmxlbmd0aCAtIDFdLndyaXRlcztcbiAgICB3cml0ZXNbaWRdID0gd3JpdGVzW2lkXSB8fCBbXTtcbiAgICB3cml0ZXNbaWRdLnB1c2goe1xuICAgICAgdHlwZTogZm5OYW1lLFxuICAgICAgdGltZTogdG90YWxUaW1lLFxuICAgICAgYXJnczogYXJnc1xuICAgIH0pO1xuICB9LFxuXG4gIG1lYXN1cmU6IGZ1bmN0aW9uIChtb2R1bGVOYW1lLCBmbk5hbWUsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvdGFsVGltZTtcbiAgICAgIHZhciBydjtcbiAgICAgIHZhciBzdGFydDtcblxuICAgICAgaWYgKGZuTmFtZSA9PT0gJ19yZW5kZXJOZXdSb290Q29tcG9uZW50JyB8fCBmbk5hbWUgPT09ICdmbHVzaEJhdGNoZWRVcGRhdGVzJykge1xuICAgICAgICAvLyBBIFwibWVhc3VyZW1lbnRcIiBpcyBhIHNldCBvZiBtZXRyaWNzIHJlY29yZGVkIGZvciBlYWNoIGZsdXNoLiBXZSB3YW50XG4gICAgICAgIC8vIHRvIGdyb3VwIHRoZSBtZXRyaWNzIGZvciBhIGdpdmVuIGZsdXNoIHRvZ2V0aGVyIHNvIHdlIGNhbiBsb29rIGF0IHRoZVxuICAgICAgICAvLyBjb21wb25lbnRzIHRoYXQgcmVuZGVyZWQgYW5kIHRoZSBET00gb3BlcmF0aW9ucyB0aGF0IGFjdHVhbGx5XG4gICAgICAgIC8vIGhhcHBlbmVkIHRvIGRldGVybWluZSB0aGUgYW1vdW50IG9mIFwid2FzdGVkIHdvcmtcIiBwZXJmb3JtZWQuXG4gICAgICAgIFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cy5wdXNoKHtcbiAgICAgICAgICBleGNsdXNpdmU6IHt9LFxuICAgICAgICAgIGluY2x1c2l2ZToge30sXG4gICAgICAgICAgcmVuZGVyOiB7fSxcbiAgICAgICAgICBjb3VudHM6IHt9LFxuICAgICAgICAgIHdyaXRlczoge30sXG4gICAgICAgICAgZGlzcGxheU5hbWVzOiB7fSxcbiAgICAgICAgICB0b3RhbFRpbWU6IDAsXG4gICAgICAgICAgY3JlYXRlZDoge31cbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgcnYgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHNbUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzLmxlbmd0aCAtIDFdLnRvdGFsVGltZSA9IHBlcmZvcm1hbmNlTm93KCkgLSBzdGFydDtcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfSBlbHNlIGlmIChmbk5hbWUgPT09ICdfbW91bnRJbWFnZUludG9Ob2RlJyB8fCBtb2R1bGVOYW1lID09PSAnUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyB8fCBtb2R1bGVOYW1lID09PSAnUmVhY3RET01JRE9wZXJhdGlvbnMnIHx8IG1vZHVsZU5hbWUgPT09ICdDU1NQcm9wZXJ0eU9wZXJhdGlvbnMnIHx8IG1vZHVsZU5hbWUgPT09ICdET01DaGlsZHJlbk9wZXJhdGlvbnMnIHx8IG1vZHVsZU5hbWUgPT09ICdET01Qcm9wZXJ0eU9wZXJhdGlvbnMnKSB7XG4gICAgICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgcnYgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB0b3RhbFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpIC0gc3RhcnQ7XG5cbiAgICAgICAgaWYgKGZuTmFtZSA9PT0gJ19tb3VudEltYWdlSW50b05vZGUnKSB7XG4gICAgICAgICAgdmFyIG1vdW50SUQgPSBSZWFjdE1vdW50LmdldElEKGFyZ3NbMV0pO1xuICAgICAgICAgIFJlYWN0RGVmYXVsdFBlcmYuX3JlY29yZFdyaXRlKG1vdW50SUQsIGZuTmFtZSwgdG90YWxUaW1lLCBhcmdzWzBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChmbk5hbWUgPT09ICdkYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXMnKSB7XG4gICAgICAgICAgLy8gc3BlY2lhbCBmb3JtYXRcbiAgICAgICAgICBhcmdzWzBdLmZvckVhY2goZnVuY3Rpb24gKHVwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHdyaXRlQXJncyA9IHt9O1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5mcm9tSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd3JpdGVBcmdzLmZyb21JbmRleCA9IHVwZGF0ZS5mcm9tSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlLnRvSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd3JpdGVBcmdzLnRvSW5kZXggPSB1cGRhdGUudG9JbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cGRhdGUudGV4dENvbnRlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd3JpdGVBcmdzLnRleHRDb250ZW50ID0gdXBkYXRlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVwZGF0ZS5tYXJrdXBJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB3cml0ZUFyZ3MubWFya3VwID0gYXJnc1sxXVt1cGRhdGUubWFya3VwSW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVhY3REZWZhdWx0UGVyZi5fcmVjb3JkV3JpdGUodXBkYXRlLnBhcmVudElELCB1cGRhdGUudHlwZSwgdG90YWxUaW1lLCB3cml0ZUFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGJhc2ljIGZvcm1hdFxuICAgICAgICAgIHZhciBpZCA9IGFyZ3NbMF07XG4gICAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlkID0gUmVhY3RNb3VudC5nZXRJRChhcmdzWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgUmVhY3REZWZhdWx0UGVyZi5fcmVjb3JkV3JpdGUoaWQsIGZuTmFtZSwgdG90YWxUaW1lLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfSBlbHNlIGlmIChtb2R1bGVOYW1lID09PSAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnICYmIChmbk5hbWUgPT09ICdtb3VudENvbXBvbmVudCcgfHwgZm5OYW1lID09PSAndXBkYXRlQ29tcG9uZW50JyB8fCAvLyBUT0RPOiByZWNlaXZlQ29tcG9uZW50KCk/XG4gICAgICBmbk5hbWUgPT09ICdfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50JykpIHtcblxuICAgICAgICBpZiAodGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSA9PT0gUmVhY3RNb3VudC5Ub3BMZXZlbFdyYXBwZXIpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByb290Tm9kZUlEID0gZm5OYW1lID09PSAnbW91bnRDb21wb25lbnQnID8gYXJnc1swXSA6IHRoaXMuX3Jvb3ROb2RlSUQ7XG4gICAgICAgIHZhciBpc1JlbmRlciA9IGZuTmFtZSA9PT0gJ19yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQnO1xuICAgICAgICB2YXIgaXNNb3VudCA9IGZuTmFtZSA9PT0gJ21vdW50Q29tcG9uZW50JztcblxuICAgICAgICB2YXIgbW91bnRTdGFjayA9IFJlYWN0RGVmYXVsdFBlcmYuX21vdW50U3RhY2s7XG4gICAgICAgIHZhciBlbnRyeSA9IFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50c1tSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKGlzUmVuZGVyKSB7XG4gICAgICAgICAgYWRkVmFsdWUoZW50cnkuY291bnRzLCByb290Tm9kZUlELCAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc01vdW50KSB7XG4gICAgICAgICAgZW50cnkuY3JlYXRlZFtyb290Tm9kZUlEXSA9IHRydWU7XG4gICAgICAgICAgbW91bnRTdGFjay5wdXNoKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICBydiA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHRvdGFsVGltZSA9IHBlcmZvcm1hbmNlTm93KCkgLSBzdGFydDtcblxuICAgICAgICBpZiAoaXNSZW5kZXIpIHtcbiAgICAgICAgICBhZGRWYWx1ZShlbnRyeS5yZW5kZXIsIHJvb3ROb2RlSUQsIHRvdGFsVGltZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb3VudCkge1xuICAgICAgICAgIHZhciBzdWJNb3VudFRpbWUgPSBtb3VudFN0YWNrLnBvcCgpO1xuICAgICAgICAgIG1vdW50U3RhY2tbbW91bnRTdGFjay5sZW5ndGggLSAxXSArPSB0b3RhbFRpbWU7XG4gICAgICAgICAgYWRkVmFsdWUoZW50cnkuZXhjbHVzaXZlLCByb290Tm9kZUlELCB0b3RhbFRpbWUgLSBzdWJNb3VudFRpbWUpO1xuICAgICAgICAgIGFkZFZhbHVlKGVudHJ5LmluY2x1c2l2ZSwgcm9vdE5vZGVJRCwgdG90YWxUaW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRWYWx1ZShlbnRyeS5pbmNsdXNpdmUsIHJvb3ROb2RlSUQsIHRvdGFsVGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbnRyeS5kaXNwbGF5TmFtZXNbcm9vdE5vZGVJRF0gPSB7XG4gICAgICAgICAgY3VycmVudDogdGhpcy5nZXROYW1lKCksXG4gICAgICAgICAgb3duZXI6IHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9vd25lciA/IHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9vd25lci5nZXROYW1lKCkgOiAnPHJvb3Q+J1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBydjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZWZhdWx0UGVyZjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RGVmYXVsdFBlcmYuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG5cbi8vIERvbid0IHRyeSB0byBzYXZlIHVzZXJzIGxlc3MgdGhhbiAxLjJtcyAoYSBudW1iZXIgSSBtYWRlIHVwKVxudmFyIERPTlRfQ0FSRV9USFJFU0hPTEQgPSAxLjI7XG52YXIgRE9NX09QRVJBVElPTl9UWVBFUyA9IHtcbiAgJ19tb3VudEltYWdlSW50b05vZGUnOiAnc2V0IGlubmVySFRNTCcsXG4gIElOU0VSVF9NQVJLVVA6ICdzZXQgaW5uZXJIVE1MJyxcbiAgTU9WRV9FWElTVElORzogJ21vdmUnLFxuICBSRU1PVkVfTk9ERTogJ3JlbW92ZScsXG4gIFNFVF9NQVJLVVA6ICdzZXQgaW5uZXJIVE1MJyxcbiAgVEVYVF9DT05URU5UOiAnc2V0IHRleHRDb250ZW50JyxcbiAgJ3NldFZhbHVlRm9yUHJvcGVydHknOiAndXBkYXRlIGF0dHJpYnV0ZScsXG4gICdzZXRWYWx1ZUZvckF0dHJpYnV0ZSc6ICd1cGRhdGUgYXR0cmlidXRlJyxcbiAgJ2RlbGV0ZVZhbHVlRm9yUHJvcGVydHknOiAncmVtb3ZlIGF0dHJpYnV0ZScsXG4gICdzZXRWYWx1ZUZvclN0eWxlcyc6ICd1cGRhdGUgc3R5bGVzJyxcbiAgJ3JlcGxhY2VOb2RlV2l0aE1hcmt1cCc6ICdyZXBsYWNlJyxcbiAgJ3VwZGF0ZVRleHRDb250ZW50JzogJ3NldCB0ZXh0Q29udGVudCdcbn07XG5cbmZ1bmN0aW9uIGdldFRvdGFsVGltZShtZWFzdXJlbWVudHMpIHtcbiAgLy8gVE9ETzogcmV0dXJuIG51bWJlciBvZiBET00gb3BzPyBjb3VsZCBiZSBtaXNsZWFkaW5nLlxuICAvLyBUT0RPOiBtZWFzdXJlIGRyb3BwZWQgZnJhbWVzIGFmdGVyIHJlY29uY2lsZT9cbiAgLy8gVE9ETzogbG9nIHRvdGFsIHRpbWUgb2YgZWFjaCByZWNvbmNpbGUgYW5kIHRoZSB0b3AtbGV2ZWwgY29tcG9uZW50XG4gIC8vIGNsYXNzIHRoYXQgdHJpZ2dlcmVkIGl0LlxuICB2YXIgdG90YWxUaW1lID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZWFzdXJlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudHNbaV07XG4gICAgdG90YWxUaW1lICs9IG1lYXN1cmVtZW50LnRvdGFsVGltZTtcbiAgfVxuICByZXR1cm4gdG90YWxUaW1lO1xufVxuXG5mdW5jdGlvbiBnZXRET01TdW1tYXJ5KG1lYXN1cmVtZW50cykge1xuICB2YXIgaXRlbXMgPSBbXTtcbiAgbWVhc3VyZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG1lYXN1cmVtZW50KSB7XG4gICAgT2JqZWN0LmtleXMobWVhc3VyZW1lbnQud3JpdGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgbWVhc3VyZW1lbnQud3JpdGVzW2lkXS5mb3JFYWNoKGZ1bmN0aW9uICh3cml0ZSkge1xuICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgdHlwZTogRE9NX09QRVJBVElPTl9UWVBFU1t3cml0ZS50eXBlXSB8fCB3cml0ZS50eXBlLFxuICAgICAgICAgIGFyZ3M6IHdyaXRlLmFyZ3NcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBpdGVtcztcbn1cblxuZnVuY3Rpb24gZ2V0RXhjbHVzaXZlU3VtbWFyeShtZWFzdXJlbWVudHMpIHtcbiAgdmFyIGNhbmRpZGF0ZXMgPSB7fTtcbiAgdmFyIGRpc3BsYXlOYW1lO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWVhc3VyZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW2ldO1xuICAgIHZhciBhbGxJRHMgPSBhc3NpZ24oe30sIG1lYXN1cmVtZW50LmV4Y2x1c2l2ZSwgbWVhc3VyZW1lbnQuaW5jbHVzaXZlKTtcblxuICAgIGZvciAodmFyIGlkIGluIGFsbElEcykge1xuICAgICAgZGlzcGxheU5hbWUgPSBtZWFzdXJlbWVudC5kaXNwbGF5TmFtZXNbaWRdLmN1cnJlbnQ7XG5cbiAgICAgIGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdID0gY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0gfHwge1xuICAgICAgICBjb21wb25lbnROYW1lOiBkaXNwbGF5TmFtZSxcbiAgICAgICAgaW5jbHVzaXZlOiAwLFxuICAgICAgICBleGNsdXNpdmU6IDAsXG4gICAgICAgIHJlbmRlcjogMCxcbiAgICAgICAgY291bnQ6IDBcbiAgICAgIH07XG4gICAgICBpZiAobWVhc3VyZW1lbnQucmVuZGVyW2lkXSkge1xuICAgICAgICBjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXS5yZW5kZXIgKz0gbWVhc3VyZW1lbnQucmVuZGVyW2lkXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZWFzdXJlbWVudC5leGNsdXNpdmVbaWRdKSB7XG4gICAgICAgIGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdLmV4Y2x1c2l2ZSArPSBtZWFzdXJlbWVudC5leGNsdXNpdmVbaWRdO1xuICAgICAgfVxuICAgICAgaWYgKG1lYXN1cmVtZW50LmluY2x1c2l2ZVtpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0uaW5jbHVzaXZlICs9IG1lYXN1cmVtZW50LmluY2x1c2l2ZVtpZF07XG4gICAgICB9XG4gICAgICBpZiAobWVhc3VyZW1lbnQuY291bnRzW2lkXSkge1xuICAgICAgICBjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXS5jb3VudCArPSBtZWFzdXJlbWVudC5jb3VudHNbaWRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE5vdyBtYWtlIGEgc29ydGVkIGFycmF5IHdpdGggdGhlIHJlc3VsdHMuXG4gIHZhciBhcnIgPSBbXTtcbiAgZm9yIChkaXNwbGF5TmFtZSBpbiBjYW5kaWRhdGVzKSB7XG4gICAgaWYgKGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdLmV4Y2x1c2l2ZSA+PSBET05UX0NBUkVfVEhSRVNIT0xEKSB7XG4gICAgICBhcnIucHVzaChjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXSk7XG4gICAgfVxuICB9XG5cbiAgYXJyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5leGNsdXNpdmUgLSBhLmV4Y2x1c2l2ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gZ2V0SW5jbHVzaXZlU3VtbWFyeShtZWFzdXJlbWVudHMsIG9ubHlDbGVhbikge1xuICB2YXIgY2FuZGlkYXRlcyA9IHt9O1xuICB2YXIgaW5jbHVzaXZlS2V5O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWVhc3VyZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW2ldO1xuICAgIHZhciBhbGxJRHMgPSBhc3NpZ24oe30sIG1lYXN1cmVtZW50LmV4Y2x1c2l2ZSwgbWVhc3VyZW1lbnQuaW5jbHVzaXZlKTtcbiAgICB2YXIgY2xlYW5Db21wb25lbnRzO1xuXG4gICAgaWYgKG9ubHlDbGVhbikge1xuICAgICAgY2xlYW5Db21wb25lbnRzID0gZ2V0VW5jaGFuZ2VkQ29tcG9uZW50cyhtZWFzdXJlbWVudCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaWQgaW4gYWxsSURzKSB7XG4gICAgICBpZiAob25seUNsZWFuICYmICFjbGVhbkNvbXBvbmVudHNbaWRdKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSBtZWFzdXJlbWVudC5kaXNwbGF5TmFtZXNbaWRdO1xuXG4gICAgICAvLyBJbmNsdXNpdmUgdGltZSBpcyBub3QgdXNlZnVsIGZvciBtYW55IGNvbXBvbmVudHMgd2l0aG91dCBrbm93aW5nIHdoZXJlXG4gICAgICAvLyB0aGV5IGFyZSBpbnN0YW50aWF0ZWQuIFNvIHdlIGFnZ3JlZ2F0ZSBpbmNsdXNpdmUgdGltZSB3aXRoIGJvdGggdGhlXG4gICAgICAvLyBvd25lciBhbmQgY3VycmVudCBkaXNwbGF5TmFtZSBhcyB0aGUga2V5LlxuICAgICAgaW5jbHVzaXZlS2V5ID0gZGlzcGxheU5hbWUub3duZXIgKyAnID4gJyArIGRpc3BsYXlOYW1lLmN1cnJlbnQ7XG5cbiAgICAgIGNhbmRpZGF0ZXNbaW5jbHVzaXZlS2V5XSA9IGNhbmRpZGF0ZXNbaW5jbHVzaXZlS2V5XSB8fCB7XG4gICAgICAgIGNvbXBvbmVudE5hbWU6IGluY2x1c2l2ZUtleSxcbiAgICAgICAgdGltZTogMCxcbiAgICAgICAgY291bnQ6IDBcbiAgICAgIH07XG5cbiAgICAgIGlmIChtZWFzdXJlbWVudC5pbmNsdXNpdmVbaWRdKSB7XG4gICAgICAgIGNhbmRpZGF0ZXNbaW5jbHVzaXZlS2V5XS50aW1lICs9IG1lYXN1cmVtZW50LmluY2x1c2l2ZVtpZF07XG4gICAgICB9XG4gICAgICBpZiAobWVhc3VyZW1lbnQuY291bnRzW2lkXSkge1xuICAgICAgICBjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0uY291bnQgKz0gbWVhc3VyZW1lbnQuY291bnRzW2lkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBOb3cgbWFrZSBhIHNvcnRlZCBhcnJheSB3aXRoIHRoZSByZXN1bHRzLlxuICB2YXIgYXJyID0gW107XG4gIGZvciAoaW5jbHVzaXZlS2V5IGluIGNhbmRpZGF0ZXMpIHtcbiAgICBpZiAoY2FuZGlkYXRlc1tpbmNsdXNpdmVLZXldLnRpbWUgPj0gRE9OVF9DQVJFX1RIUkVTSE9MRCkge1xuICAgICAgYXJyLnB1c2goY2FuZGlkYXRlc1tpbmNsdXNpdmVLZXldKTtcbiAgICB9XG4gIH1cblxuICBhcnIuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLnRpbWUgLSBhLnRpbWU7XG4gIH0pO1xuXG4gIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIGdldFVuY2hhbmdlZENvbXBvbmVudHMobWVhc3VyZW1lbnQpIHtcbiAgLy8gRm9yIGEgZ2l2ZW4gcmVjb25jaWxlLCBsb29rIGF0IHdoaWNoIGNvbXBvbmVudHMgZGlkIG5vdCBhY3R1YWxseVxuICAvLyByZW5kZXIgYW55dGhpbmcgdG8gdGhlIERPTSBhbmQgcmV0dXJuIGEgbWFwcGluZyBvZiB0aGVpciBJRCB0b1xuICAvLyB0aGUgYW1vdW50IG9mIHRpbWUgaXQgdG9vayB0byByZW5kZXIgdGhlIGVudGlyZSBzdWJ0cmVlLlxuICB2YXIgY2xlYW5Db21wb25lbnRzID0ge307XG4gIHZhciBkaXJ0eUxlYWZJRHMgPSBPYmplY3Qua2V5cyhtZWFzdXJlbWVudC53cml0ZXMpO1xuICB2YXIgYWxsSURzID0gYXNzaWduKHt9LCBtZWFzdXJlbWVudC5leGNsdXNpdmUsIG1lYXN1cmVtZW50LmluY2x1c2l2ZSk7XG5cbiAgZm9yICh2YXIgaWQgaW4gYWxsSURzKSB7XG4gICAgdmFyIGlzRGlydHkgPSBmYWxzZTtcbiAgICAvLyBGb3IgZWFjaCBjb21wb25lbnQgdGhhdCByZW5kZXJlZCwgc2VlIGlmIGEgY29tcG9uZW50IHRoYXQgdHJpZ2dlcmVkXG4gICAgLy8gYSBET00gb3AgaXMgaW4gaXRzIHN1YnRyZWUuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJ0eUxlYWZJRHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChkaXJ0eUxlYWZJRHNbaV0uaW5kZXhPZihpZCkgPT09IDApIHtcbiAgICAgICAgaXNEaXJ0eSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBjaGVjayBpZiBjb21wb25lbnQgbmV3bHkgY3JlYXRlZFxuICAgIGlmIChtZWFzdXJlbWVudC5jcmVhdGVkW2lkXSkge1xuICAgICAgaXNEaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIGlmICghaXNEaXJ0eSAmJiBtZWFzdXJlbWVudC5jb3VudHNbaWRdID4gMCkge1xuICAgICAgY2xlYW5Db21wb25lbnRzW2lkXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBjbGVhbkNvbXBvbmVudHM7XG59XG5cbnZhciBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMgPSB7XG4gIGdldEV4Y2x1c2l2ZVN1bW1hcnk6IGdldEV4Y2x1c2l2ZVN1bW1hcnksXG4gIGdldEluY2x1c2l2ZVN1bW1hcnk6IGdldEluY2x1c2l2ZVN1bW1hcnksXG4gIGdldERPTVN1bW1hcnk6IGdldERPTVN1bW1hcnksXG4gIGdldFRvdGFsVGltZTogZ2V0VG90YWxUaW1lXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBwZXJmb3JtYW5jZU5vd1xuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwZXJmb3JtYW5jZSA9IHJlcXVpcmUoJy4vcGVyZm9ybWFuY2UnKTtcblxudmFyIHBlcmZvcm1hbmNlTm93O1xuXG4vKipcbiAqIERldGVjdCBpZiB3ZSBjYW4gdXNlIGB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClgIGFuZCBncmFjZWZ1bGx5IGZhbGxiYWNrIHRvXG4gKiBgRGF0ZS5ub3coKWAgaWYgaXQgZG9lc24ndCBleGlzdC4gV2UgbmVlZCB0byBzdXBwb3J0IEZpcmVmb3ggPCAxNSBmb3Igbm93XG4gKiBiZWNhdXNlIG9mIEZhY2Vib29rJ3MgdGVzdGluZyBpbmZyYXN0cnVjdHVyZS5cbiAqL1xuaWYgKHBlcmZvcm1hbmNlLm5vdykge1xuICBwZXJmb3JtYW5jZU5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gIH07XG59IGVsc2Uge1xuICBwZXJmb3JtYW5jZU5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwZXJmb3JtYW5jZU5vdztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZmJqcy9saWIvcGVyZm9ybWFuY2VOb3cuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgcGVyZm9ybWFuY2VcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBwZXJmb3JtYW5jZTtcblxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBwZXJmb3JtYW5jZSA9IHdpbmRvdy5wZXJmb3JtYW5jZSB8fCB3aW5kb3cubXNQZXJmb3JtYW5jZSB8fCB3aW5kb3cud2Via2l0UGVyZm9ybWFuY2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGVyZm9ybWFuY2UgfHwge307XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ZianMvbGliL3BlcmZvcm1hbmNlLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0VmVyc2lvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAnMC4xNC44JztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0VmVyc2lvbi5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiogQHByb3ZpZGVzTW9kdWxlIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNb3VudC5yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NU2VydmVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3REZWZhdWx0SW5qZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdERlZmF1bHRJbmplY3Rpb24nKTtcbnZhciBSZWFjdFNlcnZlclJlbmRlcmluZyA9IHJlcXVpcmUoJy4vUmVhY3RTZXJ2ZXJSZW5kZXJpbmcnKTtcbnZhciBSZWFjdFZlcnNpb24gPSByZXF1aXJlKCcuL1JlYWN0VmVyc2lvbicpO1xuXG5SZWFjdERlZmF1bHRJbmplY3Rpb24uaW5qZWN0KCk7XG5cbnZhciBSZWFjdERPTVNlcnZlciA9IHtcbiAgcmVuZGVyVG9TdHJpbmc6IFJlYWN0U2VydmVyUmVuZGVyaW5nLnJlbmRlclRvU3RyaW5nLFxuICByZW5kZXJUb1N0YXRpY01hcmt1cDogUmVhY3RTZXJ2ZXJSZW5kZXJpbmcucmVuZGVyVG9TdGF0aWNNYXJrdXAsXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVNlcnZlcjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0RE9NU2VydmVyLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFNlcnZlclJlbmRlcmluZ1xuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5ID0gcmVxdWlyZSgnLi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5Jyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZUhhbmRsZXMnKTtcbnZhciBSZWFjdE1hcmt1cENoZWNrc3VtID0gcmVxdWlyZSgnLi9SZWFjdE1hcmt1cENoZWNrc3VtJyk7XG52YXIgUmVhY3RTZXJ2ZXJCYXRjaGluZ1N0cmF0ZWd5ID0gcmVxdWlyZSgnLi9SZWFjdFNlcnZlckJhdGNoaW5nU3RyYXRlZ3knKTtcbnZhciBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIEhUTUwgbWFya3VwXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclRvU3RyaW5nKGVsZW1lbnQpIHtcbiAgIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdyZW5kZXJUb1N0cmluZygpOiBZb3UgbXVzdCBwYXNzIGEgdmFsaWQgUmVhY3RFbGVtZW50LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICB2YXIgdHJhbnNhY3Rpb247XG4gIHRyeSB7XG4gICAgUmVhY3RVcGRhdGVzLmluamVjdGlvbi5pbmplY3RCYXRjaGluZ1N0cmF0ZWd5KFJlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneSk7XG5cbiAgICB2YXIgaWQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5jcmVhdGVSZWFjdFJvb3RJRCgpO1xuICAgIHRyYW5zYWN0aW9uID0gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5nZXRQb29sZWQoZmFsc2UpO1xuXG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLnBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChlbGVtZW50LCBudWxsKTtcbiAgICAgIHZhciBtYXJrdXAgPSBjb21wb25lbnRJbnN0YW5jZS5tb3VudENvbXBvbmVudChpZCwgdHJhbnNhY3Rpb24sIGVtcHR5T2JqZWN0KTtcbiAgICAgIHJldHVybiBSZWFjdE1hcmt1cENoZWNrc3VtLmFkZENoZWNrc3VtVG9NYXJrdXAobWFya3VwKTtcbiAgICB9LCBudWxsKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xuICAgIC8vIFJldmVydCB0byB0aGUgRE9NIGJhdGNoaW5nIHN0cmF0ZWd5IHNpbmNlIHRoZXNlIHR3byByZW5kZXJlcnNcbiAgICAvLyBjdXJyZW50bHkgc2hhcmUgdGhlc2Ugc3RhdGVmdWwgbW9kdWxlcy5cbiAgICBSZWFjdFVwZGF0ZXMuaW5qZWN0aW9uLmluamVjdEJhdGNoaW5nU3RyYXRlZ3koUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgSFRNTCBtYXJrdXAsIHdpdGhvdXQgdGhlIGV4dHJhIFJlYWN0IElEIGFuZCBjaGVja3N1bVxuICogKGZvciBnZW5lcmF0aW5nIHN0YXRpYyBwYWdlcylcbiAqL1xuZnVuY3Rpb24gcmVuZGVyVG9TdGF0aWNNYXJrdXAoZWxlbWVudCkge1xuICAhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3JlbmRlclRvU3RhdGljTWFya3VwKCk6IFlvdSBtdXN0IHBhc3MgYSB2YWxpZCBSZWFjdEVsZW1lbnQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIHZhciB0cmFuc2FjdGlvbjtcbiAgdHJ5IHtcbiAgICBSZWFjdFVwZGF0ZXMuaW5qZWN0aW9uLmluamVjdEJhdGNoaW5nU3RyYXRlZ3koUmVhY3RTZXJ2ZXJCYXRjaGluZ1N0cmF0ZWd5KTtcblxuICAgIHZhciBpZCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmNyZWF0ZVJlYWN0Um9vdElEKCk7XG4gICAgdHJhbnNhY3Rpb24gPSBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLmdldFBvb2xlZCh0cnVlKTtcblxuICAgIHJldHVybiB0cmFuc2FjdGlvbi5wZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQoZWxlbWVudCwgbnVsbCk7XG4gICAgICByZXR1cm4gY29tcG9uZW50SW5zdGFuY2UubW91bnRDb21wb25lbnQoaWQsIHRyYW5zYWN0aW9uLCBlbXB0eU9iamVjdCk7XG4gICAgfSwgbnVsbCk7XG4gIH0gZmluYWxseSB7XG4gICAgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbiAgICAvLyBSZXZlcnQgdG8gdGhlIERPTSBiYXRjaGluZyBzdHJhdGVneSBzaW5jZSB0aGVzZSB0d28gcmVuZGVyZXJzXG4gICAgLy8gY3VycmVudGx5IHNoYXJlIHRoZXNlIHN0YXRlZnVsIG1vZHVsZXMuXG4gICAgUmVhY3RVcGRhdGVzLmluamVjdGlvbi5pbmplY3RCYXRjaGluZ1N0cmF0ZWd5KFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZW5kZXJUb1N0cmluZzogcmVuZGVyVG9TdHJpbmcsXG4gIHJlbmRlclRvU3RhdGljTWFya3VwOiByZW5kZXJUb1N0YXRpY01hcmt1cFxufTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0U2VydmVyUmVuZGVyaW5nLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFNlcnZlckJhdGNoaW5nU3RyYXRlZ3kgPSB7XG4gIGlzQmF0Y2hpbmdVcGRhdGVzOiBmYWxzZSxcbiAgYmF0Y2hlZFVwZGF0ZXM6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIC8vIERvbid0IGRvIGFueXRoaW5nIGhlcmUuIER1cmluZyB0aGUgc2VydmVyIHJlbmRlcmluZyB3ZSBkb24ndCB3YW50IHRvXG4gICAgLy8gc2NoZWR1bGUgYW55IHVwZGF0ZXMuIFdlIHdpbGwgc2ltcGx5IGlnbm9yZSB0aGVtLlxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneS5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIENhbGxiYWNrUXVldWUgPSByZXF1aXJlKCcuL0NhbGxiYWNrUXVldWUnKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogUHJvdmlkZXMgYSBgQ2FsbGJhY2tRdWV1ZWAgcXVldWUgZm9yIGNvbGxlY3RpbmcgYG9uRE9NUmVhZHlgIGNhbGxiYWNrc1xuICogZHVyaW5nIHRoZSBwZXJmb3JtaW5nIG9mIHRoZSB0cmFuc2FjdGlvbi5cbiAqL1xudmFyIE9OX0RPTV9SRUFEWV9RVUVVRUlORyA9IHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBpbnRlcm5hbCBgb25ET01SZWFkeWAgcXVldWUuXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkucmVzZXQoKTtcbiAgfSxcblxuICBjbG9zZTogZW1wdHlGdW5jdGlvblxufTtcblxuLyoqXG4gKiBFeGVjdXRlZCB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBDb25zaWRlciB0aGVzZSBhc1xuICogYmVpbmcgbWVtYmVyIG1ldGhvZHMsIGJ1dCB3aXRoIGFuIGltcGxpZWQgb3JkZXJpbmcgd2hpbGUgYmVpbmcgaXNvbGF0ZWQgZnJvbVxuICogZWFjaCBvdGhlci5cbiAqL1xudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW09OX0RPTV9SRUFEWV9RVUVVRUlOR107XG5cbi8qKlxuICogQGNsYXNzIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVuZGVyVG9TdGF0aWNNYXJrdXBcbiAqL1xuZnVuY3Rpb24gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbihyZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG4gIHRoaXMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSByZW5kZXJUb1N0YXRpY01hcmt1cDtcbiAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZChudWxsKTtcbiAgdGhpcy51c2VDcmVhdGVFbGVtZW50ID0gZmFsc2U7XG59XG5cbnZhciBNaXhpbiA9IHtcbiAgLyoqXG4gICAqIEBzZWUgVHJhbnNhY3Rpb25cbiAgICogQGFic3RyYWN0XG4gICAqIEBmaW5hbFxuICAgKiBAcmV0dXJuIHthcnJheX0gRW1wdHkgbGlzdCBvZiBvcGVyYXRpb24gd3JhcCBwcm9jZWR1cmVzLlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBgb25ET01SZWFkeWAgY2FsbGJhY2tzIHdpdGguXG4gICAqL1xuICBnZXRSZWFjdE1vdW50UmVhZHk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFjdE1vdW50UmVhZHk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIHRoaXMsIGFuZCB3aWxsIGludm9rZSB0aGlzIGJlZm9yZSBhbGxvd2luZyB0aGlzXG4gICAqIGluc3RhbmNlIHRvIGJlIHJldXNlZC5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UodGhpcy5yZWFjdE1vdW50UmVhZHkpO1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5ID0gbnVsbDtcbiAgfVxufTtcblxuYXNzaWduKFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbi5NaXhpbiwgTWl4aW4pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbjtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24uanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJc29tb3JwaGljXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHJlcXVpcmUoJy4vUmVhY3RDaGlsZHJlbicpO1xudmFyIFJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudCcpO1xudmFyIFJlYWN0Q2xhc3MgPSByZXF1aXJlKCcuL1JlYWN0Q2xhc3MnKTtcbnZhciBSZWFjdERPTUZhY3RvcmllcyA9IHJlcXVpcmUoJy4vUmVhY3RET01GYWN0b3JpZXMnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50VmFsaWRhdG9yJyk7XG52YXIgUmVhY3RQcm9wVHlwZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVzJyk7XG52YXIgUmVhY3RWZXJzaW9uID0gcmVxdWlyZSgnLi9SZWFjdFZlcnNpb24nKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIG9ubHlDaGlsZCA9IHJlcXVpcmUoJy4vb25seUNoaWxkJyk7XG5cbnZhciBjcmVhdGVFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQ7XG52YXIgY3JlYXRlRmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5O1xudmFyIGNsb25lRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQ7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGNyZWF0ZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRWxlbWVudDtcbiAgY3JlYXRlRmFjdG9yeSA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVGYWN0b3J5O1xuICBjbG9uZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY2xvbmVFbGVtZW50O1xufVxuXG52YXIgUmVhY3QgPSB7XG5cbiAgLy8gTW9kZXJuXG5cbiAgQ2hpbGRyZW46IHtcbiAgICBtYXA6IFJlYWN0Q2hpbGRyZW4ubWFwLFxuICAgIGZvckVhY2g6IFJlYWN0Q2hpbGRyZW4uZm9yRWFjaCxcbiAgICBjb3VudDogUmVhY3RDaGlsZHJlbi5jb3VudCxcbiAgICB0b0FycmF5OiBSZWFjdENoaWxkcmVuLnRvQXJyYXksXG4gICAgb25seTogb25seUNoaWxkXG4gIH0sXG5cbiAgQ29tcG9uZW50OiBSZWFjdENvbXBvbmVudCxcblxuICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50LFxuICBjbG9uZUVsZW1lbnQ6IGNsb25lRWxlbWVudCxcbiAgaXNWYWxpZEVsZW1lbnQ6IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudCxcblxuICAvLyBDbGFzc2ljXG5cbiAgUHJvcFR5cGVzOiBSZWFjdFByb3BUeXBlcyxcbiAgY3JlYXRlQ2xhc3M6IFJlYWN0Q2xhc3MuY3JlYXRlQ2xhc3MsXG4gIGNyZWF0ZUZhY3Rvcnk6IGNyZWF0ZUZhY3RvcnksXG4gIGNyZWF0ZU1peGluOiBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICAvLyBDdXJyZW50bHkgYSBub29wLiBXaWxsIGJlIHVzZWQgdG8gdmFsaWRhdGUgYW5kIHRyYWNlIG1peGlucy5cbiAgICByZXR1cm4gbWl4aW47XG4gIH0sXG5cbiAgLy8gVGhpcyBsb29rcyBET00gc3BlY2lmaWMgYnV0IHRoZXNlIGFyZSBhY3R1YWxseSBpc29tb3JwaGljIGhlbHBlcnNcbiAgLy8gc2luY2UgdGhleSBhcmUganVzdCBnZW5lcmF0aW5nIERPTSBzdHJpbmdzLlxuICBET006IFJlYWN0RE9NRmFjdG9yaWVzLFxuXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcblxuICAvLyBIb29rIGZvciBKU1ggc3ByZWFkLCBkb24ndCB1c2UgdGhpcyBmb3IgYW55dGhpbmcgZWxzZS5cbiAgX19zcHJlYWQ6IGFzc2lnblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3QvbGliL1JlYWN0SXNvbW9ycGhpYy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUZhY3Rvcmllc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50VmFsaWRhdG9yJyk7XG5cbnZhciBtYXBPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9tYXBPYmplY3QnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBmYWN0b3J5IHRoYXQgY3JlYXRlcyBIVE1MIHRhZyBlbGVtZW50cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRhZyBuYW1lIChlLmcuIGBkaXZgKS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURPTUZhY3RvcnkodGFnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcmV0dXJuIFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVGYWN0b3J5KHRhZyk7XG4gIH1cbiAgcmV0dXJuIFJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5KHRhZyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcHBpbmcgZnJvbSBzdXBwb3J0ZWQgSFRNTCB0YWdzIHRvIGBSZWFjdERPTUNvbXBvbmVudGAgY2xhc3Nlcy5cbiAqIFRoaXMgaXMgYWxzbyBhY2Nlc3NpYmxlIHZpYSBgUmVhY3QuRE9NYC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBSZWFjdERPTUZhY3RvcmllcyA9IG1hcE9iamVjdCh7XG4gIGE6ICdhJyxcbiAgYWJicjogJ2FiYnInLFxuICBhZGRyZXNzOiAnYWRkcmVzcycsXG4gIGFyZWE6ICdhcmVhJyxcbiAgYXJ0aWNsZTogJ2FydGljbGUnLFxuICBhc2lkZTogJ2FzaWRlJyxcbiAgYXVkaW86ICdhdWRpbycsXG4gIGI6ICdiJyxcbiAgYmFzZTogJ2Jhc2UnLFxuICBiZGk6ICdiZGknLFxuICBiZG86ICdiZG8nLFxuICBiaWc6ICdiaWcnLFxuICBibG9ja3F1b3RlOiAnYmxvY2txdW90ZScsXG4gIGJvZHk6ICdib2R5JyxcbiAgYnI6ICdicicsXG4gIGJ1dHRvbjogJ2J1dHRvbicsXG4gIGNhbnZhczogJ2NhbnZhcycsXG4gIGNhcHRpb246ICdjYXB0aW9uJyxcbiAgY2l0ZTogJ2NpdGUnLFxuICBjb2RlOiAnY29kZScsXG4gIGNvbDogJ2NvbCcsXG4gIGNvbGdyb3VwOiAnY29sZ3JvdXAnLFxuICBkYXRhOiAnZGF0YScsXG4gIGRhdGFsaXN0OiAnZGF0YWxpc3QnLFxuICBkZDogJ2RkJyxcbiAgZGVsOiAnZGVsJyxcbiAgZGV0YWlsczogJ2RldGFpbHMnLFxuICBkZm46ICdkZm4nLFxuICBkaWFsb2c6ICdkaWFsb2cnLFxuICBkaXY6ICdkaXYnLFxuICBkbDogJ2RsJyxcbiAgZHQ6ICdkdCcsXG4gIGVtOiAnZW0nLFxuICBlbWJlZDogJ2VtYmVkJyxcbiAgZmllbGRzZXQ6ICdmaWVsZHNldCcsXG4gIGZpZ2NhcHRpb246ICdmaWdjYXB0aW9uJyxcbiAgZmlndXJlOiAnZmlndXJlJyxcbiAgZm9vdGVyOiAnZm9vdGVyJyxcbiAgZm9ybTogJ2Zvcm0nLFxuICBoMTogJ2gxJyxcbiAgaDI6ICdoMicsXG4gIGgzOiAnaDMnLFxuICBoNDogJ2g0JyxcbiAgaDU6ICdoNScsXG4gIGg2OiAnaDYnLFxuICBoZWFkOiAnaGVhZCcsXG4gIGhlYWRlcjogJ2hlYWRlcicsXG4gIGhncm91cDogJ2hncm91cCcsXG4gIGhyOiAnaHInLFxuICBodG1sOiAnaHRtbCcsXG4gIGk6ICdpJyxcbiAgaWZyYW1lOiAnaWZyYW1lJyxcbiAgaW1nOiAnaW1nJyxcbiAgaW5wdXQ6ICdpbnB1dCcsXG4gIGluczogJ2lucycsXG4gIGtiZDogJ2tiZCcsXG4gIGtleWdlbjogJ2tleWdlbicsXG4gIGxhYmVsOiAnbGFiZWwnLFxuICBsZWdlbmQ6ICdsZWdlbmQnLFxuICBsaTogJ2xpJyxcbiAgbGluazogJ2xpbmsnLFxuICBtYWluOiAnbWFpbicsXG4gIG1hcDogJ21hcCcsXG4gIG1hcms6ICdtYXJrJyxcbiAgbWVudTogJ21lbnUnLFxuICBtZW51aXRlbTogJ21lbnVpdGVtJyxcbiAgbWV0YTogJ21ldGEnLFxuICBtZXRlcjogJ21ldGVyJyxcbiAgbmF2OiAnbmF2JyxcbiAgbm9zY3JpcHQ6ICdub3NjcmlwdCcsXG4gIG9iamVjdDogJ29iamVjdCcsXG4gIG9sOiAnb2wnLFxuICBvcHRncm91cDogJ29wdGdyb3VwJyxcbiAgb3B0aW9uOiAnb3B0aW9uJyxcbiAgb3V0cHV0OiAnb3V0cHV0JyxcbiAgcDogJ3AnLFxuICBwYXJhbTogJ3BhcmFtJyxcbiAgcGljdHVyZTogJ3BpY3R1cmUnLFxuICBwcmU6ICdwcmUnLFxuICBwcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgcTogJ3EnLFxuICBycDogJ3JwJyxcbiAgcnQ6ICdydCcsXG4gIHJ1Ynk6ICdydWJ5JyxcbiAgczogJ3MnLFxuICBzYW1wOiAnc2FtcCcsXG4gIHNjcmlwdDogJ3NjcmlwdCcsXG4gIHNlY3Rpb246ICdzZWN0aW9uJyxcbiAgc2VsZWN0OiAnc2VsZWN0JyxcbiAgc21hbGw6ICdzbWFsbCcsXG4gIHNvdXJjZTogJ3NvdXJjZScsXG4gIHNwYW46ICdzcGFuJyxcbiAgc3Ryb25nOiAnc3Ryb25nJyxcbiAgc3R5bGU6ICdzdHlsZScsXG4gIHN1YjogJ3N1YicsXG4gIHN1bW1hcnk6ICdzdW1tYXJ5JyxcbiAgc3VwOiAnc3VwJyxcbiAgdGFibGU6ICd0YWJsZScsXG4gIHRib2R5OiAndGJvZHknLFxuICB0ZDogJ3RkJyxcbiAgdGV4dGFyZWE6ICd0ZXh0YXJlYScsXG4gIHRmb290OiAndGZvb3QnLFxuICB0aDogJ3RoJyxcbiAgdGhlYWQ6ICd0aGVhZCcsXG4gIHRpbWU6ICd0aW1lJyxcbiAgdGl0bGU6ICd0aXRsZScsXG4gIHRyOiAndHInLFxuICB0cmFjazogJ3RyYWNrJyxcbiAgdTogJ3UnLFxuICB1bDogJ3VsJyxcbiAgJ3Zhcic6ICd2YXInLFxuICB2aWRlbzogJ3ZpZGVvJyxcbiAgd2JyOiAnd2JyJyxcblxuICAvLyBTVkdcbiAgY2lyY2xlOiAnY2lyY2xlJyxcbiAgY2xpcFBhdGg6ICdjbGlwUGF0aCcsXG4gIGRlZnM6ICdkZWZzJyxcbiAgZWxsaXBzZTogJ2VsbGlwc2UnLFxuICBnOiAnZycsXG4gIGltYWdlOiAnaW1hZ2UnLFxuICBsaW5lOiAnbGluZScsXG4gIGxpbmVhckdyYWRpZW50OiAnbGluZWFyR3JhZGllbnQnLFxuICBtYXNrOiAnbWFzaycsXG4gIHBhdGg6ICdwYXRoJyxcbiAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICBwb2x5Z29uOiAncG9seWdvbicsXG4gIHBvbHlsaW5lOiAncG9seWxpbmUnLFxuICByYWRpYWxHcmFkaWVudDogJ3JhZGlhbEdyYWRpZW50JyxcbiAgcmVjdDogJ3JlY3QnLFxuICBzdG9wOiAnc3RvcCcsXG4gIHN2ZzogJ3N2ZycsXG4gIHRleHQ6ICd0ZXh0JyxcbiAgdHNwYW46ICd0c3BhbidcblxufSwgY3JlYXRlRE9NRmFjdG9yeSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01GYWN0b3JpZXM7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9SZWFjdERPTUZhY3Rvcmllcy5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVsZW1lbnRWYWxpZGF0b3JcbiAqL1xuXG4vKipcbiAqIFJlYWN0RWxlbWVudFZhbGlkYXRvciBwcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIGEgZWxlbWVudCBmYWN0b3J5XG4gKiB3aGljaCB2YWxpZGF0ZXMgdGhlIHByb3BzIHBhc3NlZCB0byB0aGUgZWxlbWVudC4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuICogdXNlZCBvbmx5IGluIERFViBhbmQgY291bGQgYmUgcmVwbGFjZWQgYnkgYSBzdGF0aWMgdHlwZSBjaGVja2VyIGZvciBsYW5ndWFnZXNcbiAqIHRoYXQgc3VwcG9ydCBpdC5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcblxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gIHZhciBhZGRlbmRhID0gZ2V0QWRkZW5kYUZvcktleVVzZSgndW5pcXVlS2V5JywgZWxlbWVudCwgcGFyZW50VHlwZSk7XG4gIGlmIChhZGRlbmRhID09PSBudWxsKSB7XG4gICAgLy8gd2UgYWxyZWFkeSBzaG93ZWQgdGhlIHdhcm5pbmdcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMlcycsIGFkZGVuZGEucGFyZW50T3JPd25lciB8fCAnJywgYWRkZW5kYS5jaGlsZE93bmVyIHx8ICcnLCBhZGRlbmRhLnVybCB8fCAnJykgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogU2hhcmVkIHdhcm5pbmcgYW5kIG1vbml0b3JpbmcgY29kZSBmb3IgdGhlIGtleSB3YXJuaW5ncy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlVHlwZSBBIGtleSB1c2VkIGZvciBkZS1kdXBpbmcgd2FybmluZ3MuXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBDb21wb25lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqIEByZXR1cm5zIHs/b2JqZWN0fSBBIHNldCBvZiBhZGRlbmRhIHRvIHVzZSBpbiB0aGUgd2FybmluZyBtZXNzYWdlLCBvciBudWxsXG4gKiBpZiB0aGUgd2FybmluZyBoYXMgYWxyZWFkeSBiZWVuIHNob3duIGJlZm9yZSAoYW5kIHNob3VsZG4ndCBiZSBzaG93biBhZ2FpbikuXG4gKi9cbmZ1bmN0aW9uIGdldEFkZGVuZGFGb3JLZXlVc2UobWVzc2FnZVR5cGUsIGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgdmFyIGFkZGVuZHVtID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gIGlmICghYWRkZW5kdW0pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgYWRkZW5kdW0gPSAnIENoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPCcgKyBwYXJlbnROYW1lICsgJz4uJztcbiAgICB9XG4gIH1cblxuICB2YXIgbWVtb2l6ZXIgPSBvd25lckhhc0tleVVzZVdhcm5pbmdbbWVzc2FnZVR5cGVdIHx8IChvd25lckhhc0tleVVzZVdhcm5pbmdbbWVzc2FnZVR5cGVdID0ge30pO1xuICBpZiAobWVtb2l6ZXJbYWRkZW5kdW1dKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbWVtb2l6ZXJbYWRkZW5kdW1dID0gdHJ1ZTtcblxuICB2YXIgYWRkZW5kYSA9IHtcbiAgICBwYXJlbnRPck93bmVyOiBhZGRlbmR1bSxcbiAgICB1cmw6ICcgU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsXG4gICAgY2hpbGRPd25lcjogbnVsbFxuICB9O1xuXG4gIC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGFkZGVuZGEuY2hpbGRPd25lciA9ICcgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gJyArIGVsZW1lbnQuX293bmVyLmdldE5hbWUoKSArICcuJztcbiAgfVxuXG4gIHJldHVybiBhZGRlbmRhO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuICAgICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyBwcm92aWRlIGltcGxpY2l0IGtleXMuXG4gICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHByb3BzIGFyZSB2YWxpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcFR5cGVzIE1hcCBvZiBwcm9wIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKGNvbXBvbmVudE5hbWUsIHByb3BUeXBlcywgcHJvcHMsIGxvY2F0aW9uKSB7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BUeXBlcykge1xuICAgIGlmIChwcm9wVHlwZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICB2YXIgZXJyb3I7XG4gICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgISh0eXBlb2YgcHJvcFR5cGVzW3Byb3BOYW1lXSA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICsgJ1JlYWN0LlByb3BUeXBlcy4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgcHJvcE5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgZXJyb3IgPSBwcm9wVHlwZXNbcHJvcE5hbWVdKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgIH1cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFlcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEVycm9yLCAnJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHByb3BOYW1lLCB0eXBlb2YgZXJyb3IpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGFkZGVuZHVtID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkIHByb3BUeXBlOiAlcyVzJywgZXJyb3IubWVzc2FnZSwgYWRkZW5kdW0pIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHZhciBjb21wb25lbnRDbGFzcyA9IGVsZW1lbnQudHlwZTtcbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmFtZSA9IGNvbXBvbmVudENsYXNzLmRpc3BsYXlOYW1lIHx8IGNvbXBvbmVudENsYXNzLm5hbWU7XG4gIGlmIChjb21wb25lbnRDbGFzcy5wcm9wVHlwZXMpIHtcbiAgICBjaGVja1Byb3BUeXBlcyhuYW1lLCBjb21wb25lbnRDbGFzcy5wcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMucHJvcCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcy5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhjb21wb25lbnRDbGFzcy5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQsICdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJykgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxudmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHtcblxuICBjcmVhdGVFbGVtZW50OiBmdW5jdGlvbiAodHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodmFsaWRUeXBlLCAnUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBzaG91bGQgbm90IGJlIG51bGwsIHVuZGVmaW5lZCwgYm9vbGVhbiwgb3IgJyArICdudW1iZXIuIEl0IHNob3VsZCBiZSBhIHN0cmluZyAoZm9yIERPTSBlbGVtZW50cykgb3IgYSBSZWFjdENsYXNzICcgKyAnKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykuJXMnLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSkgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9LFxuXG4gIGNyZWF0ZUZhY3Rvcnk6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRWxlbWVudC5iaW5kKG51bGwsIHR5cGUpO1xuICAgIC8vIExlZ2FjeSBob29rIFRPRE86IFdhcm4gaWYgdGhpcyBpcyBhY2Nlc3NlZFxuICAgIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xuICB9LFxuXG4gIGNsb25lRWxlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gICAgfVxuICAgIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICAgIHJldHVybiBuZXdFbGVtZW50O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvUmVhY3RFbGVtZW50VmFsaWRhdG9yLmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIG1hcE9iamVjdFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgcHJvdmlkZWQgYGNhbGxiYWNrYCBvbmNlIGZvciBlYWNoIGVudW1lcmFibGUgb3duIHByb3BlcnR5IGluIHRoZVxuICogb2JqZWN0IGFuZCBjb25zdHJ1Y3RzIGEgbmV3IG9iamVjdCBmcm9tIHRoZSByZXN1bHRzLiBUaGUgYGNhbGxiYWNrYCBpc1xuICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqXG4gKiAgLSB0aGUgcHJvcGVydHkgdmFsdWVcbiAqICAtIHRoZSBwcm9wZXJ0eSBuYW1lXG4gKiAgLSB0aGUgb2JqZWN0IGJlaW5nIHRyYXZlcnNlZFxuICpcbiAqIFByb3BlcnRpZXMgdGhhdCBhcmUgYWRkZWQgYWZ0ZXIgdGhlIGNhbGwgdG8gYG1hcE9iamVjdGAgd2lsbCBub3QgYmUgdmlzaXRlZFxuICogYnkgYGNhbGxiYWNrYC4gSWYgdGhlIHZhbHVlcyBvZiBleGlzdGluZyBwcm9wZXJ0aWVzIGFyZSBjaGFuZ2VkLCB0aGUgdmFsdWVcbiAqIHBhc3NlZCB0byBgY2FsbGJhY2tgIHdpbGwgYmUgdGhlIHZhbHVlIGF0IHRoZSB0aW1lIGBtYXBPYmplY3RgIHZpc2l0cyB0aGVtLlxuICogUHJvcGVydGllcyB0aGF0IGFyZSBkZWxldGVkIGJlZm9yZSBiZWluZyB2aXNpdGVkIGFyZSBub3QgdmlzaXRlZC5cbiAqXG4gKiBAZ3JlcCBmdW5jdGlvbiBvYmplY3RNYXAoKVxuICogQGdyZXAgZnVuY3Rpb24gb2JqTWFwKClcbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gY29udGV4dFxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gbWFwT2JqZWN0KG9iamVjdCwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgaWYgKCFvYmplY3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcmVzdWx0ID0ge307XG4gIGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBuYW1lKSkge1xuICAgICAgcmVzdWx0W25hbWVdID0gY2FsbGJhY2suY2FsbChjb250ZXh0LCBvYmplY3RbbmFtZV0sIG5hbWUsIG9iamVjdCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwT2JqZWN0O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9mYmpzL2xpYi9tYXBPYmplY3QuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgb25seUNoaWxkXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzXG4gKiBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0cyBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGVcbiAqIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG8gYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmVcbiAqIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdENvbXBvbmVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnb25seUNoaWxkIG11c3QgYmUgcGFzc2VkIGEgY2hpbGRyZW4gd2l0aCBleGFjdGx5IG9uZSBjaGlsZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvbmx5Q2hpbGQ7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0L2xpYi9vbmx5Q2hpbGQuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZGVwcmVjYXRlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogVGhpcyB3aWxsIGxvZyBhIHNpbmdsZSBkZXByZWNhdGlvbiBub3RpY2UgcGVyIGZ1bmN0aW9uIGFuZCBmb3J3YXJkIHRoZSBjYWxsXG4gKiBvbiB0byB0aGUgbmV3IEFQSS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm5OYW1lIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG5ld01vZHVsZSBUaGUgbW9kdWxlIHRoYXQgZm4gd2lsbCBleGlzdCBpblxuICogQHBhcmFtIHtzdHJpbmd9IG5ld1BhY2thZ2UgVGhlIG1vZHVsZSB0aGF0IGZuIHdpbGwgZXhpc3QgaW5cbiAqIEBwYXJhbSB7Kn0gY3R4IFRoZSBjb250ZXh0IHRoaXMgZm9yd2FyZGVkIGNhbGwgc2hvdWxkIHJ1biBpblxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGZvcndhcmQgb24gdG9cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIHdhcm4gb25jZSBhbmQgdGhlbiBjYWxsIGZuXG4gKi9cbmZ1bmN0aW9uIGRlcHJlY2F0ZWQoZm5OYW1lLCBuZXdNb2R1bGUsIG5ld1BhY2thZ2UsIGN0eCwgZm4pIHtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBuZXdGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHdhcm5lZCxcbiAgICAgIC8vIFJlcXVpcmUgZXhhbXBsZXMgaW4gdGhpcyBzdHJpbmcgbXVzdCBiZSBzcGxpdCB0byBwcmV2ZW50IFJlYWN0J3NcbiAgICAgIC8vIGJ1aWxkIHRvb2xzIGZyb20gbWlzdGFraW5nIHRoZW0gZm9yIHJlYWwgcmVxdWlyZXMuXG4gICAgICAvLyBPdGhlcndpc2UgdGhlIGJ1aWxkIHRvb2xzIHdpbGwgYXR0ZW1wdCB0byBidWlsZCBhICclcycgbW9kdWxlLlxuICAgICAgJ1JlYWN0LiVzIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgJXMuJXMgZnJvbSByZXF1aXJlJyArICcoXFwnJXNcXCcpICcgKyAnaW5zdGVhZC4nLCBmbk5hbWUsIG5ld01vZHVsZSwgZm5OYW1lLCBuZXdQYWNrYWdlKSA6IHVuZGVmaW5lZDtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICByZXR1cm4gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLy8gV2UgbmVlZCB0byBtYWtlIHN1cmUgYWxsIHByb3BlcnRpZXMgb2YgdGhlIG9yaWdpbmFsIGZuIGFyZSBjb3BpZWQgb3Zlci5cbiAgICAvLyBJbiBwYXJ0aWN1bGFyLCB0aGlzIGlzIG5lZWRlZCB0byBzdXBwb3J0IFByb3BUeXBlc1xuICAgIHJldHVybiBhc3NpZ24obmV3Rm4sIGZuKTtcbiAgfVxuXG4gIHJldHVybiBmbjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGVkO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC9saWIvZGVwcmVjYXRlZC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RET00nKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1kb20vaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNyZWF0ZU1lbW9yeUhpc3RvcnkgPSBleHBvcnRzLmhhc2hIaXN0b3J5ID0gZXhwb3J0cy5icm93c2VySGlzdG9yeSA9IGV4cG9ydHMuYXBwbHlSb3V0ZXJNaWRkbGV3YXJlID0gZXhwb3J0cy5mb3JtYXRQYXR0ZXJuID0gZXhwb3J0cy51c2VSb3V0ZXJIaXN0b3J5ID0gZXhwb3J0cy5tYXRjaCA9IGV4cG9ydHMucm91dGVyU2hhcGUgPSBleHBvcnRzLmxvY2F0aW9uU2hhcGUgPSBleHBvcnRzLlByb3BUeXBlcyA9IGV4cG9ydHMuUm91dGluZ0NvbnRleHQgPSBleHBvcnRzLlJvdXRlckNvbnRleHQgPSBleHBvcnRzLmNyZWF0ZVJvdXRlcyA9IGV4cG9ydHMudXNlUm91dGVzID0gZXhwb3J0cy5Sb3V0ZUNvbnRleHQgPSBleHBvcnRzLkxpZmVjeWNsZSA9IGV4cG9ydHMuSGlzdG9yeSA9IGV4cG9ydHMuUm91dGUgPSBleHBvcnRzLlJlZGlyZWN0ID0gZXhwb3J0cy5JbmRleFJvdXRlID0gZXhwb3J0cy5JbmRleFJlZGlyZWN0ID0gZXhwb3J0cy53aXRoUm91dGVyID0gZXhwb3J0cy5JbmRleExpbmsgPSBleHBvcnRzLkxpbmsgPSBleHBvcnRzLlJvdXRlciA9IHVuZGVmaW5lZDtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnY3JlYXRlUm91dGVzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVzO1xuICB9XG59KTtcblxudmFyIF9Qcm9wVHlwZXMyID0gcmVxdWlyZSgnLi9Qcm9wVHlwZXMnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdsb2NhdGlvblNoYXBlJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX1Byb3BUeXBlczIubG9jYXRpb25TaGFwZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3JvdXRlclNoYXBlJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX1Byb3BUeXBlczIucm91dGVyU2hhcGU7XG4gIH1cbn0pO1xuXG52YXIgX1BhdHRlcm5VdGlscyA9IHJlcXVpcmUoJy4vUGF0dGVyblV0aWxzJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZm9ybWF0UGF0dGVybicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9QYXR0ZXJuVXRpbHMuZm9ybWF0UGF0dGVybjtcbiAgfVxufSk7XG5cbnZhciBfUm91dGVyMiA9IHJlcXVpcmUoJy4vUm91dGVyJyk7XG5cbnZhciBfUm91dGVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRlcjIpO1xuXG52YXIgX0xpbmsyID0gcmVxdWlyZSgnLi9MaW5rJyk7XG5cbnZhciBfTGluazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9MaW5rMik7XG5cbnZhciBfSW5kZXhMaW5rMiA9IHJlcXVpcmUoJy4vSW5kZXhMaW5rJyk7XG5cbnZhciBfSW5kZXhMaW5rMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0luZGV4TGluazIpO1xuXG52YXIgX3dpdGhSb3V0ZXIyID0gcmVxdWlyZSgnLi93aXRoUm91dGVyJyk7XG5cbnZhciBfd2l0aFJvdXRlcjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93aXRoUm91dGVyMik7XG5cbnZhciBfSW5kZXhSZWRpcmVjdDIgPSByZXF1aXJlKCcuL0luZGV4UmVkaXJlY3QnKTtcblxudmFyIF9JbmRleFJlZGlyZWN0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0luZGV4UmVkaXJlY3QyKTtcblxudmFyIF9JbmRleFJvdXRlMiA9IHJlcXVpcmUoJy4vSW5kZXhSb3V0ZScpO1xuXG52YXIgX0luZGV4Um91dGUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSW5kZXhSb3V0ZTIpO1xuXG52YXIgX1JlZGlyZWN0MiA9IHJlcXVpcmUoJy4vUmVkaXJlY3QnKTtcblxudmFyIF9SZWRpcmVjdDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9SZWRpcmVjdDIpO1xuXG52YXIgX1JvdXRlMiA9IHJlcXVpcmUoJy4vUm91dGUnKTtcblxudmFyIF9Sb3V0ZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0ZTIpO1xuXG52YXIgX0hpc3RvcnkyID0gcmVxdWlyZSgnLi9IaXN0b3J5Jyk7XG5cbnZhciBfSGlzdG9yeTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9IaXN0b3J5Mik7XG5cbnZhciBfTGlmZWN5Y2xlMiA9IHJlcXVpcmUoJy4vTGlmZWN5Y2xlJyk7XG5cbnZhciBfTGlmZWN5Y2xlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xpZmVjeWNsZTIpO1xuXG52YXIgX1JvdXRlQ29udGV4dDIgPSByZXF1aXJlKCcuL1JvdXRlQ29udGV4dCcpO1xuXG52YXIgX1JvdXRlQ29udGV4dDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0ZUNvbnRleHQyKTtcblxudmFyIF91c2VSb3V0ZXMyID0gcmVxdWlyZSgnLi91c2VSb3V0ZXMnKTtcblxudmFyIF91c2VSb3V0ZXMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlUm91dGVzMik7XG5cbnZhciBfUm91dGVyQ29udGV4dDIgPSByZXF1aXJlKCcuL1JvdXRlckNvbnRleHQnKTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRlckNvbnRleHQyKTtcblxudmFyIF9Sb3V0aW5nQ29udGV4dDIgPSByZXF1aXJlKCcuL1JvdXRpbmdDb250ZXh0Jyk7XG5cbnZhciBfUm91dGluZ0NvbnRleHQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGluZ0NvbnRleHQyKTtcblxudmFyIF9Qcm9wVHlwZXMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUHJvcFR5cGVzMik7XG5cbnZhciBfbWF0Y2gyID0gcmVxdWlyZSgnLi9tYXRjaCcpO1xuXG52YXIgX21hdGNoMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21hdGNoMik7XG5cbnZhciBfdXNlUm91dGVySGlzdG9yeTIgPSByZXF1aXJlKCcuL3VzZVJvdXRlckhpc3RvcnknKTtcblxudmFyIF91c2VSb3V0ZXJIaXN0b3J5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZVJvdXRlckhpc3RvcnkyKTtcblxudmFyIF9hcHBseVJvdXRlck1pZGRsZXdhcmUyID0gcmVxdWlyZSgnLi9hcHBseVJvdXRlck1pZGRsZXdhcmUnKTtcblxudmFyIF9hcHBseVJvdXRlck1pZGRsZXdhcmUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXBwbHlSb3V0ZXJNaWRkbGV3YXJlMik7XG5cbnZhciBfYnJvd3Nlckhpc3RvcnkyID0gcmVxdWlyZSgnLi9icm93c2VySGlzdG9yeScpO1xuXG52YXIgX2Jyb3dzZXJIaXN0b3J5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jyb3dzZXJIaXN0b3J5Mik7XG5cbnZhciBfaGFzaEhpc3RvcnkyID0gcmVxdWlyZSgnLi9oYXNoSGlzdG9yeScpO1xuXG52YXIgX2hhc2hIaXN0b3J5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhc2hIaXN0b3J5Mik7XG5cbnZhciBfY3JlYXRlTWVtb3J5SGlzdG9yeTIgPSByZXF1aXJlKCcuL2NyZWF0ZU1lbW9yeUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVNZW1vcnlIaXN0b3J5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZU1lbW9yeUhpc3RvcnkyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5Sb3V0ZXIgPSBfUm91dGVyMy5kZWZhdWx0OyAvKiBjb21wb25lbnRzICovXG5cbmV4cG9ydHMuTGluayA9IF9MaW5rMy5kZWZhdWx0O1xuZXhwb3J0cy5JbmRleExpbmsgPSBfSW5kZXhMaW5rMy5kZWZhdWx0O1xuZXhwb3J0cy53aXRoUm91dGVyID0gX3dpdGhSb3V0ZXIzLmRlZmF1bHQ7XG5cbi8qIGNvbXBvbmVudHMgKGNvbmZpZ3VyYXRpb24pICovXG5cbmV4cG9ydHMuSW5kZXhSZWRpcmVjdCA9IF9JbmRleFJlZGlyZWN0My5kZWZhdWx0O1xuZXhwb3J0cy5JbmRleFJvdXRlID0gX0luZGV4Um91dGUzLmRlZmF1bHQ7XG5leHBvcnRzLlJlZGlyZWN0ID0gX1JlZGlyZWN0My5kZWZhdWx0O1xuZXhwb3J0cy5Sb3V0ZSA9IF9Sb3V0ZTMuZGVmYXVsdDtcblxuLyogbWl4aW5zICovXG5cbmV4cG9ydHMuSGlzdG9yeSA9IF9IaXN0b3J5My5kZWZhdWx0O1xuZXhwb3J0cy5MaWZlY3ljbGUgPSBfTGlmZWN5Y2xlMy5kZWZhdWx0O1xuZXhwb3J0cy5Sb3V0ZUNvbnRleHQgPSBfUm91dGVDb250ZXh0My5kZWZhdWx0O1xuXG4vKiB1dGlscyAqL1xuXG5leHBvcnRzLnVzZVJvdXRlcyA9IF91c2VSb3V0ZXMzLmRlZmF1bHQ7XG5leHBvcnRzLlJvdXRlckNvbnRleHQgPSBfUm91dGVyQ29udGV4dDMuZGVmYXVsdDtcbmV4cG9ydHMuUm91dGluZ0NvbnRleHQgPSBfUm91dGluZ0NvbnRleHQzLmRlZmF1bHQ7XG5leHBvcnRzLlByb3BUeXBlcyA9IF9Qcm9wVHlwZXMzLmRlZmF1bHQ7XG5leHBvcnRzLm1hdGNoID0gX21hdGNoMy5kZWZhdWx0O1xuZXhwb3J0cy51c2VSb3V0ZXJIaXN0b3J5ID0gX3VzZVJvdXRlckhpc3RvcnkzLmRlZmF1bHQ7XG5leHBvcnRzLmFwcGx5Um91dGVyTWlkZGxld2FyZSA9IF9hcHBseVJvdXRlck1pZGRsZXdhcmUzLmRlZmF1bHQ7XG5cbi8qIGhpc3RvcmllcyAqL1xuXG5leHBvcnRzLmJyb3dzZXJIaXN0b3J5ID0gX2Jyb3dzZXJIaXN0b3J5My5kZWZhdWx0O1xuZXhwb3J0cy5oYXNoSGlzdG9yeSA9IF9oYXNoSGlzdG9yeTMuZGVmYXVsdDtcbmV4cG9ydHMuY3JlYXRlTWVtb3J5SGlzdG9yeSA9IF9jcmVhdGVNZW1vcnlIaXN0b3J5My5kZWZhdWx0O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLmlzUmVhY3RDaGlsZHJlbiA9IGlzUmVhY3RDaGlsZHJlbjtcbmV4cG9ydHMuY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50ID0gY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50O1xuZXhwb3J0cy5jcmVhdGVSb3V0ZXNGcm9tUmVhY3RDaGlsZHJlbiA9IGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuO1xuZXhwb3J0cy5jcmVhdGVSb3V0ZXMgPSBjcmVhdGVSb3V0ZXM7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaXNWYWxpZENoaWxkKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgfHwgX3JlYWN0Mi5kZWZhdWx0LmlzVmFsaWRFbGVtZW50KG9iamVjdCk7XG59XG5cbmZ1bmN0aW9uIGlzUmVhY3RDaGlsZHJlbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzVmFsaWRDaGlsZChvYmplY3QpIHx8IEFycmF5LmlzQXJyYXkob2JqZWN0KSAmJiBvYmplY3QuZXZlcnkoaXNWYWxpZENoaWxkKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUm91dGUoZGVmYXVsdFByb3BzLCBwcm9wcykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIGRlZmF1bHRQcm9wcywgcHJvcHMpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQoZWxlbWVudCkge1xuICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgdmFyIHJvdXRlID0gY3JlYXRlUm91dGUodHlwZS5kZWZhdWx0UHJvcHMsIGVsZW1lbnQucHJvcHMpO1xuXG4gIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgIHZhciBjaGlsZFJvdXRlcyA9IGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuKHJvdXRlLmNoaWxkcmVuLCByb3V0ZSk7XG5cbiAgICBpZiAoY2hpbGRSb3V0ZXMubGVuZ3RoKSByb3V0ZS5jaGlsZFJvdXRlcyA9IGNoaWxkUm91dGVzO1xuXG4gICAgZGVsZXRlIHJvdXRlLmNoaWxkcmVuO1xuICB9XG5cbiAgcmV0dXJuIHJvdXRlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSByb3V0ZXMgb2JqZWN0IGZyb20gdGhlIGdpdmVuIFJlYWN0Q2hpbGRyZW4uIEpTWFxuICogcHJvdmlkZXMgYSBjb252ZW5pZW50IHdheSB0byB2aXN1YWxpemUgaG93IHJvdXRlcyBpbiB0aGUgaGllcmFyY2h5IGFyZVxuICogbmVzdGVkLlxuICpcbiAqICAgaW1wb3J0IHsgUm91dGUsIGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuIH0gZnJvbSAncmVhY3Qtcm91dGVyJ1xuICpcbiAqICAgY29uc3Qgcm91dGVzID0gY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW4oXG4gKiAgICAgPFJvdXRlIGNvbXBvbmVudD17QXBwfT5cbiAqICAgICAgIDxSb3V0ZSBwYXRoPVwiaG9tZVwiIGNvbXBvbmVudD17RGFzaGJvYXJkfS8+XG4gKiAgICAgICA8Um91dGUgcGF0aD1cIm5ld3NcIiBjb21wb25lbnQ9e05ld3NGZWVkfS8+XG4gKiAgICAgPC9Sb3V0ZT5cbiAqICAgKVxuICpcbiAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIGF1dG9tYXRpY2FsbHkgdXNlZCB3aGVuIHlvdSBwcm92aWRlIDxSb3V0ZT4gY2hpbGRyZW5cbiAqIHRvIGEgPFJvdXRlcj4gY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXNGcm9tUmVhY3RDaGlsZHJlbihjaGlsZHJlbiwgcGFyZW50Um91dGUpIHtcbiAgdmFyIHJvdXRlcyA9IFtdO1xuXG4gIF9yZWFjdDIuZGVmYXVsdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIGlmIChfcmVhY3QyLmRlZmF1bHQuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIC8vIENvbXBvbmVudCBjbGFzc2VzIG1heSBoYXZlIGEgc3RhdGljIGNyZWF0ZSogbWV0aG9kLlxuICAgICAgaWYgKGVsZW1lbnQudHlwZS5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHJvdXRlID0gZWxlbWVudC50eXBlLmNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50LCBwYXJlbnRSb3V0ZSk7XG5cbiAgICAgICAgaWYgKHJvdXRlKSByb3V0ZXMucHVzaChyb3V0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb3V0ZXMucHVzaChjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQoZWxlbWVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJvdXRlcztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHJvdXRlcyBmcm9tIHRoZSBnaXZlbiBvYmplY3Qgd2hpY2hcbiAqIG1heSBiZSBhIEpTWCByb3V0ZSwgYSBwbGFpbiBvYmplY3Qgcm91dGUsIG9yIGFuIGFycmF5IG9mIGVpdGhlci5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUm91dGVzKHJvdXRlcykge1xuICBpZiAoaXNSZWFjdENoaWxkcmVuKHJvdXRlcykpIHtcbiAgICByb3V0ZXMgPSBjcmVhdGVSb3V0ZXNGcm9tUmVhY3RDaGlsZHJlbihyb3V0ZXMpO1xuICB9IGVsc2UgaWYgKHJvdXRlcyAmJiAhQXJyYXkuaXNBcnJheShyb3V0ZXMpKSB7XG4gICAgcm91dGVzID0gW3JvdXRlc107XG4gIH1cblxuICByZXR1cm4gcm91dGVzO1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlVXRpbHMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnJvdXRlciA9IGV4cG9ydHMucm91dGVzID0gZXhwb3J0cy5yb3V0ZSA9IGV4cG9ydHMuY29tcG9uZW50cyA9IGV4cG9ydHMuY29tcG9uZW50ID0gZXhwb3J0cy5sb2NhdGlvbiA9IGV4cG9ydHMuaGlzdG9yeSA9IGV4cG9ydHMuZmFsc3kgPSBleHBvcnRzLmxvY2F0aW9uU2hhcGUgPSBleHBvcnRzLnJvdXRlclNoYXBlID0gdW5kZWZpbmVkO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzJyk7XG5cbnZhciBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzKTtcblxudmFyIF9JbnRlcm5hbFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vSW50ZXJuYWxQcm9wVHlwZXMnKTtcblxudmFyIEludGVybmFsUHJvcFR5cGVzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX0ludGVybmFsUHJvcFR5cGVzKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGZ1bmMgPSBfcmVhY3QuUHJvcFR5cGVzLmZ1bmM7XG52YXIgb2JqZWN0ID0gX3JlYWN0LlByb3BUeXBlcy5vYmplY3Q7XG52YXIgc2hhcGUgPSBfcmVhY3QuUHJvcFR5cGVzLnNoYXBlO1xudmFyIHN0cmluZyA9IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nO1xudmFyIHJvdXRlclNoYXBlID0gZXhwb3J0cy5yb3V0ZXJTaGFwZSA9IHNoYXBlKHtcbiAgcHVzaDogZnVuYy5pc1JlcXVpcmVkLFxuICByZXBsYWNlOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGdvOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGdvQmFjazogZnVuYy5pc1JlcXVpcmVkLFxuICBnb0ZvcndhcmQ6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgc2V0Um91dGVMZWF2ZUhvb2s6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgaXNBY3RpdmU6IGZ1bmMuaXNSZXF1aXJlZFxufSk7XG5cbnZhciBsb2NhdGlvblNoYXBlID0gZXhwb3J0cy5sb2NhdGlvblNoYXBlID0gc2hhcGUoe1xuICBwYXRobmFtZTogc3RyaW5nLmlzUmVxdWlyZWQsXG4gIHNlYXJjaDogc3RyaW5nLmlzUmVxdWlyZWQsXG4gIHN0YXRlOiBvYmplY3QsXG4gIGFjdGlvbjogc3RyaW5nLmlzUmVxdWlyZWQsXG4gIGtleTogc3RyaW5nXG59KTtcblxuLy8gRGVwcmVjYXRlZCBzdHVmZiBiZWxvdzpcblxudmFyIGZhbHN5ID0gZXhwb3J0cy5mYWxzeSA9IEludGVybmFsUHJvcFR5cGVzLmZhbHN5O1xudmFyIGhpc3RvcnkgPSBleHBvcnRzLmhpc3RvcnkgPSBJbnRlcm5hbFByb3BUeXBlcy5oaXN0b3J5O1xudmFyIGxvY2F0aW9uID0gZXhwb3J0cy5sb2NhdGlvbiA9IGxvY2F0aW9uU2hhcGU7XG52YXIgY29tcG9uZW50ID0gZXhwb3J0cy5jb21wb25lbnQgPSBJbnRlcm5hbFByb3BUeXBlcy5jb21wb25lbnQ7XG52YXIgY29tcG9uZW50cyA9IGV4cG9ydHMuY29tcG9uZW50cyA9IEludGVybmFsUHJvcFR5cGVzLmNvbXBvbmVudHM7XG52YXIgcm91dGUgPSBleHBvcnRzLnJvdXRlID0gSW50ZXJuYWxQcm9wVHlwZXMucm91dGU7XG52YXIgcm91dGVzID0gZXhwb3J0cy5yb3V0ZXMgPSBJbnRlcm5hbFByb3BUeXBlcy5yb3V0ZXM7XG52YXIgcm91dGVyID0gZXhwb3J0cy5yb3V0ZXIgPSByb3V0ZXJTaGFwZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGVwcmVjYXRlUHJvcFR5cGUgPSBmdW5jdGlvbiBkZXByZWNhdGVQcm9wVHlwZShwcm9wVHlwZSwgbWVzc2FnZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsIG1lc3NhZ2UpIDogdm9pZCAwO1xuICAgICAgICByZXR1cm4gcHJvcFR5cGUuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGRlcHJlY2F0ZUludGVybmFsUHJvcFR5cGUgPSBmdW5jdGlvbiBkZXByZWNhdGVJbnRlcm5hbFByb3BUeXBlKHByb3BUeXBlKSB7XG4gICAgICByZXR1cm4gZGVwcmVjYXRlUHJvcFR5cGUocHJvcFR5cGUsICdUaGlzIHByb3AgdHlwZSBpcyBub3QgaW50ZW5kZWQgZm9yIGV4dGVybmFsIHVzZSwgYW5kIHdhcyBwcmV2aW91c2x5IGV4cG9ydGVkIGJ5IG1pc3Rha2UuIFRoZXNlIGludGVybmFsIHByb3AgdHlwZXMgYXJlIGRlcHJlY2F0ZWQgZm9yIGV4dGVybmFsIHVzZSwgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGxhdGVyIHZlcnNpb24uJyk7XG4gICAgfTtcblxuICAgIHZhciBkZXByZWNhdGVSZW5hbWVkUHJvcFR5cGUgPSBmdW5jdGlvbiBkZXByZWNhdGVSZW5hbWVkUHJvcFR5cGUocHJvcFR5cGUsIG5hbWUpIHtcbiAgICAgIHJldHVybiBkZXByZWNhdGVQcm9wVHlwZShwcm9wVHlwZSwgJ1RoZSBgJyArIG5hbWUgKyAnYCBwcm9wIHR5cGUgaXMgbm93IGV4cG9ydGVkIGFzIGAnICsgbmFtZSArICdTaGFwZWAgdG8gYXZvaWQgbmFtZSBjb25mbGljdHMuIFRoaXMgZXhwb3J0IGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGxhdGVyIHZlcnNpb24uJyk7XG4gICAgfTtcblxuICAgIGV4cG9ydHMuZmFsc3kgPSBmYWxzeSA9IGRlcHJlY2F0ZUludGVybmFsUHJvcFR5cGUoZmFsc3kpO1xuICAgIGV4cG9ydHMuaGlzdG9yeSA9IGhpc3RvcnkgPSBkZXByZWNhdGVJbnRlcm5hbFByb3BUeXBlKGhpc3RvcnkpO1xuICAgIGV4cG9ydHMuY29tcG9uZW50ID0gY29tcG9uZW50ID0gZGVwcmVjYXRlSW50ZXJuYWxQcm9wVHlwZShjb21wb25lbnQpO1xuICAgIGV4cG9ydHMuY29tcG9uZW50cyA9IGNvbXBvbmVudHMgPSBkZXByZWNhdGVJbnRlcm5hbFByb3BUeXBlKGNvbXBvbmVudHMpO1xuICAgIGV4cG9ydHMucm91dGUgPSByb3V0ZSA9IGRlcHJlY2F0ZUludGVybmFsUHJvcFR5cGUocm91dGUpO1xuICAgIGV4cG9ydHMucm91dGVzID0gcm91dGVzID0gZGVwcmVjYXRlSW50ZXJuYWxQcm9wVHlwZShyb3V0ZXMpO1xuXG4gICAgZXhwb3J0cy5sb2NhdGlvbiA9IGxvY2F0aW9uID0gZGVwcmVjYXRlUmVuYW1lZFByb3BUeXBlKGxvY2F0aW9uLCAnbG9jYXRpb24nKTtcbiAgICBleHBvcnRzLnJvdXRlciA9IHJvdXRlciA9IGRlcHJlY2F0ZVJlbmFtZWRQcm9wVHlwZShyb3V0ZXIsICdyb3V0ZXInKTtcbiAgfSkoKTtcbn1cblxudmFyIGRlZmF1bHRFeHBvcnQgPSB7XG4gIGZhbHN5OiBmYWxzeSxcbiAgaGlzdG9yeTogaGlzdG9yeSxcbiAgbG9jYXRpb246IGxvY2F0aW9uLFxuICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgY29tcG9uZW50czogY29tcG9uZW50cyxcbiAgcm91dGU6IHJvdXRlLFxuICAvLyBGb3Igc29tZSByZWFzb24sIHJvdXRlcyB3YXMgbmV2ZXIgaGVyZS5cbiAgcm91dGVyOiByb3V0ZXJcbn07XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlZmF1bHRFeHBvcnQgPSAoMCwgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMyLmRlZmF1bHQpKGRlZmF1bHRFeHBvcnQsICdUaGUgZGVmYXVsdCBleHBvcnQgZnJvbSBgcmVhY3Qtcm91dGVyL2xpYi9Qcm9wVHlwZXNgIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdGhlIG5hbWVkIGV4cG9ydHMgaW5zdGVhZC4nKTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZGVmYXVsdEV4cG9ydDtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Qcm9wVHlwZXMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNhblVzZU1lbWJyYW5lID0gdW5kZWZpbmVkO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgY2FuVXNlTWVtYnJhbmUgPSBleHBvcnRzLmNhblVzZU1lbWJyYW5lID0gZmFsc2U7XG5cbi8vIE5vLW9wIGJ5IGRlZmF1bHQuXG52YXIgZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB0cnkge1xuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICd4Jywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pLngpIHtcbiAgICAgIGV4cG9ydHMuY2FuVXNlTWVtYnJhbmUgPSBjYW5Vc2VNZW1icmFuZSA9IHRydWU7XG4gICAgfVxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG4gIH0gY2F0Y2ggKGUpIHt9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tZW1wdHkgKi9cblxuICBpZiAoY2FuVXNlTWVtYnJhbmUpIHtcbiAgICBkZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyhvYmplY3QsIG1lc3NhZ2UpIHtcbiAgICAgIC8vIFdyYXAgdGhlIGRlcHJlY2F0ZWQgb2JqZWN0IGluIGEgbWVtYnJhbmUgdG8gd2FybiBvbiBwcm9wZXJ0eSBhY2Nlc3MuXG4gICAgICB2YXIgbWVtYnJhbmUgPSB7fTtcblxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AocHJvcCkge1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgcmV0dXJuICdjb250aW51ZSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG9iamVjdFtwcm9wXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIENhbid0IHVzZSBmYXQgYXJyb3cgaGVyZSBiZWNhdXNlIG9mIHVzZSBvZiBhcmd1bWVudHMgYmVsb3cuXG4gICAgICAgICAgbWVtYnJhbmVbcHJvcF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgbWVzc2FnZSkgOiB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0W3Byb3BdLmFwcGx5KG9iamVjdCwgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiAnY29udGludWUnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlc2UgcHJvcGVydGllcyBhcmUgbm9uLWVudW1lcmFibGUgdG8gcHJldmVudCBSZWFjdCBkZXYgdG9vbHMgZnJvbVxuICAgICAgICAvLyBzZWVpbmcgdGhlbSBhbmQgY2F1c2luZyBzcHVyaW91cyB3YXJuaW5ncyB3aGVuIGFjY2Vzc2luZyB0aGVtLiBJblxuICAgICAgICAvLyBwcmluY2lwbGUgdGhpcyBjb3VsZCBiZSBkb25lIHdpdGggYSBwcm94eSwgYnV0IHN1cHBvcnQgZm9yIHRoZVxuICAgICAgICAvLyBvd25LZXlzIHRyYXAgb24gcHJveGllcyBpcyBub3QgdW5pdmVyc2FsLCBldmVuIGFtb25nIGJyb3dzZXJzIHRoYXRcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHN1cHBvcnQgcHJveGllcy5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1lbWJyYW5lLCBwcm9wLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgbWVzc2FnZSkgOiB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0W3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIG9iamVjdCkge1xuICAgICAgICB2YXIgX3JldCA9IF9sb29wKHByb3ApO1xuXG4gICAgICAgIGlmIChfcmV0ID09PSAnY29udGludWUnKSBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1lbWJyYW5lO1xuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcztcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gcm91dGVyV2FybmluZztcbmV4cG9ydHMuX3Jlc2V0V2FybmVkID0gX3Jlc2V0V2FybmVkO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHdhcm5lZCA9IHt9O1xuXG5mdW5jdGlvbiByb3V0ZXJXYXJuaW5nKGZhbHNlVG9XYXJuLCBtZXNzYWdlKSB7XG4gIC8vIE9ubHkgaXNzdWUgZGVwcmVjYXRpb24gd2FybmluZ3Mgb25jZS5cbiAgaWYgKG1lc3NhZ2UuaW5kZXhPZignZGVwcmVjYXRlZCcpICE9PSAtMSkge1xuICAgIGlmICh3YXJuZWRbbWVzc2FnZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRbbWVzc2FnZV0gPSB0cnVlO1xuICB9XG5cbiAgbWVzc2FnZSA9ICdbcmVhY3Qtcm91dGVyXSAnICsgbWVzc2FnZTtcblxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIF93YXJuaW5nMi5kZWZhdWx0LmFwcGx5KHVuZGVmaW5lZCwgW2ZhbHNlVG9XYXJuLCBtZXNzYWdlXS5jb25jYXQoYXJncykpO1xufVxuXG5mdW5jdGlvbiBfcmVzZXRXYXJuZWQoKSB7XG4gIHdhcm5lZCA9IHt9O1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL3JvdXRlcldhcm5pbmcuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgd2FybmluZyA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhcmdzKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gPiAyID8gbGVuIC0gMiA6IDApO1xuICAgIGZvciAodmFyIGtleSA9IDI7IGtleSA8IGxlbjsga2V5KyspIHtcbiAgICAgIGFyZ3Nba2V5IC0gMl0gPSBhcmd1bWVudHNba2V5XTtcbiAgICB9XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICtcbiAgICAgICAgJ21lc3NhZ2UgYXJndW1lbnQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQubGVuZ3RoIDwgMTAgfHwgKC9eW3NcXFddKiQvKS50ZXN0KGZvcm1hdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1RoZSB3YXJuaW5nIGZvcm1hdCBzaG91bGQgYmUgYWJsZSB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzICcgK1xuICAgICAgICAnd2FybmluZy4gUGxlYXNlLCB1c2UgYSBtb3JlIGRlc2NyaXB0aXZlIGZvcm1hdCB0aGFuOiAnICsgZm9ybWF0XG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIH0gY2F0Y2goeCkge31cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi93YXJuaW5nL2Jyb3dzZXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnJvdXRlcyA9IGV4cG9ydHMucm91dGUgPSBleHBvcnRzLmNvbXBvbmVudHMgPSBleHBvcnRzLmNvbXBvbmVudCA9IGV4cG9ydHMuaGlzdG9yeSA9IHVuZGVmaW5lZDtcbmV4cG9ydHMuZmFsc3kgPSBmYWxzeTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBmdW5jID0gX3JlYWN0LlByb3BUeXBlcy5mdW5jO1xudmFyIG9iamVjdCA9IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0O1xudmFyIGFycmF5T2YgPSBfcmVhY3QuUHJvcFR5cGVzLmFycmF5T2Y7XG52YXIgb25lT2ZUeXBlID0gX3JlYWN0LlByb3BUeXBlcy5vbmVPZlR5cGU7XG52YXIgZWxlbWVudCA9IF9yZWFjdC5Qcm9wVHlwZXMuZWxlbWVudDtcbnZhciBzaGFwZSA9IF9yZWFjdC5Qcm9wVHlwZXMuc2hhcGU7XG52YXIgc3RyaW5nID0gX3JlYWN0LlByb3BUeXBlcy5zdHJpbmc7XG5mdW5jdGlvbiBmYWxzeShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgaWYgKHByb3BzW3Byb3BOYW1lXSkgcmV0dXJuIG5ldyBFcnJvcignPCcgKyBjb21wb25lbnROYW1lICsgJz4gc2hvdWxkIG5vdCBoYXZlIGEgXCInICsgcHJvcE5hbWUgKyAnXCIgcHJvcCcpO1xufVxuXG52YXIgaGlzdG9yeSA9IGV4cG9ydHMuaGlzdG9yeSA9IHNoYXBlKHtcbiAgbGlzdGVuOiBmdW5jLmlzUmVxdWlyZWQsXG4gIHB1c2g6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgcmVwbGFjZTogZnVuYy5pc1JlcXVpcmVkLFxuICBnbzogZnVuYy5pc1JlcXVpcmVkLFxuICBnb0JhY2s6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgZ29Gb3J3YXJkOiBmdW5jLmlzUmVxdWlyZWRcbn0pO1xuXG52YXIgY29tcG9uZW50ID0gZXhwb3J0cy5jb21wb25lbnQgPSBvbmVPZlR5cGUoW2Z1bmMsIHN0cmluZ10pO1xudmFyIGNvbXBvbmVudHMgPSBleHBvcnRzLmNvbXBvbmVudHMgPSBvbmVPZlR5cGUoW2NvbXBvbmVudCwgb2JqZWN0XSk7XG52YXIgcm91dGUgPSBleHBvcnRzLnJvdXRlID0gb25lT2ZUeXBlKFtvYmplY3QsIGVsZW1lbnRdKTtcbnZhciByb3V0ZXMgPSBleHBvcnRzLnJvdXRlcyA9IG9uZU9mVHlwZShbcm91dGUsIGFycmF5T2Yocm91dGUpXSk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvSW50ZXJuYWxQcm9wVHlwZXMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNvbXBpbGVQYXR0ZXJuID0gY29tcGlsZVBhdHRlcm47XG5leHBvcnRzLm1hdGNoUGF0dGVybiA9IG1hdGNoUGF0dGVybjtcbmV4cG9ydHMuZ2V0UGFyYW1OYW1lcyA9IGdldFBhcmFtTmFtZXM7XG5leHBvcnRzLmdldFBhcmFtcyA9IGdldFBhcmFtcztcbmV4cG9ydHMuZm9ybWF0UGF0dGVybiA9IGZvcm1hdFBhdHRlcm47XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xufVxuXG5mdW5jdGlvbiBfY29tcGlsZVBhdHRlcm4ocGF0dGVybikge1xuICB2YXIgcmVnZXhwU291cmNlID0gJyc7XG4gIHZhciBwYXJhbU5hbWVzID0gW107XG4gIHZhciB0b2tlbnMgPSBbXTtcblxuICB2YXIgbWF0Y2ggPSB2b2lkIDAsXG4gICAgICBsYXN0SW5kZXggPSAwLFxuICAgICAgbWF0Y2hlciA9IC86KFthLXpBLVpfJF1bYS16QS1aMC05XyRdKil8XFwqXFwqfFxcKnxcXCh8XFwpL2c7XG4gIHdoaWxlIChtYXRjaCA9IG1hdGNoZXIuZXhlYyhwYXR0ZXJuKSkge1xuICAgIGlmIChtYXRjaC5pbmRleCAhPT0gbGFzdEluZGV4KSB7XG4gICAgICB0b2tlbnMucHVzaChwYXR0ZXJuLnNsaWNlKGxhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgIHJlZ2V4cFNvdXJjZSArPSBlc2NhcGVSZWdFeHAocGF0dGVybi5zbGljZShsYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICByZWdleHBTb3VyY2UgKz0gJyhbXi9dKyknO1xuICAgICAgcGFyYW1OYW1lcy5wdXNoKG1hdGNoWzFdKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoWzBdID09PSAnKionKSB7XG4gICAgICByZWdleHBTb3VyY2UgKz0gJyguKiknO1xuICAgICAgcGFyYW1OYW1lcy5wdXNoKCdzcGxhdCcpO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hbMF0gPT09ICcqJykge1xuICAgICAgcmVnZXhwU291cmNlICs9ICcoLio/KSc7XG4gICAgICBwYXJhbU5hbWVzLnB1c2goJ3NwbGF0Jyk7XG4gICAgfSBlbHNlIGlmIChtYXRjaFswXSA9PT0gJygnKSB7XG4gICAgICByZWdleHBTb3VyY2UgKz0gJyg/Oic7XG4gICAgfSBlbHNlIGlmIChtYXRjaFswXSA9PT0gJyknKSB7XG4gICAgICByZWdleHBTb3VyY2UgKz0gJyk/JztcbiAgICB9XG5cbiAgICB0b2tlbnMucHVzaChtYXRjaFswXSk7XG5cbiAgICBsYXN0SW5kZXggPSBtYXRjaGVyLmxhc3RJbmRleDtcbiAgfVxuXG4gIGlmIChsYXN0SW5kZXggIT09IHBhdHRlcm4ubGVuZ3RoKSB7XG4gICAgdG9rZW5zLnB1c2gocGF0dGVybi5zbGljZShsYXN0SW5kZXgsIHBhdHRlcm4ubGVuZ3RoKSk7XG4gICAgcmVnZXhwU291cmNlICs9IGVzY2FwZVJlZ0V4cChwYXR0ZXJuLnNsaWNlKGxhc3RJbmRleCwgcGF0dGVybi5sZW5ndGgpKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0dGVybjogcGF0dGVybixcbiAgICByZWdleHBTb3VyY2U6IHJlZ2V4cFNvdXJjZSxcbiAgICBwYXJhbU5hbWVzOiBwYXJhbU5hbWVzLFxuICAgIHRva2VuczogdG9rZW5zXG4gIH07XG59XG5cbnZhciBDb21waWxlZFBhdHRlcm5zQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBjb21waWxlUGF0dGVybihwYXR0ZXJuKSB7XG4gIGlmICghQ29tcGlsZWRQYXR0ZXJuc0NhY2hlW3BhdHRlcm5dKSBDb21waWxlZFBhdHRlcm5zQ2FjaGVbcGF0dGVybl0gPSBfY29tcGlsZVBhdHRlcm4ocGF0dGVybik7XG5cbiAgcmV0dXJuIENvbXBpbGVkUGF0dGVybnNDYWNoZVtwYXR0ZXJuXTtcbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBtYXRjaCBhIHBhdHRlcm4gb24gdGhlIGdpdmVuIHBhdGhuYW1lLiBQYXR0ZXJucyBtYXkgdXNlXG4gKiB0aGUgZm9sbG93aW5nIHNwZWNpYWwgY2hhcmFjdGVyczpcbiAqXG4gKiAtIDpwYXJhbU5hbWUgICAgIE1hdGNoZXMgYSBVUkwgc2VnbWVudCB1cCB0byB0aGUgbmV4dCAvLCA/LCBvciAjLiBUaGVcbiAqICAgICAgICAgICAgICAgICAgY2FwdHVyZWQgc3RyaW5nIGlzIGNvbnNpZGVyZWQgYSBcInBhcmFtXCJcbiAqIC0gKCkgICAgICAgICAgICAgV3JhcHMgYSBzZWdtZW50IG9mIHRoZSBVUkwgdGhhdCBpcyBvcHRpb25hbFxuICogLSAqICAgICAgICAgICAgICBDb25zdW1lcyAobm9uLWdyZWVkeSkgYWxsIGNoYXJhY3RlcnMgdXAgdG8gdGhlIG5leHRcbiAqICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyIGluIHRoZSBwYXR0ZXJuLCBvciB0byB0aGUgZW5kIG9mIHRoZSBVUkwgaWZcbiAqICAgICAgICAgICAgICAgICAgdGhlcmUgaXMgbm9uZVxuICogLSAqKiAgICAgICAgICAgICBDb25zdW1lcyAoZ3JlZWR5KSBhbGwgY2hhcmFjdGVycyB1cCB0byB0aGUgbmV4dCBjaGFyYWN0ZXJcbiAqICAgICAgICAgICAgICAgICAgaW4gdGhlIHBhdHRlcm4sIG9yIHRvIHRoZSBlbmQgb2YgdGhlIFVSTCBpZiB0aGVyZSBpcyBub25lXG4gKlxuICogIFRoZSBmdW5jdGlvbiBjYWxscyBjYWxsYmFjayhlcnJvciwgbWF0Y2hlZCkgd2hlbiBmaW5pc2hlZC5cbiAqIFRoZSByZXR1cm4gdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqIC0gcmVtYWluaW5nUGF0aG5hbWVcbiAqIC0gcGFyYW1OYW1lc1xuICogLSBwYXJhbVZhbHVlc1xuICovXG5mdW5jdGlvbiBtYXRjaFBhdHRlcm4ocGF0dGVybiwgcGF0aG5hbWUpIHtcbiAgLy8gRW5zdXJlIHBhdHRlcm4gc3RhcnRzIHdpdGggbGVhZGluZyBzbGFzaCBmb3IgY29uc2lzdGVuY3kgd2l0aCBwYXRobmFtZS5cbiAgaWYgKHBhdHRlcm4uY2hhckF0KDApICE9PSAnLycpIHtcbiAgICBwYXR0ZXJuID0gJy8nICsgcGF0dGVybjtcbiAgfVxuXG4gIHZhciBfY29tcGlsZVBhdHRlcm4yID0gY29tcGlsZVBhdHRlcm4ocGF0dGVybik7XG5cbiAgdmFyIHJlZ2V4cFNvdXJjZSA9IF9jb21waWxlUGF0dGVybjIucmVnZXhwU291cmNlO1xuICB2YXIgcGFyYW1OYW1lcyA9IF9jb21waWxlUGF0dGVybjIucGFyYW1OYW1lcztcbiAgdmFyIHRva2VucyA9IF9jb21waWxlUGF0dGVybjIudG9rZW5zO1xuXG5cbiAgaWYgKHBhdHRlcm4uY2hhckF0KHBhdHRlcm4ubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgIHJlZ2V4cFNvdXJjZSArPSAnLz8nOyAvLyBBbGxvdyBvcHRpb25hbCBwYXRoIHNlcGFyYXRvciBhdCBlbmQuXG4gIH1cblxuICAvLyBTcGVjaWFsLWNhc2UgcGF0dGVybnMgbGlrZSAnKicgZm9yIGNhdGNoLWFsbCByb3V0ZXMuXG4gIGlmICh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICByZWdleHBTb3VyY2UgKz0gJyQnO1xuICB9XG5cbiAgdmFyIG1hdGNoID0gcGF0aG5hbWUubWF0Y2gobmV3IFJlZ0V4cCgnXicgKyByZWdleHBTb3VyY2UsICdpJykpO1xuICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1hdGNoZWRQYXRoID0gbWF0Y2hbMF07XG4gIHZhciByZW1haW5pbmdQYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cihtYXRjaGVkUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChyZW1haW5pbmdQYXRobmFtZSkge1xuICAgIC8vIFJlcXVpcmUgdGhhdCB0aGUgbWF0Y2ggZW5kcyBhdCBhIHBhdGggc2VwYXJhdG9yLCBpZiB3ZSBkaWRuJ3QgbWF0Y2hcbiAgICAvLyB0aGUgZnVsbCBwYXRoLCBzbyBhbnkgcmVtYWluaW5nIHBhdGhuYW1lIGlzIGEgbmV3IHBhdGggc2VnbWVudC5cbiAgICBpZiAobWF0Y2hlZFBhdGguY2hhckF0KG1hdGNoZWRQYXRoLmxlbmd0aCAtIDEpICE9PSAnLycpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgcmVtYWluaW5nIHBhdGhuYW1lLCB0cmVhdCB0aGUgcGF0aCBzZXBhcmF0b3IgYXMgcGFydCBvZlxuICAgIC8vIHRoZSByZW1haW5pbmcgcGF0aG5hbWUgZm9yIHByb3Blcmx5IGNvbnRpbnVpbmcgdGhlIG1hdGNoLlxuICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gJy8nICsgcmVtYWluaW5nUGF0aG5hbWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJlbWFpbmluZ1BhdGhuYW1lOiByZW1haW5pbmdQYXRobmFtZSxcbiAgICBwYXJhbU5hbWVzOiBwYXJhbU5hbWVzLFxuICAgIHBhcmFtVmFsdWVzOiBtYXRjaC5zbGljZSgxKS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB2ICYmIGRlY29kZVVSSUNvbXBvbmVudCh2KTtcbiAgICB9KVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRQYXJhbU5hbWVzKHBhdHRlcm4pIHtcbiAgcmV0dXJuIGNvbXBpbGVQYXR0ZXJuKHBhdHRlcm4pLnBhcmFtTmFtZXM7XG59XG5cbmZ1bmN0aW9uIGdldFBhcmFtcyhwYXR0ZXJuLCBwYXRobmFtZSkge1xuICB2YXIgbWF0Y2ggPSBtYXRjaFBhdHRlcm4ocGF0dGVybiwgcGF0aG5hbWUpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcGFyYW1OYW1lcyA9IG1hdGNoLnBhcmFtTmFtZXM7XG4gIHZhciBwYXJhbVZhbHVlcyA9IG1hdGNoLnBhcmFtVmFsdWVzO1xuXG4gIHZhciBwYXJhbXMgPSB7fTtcblxuICBwYXJhbU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtTmFtZSwgaW5kZXgpIHtcbiAgICBwYXJhbXNbcGFyYW1OYW1lXSA9IHBhcmFtVmFsdWVzW2luZGV4XTtcbiAgfSk7XG5cbiAgcmV0dXJuIHBhcmFtcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gcGF0dGVybiB3aXRoIHBhcmFtcyBpbnRlcnBvbGF0ZWQuIFRocm93c1xuICogaWYgdGhlcmUgaXMgYSBkeW5hbWljIHNlZ21lbnQgb2YgdGhlIHBhdHRlcm4gZm9yIHdoaWNoIHRoZXJlIGlzIG5vIHBhcmFtLlxuICovXG5mdW5jdGlvbiBmb3JtYXRQYXR0ZXJuKHBhdHRlcm4sIHBhcmFtcykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cbiAgdmFyIF9jb21waWxlUGF0dGVybjMgPSBjb21waWxlUGF0dGVybihwYXR0ZXJuKTtcblxuICB2YXIgdG9rZW5zID0gX2NvbXBpbGVQYXR0ZXJuMy50b2tlbnM7XG5cbiAgdmFyIHBhcmVuQ291bnQgPSAwLFxuICAgICAgcGF0aG5hbWUgPSAnJyxcbiAgICAgIHNwbGF0SW5kZXggPSAwO1xuXG4gIHZhciB0b2tlbiA9IHZvaWQgMCxcbiAgICAgIHBhcmFtTmFtZSA9IHZvaWQgMCxcbiAgICAgIHBhcmFtVmFsdWUgPSB2b2lkIDA7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgIGlmICh0b2tlbiA9PT0gJyonIHx8IHRva2VuID09PSAnKionKSB7XG4gICAgICBwYXJhbVZhbHVlID0gQXJyYXkuaXNBcnJheShwYXJhbXMuc3BsYXQpID8gcGFyYW1zLnNwbGF0W3NwbGF0SW5kZXgrK10gOiBwYXJhbXMuc3BsYXQ7XG5cbiAgICAgICEocGFyYW1WYWx1ZSAhPSBudWxsIHx8IHBhcmVuQ291bnQgPiAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdNaXNzaW5nIHNwbGF0ICMlcyBmb3IgcGF0aCBcIiVzXCInLCBzcGxhdEluZGV4LCBwYXR0ZXJuKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChwYXJhbVZhbHVlICE9IG51bGwpIHBhdGhuYW1lICs9IGVuY29kZVVSSShwYXJhbVZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnKCcpIHtcbiAgICAgIHBhcmVuQ291bnQgKz0gMTtcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnKScpIHtcbiAgICAgIHBhcmVuQ291bnQgLT0gMTtcbiAgICB9IGVsc2UgaWYgKHRva2VuLmNoYXJBdCgwKSA9PT0gJzonKSB7XG4gICAgICBwYXJhbU5hbWUgPSB0b2tlbi5zdWJzdHJpbmcoMSk7XG4gICAgICBwYXJhbVZhbHVlID0gcGFyYW1zW3BhcmFtTmFtZV07XG5cbiAgICAgICEocGFyYW1WYWx1ZSAhPSBudWxsIHx8IHBhcmVuQ291bnQgPiAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdNaXNzaW5nIFwiJXNcIiBwYXJhbWV0ZXIgZm9yIHBhdGggXCIlc1wiJywgcGFyYW1OYW1lLCBwYXR0ZXJuKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChwYXJhbVZhbHVlICE9IG51bGwpIHBhdGhuYW1lICs9IGVuY29kZVVSSUNvbXBvbmVudChwYXJhbVZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aG5hbWUgKz0gdG9rZW47XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhdGhuYW1lLnJlcGxhY2UoL1xcLysvZywgJy8nKTtcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9QYXR0ZXJuVXRpbHMuanNcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciBpbnZhcmlhbnQgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICtcbiAgICAgICAgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJ1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107IH0pXG4gICAgICApO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2ludmFyaWFudC9icm93c2VyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX2NyZWF0ZUhhc2hIaXN0b3J5ID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvY3JlYXRlSGFzaEhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVIYXNoSGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVIYXNoSGlzdG9yeSk7XG5cbnZhciBfdXNlUXVlcmllcyA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZVF1ZXJpZXMnKTtcblxudmFyIF91c2VRdWVyaWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZVF1ZXJpZXMpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIpO1xuXG52YXIgX0ludGVybmFsUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9JbnRlcm5hbFByb3BUeXBlcycpO1xuXG52YXIgX1JvdXRlckNvbnRleHQgPSByZXF1aXJlKCcuL1JvdXRlckNvbnRleHQnKTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRlckNvbnRleHQpO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxudmFyIF9Sb3V0ZXJVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVyVXRpbHMnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBpc0RlcHJlY2F0ZWRIaXN0b3J5KGhpc3RvcnkpIHtcbiAgcmV0dXJuICFoaXN0b3J5IHx8ICFoaXN0b3J5Ll9fdjJfY29tcGF0aWJsZV9fO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2FuaXR5IGNoZWNrICovXG5mdW5jdGlvbiBpc1Vuc3VwcG9ydGVkSGlzdG9yeShoaXN0b3J5KSB7XG4gIC8vIHYzIGhpc3RvcmllcyBleHBvc2UgZ2V0Q3VycmVudExvY2F0aW9uLCBidXQgYXJlbid0IGN1cnJlbnRseSBzdXBwb3J0ZWQuXG4gIHJldHVybiBoaXN0b3J5ICYmIGhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uO1xufVxuXG52YXIgX1JlYWN0JFByb3BUeXBlcyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXM7XG52YXIgZnVuYyA9IF9SZWFjdCRQcm9wVHlwZXMuZnVuYztcbnZhciBvYmplY3QgPSBfUmVhY3QkUHJvcFR5cGVzLm9iamVjdDtcblxuLyoqXG4gKiBBIDxSb3V0ZXI+IGlzIGEgaGlnaC1sZXZlbCBBUEkgZm9yIGF1dG9tYXRpY2FsbHkgc2V0dGluZyB1cFxuICogYSByb3V0ZXIgdGhhdCByZW5kZXJzIGEgPFJvdXRlckNvbnRleHQ+IHdpdGggYWxsIHRoZSBwcm9wc1xuICogaXQgbmVlZHMgZWFjaCB0aW1lIHRoZSBVUkwgY2hhbmdlcy5cbiAqL1xuXG52YXIgUm91dGVyID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSb3V0ZXInLFxuXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgaGlzdG9yeTogb2JqZWN0LFxuICAgIGNoaWxkcmVuOiBfSW50ZXJuYWxQcm9wVHlwZXMucm91dGVzLFxuICAgIHJvdXRlczogX0ludGVybmFsUHJvcFR5cGVzLnJvdXRlcywgLy8gYWxpYXMgZm9yIGNoaWxkcmVuXG4gICAgcmVuZGVyOiBmdW5jLFxuICAgIGNyZWF0ZUVsZW1lbnQ6IGZ1bmMsXG4gICAgb25FcnJvcjogZnVuYyxcbiAgICBvblVwZGF0ZTogZnVuYyxcblxuICAgIC8vIERlcHJlY2F0ZWQ6XG4gICAgcGFyc2VRdWVyeVN0cmluZzogZnVuYyxcbiAgICBzdHJpbmdpZnlRdWVyeTogZnVuYyxcblxuICAgIC8vIFBSSVZBVEU6IEZvciBjbGllbnQtc2lkZSByZWh5ZHJhdGlvbiBvZiBzZXJ2ZXIgbWF0Y2guXG4gICAgbWF0Y2hDb250ZXh0OiBvYmplY3RcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9Sb3V0ZXJDb250ZXh0Mi5kZWZhdWx0LCBwcm9wcyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvY2F0aW9uOiBudWxsLFxuICAgICAgcm91dGVzOiBudWxsLFxuICAgICAgcGFyYW1zOiBudWxsLFxuICAgICAgY29tcG9uZW50czogbnVsbFxuICAgIH07XG4gIH0sXG4gIGhhbmRsZUVycm9yOiBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvcikge1xuICAgIGlmICh0aGlzLnByb3BzLm9uRXJyb3IpIHtcbiAgICAgIHRoaXMucHJvcHMub25FcnJvci5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhyb3cgZXJyb3JzIGJ5IGRlZmF1bHQgc28gd2UgZG9uJ3Qgc2lsZW50bHkgc3dhbGxvdyB0aGVtIVxuICAgICAgdGhyb3cgZXJyb3I7IC8vIFRoaXMgZXJyb3IgcHJvYmFibHkgb2NjdXJyZWQgaW4gZ2V0Q2hpbGRSb3V0ZXMgb3IgZ2V0Q29tcG9uZW50cy5cbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcGFyc2VRdWVyeVN0cmluZyA9IF9wcm9wcy5wYXJzZVF1ZXJ5U3RyaW5nO1xuICAgIHZhciBzdHJpbmdpZnlRdWVyeSA9IF9wcm9wcy5zdHJpbmdpZnlRdWVyeTtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKCEocGFyc2VRdWVyeVN0cmluZyB8fCBzdHJpbmdpZnlRdWVyeSksICdgcGFyc2VRdWVyeVN0cmluZ2AgYW5kIGBzdHJpbmdpZnlRdWVyeWAgYXJlIGRlcHJlY2F0ZWQuIFBsZWFzZSBjcmVhdGUgYSBjdXN0b20gaGlzdG9yeS4gaHR0cDovL3RpbnkuY2Mvcm91dGVyLWN1c3RvbXF1ZXJ5c3RyaW5nJykgOiB2b2lkIDA7XG5cbiAgICB2YXIgX2NyZWF0ZVJvdXRlck9iamVjdHMgPSB0aGlzLmNyZWF0ZVJvdXRlck9iamVjdHMoKTtcblxuICAgIHZhciBoaXN0b3J5ID0gX2NyZWF0ZVJvdXRlck9iamVjdHMuaGlzdG9yeTtcbiAgICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSBfY3JlYXRlUm91dGVyT2JqZWN0cy50cmFuc2l0aW9uTWFuYWdlcjtcbiAgICB2YXIgcm91dGVyID0gX2NyZWF0ZVJvdXRlck9iamVjdHMucm91dGVyO1xuXG5cbiAgICB0aGlzLl91bmxpc3RlbiA9IHRyYW5zaXRpb25NYW5hZ2VyLmxpc3RlbihmdW5jdGlvbiAoZXJyb3IsIHN0YXRlKSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgX3RoaXMuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoc3RhdGUsIF90aGlzLnByb3BzLm9uVXBkYXRlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuaGlzdG9yeSA9IGhpc3Rvcnk7XG4gICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gIH0sXG4gIGNyZWF0ZVJvdXRlck9iamVjdHM6IGZ1bmN0aW9uIGNyZWF0ZVJvdXRlck9iamVjdHMoKSB7XG4gICAgdmFyIG1hdGNoQ29udGV4dCA9IHRoaXMucHJvcHMubWF0Y2hDb250ZXh0O1xuXG4gICAgaWYgKG1hdGNoQ29udGV4dCkge1xuICAgICAgcmV0dXJuIG1hdGNoQ29udGV4dDtcbiAgICB9XG5cbiAgICB2YXIgaGlzdG9yeSA9IHRoaXMucHJvcHMuaGlzdG9yeTtcbiAgICB2YXIgX3Byb3BzMiA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHJvdXRlcyA9IF9wcm9wczIucm91dGVzO1xuICAgIHZhciBjaGlsZHJlbiA9IF9wcm9wczIuY2hpbGRyZW47XG5cblxuICAgICEhaXNVbnN1cHBvcnRlZEhpc3RvcnkoaGlzdG9yeSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnWW91IGhhdmUgcHJvdmlkZWQgYSBoaXN0b3J5IG9iamVjdCBjcmVhdGVkIHdpdGggaGlzdG9yeSB2My54LiAnICsgJ1RoaXMgdmVyc2lvbiBvZiBSZWFjdCBSb3V0ZXIgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB2MyBoaXN0b3J5ICcgKyAnb2JqZWN0cy4gUGxlYXNlIHVzZSBoaXN0b3J5IHYyLnggaW5zdGVhZC4nKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICBpZiAoaXNEZXByZWNhdGVkSGlzdG9yeShoaXN0b3J5KSkge1xuICAgICAgaGlzdG9yeSA9IHRoaXMud3JhcERlcHJlY2F0ZWRIaXN0b3J5KGhpc3RvcnkpO1xuICAgIH1cblxuICAgIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9ICgwLCBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyLmRlZmF1bHQpKGhpc3RvcnksICgwLCBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZXMpKHJvdXRlcyB8fCBjaGlsZHJlbikpO1xuICAgIHZhciByb3V0ZXIgPSAoMCwgX1JvdXRlclV0aWxzLmNyZWF0ZVJvdXRlck9iamVjdCkoaGlzdG9yeSwgdHJhbnNpdGlvbk1hbmFnZXIpO1xuICAgIHZhciByb3V0aW5nSGlzdG9yeSA9ICgwLCBfUm91dGVyVXRpbHMuY3JlYXRlUm91dGluZ0hpc3RvcnkpKGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyKTtcblxuICAgIHJldHVybiB7IGhpc3Rvcnk6IHJvdXRpbmdIaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcjogdHJhbnNpdGlvbk1hbmFnZXIsIHJvdXRlcjogcm91dGVyIH07XG4gIH0sXG4gIHdyYXBEZXByZWNhdGVkSGlzdG9yeTogZnVuY3Rpb24gd3JhcERlcHJlY2F0ZWRIaXN0b3J5KGhpc3RvcnkpIHtcbiAgICB2YXIgX3Byb3BzMyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHBhcnNlUXVlcnlTdHJpbmcgPSBfcHJvcHMzLnBhcnNlUXVlcnlTdHJpbmc7XG4gICAgdmFyIHN0cmluZ2lmeVF1ZXJ5ID0gX3Byb3BzMy5zdHJpbmdpZnlRdWVyeTtcblxuXG4gICAgdmFyIGNyZWF0ZUhpc3RvcnkgPSB2b2lkIDA7XG4gICAgaWYgKGhpc3RvcnkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnSXQgYXBwZWFycyB5b3UgaGF2ZSBwcm92aWRlZCBhIGRlcHJlY2F0ZWQgaGlzdG9yeSBvYmplY3QgdG8gYDxSb3V0ZXIvPmAsIHBsZWFzZSB1c2UgYSBoaXN0b3J5IHByb3ZpZGVkIGJ5ICcgKyAnUmVhY3QgUm91dGVyIHdpdGggYGltcG9ydCB7IGJyb3dzZXJIaXN0b3J5IH0gZnJvbSBcXCdyZWFjdC1yb3V0ZXJcXCdgIG9yIGBpbXBvcnQgeyBoYXNoSGlzdG9yeSB9IGZyb20gXFwncmVhY3Qtcm91dGVyXFwnYC4gJyArICdJZiB5b3UgYXJlIHVzaW5nIGEgY3VzdG9tIGhpc3RvcnkgcGxlYXNlIGNyZWF0ZSBpdCB3aXRoIGB1c2VSb3V0ZXJIaXN0b3J5YCwgc2VlIGh0dHA6Ly90aW55LmNjL3JvdXRlci11c2luZ2hpc3RvcnkgZm9yIGRldGFpbHMuJykgOiB2b2lkIDA7XG4gICAgICBjcmVhdGVIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlSGlzdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuIGhpc3Rvcnk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ2BSb3V0ZXJgIG5vIGxvbmdlciBkZWZhdWx0cyB0aGUgaGlzdG9yeSBwcm9wIHRvIGhhc2ggaGlzdG9yeS4gUGxlYXNlIHVzZSB0aGUgYGhhc2hIaXN0b3J5YCBzaW5nbGV0b24gaW5zdGVhZC4gaHR0cDovL3RpbnkuY2Mvcm91dGVyLWRlZmF1bHRoaXN0b3J5JykgOiB2b2lkIDA7XG4gICAgICBjcmVhdGVIaXN0b3J5ID0gX2NyZWF0ZUhhc2hIaXN0b3J5Mi5kZWZhdWx0O1xuICAgIH1cblxuICAgIHJldHVybiAoMCwgX3VzZVF1ZXJpZXMyLmRlZmF1bHQpKGNyZWF0ZUhpc3RvcnkpKHsgcGFyc2VRdWVyeVN0cmluZzogcGFyc2VRdWVyeVN0cmluZywgc3RyaW5naWZ5UXVlcnk6IHN0cmluZ2lmeVF1ZXJ5IH0pO1xuICB9LFxuXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNhbml0eSBjaGVjayAqL1xuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKG5leHRQcm9wcy5oaXN0b3J5ID09PSB0aGlzLnByb3BzLmhpc3RvcnksICdZb3UgY2Fubm90IGNoYW5nZSA8Um91dGVyIGhpc3Rvcnk+OyBpdCB3aWxsIGJlIGlnbm9yZWQnKSA6IHZvaWQgMDtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKChuZXh0UHJvcHMucm91dGVzIHx8IG5leHRQcm9wcy5jaGlsZHJlbikgPT09ICh0aGlzLnByb3BzLnJvdXRlcyB8fCB0aGlzLnByb3BzLmNoaWxkcmVuKSwgJ1lvdSBjYW5ub3QgY2hhbmdlIDxSb3V0ZXIgcm91dGVzPjsgaXQgd2lsbCBiZSBpZ25vcmVkJykgOiB2b2lkIDA7XG4gIH0sXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5fdW5saXN0ZW4pIHRoaXMuX3VubGlzdGVuKCk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBsb2NhdGlvbiA9IF9zdGF0ZS5sb2NhdGlvbjtcbiAgICB2YXIgcm91dGVzID0gX3N0YXRlLnJvdXRlcztcbiAgICB2YXIgcGFyYW1zID0gX3N0YXRlLnBhcmFtcztcbiAgICB2YXIgY29tcG9uZW50cyA9IF9zdGF0ZS5jb21wb25lbnRzO1xuICAgIHZhciBfcHJvcHM0ID0gdGhpcy5wcm9wcztcbiAgICB2YXIgY3JlYXRlRWxlbWVudCA9IF9wcm9wczQuY3JlYXRlRWxlbWVudDtcbiAgICB2YXIgcmVuZGVyID0gX3Byb3BzNC5yZW5kZXI7XG5cbiAgICB2YXIgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzNCwgWydjcmVhdGVFbGVtZW50JywgJ3JlbmRlciddKTtcblxuICAgIGlmIChsb2NhdGlvbiA9PSBudWxsKSByZXR1cm4gbnVsbDsgLy8gQXN5bmMgbWF0Y2hcblxuICAgIC8vIE9ubHkgZm9yd2FyZCBub24tUm91dGVyLXNwZWNpZmljIHByb3BzIHRvIHJvdXRpbmcgY29udGV4dCwgYXMgdGhvc2UgYXJlXG4gICAgLy8gdGhlIG9ubHkgb25lcyB0aGF0IG1pZ2h0IGJlIGN1c3RvbSByb3V0aW5nIGNvbnRleHQgcHJvcHMuXG4gICAgT2JqZWN0LmtleXMoUm91dGVyLnByb3BUeXBlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcFR5cGUpIHtcbiAgICAgIHJldHVybiBkZWxldGUgcHJvcHNbcHJvcFR5cGVdO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlbmRlcihfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSxcbiAgICAgIHJvdXRlcjogdGhpcy5yb3V0ZXIsXG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICByb3V0ZXM6IHJvdXRlcyxcbiAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgY29tcG9uZW50czogY29tcG9uZW50cyxcbiAgICAgIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRcbiAgICB9KSk7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSb3V0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJy4vQWN0aW9ucycpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBfRE9NVXRpbHMgPSByZXF1aXJlKCcuL0RPTVV0aWxzJyk7XG5cbnZhciBfRE9NU3RhdGVTdG9yYWdlID0gcmVxdWlyZSgnLi9ET01TdGF0ZVN0b3JhZ2UnKTtcblxudmFyIF9jcmVhdGVET01IaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVET01IaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlRE9NSGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVET01IaXN0b3J5KTtcblxuZnVuY3Rpb24gaXNBYnNvbHV0ZVBhdGgocGF0aCkge1xuICByZXR1cm4gdHlwZW9mIHBhdGggPT09ICdzdHJpbmcnICYmIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59XG5cbmZ1bmN0aW9uIGVuc3VyZVNsYXNoKCkge1xuICB2YXIgcGF0aCA9IF9ET01VdGlscy5nZXRIYXNoUGF0aCgpO1xuXG4gIGlmIChpc0Fic29sdXRlUGF0aChwYXRoKSkgcmV0dXJuIHRydWU7XG5cbiAgX0RPTVV0aWxzLnJlcGxhY2VIYXNoUGF0aCgnLycgKyBwYXRoKTtcblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkZFF1ZXJ5U3RyaW5nVmFsdWVUb1BhdGgocGF0aCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gcGF0aCArIChwYXRoLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgKGtleSArICc9JyArIHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gc3RyaXBRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGgocGF0aCwga2V5KSB7XG4gIHJldHVybiBwYXRoLnJlcGxhY2UobmV3IFJlZ0V4cCgnWz8mXT8nICsga2V5ICsgJz1bYS16QS1aMC05XSsnKSwgJycpO1xufVxuXG5mdW5jdGlvbiBnZXRRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGgocGF0aCwga2V5KSB7XG4gIHZhciBtYXRjaCA9IHBhdGgubWF0Y2gobmV3IFJlZ0V4cCgnXFxcXD8uKj9cXFxcYicgKyBrZXkgKyAnPSguKz8pXFxcXGInKSk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXTtcbn1cblxudmFyIERlZmF1bHRRdWVyeUtleSA9ICdfayc7XG5cbmZ1bmN0aW9uIGNyZWF0ZUhhc2hIaXN0b3J5KCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICFfRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UsICdIYXNoIGhpc3RvcnkgbmVlZHMgYSBET00nKSA6IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIHZhciBxdWVyeUtleSA9IG9wdGlvbnMucXVlcnlLZXk7XG5cbiAgaWYgKHF1ZXJ5S2V5ID09PSB1bmRlZmluZWQgfHwgISFxdWVyeUtleSkgcXVlcnlLZXkgPSB0eXBlb2YgcXVlcnlLZXkgPT09ICdzdHJpbmcnID8gcXVlcnlLZXkgOiBEZWZhdWx0UXVlcnlLZXk7XG5cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCkge1xuICAgIHZhciBwYXRoID0gX0RPTVV0aWxzLmdldEhhc2hQYXRoKCk7XG5cbiAgICB2YXIga2V5ID0gdW5kZWZpbmVkLFxuICAgICAgICBzdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICBpZiAocXVlcnlLZXkpIHtcbiAgICAgIGtleSA9IGdldFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aChwYXRoLCBxdWVyeUtleSk7XG4gICAgICBwYXRoID0gc3RyaXBRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGgocGF0aCwgcXVlcnlLZXkpO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHN0YXRlID0gX0RPTVN0YXRlU3RvcmFnZS5yZWFkU3RhdGUoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlID0gbnVsbDtcbiAgICAgICAga2V5ID0gaGlzdG9yeS5jcmVhdGVLZXkoKTtcbiAgICAgICAgX0RPTVV0aWxzLnJlcGxhY2VIYXNoUGF0aChhZGRRdWVyeVN0cmluZ1ZhbHVlVG9QYXRoKHBhdGgsIHF1ZXJ5S2V5LCBrZXkpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAga2V5ID0gc3RhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbiA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlTG9jYXRpb24oX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7IHN0YXRlOiBzdGF0ZSB9KSwgdW5kZWZpbmVkLCBrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRIYXNoQ2hhbmdlTGlzdGVuZXIoX3JlZikge1xuICAgIHZhciB0cmFuc2l0aW9uVG8gPSBfcmVmLnRyYW5zaXRpb25UbztcblxuICAgIGZ1bmN0aW9uIGhhc2hDaGFuZ2VMaXN0ZW5lcigpIHtcbiAgICAgIGlmICghZW5zdXJlU2xhc2goKSkgcmV0dXJuOyAvLyBBbHdheXMgbWFrZSBzdXJlIGhhc2hlcyBhcmUgcHJlY2VlZGVkIHdpdGggYSAvLlxuXG4gICAgICB0cmFuc2l0aW9uVG8oZ2V0Q3VycmVudExvY2F0aW9uKCkpO1xuICAgIH1cblxuICAgIGVuc3VyZVNsYXNoKCk7XG4gICAgX0RPTVV0aWxzLmFkZEV2ZW50TGlzdGVuZXIod2luZG93LCAnaGFzaGNoYW5nZScsIGhhc2hDaGFuZ2VMaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgX0RPTVV0aWxzLnJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCAnaGFzaGNoYW5nZScsIGhhc2hDaGFuZ2VMaXN0ZW5lcik7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaFRyYW5zaXRpb24obG9jYXRpb24pIHtcbiAgICB2YXIgYmFzZW5hbWUgPSBsb2NhdGlvbi5iYXNlbmFtZTtcbiAgICB2YXIgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICB2YXIgc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoO1xuICAgIHZhciBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuICAgIHZhciBhY3Rpb24gPSBsb2NhdGlvbi5hY3Rpb247XG4gICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleTtcblxuICAgIGlmIChhY3Rpb24gPT09IF9BY3Rpb25zLlBPUCkgcmV0dXJuOyAvLyBOb3RoaW5nIHRvIGRvLlxuXG4gICAgdmFyIHBhdGggPSAoYmFzZW5hbWUgfHwgJycpICsgcGF0aG5hbWUgKyBzZWFyY2g7XG5cbiAgICBpZiAocXVlcnlLZXkpIHtcbiAgICAgIHBhdGggPSBhZGRRdWVyeVN0cmluZ1ZhbHVlVG9QYXRoKHBhdGgsIHF1ZXJ5S2V5LCBrZXkpO1xuICAgICAgX0RPTVN0YXRlU3RvcmFnZS5zYXZlU3RhdGUoa2V5LCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERyb3Aga2V5IGFuZCBzdGF0ZS5cbiAgICAgIGxvY2F0aW9uLmtleSA9IGxvY2F0aW9uLnN0YXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudEhhc2ggPSBfRE9NVXRpbHMuZ2V0SGFzaFBhdGgoKTtcblxuICAgIGlmIChhY3Rpb24gPT09IF9BY3Rpb25zLlBVU0gpIHtcbiAgICAgIGlmIChjdXJyZW50SGFzaCAhPT0gcGF0aCkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IHBhdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsICdZb3UgY2Fubm90IFBVU0ggdGhlIHNhbWUgcGF0aCB1c2luZyBoYXNoIGhpc3RvcnknKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRIYXNoICE9PSBwYXRoKSB7XG4gICAgICAvLyBSRVBMQUNFXG4gICAgICBfRE9NVXRpbHMucmVwbGFjZUhhc2hQYXRoKHBhdGgpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBoaXN0b3J5ID0gX2NyZWF0ZURPTUhpc3RvcnkyWydkZWZhdWx0J10oX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICBnZXRDdXJyZW50TG9jYXRpb246IGdldEN1cnJlbnRMb2NhdGlvbixcbiAgICBmaW5pc2hUcmFuc2l0aW9uOiBmaW5pc2hUcmFuc2l0aW9uLFxuICAgIHNhdmVTdGF0ZTogX0RPTVN0YXRlU3RvcmFnZS5zYXZlU3RhdGVcbiAgfSkpO1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMCxcbiAgICAgIHN0b3BIYXNoQ2hhbmdlTGlzdGVuZXIgPSB1bmRlZmluZWQ7XG5cbiAgZnVuY3Rpb24gbGlzdGVuQmVmb3JlKGxpc3RlbmVyKSB7XG4gICAgaWYgKCsrbGlzdGVuZXJDb3VudCA9PT0gMSkgc3RvcEhhc2hDaGFuZ2VMaXN0ZW5lciA9IHN0YXJ0SGFzaENoYW5nZUxpc3RlbmVyKGhpc3RvcnkpO1xuXG4gICAgdmFyIHVubGlzdGVuID0gaGlzdG9yeS5saXN0ZW5CZWZvcmUobGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHVubGlzdGVuKCk7XG5cbiAgICAgIGlmICgtLWxpc3RlbmVyQ291bnQgPT09IDApIHN0b3BIYXNoQ2hhbmdlTGlzdGVuZXIoKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgaWYgKCsrbGlzdGVuZXJDb3VudCA9PT0gMSkgc3RvcEhhc2hDaGFuZ2VMaXN0ZW5lciA9IHN0YXJ0SGFzaENoYW5nZUxpc3RlbmVyKGhpc3RvcnkpO1xuXG4gICAgdmFyIHVubGlzdGVuID0gaGlzdG9yeS5saXN0ZW4obGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHVubGlzdGVuKCk7XG5cbiAgICAgIGlmICgtLWxpc3RlbmVyQ291bnQgPT09IDApIHN0b3BIYXNoQ2hhbmdlTGlzdGVuZXIoKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaChsb2NhdGlvbikge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShxdWVyeUtleSB8fCBsb2NhdGlvbi5zdGF0ZSA9PSBudWxsLCAnWW91IGNhbm5vdCB1c2Ugc3RhdGUgd2l0aG91dCBhIHF1ZXJ5S2V5IGl0IHdpbGwgYmUgZHJvcHBlZCcpIDogdW5kZWZpbmVkO1xuXG4gICAgaGlzdG9yeS5wdXNoKGxvY2F0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2UobG9jYXRpb24pIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10ocXVlcnlLZXkgfHwgbG9jYXRpb24uc3RhdGUgPT0gbnVsbCwgJ1lvdSBjYW5ub3QgdXNlIHN0YXRlIHdpdGhvdXQgYSBxdWVyeUtleSBpdCB3aWxsIGJlIGRyb3BwZWQnKSA6IHVuZGVmaW5lZDtcblxuICAgIGhpc3RvcnkucmVwbGFjZShsb2NhdGlvbik7XG4gIH1cblxuICB2YXIgZ29Jc1N1cHBvcnRlZFdpdGhvdXRSZWxvYWQgPSBfRE9NVXRpbHMuc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2goKTtcblxuICBmdW5jdGlvbiBnbyhuKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGdvSXNTdXBwb3J0ZWRXaXRob3V0UmVsb2FkLCAnSGFzaCBoaXN0b3J5IGdvKG4pIGNhdXNlcyBhIGZ1bGwgcGFnZSByZWxvYWQgaW4gdGhpcyBicm93c2VyJykgOiB1bmRlZmluZWQ7XG5cbiAgICBoaXN0b3J5LmdvKG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSHJlZihwYXRoKSB7XG4gICAgcmV0dXJuICcjJyArIGhpc3RvcnkuY3JlYXRlSHJlZihwYXRoKTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gcmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKSB7XG4gICAgaWYgKCsrbGlzdGVuZXJDb3VudCA9PT0gMSkgc3RvcEhhc2hDaGFuZ2VMaXN0ZW5lciA9IHN0YXJ0SGFzaENoYW5nZUxpc3RlbmVyKGhpc3RvcnkpO1xuXG4gICAgaGlzdG9yeS5yZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiB1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vaykge1xuICAgIGhpc3RvcnkudW5yZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spO1xuXG4gICAgaWYgKC0tbGlzdGVuZXJDb3VudCA9PT0gMCkgc3RvcEhhc2hDaGFuZ2VMaXN0ZW5lcigpO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiBwdXNoU3RhdGUoc3RhdGUsIHBhdGgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10ocXVlcnlLZXkgfHwgc3RhdGUgPT0gbnVsbCwgJ1lvdSBjYW5ub3QgdXNlIHN0YXRlIHdpdGhvdXQgYSBxdWVyeUtleSBpdCB3aWxsIGJlIGRyb3BwZWQnKSA6IHVuZGVmaW5lZDtcblxuICAgIGhpc3RvcnkucHVzaFN0YXRlKHN0YXRlLCBwYXRoKTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gcmVwbGFjZVN0YXRlKHN0YXRlLCBwYXRoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKHF1ZXJ5S2V5IHx8IHN0YXRlID09IG51bGwsICdZb3UgY2Fubm90IHVzZSBzdGF0ZSB3aXRob3V0IGEgcXVlcnlLZXkgaXQgd2lsbCBiZSBkcm9wcGVkJykgOiB1bmRlZmluZWQ7XG5cbiAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZShzdGF0ZSwgcGF0aCk7XG4gIH1cblxuICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICBsaXN0ZW5CZWZvcmU6IGxpc3RlbkJlZm9yZSxcbiAgICBsaXN0ZW46IGxpc3RlbixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG5cbiAgICByZWdpc3RlclRyYW5zaXRpb25Ib29rOiByZWdpc3RlclRyYW5zaXRpb25Ib29rLCAvLyBkZXByZWNhdGVkIC0gd2FybmluZyBpcyBpbiBjcmVhdGVIaXN0b3J5XG4gICAgdW5yZWdpc3RlclRyYW5zaXRpb25Ib29rOiB1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2ssIC8vIGRlcHJlY2F0ZWQgLSB3YXJuaW5nIGlzIGluIGNyZWF0ZUhpc3RvcnlcbiAgICBwdXNoU3RhdGU6IHB1c2hTdGF0ZSwgLy8gZGVwcmVjYXRlZCAtIHdhcm5pbmcgaXMgaW4gY3JlYXRlSGlzdG9yeVxuICAgIHJlcGxhY2VTdGF0ZTogcmVwbGFjZVN0YXRlIC8vIGRlcHJlY2F0ZWQgLSB3YXJuaW5nIGlzIGluIGNyZWF0ZUhpc3RvcnlcbiAgfSk7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZUhhc2hIaXN0b3J5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2hpc3RvcnkvbGliL2NyZWF0ZUhhc2hIaXN0b3J5LmpzXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYXJncykge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuID4gMiA/IGxlbiAtIDIgOiAwKTtcbiAgICBmb3IgKHZhciBrZXkgPSAyOyBrZXkgPCBsZW47IGtleSsrKSB7XG4gICAgICBhcmdzW2tleSAtIDJdID0gYXJndW1lbnRzW2tleV07XG4gICAgfVxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArXG4gICAgICAgICdtZXNzYWdlIGFyZ3VtZW50J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0Lmxlbmd0aCA8IDEwIHx8ICgvXltzXFxXXSokLykudGVzdChmb3JtYXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUaGUgd2FybmluZyBmb3JtYXQgc2hvdWxkIGJlIGFibGUgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyAnICtcbiAgICAgICAgJ3dhcm5pbmcuIFBsZWFzZSwgdXNlIGEgbW9yZSBkZXNjcmlwdGl2ZSBmb3JtYXQgdGhhbjogJyArIGZvcm1hdFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgK1xuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoKHgpIHt9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vaGlzdG9yeS9+L3dhcm5pbmcvYnJvd3Nlci5qc1xuICoqLyIsIi8qKlxuICogSW5kaWNhdGVzIHRoYXQgbmF2aWdhdGlvbiB3YXMgY2F1c2VkIGJ5IGEgY2FsbCB0byBoaXN0b3J5LnB1c2guXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBQVVNIID0gJ1BVU0gnO1xuXG5leHBvcnRzLlBVU0ggPSBQVVNIO1xuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCBuYXZpZ2F0aW9uIHdhcyBjYXVzZWQgYnkgYSBjYWxsIHRvIGhpc3RvcnkucmVwbGFjZS5cbiAqL1xudmFyIFJFUExBQ0UgPSAnUkVQTEFDRSc7XG5cbmV4cG9ydHMuUkVQTEFDRSA9IFJFUExBQ0U7XG4vKipcbiAqIEluZGljYXRlcyB0aGF0IG5hdmlnYXRpb24gd2FzIGNhdXNlZCBieSBzb21lIG90aGVyIGFjdGlvbiBzdWNoXG4gKiBhcyB1c2luZyBhIGJyb3dzZXIncyBiYWNrL2ZvcndhcmQgYnV0dG9ucyBhbmQvb3IgbWFudWFsbHkgbWFuaXB1bGF0aW5nXG4gKiB0aGUgVVJMIGluIGEgYnJvd3NlcidzIGxvY2F0aW9uIGJhci4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvd0V2ZW50SGFuZGxlcnMvb25wb3BzdGF0ZVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBQT1AgPSAnUE9QJztcblxuZXhwb3J0cy5QT1AgPSBQT1A7XG5leHBvcnRzWydkZWZhdWx0J10gPSB7XG4gIFBVU0g6IFBVU0gsXG4gIFJFUExBQ0U6IFJFUExBQ0UsXG4gIFBPUDogUE9QXG59O1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9oaXN0b3J5L2xpYi9BY3Rpb25zLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5leHRyYWN0UGF0aCA9IGV4dHJhY3RQYXRoO1xuZXhwb3J0cy5wYXJzZVBhdGggPSBwYXJzZVBhdGg7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIGV4dHJhY3RQYXRoKHN0cmluZykge1xuICB2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goL15odHRwcz86XFwvXFwvW15cXC9dKi8pO1xuXG4gIGlmIChtYXRjaCA9PSBudWxsKSByZXR1cm4gc3RyaW5nO1xuXG4gIHJldHVybiBzdHJpbmcuc3Vic3RyaW5nKG1hdGNoWzBdLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIHZhciBwYXRobmFtZSA9IGV4dHJhY3RQYXRoKHBhdGgpO1xuICB2YXIgc2VhcmNoID0gJyc7XG4gIHZhciBoYXNoID0gJyc7XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKHBhdGggPT09IHBhdGhuYW1lLCAnQSBwYXRoIG11c3QgYmUgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoIG9ubHksIG5vdCBhIGZ1bGx5IHF1YWxpZmllZCBVUkwgbGlrZSBcIiVzXCInLCBwYXRoKSA6IHVuZGVmaW5lZDtcblxuICB2YXIgaGFzaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaEluZGV4ICE9PSAtMSkge1xuICAgIGhhc2ggPSBwYXRobmFtZS5zdWJzdHJpbmcoaGFzaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cmluZygwLCBoYXNoSW5kZXgpO1xuICB9XG5cbiAgdmFyIHNlYXJjaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignPycpO1xuICBpZiAoc2VhcmNoSW5kZXggIT09IC0xKSB7XG4gICAgc2VhcmNoID0gcGF0aG5hbWUuc3Vic3RyaW5nKHNlYXJjaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cmluZygwLCBzZWFyY2hJbmRleCk7XG4gIH1cblxuICBpZiAocGF0aG5hbWUgPT09ICcnKSBwYXRobmFtZSA9ICcvJztcblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICBzZWFyY2g6IHNlYXJjaCxcbiAgICBoYXNoOiBoYXNoXG4gIH07XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2hpc3RvcnkvbGliL1BhdGhVdGlscy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuZXhwb3J0cy5jYW5Vc2VET00gPSBjYW5Vc2VET007XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2hpc3RvcnkvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5hZGRFdmVudExpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lcjtcbmV4cG9ydHMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG5leHBvcnRzLmdldEhhc2hQYXRoID0gZ2V0SGFzaFBhdGg7XG5leHBvcnRzLnJlcGxhY2VIYXNoUGF0aCA9IHJlcGxhY2VIYXNoUGF0aDtcbmV4cG9ydHMuZ2V0V2luZG93UGF0aCA9IGdldFdpbmRvd1BhdGg7XG5leHBvcnRzLmdvID0gZ287XG5leHBvcnRzLmdldFVzZXJDb25maXJtYXRpb24gPSBnZXRVc2VyQ29uZmlybWF0aW9uO1xuZXhwb3J0cy5zdXBwb3J0c0hpc3RvcnkgPSBzdXBwb3J0c0hpc3Rvcnk7XG5leHBvcnRzLnN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoID0gc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2g7XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGxpc3RlbmVyKSB7XG4gIGlmIChub2RlLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICBpZiAobm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SGFzaFBhdGgoKSB7XG4gIC8vIFdlIGNhbid0IHVzZSB3aW5kb3cubG9jYXRpb24uaGFzaCBoZXJlIGJlY2F1c2UgaXQncyBub3RcbiAgLy8gY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnMgLSBGaXJlZm94IHdpbGwgcHJlLWRlY29kZSBpdCFcbiAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5ocmVmLnNwbGl0KCcjJylbMV0gfHwgJyc7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VIYXNoUGF0aChwYXRoKSB7XG4gIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggKyAnIycgKyBwYXRoKTtcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93UGF0aCgpIHtcbiAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggKyB3aW5kb3cubG9jYXRpb24uaGFzaDtcbn1cblxuZnVuY3Rpb24gZ28obikge1xuICBpZiAobikgd2luZG93Lmhpc3RvcnkuZ28obik7XG59XG5cbmZ1bmN0aW9uIGdldFVzZXJDb25maXJtYXRpb24obWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sod2luZG93LmNvbmZpcm0obWVzc2FnZSkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgaXMgc3VwcG9ydGVkLiBUYWtlbiBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvaGlzdG9yeS5qc1xuICogY2hhbmdlZCB0byBhdm9pZCBmYWxzZSBuZWdhdGl2ZXMgZm9yIFdpbmRvd3MgUGhvbmVzOiBodHRwczovL2dpdGh1Yi5jb20vcmFja3QvcmVhY3Qtcm91dGVyL2lzc3Vlcy81ODZcbiAqL1xuXG5mdW5jdGlvbiBzdXBwb3J0c0hpc3RvcnkoKSB7XG4gIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIGlmICgodWEuaW5kZXhPZignQW5kcm9pZCAyLicpICE9PSAtMSB8fCB1YS5pbmRleE9mKCdBbmRyb2lkIDQuMCcpICE9PSAtMSkgJiYgdWEuaW5kZXhPZignTW9iaWxlIFNhZmFyaScpICE9PSAtMSAmJiB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiYgdWEuaW5kZXhPZignV2luZG93cyBQaG9uZScpID09PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gd2luZG93Lmhpc3RvcnkgJiYgJ3B1c2hTdGF0ZScgaW4gd2luZG93Lmhpc3Rvcnk7XG59XG5cbi8qKlxuICogUmV0dXJucyBmYWxzZSBpZiB1c2luZyBnbyhuKSB3aXRoIGhhc2ggaGlzdG9yeSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkLlxuICovXG5cbmZ1bmN0aW9uIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKCkge1xuICB2YXIgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICByZXR1cm4gdWEuaW5kZXhPZignRmlyZWZveCcpID09PSAtMTtcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vaGlzdG9yeS9saWIvRE9NVXRpbHMuanNcbiAqKi8iLCIvKmVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnNhdmVTdGF0ZSA9IHNhdmVTdGF0ZTtcbmV4cG9ydHMucmVhZFN0YXRlID0gcmVhZFN0YXRlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgS2V5UHJlZml4ID0gJ0BASGlzdG9yeS8nO1xudmFyIFF1b3RhRXhjZWVkZWRFcnJvcnMgPSBbJ1F1b3RhRXhjZWVkZWRFcnJvcicsICdRVU9UQV9FWENFRURFRF9FUlInXTtcblxudmFyIFNlY3VyaXR5RXJyb3IgPSAnU2VjdXJpdHlFcnJvcic7XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleShrZXkpIHtcbiAgcmV0dXJuIEtleVByZWZpeCArIGtleTtcbn1cblxuZnVuY3Rpb24gc2F2ZVN0YXRlKGtleSwgc3RhdGUpIHtcbiAgdHJ5IHtcbiAgICBpZiAoc3RhdGUgPT0gbnVsbCkge1xuICAgICAgd2luZG93LnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oY3JlYXRlS2V5KGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShjcmVhdGVLZXkoa2V5KSwgSlNPTi5zdHJpbmdpZnkoc3RhdGUpKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yLm5hbWUgPT09IFNlY3VyaXR5RXJyb3IpIHtcbiAgICAgIC8vIEJsb2NraW5nIGNvb2tpZXMgaW4gQ2hyb21lL0ZpcmVmb3gvU2FmYXJpIHRocm93cyBTZWN1cml0eUVycm9yIG9uIGFueVxuICAgICAgLy8gYXR0ZW1wdCB0byBhY2Nlc3Mgd2luZG93LnNlc3Npb25TdG9yYWdlLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnW2hpc3RvcnldIFVuYWJsZSB0byBzYXZlIHN0YXRlOyBzZXNzaW9uU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlIGR1ZSB0byBzZWN1cml0eSBzZXR0aW5ncycpIDogdW5kZWZpbmVkO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKFF1b3RhRXhjZWVkZWRFcnJvcnMuaW5kZXhPZihlcnJvci5uYW1lKSA+PSAwICYmIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIFNhZmFyaSBcInByaXZhdGUgbW9kZVwiIHRocm93cyBRdW90YUV4Y2VlZGVkRXJyb3IuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsICdbaGlzdG9yeV0gVW5hYmxlIHRvIHNhdmUgc3RhdGU7IHNlc3Npb25TdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUgaW4gU2FmYXJpIHByaXZhdGUgbW9kZScpIDogdW5kZWZpbmVkO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhZFN0YXRlKGtleSkge1xuICB2YXIganNvbiA9IHVuZGVmaW5lZDtcbiAgdHJ5IHtcbiAgICBqc29uID0gd2luZG93LnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oY3JlYXRlS2V5KGtleSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvci5uYW1lID09PSBTZWN1cml0eUVycm9yKSB7XG4gICAgICAvLyBCbG9ja2luZyBjb29raWVzIGluIENocm9tZS9GaXJlZm94L1NhZmFyaSB0aHJvd3MgU2VjdXJpdHlFcnJvciBvbiBhbnlcbiAgICAgIC8vIGF0dGVtcHQgdG8gYWNjZXNzIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ1toaXN0b3J5XSBVbmFibGUgdG8gcmVhZCBzdGF0ZTsgc2Vzc2lvblN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZSBkdWUgdG8gc2VjdXJpdHkgc2V0dGluZ3MnKSA6IHVuZGVmaW5lZDtcblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgaWYgKGpzb24pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvbik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElnbm9yZSBpbnZhbGlkIEpTT04uXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2hpc3RvcnkvbGliL0RPTVN0YXRlU3RvcmFnZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX0V4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZSgnLi9ET01VdGlscycpO1xuXG52YXIgX2NyZWF0ZUhpc3RvcnkgPSByZXF1aXJlKCcuL2NyZWF0ZUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUhpc3RvcnkpO1xuXG5mdW5jdGlvbiBjcmVhdGVET01IaXN0b3J5KG9wdGlvbnMpIHtcbiAgdmFyIGhpc3RvcnkgPSBfY3JlYXRlSGlzdG9yeTJbJ2RlZmF1bHQnXShfZXh0ZW5kcyh7XG4gICAgZ2V0VXNlckNvbmZpcm1hdGlvbjogX0RPTVV0aWxzLmdldFVzZXJDb25maXJtYXRpb25cbiAgfSwgb3B0aW9ucywge1xuICAgIGdvOiBfRE9NVXRpbHMuZ29cbiAgfSkpO1xuXG4gIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgICFfRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UsICdET00gaGlzdG9yeSBuZWVkcyBhIERPTScpIDogX2ludmFyaWFudDJbJ2RlZmF1bHQnXShmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW4obGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfSk7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZURPTUhpc3Rvcnk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vaGlzdG9yeS9saWIvY3JlYXRlRE9NSGlzdG9yeS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9kZWVwRXF1YWwgPSByZXF1aXJlKCdkZWVwLWVxdWFsJyk7XG5cbnZhciBfZGVlcEVxdWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZXBFcXVhbCk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9Bc3luY1V0aWxzID0gcmVxdWlyZSgnLi9Bc3luY1V0aWxzJyk7XG5cbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJy4vQWN0aW9ucycpO1xuXG52YXIgX2NyZWF0ZUxvY2F0aW9uMiA9IHJlcXVpcmUoJy4vY3JlYXRlTG9jYXRpb24nKTtcblxudmFyIF9jcmVhdGVMb2NhdGlvbjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVMb2NhdGlvbjIpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rID0gcmVxdWlyZSgnLi9ydW5UcmFuc2l0aW9uSG9vaycpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3J1blRyYW5zaXRpb25Ib29rKTtcblxudmFyIF9kZXByZWNhdGUgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZScpO1xuXG52YXIgX2RlcHJlY2F0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXByZWNhdGUpO1xuXG5mdW5jdGlvbiBjcmVhdGVSYW5kb21LZXkobGVuZ3RoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgbGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gbG9jYXRpb25zQXJlRXF1YWwoYSwgYikge1xuICByZXR1cm4gYS5wYXRobmFtZSA9PT0gYi5wYXRobmFtZSAmJiBhLnNlYXJjaCA9PT0gYi5zZWFyY2ggJiZcbiAgLy9hLmFjdGlvbiA9PT0gYi5hY3Rpb24gJiYgLy8gRGlmZmVyZW50IGFjdGlvbiAhPT0gbG9jYXRpb24gY2hhbmdlLlxuICBhLmtleSA9PT0gYi5rZXkgJiYgX2RlZXBFcXVhbDJbJ2RlZmF1bHQnXShhLnN0YXRlLCBiLnN0YXRlKTtcbn1cblxudmFyIERlZmF1bHRLZXlMZW5ndGggPSA2O1xuXG5mdW5jdGlvbiBjcmVhdGVIaXN0b3J5KCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuICB2YXIgZ2V0Q3VycmVudExvY2F0aW9uID0gb3B0aW9ucy5nZXRDdXJyZW50TG9jYXRpb247XG4gIHZhciBmaW5pc2hUcmFuc2l0aW9uID0gb3B0aW9ucy5maW5pc2hUcmFuc2l0aW9uO1xuICB2YXIgc2F2ZVN0YXRlID0gb3B0aW9ucy5zYXZlU3RhdGU7XG4gIHZhciBnbyA9IG9wdGlvbnMuZ287XG4gIHZhciBnZXRVc2VyQ29uZmlybWF0aW9uID0gb3B0aW9ucy5nZXRVc2VyQ29uZmlybWF0aW9uO1xuICB2YXIga2V5TGVuZ3RoID0gb3B0aW9ucy5rZXlMZW5ndGg7XG5cbiAgaWYgKHR5cGVvZiBrZXlMZW5ndGggIT09ICdudW1iZXInKSBrZXlMZW5ndGggPSBEZWZhdWx0S2V5TGVuZ3RoO1xuXG4gIHZhciB0cmFuc2l0aW9uSG9va3MgPSBbXTtcblxuICBmdW5jdGlvbiBsaXN0ZW5CZWZvcmUoaG9vaykge1xuICAgIHRyYW5zaXRpb25Ib29rcy5wdXNoKGhvb2spO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyYW5zaXRpb25Ib29rcyA9IHRyYW5zaXRpb25Ib29rcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGhvb2s7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGFsbEtleXMgPSBbXTtcbiAgdmFyIGNoYW5nZUxpc3RlbmVycyA9IFtdO1xuICB2YXIgbG9jYXRpb24gPSB1bmRlZmluZWQ7XG5cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudCgpIHtcbiAgICBpZiAocGVuZGluZ0xvY2F0aW9uICYmIHBlbmRpbmdMb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlBPUCkge1xuICAgICAgcmV0dXJuIGFsbEtleXMuaW5kZXhPZihwZW5kaW5nTG9jYXRpb24ua2V5KTtcbiAgICB9IGVsc2UgaWYgKGxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gYWxsS2V5cy5pbmRleE9mKGxvY2F0aW9uLmtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMb2NhdGlvbihuZXdMb2NhdGlvbikge1xuICAgIHZhciBjdXJyZW50ID0gZ2V0Q3VycmVudCgpO1xuXG4gICAgbG9jYXRpb24gPSBuZXdMb2NhdGlvbjtcblxuICAgIGlmIChsb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlBVU0gpIHtcbiAgICAgIGFsbEtleXMgPSBbXS5jb25jYXQoYWxsS2V5cy5zbGljZSgwLCBjdXJyZW50ICsgMSksIFtsb2NhdGlvbi5rZXldKTtcbiAgICB9IGVsc2UgaWYgKGxvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUkVQTEFDRSkge1xuICAgICAgYWxsS2V5c1tjdXJyZW50XSA9IGxvY2F0aW9uLmtleTtcbiAgICB9XG5cbiAgICBjaGFuZ2VMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyKGxvY2F0aW9uKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIGNoYW5nZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgbGlzdGVuZXIobG9jYXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2xvY2F0aW9uID0gZ2V0Q3VycmVudExvY2F0aW9uKCk7XG4gICAgICBhbGxLZXlzID0gW19sb2NhdGlvbi5rZXldO1xuICAgICAgdXBkYXRlTG9jYXRpb24oX2xvY2F0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgY2hhbmdlTGlzdGVuZXJzID0gY2hhbmdlTGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gbGlzdGVuZXI7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgICBfQXN5bmNVdGlscy5sb29wQXN5bmModHJhbnNpdGlvbkhvb2tzLmxlbmd0aCwgZnVuY3Rpb24gKGluZGV4LCBuZXh0LCBkb25lKSB7XG4gICAgICBfcnVuVHJhbnNpdGlvbkhvb2syWydkZWZhdWx0J10odHJhbnNpdGlvbkhvb2tzW2luZGV4XSwgbG9jYXRpb24sIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgICAgZG9uZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIGlmIChnZXRVc2VyQ29uZmlybWF0aW9uICYmIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICBnZXRVc2VyQ29uZmlybWF0aW9uKG1lc3NhZ2UsIGZ1bmN0aW9uIChvaykge1xuICAgICAgICAgIGNhbGxiYWNrKG9rICE9PSBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sobWVzc2FnZSAhPT0gZmFsc2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIHBlbmRpbmdMb2NhdGlvbiA9IHVuZGVmaW5lZDtcblxuICBmdW5jdGlvbiB0cmFuc2l0aW9uVG8obmV4dExvY2F0aW9uKSB7XG4gICAgaWYgKGxvY2F0aW9uICYmIGxvY2F0aW9uc0FyZUVxdWFsKGxvY2F0aW9uLCBuZXh0TG9jYXRpb24pKSByZXR1cm47IC8vIE5vdGhpbmcgdG8gZG8uXG5cbiAgICBwZW5kaW5nTG9jYXRpb24gPSBuZXh0TG9jYXRpb247XG5cbiAgICBjb25maXJtVHJhbnNpdGlvblRvKG5leHRMb2NhdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAocGVuZGluZ0xvY2F0aW9uICE9PSBuZXh0TG9jYXRpb24pIHJldHVybjsgLy8gVHJhbnNpdGlvbiB3YXMgaW50ZXJydXB0ZWQuXG5cbiAgICAgIGlmIChvaykge1xuICAgICAgICAvLyB0cmVhdCBQVVNIIHRvIGN1cnJlbnQgcGF0aCBsaWtlIFJFUExBQ0UgdG8gYmUgY29uc2lzdGVudCB3aXRoIGJyb3dzZXJzXG4gICAgICAgIGlmIChuZXh0TG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5QVVNIKSB7XG4gICAgICAgICAgdmFyIHByZXZQYXRoID0gY3JlYXRlUGF0aChsb2NhdGlvbik7XG4gICAgICAgICAgdmFyIG5leHRQYXRoID0gY3JlYXRlUGF0aChuZXh0TG9jYXRpb24pO1xuXG4gICAgICAgICAgaWYgKG5leHRQYXRoID09PSBwcmV2UGF0aCAmJiBfZGVlcEVxdWFsMlsnZGVmYXVsdCddKGxvY2F0aW9uLnN0YXRlLCBuZXh0TG9jYXRpb24uc3RhdGUpKSBuZXh0TG9jYXRpb24uYWN0aW9uID0gX0FjdGlvbnMuUkVQTEFDRTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaW5pc2hUcmFuc2l0aW9uKG5leHRMb2NhdGlvbikgIT09IGZhbHNlKSB1cGRhdGVMb2NhdGlvbihuZXh0TG9jYXRpb24pO1xuICAgICAgfSBlbHNlIGlmIChsb2NhdGlvbiAmJiBuZXh0TG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5QT1ApIHtcbiAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihsb2NhdGlvbi5rZXkpO1xuICAgICAgICB2YXIgbmV4dEluZGV4ID0gYWxsS2V5cy5pbmRleE9mKG5leHRMb2NhdGlvbi5rZXkpO1xuXG4gICAgICAgIGlmIChwcmV2SW5kZXggIT09IC0xICYmIG5leHRJbmRleCAhPT0gLTEpIGdvKHByZXZJbmRleCAtIG5leHRJbmRleCk7IC8vIFJlc3RvcmUgdGhlIFVSTC5cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2gobG9jYXRpb24pIHtcbiAgICB0cmFuc2l0aW9uVG8oY3JlYXRlTG9jYXRpb24obG9jYXRpb24sIF9BY3Rpb25zLlBVU0gsIGNyZWF0ZUtleSgpKSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlKGxvY2F0aW9uKSB7XG4gICAgdHJhbnNpdGlvblRvKGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uLCBfQWN0aW9ucy5SRVBMQUNFLCBjcmVhdGVLZXkoKSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIGdvKC0xKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICBnbygxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gY3JlYXRlUmFuZG9tS2V5KGtleUxlbmd0aCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQYXRoKGxvY2F0aW9uKSB7XG4gICAgaWYgKGxvY2F0aW9uID09IG51bGwgfHwgdHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJykgcmV0dXJuIGxvY2F0aW9uO1xuXG4gICAgdmFyIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgdmFyIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcbiAgICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG5cbiAgICB2YXIgcmVzdWx0ID0gcGF0aG5hbWU7XG5cbiAgICBpZiAoc2VhcmNoKSByZXN1bHQgKz0gc2VhcmNoO1xuXG4gICAgaWYgKGhhc2gpIHJlc3VsdCArPSBoYXNoO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICByZXR1cm4gY3JlYXRlUGF0aChsb2NhdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbiwgYWN0aW9uKSB7XG4gICAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IGNyZWF0ZUtleSgpIDogYXJndW1lbnRzWzJdO1xuXG4gICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdvYmplY3QnKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsICdUaGUgc3RhdGUgKDJuZCkgYXJndW1lbnQgdG8gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbiBpcyBkZXByZWNhdGVkOyB1c2UgYSAnICsgJ2xvY2F0aW9uIGRlc2NyaXB0b3IgaW5zdGVhZCcpIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJykgbG9jYXRpb24gPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChsb2NhdGlvbik7XG5cbiAgICAgIGxvY2F0aW9uID0gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7IHN0YXRlOiBhY3Rpb24gfSk7XG5cbiAgICAgIGFjdGlvbiA9IGtleTtcbiAgICAgIGtleSA9IGFyZ3VtZW50c1szXSB8fCBjcmVhdGVLZXkoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2NyZWF0ZUxvY2F0aW9uM1snZGVmYXVsdCddKGxvY2F0aW9uLCBhY3Rpb24sIGtleSk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHNldFN0YXRlKHN0YXRlKSB7XG4gICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICB1cGRhdGVMb2NhdGlvblN0YXRlKGxvY2F0aW9uLCBzdGF0ZSk7XG4gICAgICB1cGRhdGVMb2NhdGlvbihsb2NhdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZUxvY2F0aW9uU3RhdGUoZ2V0Q3VycmVudExvY2F0aW9uKCksIHN0YXRlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMb2NhdGlvblN0YXRlKGxvY2F0aW9uLCBzdGF0ZSkge1xuICAgIGxvY2F0aW9uLnN0YXRlID0gX2V4dGVuZHMoe30sIGxvY2F0aW9uLnN0YXRlLCBzdGF0ZSk7XG4gICAgc2F2ZVN0YXRlKGxvY2F0aW9uLmtleSwgbG9jYXRpb24uc3RhdGUpO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiByZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spIHtcbiAgICBpZiAodHJhbnNpdGlvbkhvb2tzLmluZGV4T2YoaG9vaykgPT09IC0xKSB0cmFuc2l0aW9uSG9va3MucHVzaChob29rKTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gdW5yZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spIHtcbiAgICB0cmFuc2l0aW9uSG9va3MgPSB0cmFuc2l0aW9uSG9va3MuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbSAhPT0gaG9vaztcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gcHVzaFN0YXRlKHN0YXRlLCBwYXRoKSB7XG4gICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgcGF0aCA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgcHVzaChfZXh0ZW5kcyh7IHN0YXRlOiBzdGF0ZSB9LCBwYXRoKSk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZShzdGF0ZSwgcGF0aCkge1xuICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHBhdGggPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgIHJlcGxhY2UoX2V4dGVuZHMoeyBzdGF0ZTogc3RhdGUgfSwgcGF0aCkpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBsaXN0ZW5CZWZvcmU6IGxpc3RlbkJlZm9yZSxcbiAgICBsaXN0ZW46IGxpc3RlbixcbiAgICB0cmFuc2l0aW9uVG86IHRyYW5zaXRpb25UbyxcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGNyZWF0ZUtleTogY3JlYXRlS2V5LFxuICAgIGNyZWF0ZVBhdGg6IGNyZWF0ZVBhdGgsXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBjcmVhdGVMb2NhdGlvbjogY3JlYXRlTG9jYXRpb24sXG5cbiAgICBzZXRTdGF0ZTogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShzZXRTdGF0ZSwgJ3NldFN0YXRlIGlzIGRlcHJlY2F0ZWQ7IHVzZSBsb2NhdGlvbi5rZXkgdG8gc2F2ZSBzdGF0ZSBpbnN0ZWFkJyksXG4gICAgcmVnaXN0ZXJUcmFuc2l0aW9uSG9vazogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShyZWdpc3RlclRyYW5zaXRpb25Ib29rLCAncmVnaXN0ZXJUcmFuc2l0aW9uSG9vayBpcyBkZXByZWNhdGVkOyB1c2UgbGlzdGVuQmVmb3JlIGluc3RlYWQnKSxcbiAgICB1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2s6IF9kZXByZWNhdGUyWydkZWZhdWx0J10odW5yZWdpc3RlclRyYW5zaXRpb25Ib29rLCAndW5yZWdpc3RlclRyYW5zaXRpb25Ib29rIGlzIGRlcHJlY2F0ZWQ7IHVzZSB0aGUgY2FsbGJhY2sgcmV0dXJuZWQgZnJvbSBsaXN0ZW5CZWZvcmUgaW5zdGVhZCcpLFxuICAgIHB1c2hTdGF0ZTogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShwdXNoU3RhdGUsICdwdXNoU3RhdGUgaXMgZGVwcmVjYXRlZDsgdXNlIHB1c2ggaW5zdGVhZCcpLFxuICAgIHJlcGxhY2VTdGF0ZTogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShyZXBsYWNlU3RhdGUsICdyZXBsYWNlU3RhdGUgaXMgZGVwcmVjYXRlZDsgdXNlIHJlcGxhY2UgaW5zdGVhZCcpXG4gIH07XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZUhpc3Rvcnk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vaGlzdG9yeS9saWIvY3JlYXRlSGlzdG9yeS5qc1xuICoqLyIsInZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4vbGliL2tleXMuanMnKTtcbnZhciBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vbGliL2lzX2FyZ3VtZW50cy5qcycpO1xuXG52YXIgZGVlcEVxdWFsID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgb3B0cykge1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBEYXRlICYmIGV4cGVjdGVkIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zLiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKCFhY3R1YWwgfHwgIWV4cGVjdGVkIHx8IHR5cGVvZiBhY3R1YWwgIT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cGVjdGVkICE9ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9wdHMuc3RyaWN0ID8gYWN0dWFsID09PSBleHBlY3RlZCA6IGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyA3LjQuIEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCwgb3B0cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWRPck51bGwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyICh4KSB7XG4gIGlmICgheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIHgubGVuZ3RoICE9PSAnbnVtYmVyJykgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIHguY29weSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgeC5zbGljZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoeC5sZW5ndGggPiAwICYmIHR5cGVvZiB4WzBdICE9PSAnbnVtYmVyJykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYiwgb3B0cykge1xuICB2YXIgaSwga2V5O1xuICBpZiAoaXNVbmRlZmluZWRPck51bGwoYSkgfHwgaXNVbmRlZmluZWRPck51bGwoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvLyBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuXG4gIGlmIChhLnByb3RvdHlwZSAhPT0gYi5wcm90b3R5cGUpIHJldHVybiBmYWxzZTtcbiAgLy9+fn5JJ3ZlIG1hbmFnZWQgdG8gYnJlYWsgT2JqZWN0LmtleXMgdGhyb3VnaCBzY3Jld3kgYXJndW1lbnRzIHBhc3NpbmcuXG4gIC8vICAgQ29udmVydGluZyB0byBhcnJheSBzb2x2ZXMgdGhlIHByb2JsZW0uXG4gIGlmIChpc0FyZ3VtZW50cyhhKSkge1xuICAgIGlmICghaXNBcmd1bWVudHMoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gZGVlcEVxdWFsKGEsIGIsIG9wdHMpO1xuICB9XG4gIGlmIChpc0J1ZmZlcihhKSkge1xuICAgIGlmICghaXNCdWZmZXIoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0cnkge1xuICAgIHZhciBrYSA9IG9iamVjdEtleXMoYSksXG4gICAgICAgIGtiID0gb2JqZWN0S2V5cyhiKTtcbiAgfSBjYXRjaCAoZSkgey8vaGFwcGVucyB3aGVuIG9uZSBpcyBhIHN0cmluZyBsaXRlcmFsIGFuZCB0aGUgb3RoZXIgaXNuJ3RcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghZGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBvcHRzKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGI7XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZGVlcC1lcXVhbC9pbmRleC5qc1xuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJ1xuICA/IE9iamVjdC5rZXlzIDogc2hpbTtcblxuZXhwb3J0cy5zaGltID0gc2hpbTtcbmZ1bmN0aW9uIHNoaW0gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgcmV0dXJuIGtleXM7XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZGVlcC1lcXVhbC9saWIva2V5cy5qc1xuICoqLyIsInZhciBzdXBwb3J0c0FyZ3VtZW50c0NsYXNzID0gKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnRzKVxufSkoKSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA/IHN1cHBvcnRlZCA6IHVuc3VwcG9ydGVkO1xuXG5leHBvcnRzLnN1cHBvcnRlZCA9IHN1cHBvcnRlZDtcbmZ1bmN0aW9uIHN1cHBvcnRlZChvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxuZXhwb3J0cy51bnN1cHBvcnRlZCA9IHVuc3VwcG9ydGVkO1xuZnVuY3Rpb24gdW5zdXBwb3J0ZWQob2JqZWN0KXtcbiAgcmV0dXJuIG9iamVjdCAmJlxuICAgIHR5cGVvZiBvYmplY3QgPT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygb2JqZWN0Lmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdjYWxsZWUnKSAmJlxuICAgICFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCAnY2FsbGVlJykgfHxcbiAgICBmYWxzZTtcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vZGVlcC1lcXVhbC9saWIvaXNfYXJndW1lbnRzLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgX3NsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuZXhwb3J0cy5sb29wQXN5bmMgPSBsb29wQXN5bmM7XG5cbmZ1bmN0aW9uIGxvb3BBc3luYyh0dXJucywgd29yaywgY2FsbGJhY2spIHtcbiAgdmFyIGN1cnJlbnRUdXJuID0gMCxcbiAgICAgIGlzRG9uZSA9IGZhbHNlO1xuICB2YXIgc3luYyA9IGZhbHNlLFxuICAgICAgaGFzTmV4dCA9IGZhbHNlLFxuICAgICAgZG9uZUFyZ3MgPSB1bmRlZmluZWQ7XG5cbiAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICBpc0RvbmUgPSB0cnVlO1xuICAgIGlmIChzeW5jKSB7XG4gICAgICAvLyBJdGVyYXRlIGluc3RlYWQgb2YgcmVjdXJzaW5nIGlmIHBvc3NpYmxlLlxuICAgICAgZG9uZUFyZ3MgPSBbXS5jb25jYXQoX3NsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgaWYgKGlzRG9uZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGhhc05leHQgPSB0cnVlO1xuICAgIGlmIChzeW5jKSB7XG4gICAgICAvLyBJdGVyYXRlIGluc3RlYWQgb2YgcmVjdXJzaW5nIGlmIHBvc3NpYmxlLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN5bmMgPSB0cnVlO1xuXG4gICAgd2hpbGUgKCFpc0RvbmUgJiYgY3VycmVudFR1cm4gPCB0dXJucyAmJiBoYXNOZXh0KSB7XG4gICAgICBoYXNOZXh0ID0gZmFsc2U7XG4gICAgICB3b3JrLmNhbGwodGhpcywgY3VycmVudFR1cm4rKywgbmV4dCwgZG9uZSk7XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuXG4gICAgaWYgKGlzRG9uZSkge1xuICAgICAgLy8gVGhpcyBtZWFucyB0aGUgbG9vcCBmaW5pc2hlZCBzeW5jaHJvbm91c2x5LlxuICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgZG9uZUFyZ3MpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50VHVybiA+PSB0dXJucyAmJiBoYXNOZXh0KSB7XG4gICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH1cblxuICBuZXh0KCk7XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2hpc3RvcnkvbGliL0FzeW5jVXRpbHMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJy4vQWN0aW9ucycpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKCkge1xuICB2YXIgbG9jYXRpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyAnLycgOiBhcmd1bWVudHNbMF07XG4gIHZhciBhY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBfQWN0aW9ucy5QT1AgOiBhcmd1bWVudHNbMV07XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJndW1lbnRzWzJdO1xuXG4gIHZhciBfZm91cnRoQXJnID0gYXJndW1lbnRzLmxlbmd0aCA8PSAzIHx8IGFyZ3VtZW50c1szXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1szXTtcblxuICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJykgbG9jYXRpb24gPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChsb2NhdGlvbik7XG5cbiAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdvYmplY3QnKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnVGhlIHN0YXRlICgybmQpIGFyZ3VtZW50IHRvIGNyZWF0ZUxvY2F0aW9uIGlzIGRlcHJlY2F0ZWQ7IHVzZSBhICcgKyAnbG9jYXRpb24gZGVzY3JpcHRvciBpbnN0ZWFkJykgOiB1bmRlZmluZWQ7XG5cbiAgICBsb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBsb2NhdGlvbiwgeyBzdGF0ZTogYWN0aW9uIH0pO1xuXG4gICAgYWN0aW9uID0ga2V5IHx8IF9BY3Rpb25zLlBPUDtcbiAgICBrZXkgPSBfZm91cnRoQXJnO1xuICB9XG5cbiAgdmFyIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUgfHwgJy8nO1xuICB2YXIgc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoIHx8ICcnO1xuICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2ggfHwgJyc7XG4gIHZhciBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlIHx8IG51bGw7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBzZWFyY2gsXG4gICAgaGFzaDogaGFzaCxcbiAgICBzdGF0ZTogc3RhdGUsXG4gICAgYWN0aW9uOiBhY3Rpb24sXG4gICAga2V5OiBrZXlcbiAgfTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gY3JlYXRlTG9jYXRpb247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vaGlzdG9yeS9saWIvY3JlYXRlTG9jYXRpb24uanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIHJ1blRyYW5zaXRpb25Ib29rKGhvb2ssIGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICB2YXIgcmVzdWx0ID0gaG9vayhsb2NhdGlvbiwgY2FsbGJhY2spO1xuXG4gIGlmIChob29rLmxlbmd0aCA8IDIpIHtcbiAgICAvLyBBc3N1bWUgdGhlIGhvb2sgcnVucyBzeW5jaHJvbm91c2x5IGFuZCBhdXRvbWF0aWNhbGx5XG4gICAgLy8gY2FsbCB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgcmV0dXJuIHZhbHVlLlxuICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKHJlc3VsdCA9PT0gdW5kZWZpbmVkLCAnWW91IHNob3VsZCBub3QgXCJyZXR1cm5cIiBpbiBhIHRyYW5zaXRpb24gaG9vayB3aXRoIGEgY2FsbGJhY2sgYXJndW1lbnQ7IGNhbGwgdGhlIGNhbGxiYWNrIGluc3RlYWQnKSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBydW5UcmFuc2l0aW9uSG9vaztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9oaXN0b3J5L2xpYi9ydW5UcmFuc2l0aW9uSG9vay5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gZGVwcmVjYXRlKGZuLCBtZXNzYWdlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnW2hpc3RvcnldICcgKyBtZXNzYWdlKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gZGVwcmVjYXRlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2hpc3RvcnkvbGliL2RlcHJlY2F0ZS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9xdWVyeVN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5LXN0cmluZycpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rID0gcmVxdWlyZSgnLi9ydW5UcmFuc2l0aW9uSG9vaycpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3J1blRyYW5zaXRpb25Ib29rKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX2RlcHJlY2F0ZSA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlJyk7XG5cbnZhciBfZGVwcmVjYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlcHJlY2F0ZSk7XG5cbnZhciBTRUFSQ0hfQkFTRV9LRVkgPSAnJHNlYXJjaEJhc2UnO1xuXG5mdW5jdGlvbiBkZWZhdWx0U3RyaW5naWZ5UXVlcnkocXVlcnkpIHtcbiAgcmV0dXJuIF9xdWVyeVN0cmluZy5zdHJpbmdpZnkocXVlcnkpLnJlcGxhY2UoLyUyMC9nLCAnKycpO1xufVxuXG52YXIgZGVmYXVsdFBhcnNlUXVlcnlTdHJpbmcgPSBfcXVlcnlTdHJpbmcucGFyc2U7XG5cbmZ1bmN0aW9uIGlzTmVzdGVkT2JqZWN0KG9iamVjdCkge1xuICBmb3IgKHZhciBwIGluIG9iamVjdCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwKSAmJiB0eXBlb2Ygb2JqZWN0W3BdID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShvYmplY3RbcF0pICYmIG9iamVjdFtwXSAhPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIH1yZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBjcmVhdGVIaXN0b3J5IGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gY3JlYXRlXG4gKiBoaXN0b3J5IG9iamVjdHMgdGhhdCBrbm93IGhvdyB0byBoYW5kbGUgVVJMIHF1ZXJpZXMuXG4gKi9cbmZ1bmN0aW9uIHVzZVF1ZXJpZXMoY3JlYXRlSGlzdG9yeSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICB2YXIgaGlzdG9yeSA9IGNyZWF0ZUhpc3Rvcnkob3B0aW9ucyk7XG5cbiAgICB2YXIgc3RyaW5naWZ5UXVlcnkgPSBvcHRpb25zLnN0cmluZ2lmeVF1ZXJ5O1xuICAgIHZhciBwYXJzZVF1ZXJ5U3RyaW5nID0gb3B0aW9ucy5wYXJzZVF1ZXJ5U3RyaW5nO1xuXG4gICAgaWYgKHR5cGVvZiBzdHJpbmdpZnlRdWVyeSAhPT0gJ2Z1bmN0aW9uJykgc3RyaW5naWZ5UXVlcnkgPSBkZWZhdWx0U3RyaW5naWZ5UXVlcnk7XG5cbiAgICBpZiAodHlwZW9mIHBhcnNlUXVlcnlTdHJpbmcgIT09ICdmdW5jdGlvbicpIHBhcnNlUXVlcnlTdHJpbmcgPSBkZWZhdWx0UGFyc2VRdWVyeVN0cmluZztcblxuICAgIGZ1bmN0aW9uIGFkZFF1ZXJ5KGxvY2F0aW9uKSB7XG4gICAgICBpZiAobG9jYXRpb24ucXVlcnkgPT0gbnVsbCkge1xuICAgICAgICB2YXIgc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoO1xuXG4gICAgICAgIGxvY2F0aW9uLnF1ZXJ5ID0gcGFyc2VRdWVyeVN0cmluZyhzZWFyY2guc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgbG9jYXRpb25bU0VBUkNIX0JBU0VfS0VZXSA9IHsgc2VhcmNoOiBzZWFyY2gsIHNlYXJjaEJhc2U6ICcnIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IEluc3RlYWQgb2YgYWxsIHRoZSBib29rLWtlZXBpbmcgaGVyZSwgdGhpcyBzaG91bGQganVzdCBzdHJpcCB0aGVcbiAgICAgIC8vIHN0cmluZ2lmaWVkIHF1ZXJ5IGZyb20gdGhlIHNlYXJjaC5cblxuICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGVuZFF1ZXJ5KGxvY2F0aW9uLCBxdWVyeSkge1xuICAgICAgdmFyIF9leHRlbmRzMjtcblxuICAgICAgdmFyIHNlYXJjaEJhc2VTcGVjID0gbG9jYXRpb25bU0VBUkNIX0JBU0VfS0VZXTtcbiAgICAgIHZhciBxdWVyeVN0cmluZyA9IHF1ZXJ5ID8gc3RyaW5naWZ5UXVlcnkocXVlcnkpIDogJyc7XG4gICAgICBpZiAoIXNlYXJjaEJhc2VTcGVjICYmICFxdWVyeVN0cmluZykge1xuICAgICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShzdHJpbmdpZnlRdWVyeSAhPT0gZGVmYXVsdFN0cmluZ2lmeVF1ZXJ5IHx8ICFpc05lc3RlZE9iamVjdChxdWVyeSksICd1c2VRdWVyaWVzIGRvZXMgbm90IHN0cmluZ2lmeSBuZXN0ZWQgcXVlcnkgb2JqZWN0cyBieSBkZWZhdWx0OyAnICsgJ3VzZSBhIGN1c3RvbSBzdHJpbmdpZnlRdWVyeSBmdW5jdGlvbicpIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJykgbG9jYXRpb24gPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChsb2NhdGlvbik7XG5cbiAgICAgIHZhciBzZWFyY2hCYXNlID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHNlYXJjaEJhc2VTcGVjICYmIGxvY2F0aW9uLnNlYXJjaCA9PT0gc2VhcmNoQmFzZVNwZWMuc2VhcmNoKSB7XG4gICAgICAgIHNlYXJjaEJhc2UgPSBzZWFyY2hCYXNlU3BlYy5zZWFyY2hCYXNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VhcmNoQmFzZSA9IGxvY2F0aW9uLnNlYXJjaCB8fCAnJztcbiAgICAgIH1cblxuICAgICAgdmFyIHNlYXJjaCA9IHNlYXJjaEJhc2U7XG4gICAgICBpZiAocXVlcnlTdHJpbmcpIHtcbiAgICAgICAgc2VhcmNoICs9IChzZWFyY2ggPyAnJicgOiAnPycpICsgcXVlcnlTdHJpbmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIChfZXh0ZW5kczIgPSB7XG4gICAgICAgIHNlYXJjaDogc2VhcmNoXG4gICAgICB9LCBfZXh0ZW5kczJbU0VBUkNIX0JBU0VfS0VZXSA9IHsgc2VhcmNoOiBzZWFyY2gsIHNlYXJjaEJhc2U6IHNlYXJjaEJhc2UgfSwgX2V4dGVuZHMyKSk7XG4gICAgfVxuXG4gICAgLy8gT3ZlcnJpZGUgYWxsIHJlYWQgbWV0aG9kcyB3aXRoIHF1ZXJ5LWF3YXJlIHZlcnNpb25zLlxuICAgIGZ1bmN0aW9uIGxpc3RlbkJlZm9yZShob29rKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW5CZWZvcmUoZnVuY3Rpb24gKGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICBfcnVuVHJhbnNpdGlvbkhvb2syWydkZWZhdWx0J10oaG9vaywgYWRkUXVlcnkobG9jYXRpb24pLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgICAgbGlzdGVuZXIoYWRkUXVlcnkobG9jYXRpb24pKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIE92ZXJyaWRlIGFsbCB3cml0ZSBtZXRob2RzIHdpdGggcXVlcnktYXdhcmUgdmVyc2lvbnMuXG4gICAgZnVuY3Rpb24gcHVzaChsb2NhdGlvbikge1xuICAgICAgaGlzdG9yeS5wdXNoKGFwcGVuZFF1ZXJ5KGxvY2F0aW9uLCBsb2NhdGlvbi5xdWVyeSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGxhY2UobG9jYXRpb24pIHtcbiAgICAgIGhpc3RvcnkucmVwbGFjZShhcHBlbmRRdWVyeShsb2NhdGlvbiwgbG9jYXRpb24ucXVlcnkpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXRoKGxvY2F0aW9uLCBxdWVyeSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKCFxdWVyeSwgJ3RoZSBxdWVyeSBhcmd1bWVudCB0byBjcmVhdGVQYXRoIGlzIGRlcHJlY2F0ZWQ7IHVzZSBhIGxvY2F0aW9uIGRlc2NyaXB0b3IgaW5zdGVhZCcpIDogdW5kZWZpbmVkO1xuXG4gICAgICByZXR1cm4gaGlzdG9yeS5jcmVhdGVQYXRoKGFwcGVuZFF1ZXJ5KGxvY2F0aW9uLCBxdWVyeSB8fCBsb2NhdGlvbi5xdWVyeSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24sIHF1ZXJ5KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oIXF1ZXJ5LCAndGhlIHF1ZXJ5IGFyZ3VtZW50IHRvIGNyZWF0ZUhyZWYgaXMgZGVwcmVjYXRlZDsgdXNlIGEgbG9jYXRpb24gZGVzY3JpcHRvciBpbnN0ZWFkJykgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZUhyZWYoYXBwZW5kUXVlcnkobG9jYXRpb24sIHF1ZXJ5IHx8IGxvY2F0aW9uLnF1ZXJ5KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24obG9jYXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZ1bGxMb2NhdGlvbiA9IGhpc3RvcnkuY3JlYXRlTG9jYXRpb24uYXBwbHkoaGlzdG9yeSwgW2FwcGVuZFF1ZXJ5KGxvY2F0aW9uLCBsb2NhdGlvbi5xdWVyeSldLmNvbmNhdChhcmdzKSk7XG4gICAgICBpZiAobG9jYXRpb24ucXVlcnkpIHtcbiAgICAgICAgZnVsbExvY2F0aW9uLnF1ZXJ5ID0gbG9jYXRpb24ucXVlcnk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWRkUXVlcnkoZnVsbExvY2F0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgZnVuY3Rpb24gcHVzaFN0YXRlKHN0YXRlLCBwYXRoLCBxdWVyeSkge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgcGF0aCA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgICBwdXNoKF9leHRlbmRzKHsgc3RhdGU6IHN0YXRlIH0sIHBhdGgsIHsgcXVlcnk6IHF1ZXJ5IH0pKTtcbiAgICB9XG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgZnVuY3Rpb24gcmVwbGFjZVN0YXRlKHN0YXRlLCBwYXRoLCBxdWVyeSkge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgcGF0aCA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgICByZXBsYWNlKF9leHRlbmRzKHsgc3RhdGU6IHN0YXRlIH0sIHBhdGgsIHsgcXVlcnk6IHF1ZXJ5IH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICAgIGxpc3RlbkJlZm9yZTogbGlzdGVuQmVmb3JlLFxuICAgICAgbGlzdGVuOiBsaXN0ZW4sXG4gICAgICBwdXNoOiBwdXNoLFxuICAgICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICAgIGNyZWF0ZVBhdGg6IGNyZWF0ZVBhdGgsXG4gICAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgICAgY3JlYXRlTG9jYXRpb246IGNyZWF0ZUxvY2F0aW9uLFxuXG4gICAgICBwdXNoU3RhdGU6IF9kZXByZWNhdGUyWydkZWZhdWx0J10ocHVzaFN0YXRlLCAncHVzaFN0YXRlIGlzIGRlcHJlY2F0ZWQ7IHVzZSBwdXNoIGluc3RlYWQnKSxcbiAgICAgIHJlcGxhY2VTdGF0ZTogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShyZXBsYWNlU3RhdGUsICdyZXBsYWNlU3RhdGUgaXMgZGVwcmVjYXRlZDsgdXNlIHJlcGxhY2UgaW5zdGVhZCcpXG4gICAgfSk7XG4gIH07XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHVzZVF1ZXJpZXM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vaGlzdG9yeS9saWIvdXNlUXVlcmllcy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJpY3RVcmlFbmNvZGUgPSByZXF1aXJlKCdzdHJpY3QtdXJpLWVuY29kZScpO1xuXG5leHBvcnRzLmV4dHJhY3QgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiBzdHIuc3BsaXQoJz8nKVsxXSB8fCAnJztcbn07XG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiB7fTtcblx0fVxuXG5cdHN0ciA9IHN0ci50cmltKCkucmVwbGFjZSgvXihcXD98I3wmKS8sICcnKTtcblxuXHRpZiAoIXN0cikge1xuXHRcdHJldHVybiB7fTtcblx0fVxuXG5cdHJldHVybiBzdHIuc3BsaXQoJyYnKS5yZWR1Y2UoZnVuY3Rpb24gKHJldCwgcGFyYW0pIHtcblx0XHR2YXIgcGFydHMgPSBwYXJhbS5yZXBsYWNlKC9cXCsvZywgJyAnKS5zcGxpdCgnPScpO1xuXHRcdC8vIEZpcmVmb3ggKHByZSA0MCkgZGVjb2RlcyBgJTNEYCB0byBgPWBcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3F1ZXJ5LXN0cmluZy9wdWxsLzM3XG5cdFx0dmFyIGtleSA9IHBhcnRzLnNoaWZ0KCk7XG5cdFx0dmFyIHZhbCA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0cy5qb2luKCc9JykgOiB1bmRlZmluZWQ7XG5cblx0XHRrZXkgPSBkZWNvZGVVUklDb21wb25lbnQoa2V5KTtcblxuXHRcdC8vIG1pc3NpbmcgYD1gIHNob3VsZCBiZSBgbnVsbGA6XG5cdFx0Ly8gaHR0cDovL3czLm9yZy9UUi8yMDEyL1dELXVybC0yMDEyMDUyNC8jY29sbGVjdC11cmwtcGFyYW1ldGVyc1xuXHRcdHZhbCA9IHZhbCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlY29kZVVSSUNvbXBvbmVudCh2YWwpO1xuXG5cdFx0aWYgKCFyZXQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0cmV0W2tleV0gPSB2YWw7XG5cdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJldFtrZXldKSkge1xuXHRcdFx0cmV0W2tleV0ucHVzaCh2YWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXRba2V5XSA9IFtyZXRba2V5XSwgdmFsXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LCB7fSk7XG59O1xuXG5leHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChvYmopIHtcblx0cmV0dXJuIG9iaiA/IE9iamVjdC5rZXlzKG9iaikuc29ydCgpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIHZhbCA9IG9ialtrZXldO1xuXG5cdFx0aWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXG5cdFx0aWYgKHZhbCA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGtleTtcblx0XHR9XG5cblx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnNsaWNlKCkuc29ydCgpLm1hcChmdW5jdGlvbiAodmFsMikge1xuXHRcdFx0XHRyZXR1cm4gc3RyaWN0VXJpRW5jb2RlKGtleSkgKyAnPScgKyBzdHJpY3RVcmlFbmNvZGUodmFsMik7XG5cdFx0XHR9KS5qb2luKCcmJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN0cmljdFVyaUVuY29kZShrZXkpICsgJz0nICsgc3RyaWN0VXJpRW5jb2RlKHZhbCk7XG5cdH0pLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuXHRcdHJldHVybiB4Lmxlbmd0aCA+IDA7XG5cdH0pLmpvaW4oJyYnKSA6ICcnO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9xdWVyeS1zdHJpbmcvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoL1shJygpKl0vZywgZnVuY3Rpb24gKGMpIHtcblx0XHRyZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHR9KTtcbn07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vc3RyaWN0LXVyaS1lbmNvZGUvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX2NvbXB1dGVDaGFuZ2VkUm91dGVzMiA9IHJlcXVpcmUoJy4vY29tcHV0ZUNoYW5nZWRSb3V0ZXMnKTtcblxudmFyIF9jb21wdXRlQ2hhbmdlZFJvdXRlczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wdXRlQ2hhbmdlZFJvdXRlczIpO1xuXG52YXIgX1RyYW5zaXRpb25VdGlscyA9IHJlcXVpcmUoJy4vVHJhbnNpdGlvblV0aWxzJyk7XG5cbnZhciBfaXNBY3RpdmUyID0gcmVxdWlyZSgnLi9pc0FjdGl2ZScpO1xuXG52YXIgX2lzQWN0aXZlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzQWN0aXZlMik7XG5cbnZhciBfZ2V0Q29tcG9uZW50cyA9IHJlcXVpcmUoJy4vZ2V0Q29tcG9uZW50cycpO1xuXG52YXIgX2dldENvbXBvbmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0Q29tcG9uZW50cyk7XG5cbnZhciBfbWF0Y2hSb3V0ZXMgPSByZXF1aXJlKCcuL21hdGNoUm91dGVzJyk7XG5cbnZhciBfbWF0Y2hSb3V0ZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0Y2hSb3V0ZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBoYXNBbnlQcm9wZXJ0aWVzKG9iamVjdCkge1xuICBmb3IgKHZhciBwIGluIG9iamVjdCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwKSkgcmV0dXJuIHRydWU7XG4gIH1yZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKGhpc3RvcnksIHJvdXRlcykge1xuICB2YXIgc3RhdGUgPSB7fTtcblxuICAvLyBTaWduYXR1cmUgc2hvdWxkIGJlIChsb2NhdGlvbiwgaW5kZXhPbmx5KSwgYnV0IG5lZWRzIHRvIHN1cHBvcnQgKHBhdGgsXG4gIC8vIHF1ZXJ5LCBpbmRleE9ubHkpXG4gIGZ1bmN0aW9uIGlzQWN0aXZlKGxvY2F0aW9uKSB7XG4gICAgdmFyIGluZGV4T25seU9yRGVwcmVjYXRlZFF1ZXJ5ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbMV07XG4gICAgdmFyIGRlcHJlY2F0ZWRJbmRleE9ubHkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJndW1lbnRzWzJdO1xuXG4gICAgdmFyIGluZGV4T25seSA9IHZvaWQgMDtcbiAgICBpZiAoaW5kZXhPbmx5T3JEZXByZWNhdGVkUXVlcnkgJiYgaW5kZXhPbmx5T3JEZXByZWNhdGVkUXVlcnkgIT09IHRydWUgfHwgZGVwcmVjYXRlZEluZGV4T25seSAhPT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdgaXNBY3RpdmUocGF0aG5hbWUsIHF1ZXJ5LCBpbmRleE9ubHkpIGlzIGRlcHJlY2F0ZWQ7IHVzZSBgaXNBY3RpdmUobG9jYXRpb24sIGluZGV4T25seSlgIHdpdGggYSBsb2NhdGlvbiBkZXNjcmlwdG9yIGluc3RlYWQuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1pc0FjdGl2ZWRlcHJlY2F0ZWQnKSA6IHZvaWQgMDtcbiAgICAgIGxvY2F0aW9uID0geyBwYXRobmFtZTogbG9jYXRpb24sIHF1ZXJ5OiBpbmRleE9ubHlPckRlcHJlY2F0ZWRRdWVyeSB9O1xuICAgICAgaW5kZXhPbmx5ID0gZGVwcmVjYXRlZEluZGV4T25seSB8fCBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9jYXRpb24gPSBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKTtcbiAgICAgIGluZGV4T25seSA9IGluZGV4T25seU9yRGVwcmVjYXRlZFF1ZXJ5O1xuICAgIH1cblxuICAgIHJldHVybiAoMCwgX2lzQWN0aXZlMy5kZWZhdWx0KShsb2NhdGlvbiwgaW5kZXhPbmx5LCBzdGF0ZS5sb2NhdGlvbiwgc3RhdGUucm91dGVzLCBzdGF0ZS5wYXJhbXMpO1xuICB9XG5cbiAgdmFyIHBhcnRpYWxOZXh0U3RhdGUgPSB2b2lkIDA7XG5cbiAgZnVuY3Rpb24gbWF0Y2gobG9jYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgaWYgKHBhcnRpYWxOZXh0U3RhdGUgJiYgcGFydGlhbE5leHRTdGF0ZS5sb2NhdGlvbiA9PT0gbG9jYXRpb24pIHtcbiAgICAgIC8vIENvbnRpbnVlIGZyb20gd2hlcmUgd2UgbGVmdCBvZmYuXG4gICAgICBmaW5pc2hNYXRjaChwYXJ0aWFsTmV4dFN0YXRlLCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICgwLCBfbWF0Y2hSb3V0ZXMyLmRlZmF1bHQpKHJvdXRlcywgbG9jYXRpb24sIGZ1bmN0aW9uIChlcnJvciwgbmV4dFN0YXRlKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0U3RhdGUpIHtcbiAgICAgICAgICBmaW5pc2hNYXRjaChfZXh0ZW5kcyh7fSwgbmV4dFN0YXRlLCB7IGxvY2F0aW9uOiBsb2NhdGlvbiB9KSwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaE1hdGNoKG5leHRTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgX2NvbXB1dGVDaGFuZ2VkUm91dGVzID0gKDAsIF9jb21wdXRlQ2hhbmdlZFJvdXRlczMuZGVmYXVsdCkoc3RhdGUsIG5leHRTdGF0ZSk7XG5cbiAgICB2YXIgbGVhdmVSb3V0ZXMgPSBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMubGVhdmVSb3V0ZXM7XG4gICAgdmFyIGNoYW5nZVJvdXRlcyA9IF9jb21wdXRlQ2hhbmdlZFJvdXRlcy5jaGFuZ2VSb3V0ZXM7XG4gICAgdmFyIGVudGVyUm91dGVzID0gX2NvbXB1dGVDaGFuZ2VkUm91dGVzLmVudGVyUm91dGVzO1xuXG5cbiAgICAoMCwgX1RyYW5zaXRpb25VdGlscy5ydW5MZWF2ZUhvb2tzKShsZWF2ZVJvdXRlcywgc3RhdGUpO1xuXG4gICAgLy8gVGVhciBkb3duIGNvbmZpcm1hdGlvbiBob29rcyBmb3IgbGVmdCByb3V0ZXNcbiAgICBsZWF2ZVJvdXRlcy5maWx0ZXIoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICByZXR1cm4gZW50ZXJSb3V0ZXMuaW5kZXhPZihyb3V0ZSkgPT09IC0xO1xuICAgIH0pLmZvckVhY2gocmVtb3ZlTGlzdGVuQmVmb3JlSG9va3NGb3JSb3V0ZSk7XG5cbiAgICAvLyBjaGFuZ2UgYW5kIGVudGVyIGhvb2tzIGFyZSBydW4gaW4gc2VyaWVzXG4gICAgKDAsIF9UcmFuc2l0aW9uVXRpbHMucnVuQ2hhbmdlSG9va3MpKGNoYW5nZVJvdXRlcywgc3RhdGUsIG5leHRTdGF0ZSwgZnVuY3Rpb24gKGVycm9yLCByZWRpcmVjdEluZm8pIHtcbiAgICAgIGlmIChlcnJvciB8fCByZWRpcmVjdEluZm8pIHJldHVybiBoYW5kbGVFcnJvck9yUmVkaXJlY3QoZXJyb3IsIHJlZGlyZWN0SW5mbyk7XG5cbiAgICAgICgwLCBfVHJhbnNpdGlvblV0aWxzLnJ1bkVudGVySG9va3MpKGVudGVyUm91dGVzLCBuZXh0U3RhdGUsIGZpbmlzaEVudGVySG9va3MpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZmluaXNoRW50ZXJIb29rcyhlcnJvciwgcmVkaXJlY3RJbmZvKSB7XG4gICAgICBpZiAoZXJyb3IgfHwgcmVkaXJlY3RJbmZvKSByZXR1cm4gaGFuZGxlRXJyb3JPclJlZGlyZWN0KGVycm9yLCByZWRpcmVjdEluZm8pO1xuXG4gICAgICAvLyBUT0RPOiBGZXRjaCBjb21wb25lbnRzIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAgICAoMCwgX2dldENvbXBvbmVudHMyLmRlZmF1bHQpKG5leHRTdGF0ZSwgZnVuY3Rpb24gKGVycm9yLCBjb21wb25lbnRzKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUT0RPOiBNYWtlIG1hdGNoIGEgcHVyZSBmdW5jdGlvbiBhbmQgaGF2ZSBzb21lIG90aGVyIEFQSVxuICAgICAgICAgIC8vIGZvciBcIm1hdGNoIGFuZCB1cGRhdGUgc3RhdGVcIi5cbiAgICAgICAgICBjYWxsYmFjayhudWxsLCBudWxsLCBzdGF0ZSA9IF9leHRlbmRzKHt9LCBuZXh0U3RhdGUsIHsgY29tcG9uZW50czogY29tcG9uZW50cyB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZUVycm9yT3JSZWRpcmVjdChlcnJvciwgcmVkaXJlY3RJbmZvKSB7XG4gICAgICBpZiAoZXJyb3IpIGNhbGxiYWNrKGVycm9yKTtlbHNlIGNhbGxiYWNrKG51bGwsIHJlZGlyZWN0SW5mbyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIFJvdXRlR3VpZCA9IDE7XG5cbiAgZnVuY3Rpb24gZ2V0Um91dGVJRChyb3V0ZSkge1xuICAgIHZhciBjcmVhdGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzFdO1xuXG4gICAgcmV0dXJuIHJvdXRlLl9faWRfXyB8fCBjcmVhdGUgJiYgKHJvdXRlLl9faWRfXyA9IFJvdXRlR3VpZCsrKTtcbiAgfVxuXG4gIHZhciBSb3V0ZUhvb2tzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmdW5jdGlvbiBnZXRSb3V0ZUhvb2tzRm9yUm91dGVzKHJvdXRlcykge1xuICAgIHJldHVybiByb3V0ZXMucmVkdWNlKGZ1bmN0aW9uIChob29rcywgcm91dGUpIHtcbiAgICAgIGhvb2tzLnB1c2guYXBwbHkoaG9va3MsIFJvdXRlSG9va3NbZ2V0Um91dGVJRChyb3V0ZSldKTtcbiAgICAgIHJldHVybiBob29rcztcbiAgICB9LCBbXSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2l0aW9uSG9vayhsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgICAoMCwgX21hdGNoUm91dGVzMi5kZWZhdWx0KShyb3V0ZXMsIGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIG5leHRTdGF0ZSkge1xuICAgICAgaWYgKG5leHRTdGF0ZSA9PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFdlIGRpZG4ndCBhY3R1YWxseSBtYXRjaCBhbnl0aGluZywgYnV0IGhhbmdcbiAgICAgICAgLy8gb250byBlcnJvci9uZXh0U3RhdGUgc28gd2UgZG9uJ3QgaGF2ZSB0byBtYXRjaFJvdXRlc1xuICAgICAgICAvLyBhZ2FpbiBpbiB0aGUgbGlzdGVuIGNhbGxiYWNrLlxuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENhY2hlIHNvbWUgc3RhdGUgaGVyZSBzbyB3ZSBkb24ndCBoYXZlIHRvXG4gICAgICAvLyBtYXRjaFJvdXRlcygpIGFnYWluIGluIHRoZSBsaXN0ZW4gY2FsbGJhY2suXG4gICAgICBwYXJ0aWFsTmV4dFN0YXRlID0gX2V4dGVuZHMoe30sIG5leHRTdGF0ZSwgeyBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG5cbiAgICAgIHZhciBob29rcyA9IGdldFJvdXRlSG9va3NGb3JSb3V0ZXMoKDAsIF9jb21wdXRlQ2hhbmdlZFJvdXRlczMuZGVmYXVsdCkoc3RhdGUsIHBhcnRpYWxOZXh0U3RhdGUpLmxlYXZlUm91dGVzKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBob29rcy5sZW5ndGg7IHJlc3VsdCA9PSBudWxsICYmIGkgPCBsZW47ICsraSkge1xuICAgICAgICAvLyBQYXNzaW5nIHRoZSBsb2NhdGlvbiBhcmcgaGVyZSBpbmRpY2F0ZXMgdG9cbiAgICAgICAgLy8gdGhlIHVzZXIgdGhhdCB0aGlzIGlzIGEgdHJhbnNpdGlvbiBob29rLlxuICAgICAgICByZXN1bHQgPSBob29rc1tpXShsb2NhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgfSk7XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogdW50ZXN0YWJsZSB3aXRoIEthcm1hICovXG4gIGZ1bmN0aW9uIGJlZm9yZVVubG9hZEhvb2soKSB7XG4gICAgLy8gU3luY2hyb25vdXNseSBjaGVjayB0byBzZWUgaWYgYW55IHJvdXRlIGhvb2tzIHdhbnRcbiAgICAvLyB0byBwcmV2ZW50IHRoZSBjdXJyZW50IHdpbmRvdy90YWIgZnJvbSBjbG9zaW5nLlxuICAgIGlmIChzdGF0ZS5yb3V0ZXMpIHtcbiAgICAgIHZhciBob29rcyA9IGdldFJvdXRlSG9va3NGb3JSb3V0ZXMoc3RhdGUucm91dGVzKTtcblxuICAgICAgdmFyIG1lc3NhZ2UgPSB2b2lkIDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaG9va3MubGVuZ3RoOyB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycgJiYgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIC8vIFBhc3Npbmcgbm8gYXJncyBpbmRpY2F0ZXMgdG8gdGhlIHVzZXIgdGhhdCB0aGlzIGlzIGFcbiAgICAgICAgLy8gYmVmb3JldW5sb2FkIGhvb2suIFdlIGRvbid0IGtub3cgdGhlIG5leHQgbG9jYXRpb24uXG4gICAgICAgIG1lc3NhZ2UgPSBob29rc1tpXSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5saXN0ZW5CZWZvcmUgPSB2b2lkIDAsXG4gICAgICB1bmxpc3RlbkJlZm9yZVVubG9hZCA9IHZvaWQgMDtcblxuICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5CZWZvcmVIb29rc0ZvclJvdXRlKHJvdXRlKSB7XG4gICAgdmFyIHJvdXRlSUQgPSBnZXRSb3V0ZUlEKHJvdXRlLCBmYWxzZSk7XG4gICAgaWYgKCFyb3V0ZUlEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGVsZXRlIFJvdXRlSG9va3Nbcm91dGVJRF07XG5cbiAgICBpZiAoIWhhc0FueVByb3BlcnRpZXMoUm91dGVIb29rcykpIHtcbiAgICAgIC8vIHRlYXJkb3duIHRyYW5zaXRpb24gJiBiZWZvcmV1bmxvYWQgaG9va3NcbiAgICAgIGlmICh1bmxpc3RlbkJlZm9yZSkge1xuICAgICAgICB1bmxpc3RlbkJlZm9yZSgpO1xuICAgICAgICB1bmxpc3RlbkJlZm9yZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh1bmxpc3RlbkJlZm9yZVVubG9hZCkge1xuICAgICAgICB1bmxpc3RlbkJlZm9yZVVubG9hZCgpO1xuICAgICAgICB1bmxpc3RlbkJlZm9yZVVubG9hZCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyB0aGUgZ2l2ZW4gaG9vayBmdW5jdGlvbiB0byBydW4gYmVmb3JlIGxlYXZpbmcgdGhlIGdpdmVuIHJvdXRlLlxuICAgKlxuICAgKiBEdXJpbmcgYSBub3JtYWwgdHJhbnNpdGlvbiwgdGhlIGhvb2sgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIG5leHQgbG9jYXRpb25cbiAgICogYXMgaXRzIG9ubHkgYXJndW1lbnQgYW5kIGNhbiByZXR1cm4gZWl0aGVyIGEgcHJvbXB0IG1lc3NhZ2UgKHN0cmluZykgdG8gc2hvdyB0aGUgdXNlcixcbiAgICogdG8gbWFrZSBzdXJlIHRoZXkgd2FudCB0byBsZWF2ZSB0aGUgcGFnZTsgb3IgYGZhbHNlYCwgdG8gcHJldmVudCB0aGUgdHJhbnNpdGlvbi5cbiAgICogQW55IG90aGVyIHJldHVybiB2YWx1ZSB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuICAgKlxuICAgKiBEdXJpbmcgdGhlIGJlZm9yZXVubG9hZCBldmVudCAoaW4gYnJvd3NlcnMpIHRoZSBob29rIHJlY2VpdmVzIG5vIGFyZ3VtZW50cy5cbiAgICogSW4gdGhpcyBjYXNlIGl0IG11c3QgcmV0dXJuIGEgcHJvbXB0IG1lc3NhZ2UgdG8gcHJldmVudCB0aGUgdHJhbnNpdGlvbi5cbiAgICpcbiAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gdW5iaW5kIHRoZSBsaXN0ZW5lci5cbiAgICovXG4gIGZ1bmN0aW9uIGxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZShyb3V0ZSwgaG9vaykge1xuICAgIC8vIFRPRE86IFdhcm4gaWYgdGhleSByZWdpc3RlciBmb3IgYSByb3V0ZSB0aGF0IGlzbid0IGN1cnJlbnRseVxuICAgIC8vIGFjdGl2ZS4gVGhleSdyZSBwcm9iYWJseSBkb2luZyBzb21ldGhpbmcgd3JvbmcsIGxpa2UgcmUtY3JlYXRpbmdcbiAgICAvLyByb3V0ZSBvYmplY3RzIG9uIGV2ZXJ5IGxvY2F0aW9uIGNoYW5nZS5cbiAgICB2YXIgcm91dGVJRCA9IGdldFJvdXRlSUQocm91dGUpO1xuICAgIHZhciBob29rcyA9IFJvdXRlSG9va3Nbcm91dGVJRF07XG5cbiAgICBpZiAoIWhvb2tzKSB7XG4gICAgICB2YXIgdGhlcmVXZXJlTm9Sb3V0ZUhvb2tzID0gIWhhc0FueVByb3BlcnRpZXMoUm91dGVIb29rcyk7XG5cbiAgICAgIFJvdXRlSG9va3Nbcm91dGVJRF0gPSBbaG9va107XG5cbiAgICAgIGlmICh0aGVyZVdlcmVOb1JvdXRlSG9va3MpIHtcbiAgICAgICAgLy8gc2V0dXAgdHJhbnNpdGlvbiAmIGJlZm9yZXVubG9hZCBob29rc1xuICAgICAgICB1bmxpc3RlbkJlZm9yZSA9IGhpc3RvcnkubGlzdGVuQmVmb3JlKHRyYW5zaXRpb25Ib29rKTtcblxuICAgICAgICBpZiAoaGlzdG9yeS5saXN0ZW5CZWZvcmVVbmxvYWQpIHVubGlzdGVuQmVmb3JlVW5sb2FkID0gaGlzdG9yeS5saXN0ZW5CZWZvcmVVbmxvYWQoYmVmb3JlVW5sb2FkSG9vayk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChob29rcy5pbmRleE9mKGhvb2spID09PSAtMSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ2FkZGluZyBtdWx0aXBsZSBsZWF2ZSBob29rcyBmb3IgdGhlIHNhbWUgcm91dGUgaXMgZGVwcmVjYXRlZDsgbWFuYWdlIG11bHRpcGxlIGNvbmZpcm1hdGlvbnMgaW4geW91ciBvd24gY29kZSBpbnN0ZWFkJykgOiB2b2lkIDA7XG5cbiAgICAgICAgaG9va3MucHVzaChob29rKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGhvb2tzID0gUm91dGVIb29rc1tyb3V0ZUlEXTtcblxuICAgICAgaWYgKGhvb2tzKSB7XG4gICAgICAgIHZhciBuZXdIb29rcyA9IGhvb2tzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHJldHVybiBpdGVtICE9PSBob29rO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobmV3SG9va3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmVtb3ZlTGlzdGVuQmVmb3JlSG9va3NGb3JSb3V0ZShyb3V0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUm91dGVIb29rc1tyb3V0ZUlEXSA9IG5ld0hvb2tzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBBUEkgZm9yIHN0YXRlZnVsIGVudmlyb25tZW50cy4gQXMgdGhlIGxvY2F0aW9uXG4gICAqIGNoYW5nZXMsIHdlIHVwZGF0ZSBzdGF0ZSBhbmQgY2FsbCB0aGUgbGlzdGVuZXIuIFdlIGNhbiBhbHNvXG4gICAqIGdyYWNlZnVsbHkgaGFuZGxlIGVycm9ycyBhbmQgcmVkaXJlY3RzLlxuICAgKi9cbiAgZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgLy8gVE9ETzogT25seSB1c2UgYSBzaW5nbGUgaGlzdG9yeSBsaXN0ZW5lci4gT3RoZXJ3aXNlIHdlJ2xsXG4gICAgLy8gZW5kIHVwIHdpdGggbXVsdGlwbGUgY29uY3VycmVudCBjYWxscyB0byBtYXRjaC5cbiAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICBpZiAoc3RhdGUubG9jYXRpb24gPT09IGxvY2F0aW9uKSB7XG4gICAgICAgIGxpc3RlbmVyKG51bGwsIHN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoKGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIHJlZGlyZWN0TG9jYXRpb24sIG5leHRTdGF0ZSkge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgbGlzdGVuZXIoZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVkaXJlY3RMb2NhdGlvbikge1xuICAgICAgICAgICAgaGlzdG9yeS5yZXBsYWNlKHJlZGlyZWN0TG9jYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmV4dFN0YXRlKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcihudWxsLCBuZXh0U3RhdGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ0xvY2F0aW9uIFwiJXNcIiBkaWQgbm90IG1hdGNoIGFueSByb3V0ZXMnLCBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCArIGxvY2F0aW9uLmhhc2gpIDogdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlzQWN0aXZlOiBpc0FjdGl2ZSxcbiAgICBtYXRjaDogbWF0Y2gsXG4gICAgbGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlOiBsaXN0ZW5CZWZvcmVMZWF2aW5nUm91dGUsXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcbn1cblxuLy9leHBvcnQgZGVmYXVsdCB1c2VSb3V0ZXNcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfUGF0dGVyblV0aWxzID0gcmVxdWlyZSgnLi9QYXR0ZXJuVXRpbHMnKTtcblxuZnVuY3Rpb24gcm91dGVQYXJhbXNDaGFuZ2VkKHJvdXRlLCBwcmV2U3RhdGUsIG5leHRTdGF0ZSkge1xuICBpZiAoIXJvdXRlLnBhdGgpIHJldHVybiBmYWxzZTtcblxuICB2YXIgcGFyYW1OYW1lcyA9ICgwLCBfUGF0dGVyblV0aWxzLmdldFBhcmFtTmFtZXMpKHJvdXRlLnBhdGgpO1xuXG4gIHJldHVybiBwYXJhbU5hbWVzLnNvbWUoZnVuY3Rpb24gKHBhcmFtTmFtZSkge1xuICAgIHJldHVybiBwcmV2U3RhdGUucGFyYW1zW3BhcmFtTmFtZV0gIT09IG5leHRTdGF0ZS5wYXJhbXNbcGFyYW1OYW1lXTtcbiAgfSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3Qgb2YgeyBsZWF2ZVJvdXRlcywgY2hhbmdlUm91dGVzLCBlbnRlclJvdXRlcyB9IGRldGVybWluZWQgYnlcbiAqIHRoZSBjaGFuZ2UgZnJvbSBwcmV2U3RhdGUgdG8gbmV4dFN0YXRlLiBXZSBsZWF2ZSByb3V0ZXMgaWYgZWl0aGVyXG4gKiAxKSB0aGV5IGFyZSBub3QgaW4gdGhlIG5leHQgc3RhdGUgb3IgMikgdGhleSBhcmUgaW4gdGhlIG5leHQgc3RhdGVcbiAqIGJ1dCB0aGVpciBwYXJhbXMgaGF2ZSBjaGFuZ2VkIChpLmUuIC91c2Vycy8xMjMgPT4gL3VzZXJzLzQ1NikuXG4gKlxuICogbGVhdmVSb3V0ZXMgYXJlIG9yZGVyZWQgc3RhcnRpbmcgYXQgdGhlIGxlYWYgcm91dGUgb2YgdGhlIHRyZWVcbiAqIHdlJ3JlIGxlYXZpbmcgdXAgdG8gdGhlIGNvbW1vbiBwYXJlbnQgcm91dGUuIGVudGVyUm91dGVzIGFyZSBvcmRlcmVkXG4gKiBmcm9tIHRoZSB0b3Agb2YgdGhlIHRyZWUgd2UncmUgZW50ZXJpbmcgZG93biB0byB0aGUgbGVhZiByb3V0ZS5cbiAqXG4gKiBjaGFuZ2VSb3V0ZXMgYXJlIGFueSByb3V0ZXMgdGhhdCBkaWRuJ3QgbGVhdmUgb3IgZW50ZXIgZHVyaW5nXG4gKiB0aGUgdHJhbnNpdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUNoYW5nZWRSb3V0ZXMocHJldlN0YXRlLCBuZXh0U3RhdGUpIHtcbiAgdmFyIHByZXZSb3V0ZXMgPSBwcmV2U3RhdGUgJiYgcHJldlN0YXRlLnJvdXRlcztcbiAgdmFyIG5leHRSb3V0ZXMgPSBuZXh0U3RhdGUucm91dGVzO1xuXG4gIHZhciBsZWF2ZVJvdXRlcyA9IHZvaWQgMCxcbiAgICAgIGNoYW5nZVJvdXRlcyA9IHZvaWQgMCxcbiAgICAgIGVudGVyUm91dGVzID0gdm9pZCAwO1xuICBpZiAocHJldlJvdXRlcykge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50SXNMZWF2aW5nID0gZmFsc2U7XG4gICAgICBsZWF2ZVJvdXRlcyA9IHByZXZSb3V0ZXMuZmlsdGVyKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICBpZiAocGFyZW50SXNMZWF2aW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGlzTGVhdmluZyA9IG5leHRSb3V0ZXMuaW5kZXhPZihyb3V0ZSkgPT09IC0xIHx8IHJvdXRlUGFyYW1zQ2hhbmdlZChyb3V0ZSwgcHJldlN0YXRlLCBuZXh0U3RhdGUpO1xuICAgICAgICAgIGlmIChpc0xlYXZpbmcpIHBhcmVudElzTGVhdmluZyA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGlzTGVhdmluZztcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIG9uTGVhdmUgaG9va3Mgc3RhcnQgYXQgdGhlIGxlYWYgcm91dGUuXG4gICAgICBsZWF2ZVJvdXRlcy5yZXZlcnNlKCk7XG5cbiAgICAgIGVudGVyUm91dGVzID0gW107XG4gICAgICBjaGFuZ2VSb3V0ZXMgPSBbXTtcblxuICAgICAgbmV4dFJvdXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICB2YXIgaXNOZXcgPSBwcmV2Um91dGVzLmluZGV4T2Yocm91dGUpID09PSAtMTtcbiAgICAgICAgdmFyIHBhcmFtc0NoYW5nZWQgPSBsZWF2ZVJvdXRlcy5pbmRleE9mKHJvdXRlKSAhPT0gLTE7XG5cbiAgICAgICAgaWYgKGlzTmV3IHx8IHBhcmFtc0NoYW5nZWQpIGVudGVyUm91dGVzLnB1c2gocm91dGUpO2Vsc2UgY2hhbmdlUm91dGVzLnB1c2gocm91dGUpO1xuICAgICAgfSk7XG4gICAgfSkoKTtcbiAgfSBlbHNlIHtcbiAgICBsZWF2ZVJvdXRlcyA9IFtdO1xuICAgIGNoYW5nZVJvdXRlcyA9IFtdO1xuICAgIGVudGVyUm91dGVzID0gbmV4dFJvdXRlcztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbGVhdmVSb3V0ZXM6IGxlYXZlUm91dGVzLFxuICAgIGNoYW5nZVJvdXRlczogY2hhbmdlUm91dGVzLFxuICAgIGVudGVyUm91dGVzOiBlbnRlclJvdXRlc1xuICB9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBjb21wdXRlQ2hhbmdlZFJvdXRlcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2NvbXB1dGVDaGFuZ2VkUm91dGVzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5ydW5FbnRlckhvb2tzID0gcnVuRW50ZXJIb29rcztcbmV4cG9ydHMucnVuQ2hhbmdlSG9va3MgPSBydW5DaGFuZ2VIb29rcztcbmV4cG9ydHMucnVuTGVhdmVIb29rcyA9IHJ1bkxlYXZlSG9va3M7XG5cbnZhciBfQXN5bmNVdGlscyA9IHJlcXVpcmUoJy4vQXN5bmNVdGlscycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uSG9vayhob29rLCByb3V0ZSwgYXN5bmNBcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGhvb2suYXBwbHkocm91dGUsIGFyZ3MpO1xuXG4gICAgaWYgKGhvb2subGVuZ3RoIDwgYXN5bmNBcml0eSkge1xuICAgICAgdmFyIGNhbGxiYWNrID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgLy8gQXNzdW1lIGhvb2sgZXhlY3V0ZXMgc3luY2hyb25vdXNseSBhbmRcbiAgICAgIC8vIGF1dG9tYXRpY2FsbHkgY2FsbCB0aGUgY2FsbGJhY2suXG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RW50ZXJIb29rcyhyb3V0ZXMpIHtcbiAgcmV0dXJuIHJvdXRlcy5yZWR1Y2UoZnVuY3Rpb24gKGhvb2tzLCByb3V0ZSkge1xuICAgIGlmIChyb3V0ZS5vbkVudGVyKSBob29rcy5wdXNoKGNyZWF0ZVRyYW5zaXRpb25Ib29rKHJvdXRlLm9uRW50ZXIsIHJvdXRlLCAzKSk7XG5cbiAgICByZXR1cm4gaG9va3M7XG4gIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2hhbmdlSG9va3Mocm91dGVzKSB7XG4gIHJldHVybiByb3V0ZXMucmVkdWNlKGZ1bmN0aW9uIChob29rcywgcm91dGUpIHtcbiAgICBpZiAocm91dGUub25DaGFuZ2UpIGhvb2tzLnB1c2goY3JlYXRlVHJhbnNpdGlvbkhvb2socm91dGUub25DaGFuZ2UsIHJvdXRlLCA0KSk7XG4gICAgcmV0dXJuIGhvb2tzO1xuICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIHJ1blRyYW5zaXRpb25Ib29rcyhsZW5ndGgsIGl0ZXIsIGNhbGxiYWNrKSB7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcmVkaXJlY3RJbmZvID0gdm9pZCAwO1xuICBmdW5jdGlvbiByZXBsYWNlKGxvY2F0aW9uLCBkZXByZWNhdGVkUGF0aG5hbWUsIGRlcHJlY2F0ZWRRdWVyeSkge1xuICAgIGlmIChkZXByZWNhdGVkUGF0aG5hbWUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnYHJlcGxhY2VTdGF0ZShzdGF0ZSwgcGF0aG5hbWUsIHF1ZXJ5KSBpcyBkZXByZWNhdGVkOyB1c2UgYHJlcGxhY2UobG9jYXRpb24pYCB3aXRoIGEgbG9jYXRpb24gZGVzY3JpcHRvciBpbnN0ZWFkLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItaXNBY3RpdmVkZXByZWNhdGVkJykgOiB2b2lkIDA7XG4gICAgICByZWRpcmVjdEluZm8gPSB7XG4gICAgICAgIHBhdGhuYW1lOiBkZXByZWNhdGVkUGF0aG5hbWUsXG4gICAgICAgIHF1ZXJ5OiBkZXByZWNhdGVkUXVlcnksXG4gICAgICAgIHN0YXRlOiBsb2NhdGlvblxuICAgICAgfTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlZGlyZWN0SW5mbyA9IGxvY2F0aW9uO1xuICB9XG5cbiAgKDAsIF9Bc3luY1V0aWxzLmxvb3BBc3luYykobGVuZ3RoLCBmdW5jdGlvbiAoaW5kZXgsIG5leHQsIGRvbmUpIHtcbiAgICBpdGVyKGluZGV4LCByZXBsYWNlLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciB8fCByZWRpcmVjdEluZm8pIHtcbiAgICAgICAgZG9uZShlcnJvciwgcmVkaXJlY3RJbmZvKTsgLy8gTm8gbmVlZCB0byBjb250aW51ZS5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIFJ1bnMgYWxsIG9uRW50ZXIgaG9va3MgaW4gdGhlIGdpdmVuIGFycmF5IG9mIHJvdXRlcyBpbiBvcmRlclxuICogd2l0aCBvbkVudGVyKG5leHRTdGF0ZSwgcmVwbGFjZSwgY2FsbGJhY2spIGFuZCBjYWxsc1xuICogY2FsbGJhY2soZXJyb3IsIHJlZGlyZWN0SW5mbykgd2hlbiBmaW5pc2hlZC4gVGhlIGZpcnN0IGhvb2tcbiAqIHRvIHVzZSByZXBsYWNlIHNob3J0LWNpcmN1aXRzIHRoZSBsb29wLlxuICpcbiAqIElmIGEgaG9vayBuZWVkcyB0byBydW4gYXN5bmNocm9ub3VzbHksIGl0IG1heSB1c2UgdGhlIGNhbGxiYWNrXG4gKiBmdW5jdGlvbi4gSG93ZXZlciwgZG9pbmcgc28gd2lsbCBjYXVzZSB0aGUgdHJhbnNpdGlvbiB0byBwYXVzZSxcbiAqIHdoaWNoIGNvdWxkIGxlYWQgdG8gYSBub24tcmVzcG9uc2l2ZSBVSSBpZiB0aGUgaG9vayBpcyBzbG93LlxuICovXG5mdW5jdGlvbiBydW5FbnRlckhvb2tzKHJvdXRlcywgbmV4dFN0YXRlLCBjYWxsYmFjaykge1xuICB2YXIgaG9va3MgPSBnZXRFbnRlckhvb2tzKHJvdXRlcyk7XG4gIHJldHVybiBydW5UcmFuc2l0aW9uSG9va3MoaG9va3MubGVuZ3RoLCBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2UsIG5leHQpIHtcbiAgICBob29rc1tpbmRleF0obmV4dFN0YXRlLCByZXBsYWNlLCBuZXh0KTtcbiAgfSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIFJ1bnMgYWxsIG9uQ2hhbmdlIGhvb2tzIGluIHRoZSBnaXZlbiBhcnJheSBvZiByb3V0ZXMgaW4gb3JkZXJcbiAqIHdpdGggb25DaGFuZ2UocHJldlN0YXRlLCBuZXh0U3RhdGUsIHJlcGxhY2UsIGNhbGxiYWNrKSBhbmQgY2FsbHNcbiAqIGNhbGxiYWNrKGVycm9yLCByZWRpcmVjdEluZm8pIHdoZW4gZmluaXNoZWQuIFRoZSBmaXJzdCBob29rXG4gKiB0byB1c2UgcmVwbGFjZSBzaG9ydC1jaXJjdWl0cyB0aGUgbG9vcC5cbiAqXG4gKiBJZiBhIGhvb2sgbmVlZHMgdG8gcnVuIGFzeW5jaHJvbm91c2x5LCBpdCBtYXkgdXNlIHRoZSBjYWxsYmFja1xuICogZnVuY3Rpb24uIEhvd2V2ZXIsIGRvaW5nIHNvIHdpbGwgY2F1c2UgdGhlIHRyYW5zaXRpb24gdG8gcGF1c2UsXG4gKiB3aGljaCBjb3VsZCBsZWFkIHRvIGEgbm9uLXJlc3BvbnNpdmUgVUkgaWYgdGhlIGhvb2sgaXMgc2xvdy5cbiAqL1xuZnVuY3Rpb24gcnVuQ2hhbmdlSG9va3Mocm91dGVzLCBzdGF0ZSwgbmV4dFN0YXRlLCBjYWxsYmFjaykge1xuICB2YXIgaG9va3MgPSBnZXRDaGFuZ2VIb29rcyhyb3V0ZXMpO1xuICByZXR1cm4gcnVuVHJhbnNpdGlvbkhvb2tzKGhvb2tzLmxlbmd0aCwgZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlLCBuZXh0KSB7XG4gICAgaG9va3NbaW5kZXhdKHN0YXRlLCBuZXh0U3RhdGUsIHJlcGxhY2UsIG5leHQpO1xuICB9LCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogUnVucyBhbGwgb25MZWF2ZSBob29rcyBpbiB0aGUgZ2l2ZW4gYXJyYXkgb2Ygcm91dGVzIGluIG9yZGVyLlxuICovXG5mdW5jdGlvbiBydW5MZWF2ZUhvb2tzKHJvdXRlcywgcHJldlN0YXRlKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSByb3V0ZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAocm91dGVzW2ldLm9uTGVhdmUpIHJvdXRlc1tpXS5vbkxlYXZlLmNhbGwocm91dGVzW2ldLCBwcmV2U3RhdGUpO1xuICB9XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvVHJhbnNpdGlvblV0aWxzLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmxvb3BBc3luYyA9IGxvb3BBc3luYztcbmV4cG9ydHMubWFwQXN5bmMgPSBtYXBBc3luYztcbmZ1bmN0aW9uIGxvb3BBc3luYyh0dXJucywgd29yaywgY2FsbGJhY2spIHtcbiAgdmFyIGN1cnJlbnRUdXJuID0gMCxcbiAgICAgIGlzRG9uZSA9IGZhbHNlO1xuICB2YXIgc3luYyA9IGZhbHNlLFxuICAgICAgaGFzTmV4dCA9IGZhbHNlLFxuICAgICAgZG9uZUFyZ3MgPSB2b2lkIDA7XG5cbiAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICBpc0RvbmUgPSB0cnVlO1xuICAgIGlmIChzeW5jKSB7XG4gICAgICAvLyBJdGVyYXRlIGluc3RlYWQgb2YgcmVjdXJzaW5nIGlmIHBvc3NpYmxlLlxuICAgICAgZG9uZUFyZ3MgPSBbXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgaWYgKGlzRG9uZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGhhc05leHQgPSB0cnVlO1xuICAgIGlmIChzeW5jKSB7XG4gICAgICAvLyBJdGVyYXRlIGluc3RlYWQgb2YgcmVjdXJzaW5nIGlmIHBvc3NpYmxlLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN5bmMgPSB0cnVlO1xuXG4gICAgd2hpbGUgKCFpc0RvbmUgJiYgY3VycmVudFR1cm4gPCB0dXJucyAmJiBoYXNOZXh0KSB7XG4gICAgICBoYXNOZXh0ID0gZmFsc2U7XG4gICAgICB3b3JrLmNhbGwodGhpcywgY3VycmVudFR1cm4rKywgbmV4dCwgZG9uZSk7XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuXG4gICAgaWYgKGlzRG9uZSkge1xuICAgICAgLy8gVGhpcyBtZWFucyB0aGUgbG9vcCBmaW5pc2hlZCBzeW5jaHJvbm91c2x5LlxuICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgZG9uZUFyZ3MpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50VHVybiA+PSB0dXJucyAmJiBoYXNOZXh0KSB7XG4gICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH1cblxuICBuZXh0KCk7XG59XG5cbmZ1bmN0aW9uIG1hcEFzeW5jKGFycmF5LCB3b3JrLCBjYWxsYmFjaykge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgdmFsdWVzID0gW107XG5cbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHZhbHVlcyk7XG5cbiAgdmFyIGlzRG9uZSA9IGZhbHNlLFxuICAgICAgZG9uZUNvdW50ID0gMDtcblxuICBmdW5jdGlvbiBkb25lKGluZGV4LCBlcnJvciwgdmFsdWUpIHtcbiAgICBpZiAoaXNEb25lKSByZXR1cm47XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcblxuICAgICAgaXNEb25lID0gKytkb25lQ291bnQgPT09IGxlbmd0aDtcblxuICAgICAgaWYgKGlzRG9uZSkgY2FsbGJhY2sobnVsbCwgdmFsdWVzKTtcbiAgICB9XG4gIH1cblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgIHdvcmsoaXRlbSwgaW5kZXgsIGZ1bmN0aW9uIChlcnJvciwgdmFsdWUpIHtcbiAgICAgIGRvbmUoaW5kZXgsIGVycm9yLCB2YWx1ZSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL0FzeW5jVXRpbHMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBpc0FjdGl2ZTtcblxudmFyIF9QYXR0ZXJuVXRpbHMgPSByZXF1aXJlKCcuL1BhdHRlcm5VdGlscycpO1xuXG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PSBiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYikgJiYgYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICByZXR1cm4gZGVlcEVxdWFsKGl0ZW0sIGJbaW5kZXhdKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmICgodHlwZW9mIGEgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGEpKSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHZhciBwIGluIGEpIHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIHApKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYVtwXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChiW3BdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCFkZWVwRXF1YWwoYVtwXSwgYltwXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBwYXRobmFtZSBtYXRjaGVzIHRoZSBzdXBwbGllZCBvbmUsIG5ldCBvZlxuICogbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2ggbm9ybWFsaXphdGlvbi4gVGhpcyBpcyBzdWZmaWNpZW50IGZvciBhblxuICogaW5kZXhPbmx5IHJvdXRlIG1hdGNoLlxuICovXG5mdW5jdGlvbiBwYXRoSXNBY3RpdmUocGF0aG5hbWUsIGN1cnJlbnRQYXRobmFtZSkge1xuICAvLyBOb3JtYWxpemUgbGVhZGluZyBzbGFzaCBmb3IgY29uc2lzdGVuY3kuIExlYWRpbmcgc2xhc2ggb24gcGF0aG5hbWUgaGFzXG4gIC8vIGFscmVhZHkgYmVlbiBub3JtYWxpemVkIGluIGlzQWN0aXZlLiBTZWUgY2F2ZWF0IHRoZXJlLlxuICBpZiAoY3VycmVudFBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgY3VycmVudFBhdGhuYW1lID0gJy8nICsgY3VycmVudFBhdGhuYW1lO1xuICB9XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBlbmQgb2YgYm90aCBwYXRoIG5hbWVzIHRvby4gTWF5YmUgYC9mb28vYCBzaG91bGRuJ3Qgc2hvd1xuICAvLyBgL2Zvb2AgYXMgYWN0aXZlLCBidXQgaW4gdGhpcyBjYXNlLCB3ZSB3b3VsZCBhbHJlYWR5IGhhdmUgZmFpbGVkIHRoZVxuICAvLyBtYXRjaC5cbiAgaWYgKHBhdGhuYW1lLmNoYXJBdChwYXRobmFtZS5sZW5ndGggLSAxKSAhPT0gJy8nKSB7XG4gICAgcGF0aG5hbWUgKz0gJy8nO1xuICB9XG4gIGlmIChjdXJyZW50UGF0aG5hbWUuY2hhckF0KGN1cnJlbnRQYXRobmFtZS5sZW5ndGggLSAxKSAhPT0gJy8nKSB7XG4gICAgY3VycmVudFBhdGhuYW1lICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiBjdXJyZW50UGF0aG5hbWUgPT09IHBhdGhuYW1lO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcGF0aG5hbWUgbWF0Y2hlcyB0aGUgYWN0aXZlIHJvdXRlcyBhbmQgcGFyYW1zLlxuICovXG5mdW5jdGlvbiByb3V0ZUlzQWN0aXZlKHBhdGhuYW1lLCByb3V0ZXMsIHBhcmFtcykge1xuICB2YXIgcmVtYWluaW5nUGF0aG5hbWUgPSBwYXRobmFtZSxcbiAgICAgIHBhcmFtTmFtZXMgPSBbXSxcbiAgICAgIHBhcmFtVmFsdWVzID0gW107XG5cbiAgLy8gZm9yLi4ub2Ygd291bGQgd29yayBoZXJlIGJ1dCBpdCdzIHByb2JhYmx5IHNsb3dlciBwb3N0LXRyYW5zcGlsYXRpb24uXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSByb3V0ZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgcm91dGUgPSByb3V0ZXNbaV07XG4gICAgdmFyIHBhdHRlcm4gPSByb3V0ZS5wYXRoIHx8ICcnO1xuXG4gICAgaWYgKHBhdHRlcm4uY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICBwYXJhbU5hbWVzID0gW107XG4gICAgICBwYXJhbVZhbHVlcyA9IFtdO1xuICAgIH1cblxuICAgIGlmIChyZW1haW5pbmdQYXRobmFtZSAhPT0gbnVsbCAmJiBwYXR0ZXJuKSB7XG4gICAgICB2YXIgbWF0Y2hlZCA9ICgwLCBfUGF0dGVyblV0aWxzLm1hdGNoUGF0dGVybikocGF0dGVybiwgcmVtYWluaW5nUGF0aG5hbWUpO1xuICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgcmVtYWluaW5nUGF0aG5hbWUgPSBtYXRjaGVkLnJlbWFpbmluZ1BhdGhuYW1lO1xuICAgICAgICBwYXJhbU5hbWVzID0gW10uY29uY2F0KHBhcmFtTmFtZXMsIG1hdGNoZWQucGFyYW1OYW1lcyk7XG4gICAgICAgIHBhcmFtVmFsdWVzID0gW10uY29uY2F0KHBhcmFtVmFsdWVzLCBtYXRjaGVkLnBhcmFtVmFsdWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlbWFpbmluZ1BhdGhuYW1lID09PSAnJykge1xuICAgICAgICAvLyBXZSBoYXZlIGFuIGV4YWN0IG1hdGNoIG9uIHRoZSByb3V0ZS4gSnVzdCBjaGVjayB0aGF0IGFsbCB0aGUgcGFyYW1zXG4gICAgICAgIC8vIG1hdGNoLlxuICAgICAgICAvLyBGSVhNRTogVGhpcyBkb2Vzbid0IHdvcmsgb24gcmVwZWF0ZWQgcGFyYW1zLlxuICAgICAgICByZXR1cm4gcGFyYW1OYW1lcy5ldmVyeShmdW5jdGlvbiAocGFyYW1OYW1lLCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcocGFyYW1WYWx1ZXNbaW5kZXhdKSA9PT0gU3RyaW5nKHBhcmFtc1twYXJhbU5hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbGwga2V5L3ZhbHVlIHBhaXJzIGluIHRoZSBnaXZlbiBxdWVyeSBhcmVcbiAqIGN1cnJlbnRseSBhY3RpdmUuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5SXNBY3RpdmUocXVlcnksIGFjdGl2ZVF1ZXJ5KSB7XG4gIGlmIChhY3RpdmVRdWVyeSA9PSBudWxsKSByZXR1cm4gcXVlcnkgPT0gbnVsbDtcblxuICBpZiAocXVlcnkgPT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgcmV0dXJuIGRlZXBFcXVhbChxdWVyeSwgYWN0aXZlUXVlcnkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhIDxMaW5rPiB0byB0aGUgZ2l2ZW4gcGF0aG5hbWUvcXVlcnkgY29tYmluYXRpb24gaXNcbiAqIGN1cnJlbnRseSBhY3RpdmUuXG4gKi9cbmZ1bmN0aW9uIGlzQWN0aXZlKF9yZWYsIGluZGV4T25seSwgY3VycmVudExvY2F0aW9uLCByb3V0ZXMsIHBhcmFtcykge1xuICB2YXIgcGF0aG5hbWUgPSBfcmVmLnBhdGhuYW1lO1xuICB2YXIgcXVlcnkgPSBfcmVmLnF1ZXJ5O1xuXG4gIGlmIChjdXJyZW50TG9jYXRpb24gPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIFRPRE86IFRoaXMgaXMgYSBiaXQgdWdseS4gSXQga2VlcHMgYXJvdW5kIHN1cHBvcnQgZm9yIHRyZWF0aW5nIHBhdGhuYW1lc1xuICAvLyB3aXRob3V0IHByZWNlZGluZyBzbGFzaGVzIGFzIGFic29sdXRlIHBhdGhzLCBidXQgcG9zc2libHkgYWxzbyB3b3Jrc1xuICAvLyBhcm91bmQgdGhlIHNhbWUgcXVpcmtzIHdpdGggYmFzZW5hbWVzIGFzIGluIG1hdGNoUm91dGVzLlxuICBpZiAocGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9XG5cbiAgaWYgKCFwYXRoSXNBY3RpdmUocGF0aG5hbWUsIGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSkpIHtcbiAgICAvLyBUaGUgcGF0aCBjaGVjayBpcyBuZWNlc3NhcnkgYW5kIHN1ZmZpY2llbnQgZm9yIGluZGV4T25seSwgYnV0IG90aGVyd2lzZVxuICAgIC8vIHdlIHN0aWxsIG5lZWQgdG8gY2hlY2sgdGhlIHJvdXRlcy5cbiAgICBpZiAoaW5kZXhPbmx5IHx8ICFyb3V0ZUlzQWN0aXZlKHBhdGhuYW1lLCByb3V0ZXMsIHBhcmFtcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcXVlcnlJc0FjdGl2ZShxdWVyeSwgY3VycmVudExvY2F0aW9uLnF1ZXJ5KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2lzQWN0aXZlLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX0FzeW5jVXRpbHMgPSByZXF1aXJlKCcuL0FzeW5jVXRpbHMnKTtcblxudmFyIF9tYWtlU3RhdGVXaXRoTG9jYXRpb24gPSByZXF1aXJlKCcuL21ha2VTdGF0ZVdpdGhMb2NhdGlvbicpO1xuXG52YXIgX21ha2VTdGF0ZVdpdGhMb2NhdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYWtlU3RhdGVXaXRoTG9jYXRpb24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnRzRm9yUm91dGUobmV4dFN0YXRlLCByb3V0ZSwgY2FsbGJhY2spIHtcbiAgaWYgKHJvdXRlLmNvbXBvbmVudCB8fCByb3V0ZS5jb21wb25lbnRzKSB7XG4gICAgY2FsbGJhY2sobnVsbCwgcm91dGUuY29tcG9uZW50IHx8IHJvdXRlLmNvbXBvbmVudHMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBnZXRDb21wb25lbnQgPSByb3V0ZS5nZXRDb21wb25lbnQgfHwgcm91dGUuZ2V0Q29tcG9uZW50cztcbiAgaWYgKCFnZXRDb21wb25lbnQpIHtcbiAgICBjYWxsYmFjaygpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBsb2NhdGlvbiA9IG5leHRTdGF0ZS5sb2NhdGlvbjtcblxuICB2YXIgbmV4dFN0YXRlV2l0aExvY2F0aW9uID0gKDAsIF9tYWtlU3RhdGVXaXRoTG9jYXRpb24yLmRlZmF1bHQpKG5leHRTdGF0ZSwgbG9jYXRpb24pO1xuXG4gIGdldENvbXBvbmVudC5jYWxsKHJvdXRlLCBuZXh0U3RhdGVXaXRoTG9jYXRpb24sIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBmZXRjaGVzIGFsbCBjb21wb25lbnRzIG5lZWRlZCBmb3IgdGhlIGdpdmVuIHJvdXRlclxuICogc3RhdGUgYW5kIGNhbGxzIGNhbGxiYWNrKGVycm9yLCBjb21wb25lbnRzKSB3aGVuIGZpbmlzaGVkLlxuICpcbiAqIE5vdGU6IFRoaXMgb3BlcmF0aW9uIG1heSBmaW5pc2ggc3luY2hyb25vdXNseSBpZiBubyByb3V0ZXMgaGF2ZSBhblxuICogYXN5bmNocm9ub3VzIGdldENvbXBvbmVudHMgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnRzKG5leHRTdGF0ZSwgY2FsbGJhY2spIHtcbiAgKDAsIF9Bc3luY1V0aWxzLm1hcEFzeW5jKShuZXh0U3RhdGUucm91dGVzLCBmdW5jdGlvbiAocm91dGUsIGluZGV4LCBjYWxsYmFjaykge1xuICAgIGdldENvbXBvbmVudHNGb3JSb3V0ZShuZXh0U3RhdGUsIHJvdXRlLCBjYWxsYmFjayk7XG4gIH0sIGNhbGxiYWNrKTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0Q29tcG9uZW50cztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2dldENvbXBvbmVudHMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG1ha2VTdGF0ZVdpdGhMb2NhdGlvbjtcblxudmFyIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzJyk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIG1ha2VTdGF0ZVdpdGhMb2NhdGlvbihzdGF0ZSwgbG9jYXRpb24pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMuY2FuVXNlTWVtYnJhbmUpIHtcbiAgICB2YXIgc3RhdGVXaXRoTG9jYXRpb24gPSBfZXh0ZW5kcyh7fSwgc3RhdGUpO1xuXG4gICAgLy8gSSBkb24ndCB1c2UgZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyBoZXJlIGJlY2F1c2UgSSB3YW50IHRvIGtlZXAgdGhlXG4gICAgLy8gc2FtZSBjb2RlIHBhdGggYmV0d2VlbiBkZXZlbG9wbWVudCBhbmQgcHJvZHVjdGlvbiwgaW4gdGhhdCB3ZSBqdXN0XG4gICAgLy8gYXNzaWduIGV4dHJhIHByb3BlcnRpZXMgdG8gdGhlIGNvcHkgb2YgdGhlIHN0YXRlIG9iamVjdCBpbiBib3RoIGNhc2VzLlxuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AocHJvcCkge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobG9jYXRpb24sIHByb3ApKSB7XG4gICAgICAgIHJldHVybiAnY29udGludWUnO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3RhdGVXaXRoTG9jYXRpb24sIHByb3AsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdBY2Nlc3NpbmcgbG9jYXRpb24gcHJvcGVydGllcyBkaXJlY3RseSBmcm9tIHRoZSBmaXJzdCBhcmd1bWVudCB0byBgZ2V0Q29tcG9uZW50YCwgYGdldENvbXBvbmVudHNgLCBgZ2V0Q2hpbGRSb3V0ZXNgLCBhbmQgYGdldEluZGV4Um91dGVgIGlzIGRlcHJlY2F0ZWQuIFRoYXQgYXJndW1lbnQgaXMgbm93IHRoZSByb3V0ZXIgc3RhdGUgKGBuZXh0U3RhdGVgIG9yIGBwYXJ0aWFsTmV4dFN0YXRlYCkgcmF0aGVyIHRoYW4gdGhlIGxvY2F0aW9uLiBUbyBhY2Nlc3MgdGhlIGxvY2F0aW9uLCB1c2UgYG5leHRTdGF0ZS5sb2NhdGlvbmAgb3IgYHBhcnRpYWxOZXh0U3RhdGUubG9jYXRpb25gLicpIDogdm9pZCAwO1xuICAgICAgICAgIHJldHVybiBsb2NhdGlvbltwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gbG9jYXRpb24pIHtcbiAgICAgIHZhciBfcmV0ID0gX2xvb3AocHJvcCk7XG5cbiAgICAgIGlmIChfcmV0ID09PSAnY29udGludWUnKSBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGVXaXRoTG9jYXRpb247XG4gIH1cblxuICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCBsb2NhdGlvbik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9tYWtlU3RhdGVXaXRoTG9jYXRpb24uanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBtYXRjaFJvdXRlcztcblxudmFyIF9Bc3luY1V0aWxzID0gcmVxdWlyZSgnLi9Bc3luY1V0aWxzJyk7XG5cbnZhciBfbWFrZVN0YXRlV2l0aExvY2F0aW9uID0gcmVxdWlyZSgnLi9tYWtlU3RhdGVXaXRoTG9jYXRpb24nKTtcblxudmFyIF9tYWtlU3RhdGVXaXRoTG9jYXRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWFrZVN0YXRlV2l0aExvY2F0aW9uKTtcblxudmFyIF9QYXR0ZXJuVXRpbHMgPSByZXF1aXJlKCcuL1BhdHRlcm5VdGlscycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZ2V0Q2hpbGRSb3V0ZXMocm91dGUsIGxvY2F0aW9uLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgY2FsbGJhY2spIHtcbiAgaWYgKHJvdXRlLmNoaWxkUm91dGVzKSB7XG4gICAgcmV0dXJuIFtudWxsLCByb3V0ZS5jaGlsZFJvdXRlc107XG4gIH1cbiAgaWYgKCFyb3V0ZS5nZXRDaGlsZFJvdXRlcykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBzeW5jID0gdHJ1ZSxcbiAgICAgIHJlc3VsdCA9IHZvaWQgMDtcblxuICB2YXIgcGFydGlhbE5leHRTdGF0ZSA9IHtcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgcGFyYW1zOiBjcmVhdGVQYXJhbXMocGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMpXG4gIH07XG5cbiAgdmFyIHBhcnRpYWxOZXh0U3RhdGVXaXRoTG9jYXRpb24gPSAoMCwgX21ha2VTdGF0ZVdpdGhMb2NhdGlvbjIuZGVmYXVsdCkocGFydGlhbE5leHRTdGF0ZSwgbG9jYXRpb24pO1xuXG4gIHJvdXRlLmdldENoaWxkUm91dGVzKHBhcnRpYWxOZXh0U3RhdGVXaXRoTG9jYXRpb24sIGZ1bmN0aW9uIChlcnJvciwgY2hpbGRSb3V0ZXMpIHtcbiAgICBjaGlsZFJvdXRlcyA9ICFlcnJvciAmJiAoMCwgX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVzKShjaGlsZFJvdXRlcyk7XG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHJlc3VsdCA9IFtlcnJvciwgY2hpbGRSb3V0ZXNdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKGVycm9yLCBjaGlsZFJvdXRlcyk7XG4gIH0pO1xuXG4gIHN5bmMgPSBmYWxzZTtcbiAgcmV0dXJuIHJlc3VsdDsgLy8gTWlnaHQgYmUgdW5kZWZpbmVkLlxufVxuXG5mdW5jdGlvbiBnZXRJbmRleFJvdXRlKHJvdXRlLCBsb2NhdGlvbiwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIGNhbGxiYWNrKSB7XG4gIGlmIChyb3V0ZS5pbmRleFJvdXRlKSB7XG4gICAgY2FsbGJhY2sobnVsbCwgcm91dGUuaW5kZXhSb3V0ZSk7XG4gIH0gZWxzZSBpZiAocm91dGUuZ2V0SW5kZXhSb3V0ZSkge1xuICAgIHZhciBwYXJ0aWFsTmV4dFN0YXRlID0ge1xuICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgcGFyYW1zOiBjcmVhdGVQYXJhbXMocGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMpXG4gICAgfTtcblxuICAgIHZhciBwYXJ0aWFsTmV4dFN0YXRlV2l0aExvY2F0aW9uID0gKDAsIF9tYWtlU3RhdGVXaXRoTG9jYXRpb24yLmRlZmF1bHQpKHBhcnRpYWxOZXh0U3RhdGUsIGxvY2F0aW9uKTtcblxuICAgIHJvdXRlLmdldEluZGV4Um91dGUocGFydGlhbE5leHRTdGF0ZVdpdGhMb2NhdGlvbiwgZnVuY3Rpb24gKGVycm9yLCBpbmRleFJvdXRlKSB7XG4gICAgICBjYWxsYmFjayhlcnJvciwgIWVycm9yICYmICgwLCBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZXMpKGluZGV4Um91dGUpWzBdKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChyb3V0ZS5jaGlsZFJvdXRlcykge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGF0aGxlc3MgPSByb3V0ZS5jaGlsZFJvdXRlcy5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkUm91dGUpIHtcbiAgICAgICAgcmV0dXJuICFjaGlsZFJvdXRlLnBhdGg7XG4gICAgICB9KTtcblxuICAgICAgKDAsIF9Bc3luY1V0aWxzLmxvb3BBc3luYykocGF0aGxlc3MubGVuZ3RoLCBmdW5jdGlvbiAoaW5kZXgsIG5leHQsIGRvbmUpIHtcbiAgICAgICAgZ2V0SW5kZXhSb3V0ZShwYXRobGVzc1tpbmRleF0sIGxvY2F0aW9uLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgZnVuY3Rpb24gKGVycm9yLCBpbmRleFJvdXRlKSB7XG4gICAgICAgICAgaWYgKGVycm9yIHx8IGluZGV4Um91dGUpIHtcbiAgICAgICAgICAgIHZhciByb3V0ZXMgPSBbcGF0aGxlc3NbaW5kZXhdXS5jb25jYXQoQXJyYXkuaXNBcnJheShpbmRleFJvdXRlKSA/IGluZGV4Um91dGUgOiBbaW5kZXhSb3V0ZV0pO1xuICAgICAgICAgICAgZG9uZShlcnJvciwgcm91dGVzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LCBmdW5jdGlvbiAoZXJyLCByb3V0ZXMpIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgcm91dGVzKTtcbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ25QYXJhbXMocGFyYW1zLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcykge1xuICByZXR1cm4gcGFyYW1OYW1lcy5yZWR1Y2UoZnVuY3Rpb24gKHBhcmFtcywgcGFyYW1OYW1lLCBpbmRleCkge1xuICAgIHZhciBwYXJhbVZhbHVlID0gcGFyYW1WYWx1ZXMgJiYgcGFyYW1WYWx1ZXNbaW5kZXhdO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1zW3BhcmFtTmFtZV0pKSB7XG4gICAgICBwYXJhbXNbcGFyYW1OYW1lXS5wdXNoKHBhcmFtVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocGFyYW1OYW1lIGluIHBhcmFtcykge1xuICAgICAgcGFyYW1zW3BhcmFtTmFtZV0gPSBbcGFyYW1zW3BhcmFtTmFtZV0sIHBhcmFtVmFsdWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJhbXNbcGFyYW1OYW1lXSA9IHBhcmFtVmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfSwgcGFyYW1zKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGFyYW1zKHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzKSB7XG4gIHJldHVybiBhc3NpZ25QYXJhbXMoe30sIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hSb3V0ZURlZXAocm91dGUsIGxvY2F0aW9uLCByZW1haW5pbmdQYXRobmFtZSwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIGNhbGxiYWNrKSB7XG4gIHZhciBwYXR0ZXJuID0gcm91dGUucGF0aCB8fCAnJztcblxuICBpZiAocGF0dGVybi5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgcGFyYW1OYW1lcyA9IFtdO1xuICAgIHBhcmFtVmFsdWVzID0gW107XG4gIH1cblxuICAvLyBPbmx5IHRyeSB0byBtYXRjaCB0aGUgcGF0aCBpZiB0aGUgcm91dGUgYWN0dWFsbHkgaGFzIGEgcGF0dGVybiwgYW5kIGlmXG4gIC8vIHdlJ3JlIG5vdCBqdXN0IHNlYXJjaGluZyBmb3IgcG90ZW50aWFsIG5lc3RlZCBhYnNvbHV0ZSBwYXRocy5cbiAgaWYgKHJlbWFpbmluZ1BhdGhuYW1lICE9PSBudWxsICYmIHBhdHRlcm4pIHtcbiAgICB0cnkge1xuICAgICAgdmFyIG1hdGNoZWQgPSAoMCwgX1BhdHRlcm5VdGlscy5tYXRjaFBhdHRlcm4pKHBhdHRlcm4sIHJlbWFpbmluZ1BhdGhuYW1lKTtcbiAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gbWF0Y2hlZC5yZW1haW5pbmdQYXRobmFtZTtcbiAgICAgICAgcGFyYW1OYW1lcyA9IFtdLmNvbmNhdChwYXJhbU5hbWVzLCBtYXRjaGVkLnBhcmFtTmFtZXMpO1xuICAgICAgICBwYXJhbVZhbHVlcyA9IFtdLmNvbmNhdChwYXJhbVZhbHVlcywgbWF0Y2hlZC5wYXJhbVZhbHVlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1haW5pbmdQYXRobmFtZSA9IG51bGw7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9XG5cbiAgICAvLyBCeSBhc3N1bXB0aW9uLCBwYXR0ZXJuIGlzIG5vbi1lbXB0eSBoZXJlLCB3aGljaCBpcyB0aGUgcHJlcmVxdWlzaXRlIGZvclxuICAgIC8vIGFjdHVhbGx5IHRlcm1pbmF0aW5nIGEgbWF0Y2guXG4gICAgaWYgKHJlbWFpbmluZ1BhdGhuYW1lID09PSAnJykge1xuICAgICAgdmFyIF9yZXQyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB7XG4gICAgICAgICAgcm91dGVzOiBbcm91dGVdLFxuICAgICAgICAgIHBhcmFtczogY3JlYXRlUGFyYW1zKHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzKVxuICAgICAgICB9O1xuXG4gICAgICAgIGdldEluZGV4Um91dGUocm91dGUsIGxvY2F0aW9uLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgZnVuY3Rpb24gKGVycm9yLCBpbmRleFJvdXRlKSB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGluZGV4Um91dGUpKSB7XG4gICAgICAgICAgICAgIHZhciBfbWF0Y2gkcm91dGVzO1xuXG4gICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGluZGV4Um91dGUuZXZlcnkoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFyb3V0ZS5wYXRoO1xuICAgICAgICAgICAgICB9KSwgJ0luZGV4IHJvdXRlcyBzaG91bGQgbm90IGhhdmUgcGF0aHMnKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgKF9tYXRjaCRyb3V0ZXMgPSBtYXRjaC5yb3V0ZXMpLnB1c2guYXBwbHkoX21hdGNoJHJvdXRlcywgaW5kZXhSb3V0ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4Um91dGUpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoIWluZGV4Um91dGUucGF0aCwgJ0luZGV4IHJvdXRlcyBzaG91bGQgbm90IGhhdmUgcGF0aHMnKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgbWF0Y2gucm91dGVzLnB1c2goaW5kZXhSb3V0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1hdGNoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdjogdm9pZCAwXG4gICAgICAgIH07XG4gICAgICB9KCk7XG5cbiAgICAgIGlmICgodHlwZW9mIF9yZXQyID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihfcmV0MikpID09PSBcIm9iamVjdFwiKSByZXR1cm4gX3JldDIudjtcbiAgICB9XG4gIH1cblxuICBpZiAocmVtYWluaW5nUGF0aG5hbWUgIT0gbnVsbCB8fCByb3V0ZS5jaGlsZFJvdXRlcykge1xuICAgIC8vIEVpdGhlciBhKSB0aGlzIHJvdXRlIG1hdGNoZWQgYXQgbGVhc3Qgc29tZSBvZiB0aGUgcGF0aCBvciBiKVxuICAgIC8vIHdlIGRvbid0IGhhdmUgdG8gbG9hZCB0aGlzIHJvdXRlJ3MgY2hpbGRyZW4gYXN5bmNocm9ub3VzbHkuIEluXG4gICAgLy8gZWl0aGVyIGNhc2UgY29udGludWUgY2hlY2tpbmcgZm9yIG1hdGNoZXMgaW4gdGhlIHN1YnRyZWUuXG4gICAgdmFyIG9uQ2hpbGRSb3V0ZXMgPSBmdW5jdGlvbiBvbkNoaWxkUm91dGVzKGVycm9yLCBjaGlsZFJvdXRlcykge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRSb3V0ZXMpIHtcbiAgICAgICAgLy8gQ2hlY2sgdGhlIGNoaWxkIHJvdXRlcyB0byBzZWUgaWYgYW55IG9mIHRoZW0gbWF0Y2guXG4gICAgICAgIG1hdGNoUm91dGVzKGNoaWxkUm91dGVzLCBsb2NhdGlvbiwgZnVuY3Rpb24gKGVycm9yLCBtYXRjaCkge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIEEgY2hpbGQgcm91dGUgbWF0Y2hlZCEgQXVnbWVudCB0aGUgbWF0Y2ggYW5kIHBhc3MgaXQgdXAgdGhlIHN0YWNrLlxuICAgICAgICAgICAgbWF0Y2gucm91dGVzLnVuc2hpZnQocm91dGUpO1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWF0Y2gpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgcmVtYWluaW5nUGF0aG5hbWUsIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZXN1bHQgPSBnZXRDaGlsZFJvdXRlcyhyb3V0ZSwgbG9jYXRpb24sIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzLCBvbkNoaWxkUm91dGVzKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBvbkNoaWxkUm91dGVzLmFwcGx5KHVuZGVmaW5lZCwgcmVzdWx0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IG1hdGNoZXMgdGhlIGdpdmVuIGxvY2F0aW9uIHRvIGEgc2V0IG9mIHJvdXRlcyBhbmQgY2FsbHNcbiAqIGNhbGxiYWNrKGVycm9yLCBzdGF0ZSkgd2hlbiBmaW5pc2hlZC4gVGhlIHN0YXRlIG9iamVjdCB3aWxsIGhhdmUgdGhlXG4gKiBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAtIHJvdXRlcyAgICAgICBBbiBhcnJheSBvZiByb3V0ZXMgdGhhdCBtYXRjaGVkLCBpbiBoaWVyYXJjaGljYWwgb3JkZXJcbiAqIC0gcGFyYW1zICAgICAgIEFuIG9iamVjdCBvZiBVUkwgcGFyYW1ldGVyc1xuICpcbiAqIE5vdGU6IFRoaXMgb3BlcmF0aW9uIG1heSBmaW5pc2ggc3luY2hyb25vdXNseSBpZiBubyByb3V0ZXMgaGF2ZSBhblxuICogYXN5bmNocm9ub3VzIGdldENoaWxkUm91dGVzIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hSb3V0ZXMocm91dGVzLCBsb2NhdGlvbiwgY2FsbGJhY2ssIHJlbWFpbmluZ1BhdGhuYW1lKSB7XG4gIHZhciBwYXJhbU5hbWVzID0gYXJndW1lbnRzLmxlbmd0aCA8PSA0IHx8IGFyZ3VtZW50c1s0XSA9PT0gdW5kZWZpbmVkID8gW10gOiBhcmd1bWVudHNbNF07XG4gIHZhciBwYXJhbVZhbHVlcyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gNSB8fCBhcmd1bWVudHNbNV0gPT09IHVuZGVmaW5lZCA/IFtdIDogYXJndW1lbnRzWzVdO1xuXG4gIGlmIChyZW1haW5pbmdQYXRobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gVE9ETzogVGhpcyBpcyBhIGxpdHRsZSBiaXQgdWdseSwgYnV0IGl0IHdvcmtzIGFyb3VuZCBhIHF1aXJrIGluIGhpc3RvcnlcbiAgICAvLyB0aGF0IHN0cmlwcyB0aGUgbGVhZGluZyBzbGFzaCBmcm9tIHBhdGhuYW1lcyB3aGVuIHVzaW5nIGJhc2VuYW1lcyB3aXRoXG4gICAgLy8gdHJhaWxpbmcgc2xhc2hlcy5cbiAgICBpZiAobG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgIGxvY2F0aW9uID0gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7XG4gICAgICAgIHBhdGhuYW1lOiAnLycgKyBsb2NhdGlvbi5wYXRobmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gIH1cblxuICAoMCwgX0FzeW5jVXRpbHMubG9vcEFzeW5jKShyb3V0ZXMubGVuZ3RoLCBmdW5jdGlvbiAoaW5kZXgsIG5leHQsIGRvbmUpIHtcbiAgICBtYXRjaFJvdXRlRGVlcChyb3V0ZXNbaW5kZXhdLCBsb2NhdGlvbiwgcmVtYWluaW5nUGF0aG5hbWUsIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzLCBmdW5jdGlvbiAoZXJyb3IsIG1hdGNoKSB7XG4gICAgICBpZiAoZXJyb3IgfHwgbWF0Y2gpIHtcbiAgICAgICAgZG9uZShlcnJvciwgbWF0Y2gpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBjYWxsYmFjayk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9tYXRjaFJvdXRlcy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzJyk7XG5cbnZhciBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzKTtcblxudmFyIF9nZXRSb3V0ZVBhcmFtcyA9IHJlcXVpcmUoJy4vZ2V0Um91dGVQYXJhbXMnKTtcblxudmFyIF9nZXRSb3V0ZVBhcmFtczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRSb3V0ZVBhcmFtcyk7XG5cbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgX1JlYWN0JFByb3BUeXBlcyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXM7XG52YXIgYXJyYXkgPSBfUmVhY3QkUHJvcFR5cGVzLmFycmF5O1xudmFyIGZ1bmMgPSBfUmVhY3QkUHJvcFR5cGVzLmZ1bmM7XG52YXIgb2JqZWN0ID0gX1JlYWN0JFByb3BUeXBlcy5vYmplY3Q7XG5cbi8qKlxuICogQSA8Um91dGVyQ29udGV4dD4gcmVuZGVycyB0aGUgY29tcG9uZW50IHRyZWUgZm9yIGEgZ2l2ZW4gcm91dGVyIHN0YXRlXG4gKiBhbmQgc2V0cyB0aGUgaGlzdG9yeSBvYmplY3QgYW5kIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIGNvbnRleHQuXG4gKi9cblxudmFyIFJvdXRlckNvbnRleHQgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JvdXRlckNvbnRleHQnLFxuXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgaGlzdG9yeTogb2JqZWN0LFxuICAgIHJvdXRlcjogb2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgbG9jYXRpb246IG9iamVjdC5pc1JlcXVpcmVkLFxuICAgIHJvdXRlczogYXJyYXkuaXNSZXF1aXJlZCxcbiAgICBwYXJhbXM6IG9iamVjdC5pc1JlcXVpcmVkLFxuICAgIGNvbXBvbmVudHM6IGFycmF5LmlzUmVxdWlyZWQsXG4gICAgY3JlYXRlRWxlbWVudDogZnVuYy5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZUVsZW1lbnQ6IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50XG4gICAgfTtcbiAgfSxcblxuXG4gIGNoaWxkQ29udGV4dFR5cGVzOiB7XG4gICAgaGlzdG9yeTogb2JqZWN0LFxuICAgIGxvY2F0aW9uOiBvYmplY3QuaXNSZXF1aXJlZCxcbiAgICByb3V0ZXI6IG9iamVjdC5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgZ2V0Q2hpbGRDb250ZXh0OiBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHJvdXRlciA9IF9wcm9wcy5yb3V0ZXI7XG4gICAgdmFyIGhpc3RvcnkgPSBfcHJvcHMuaGlzdG9yeTtcbiAgICB2YXIgbG9jYXRpb24gPSBfcHJvcHMubG9jYXRpb247XG5cbiAgICBpZiAoIXJvdXRlcikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdgPFJvdXRlckNvbnRleHQ+YCBleHBlY3RzIGEgYHJvdXRlcmAgcmF0aGVyIHRoYW4gYSBgaGlzdG9yeWAnKSA6IHZvaWQgMDtcblxuICAgICAgcm91dGVyID0gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICAgICAgc2V0Um91dGVMZWF2ZUhvb2s6IGhpc3RvcnkubGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlXG4gICAgICB9KTtcbiAgICAgIGRlbGV0ZSByb3V0ZXIubGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBsb2NhdGlvbiA9ICgwLCBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllczIuZGVmYXVsdCkobG9jYXRpb24sICdgY29udGV4dC5sb2NhdGlvbmAgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBhIHJvdXRlIGNvbXBvbmVudFxcJ3MgYHByb3BzLmxvY2F0aW9uYCBpbnN0ZWFkLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItYWNjZXNzaW5nbG9jYXRpb24nKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBoaXN0b3J5OiBoaXN0b3J5LCBsb2NhdGlvbjogbG9jYXRpb24sIHJvdXRlcjogcm91dGVyIH07XG4gIH0sXG4gIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBwcm9wcykge1xuICAgIHJldHVybiBjb21wb25lbnQgPT0gbnVsbCA/IG51bGwgOiB0aGlzLnByb3BzLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBwcm9wcyk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgX3Byb3BzMiA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGhpc3RvcnkgPSBfcHJvcHMyLmhpc3Rvcnk7XG4gICAgdmFyIGxvY2F0aW9uID0gX3Byb3BzMi5sb2NhdGlvbjtcbiAgICB2YXIgcm91dGVzID0gX3Byb3BzMi5yb3V0ZXM7XG4gICAgdmFyIHBhcmFtcyA9IF9wcm9wczIucGFyYW1zO1xuICAgIHZhciBjb21wb25lbnRzID0gX3Byb3BzMi5jb21wb25lbnRzO1xuXG4gICAgdmFyIGVsZW1lbnQgPSBudWxsO1xuXG4gICAgaWYgKGNvbXBvbmVudHMpIHtcbiAgICAgIGVsZW1lbnQgPSBjb21wb25lbnRzLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChlbGVtZW50LCBjb21wb25lbnRzLCBpbmRleCkge1xuICAgICAgICBpZiAoY29tcG9uZW50cyA9PSBudWxsKSByZXR1cm4gZWxlbWVudDsgLy8gRG9uJ3QgY3JlYXRlIG5ldyBjaGlsZHJlbjsgdXNlIHRoZSBncmFuZGNoaWxkcmVuLlxuXG4gICAgICAgIHZhciByb3V0ZSA9IHJvdXRlc1tpbmRleF07XG4gICAgICAgIHZhciByb3V0ZVBhcmFtcyA9ICgwLCBfZ2V0Um91dGVQYXJhbXMyLmRlZmF1bHQpKHJvdXRlLCBwYXJhbXMpO1xuICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgaGlzdG9yeTogaGlzdG9yeSxcbiAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgcm91dGU6IHJvdXRlLFxuICAgICAgICAgIHJvdXRlUGFyYW1zOiByb3V0ZVBhcmFtcyxcbiAgICAgICAgICByb3V0ZXM6IHJvdXRlc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICgoMCwgX1JvdXRlVXRpbHMuaXNSZWFjdENoaWxkcmVuKShlbGVtZW50KSkge1xuICAgICAgICAgIHByb3BzLmNoaWxkcmVuID0gZWxlbWVudDtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVsZW1lbnQsIHByb3ApKSBwcm9wc1twcm9wXSA9IGVsZW1lbnRbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCh0eXBlb2YgY29tcG9uZW50cyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY29tcG9uZW50cykpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHZhciBlbGVtZW50cyA9IHt9O1xuXG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIGNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29tcG9uZW50cywga2V5KSkge1xuICAgICAgICAgICAgICAvLyBQYXNzIHRocm91Z2ggdGhlIGtleSBhcyBhIHByb3AgdG8gY3JlYXRlRWxlbWVudCB0byBhbGxvd1xuICAgICAgICAgICAgICAvLyBjdXN0b20gY3JlYXRlRWxlbWVudCBmdW5jdGlvbnMgdG8ga25vdyB3aGljaCBuYW1lZCBjb21wb25lbnRcbiAgICAgICAgICAgICAgLy8gdGhleSdyZSByZW5kZXJpbmcsIGZvciBlLmcuIG1hdGNoaW5nIHVwIHRvIGZldGNoZWQgZGF0YS5cbiAgICAgICAgICAgICAgZWxlbWVudHNba2V5XSA9IF90aGlzLmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50c1trZXldLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXkgfSwgcHJvcHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3RoaXMuY3JlYXRlRWxlbWVudChjb21wb25lbnRzLCBwcm9wcyk7XG4gICAgICB9LCBlbGVtZW50KTtcbiAgICB9XG5cbiAgICAhKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gZmFsc2UgfHwgX3JlYWN0Mi5kZWZhdWx0LmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdUaGUgcm9vdCByb3V0ZSBtdXN0IHJlbmRlciBhIHNpbmdsZSBlbGVtZW50JykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSb3V0ZXJDb250ZXh0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGVyQ29udGV4dC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9QYXR0ZXJuVXRpbHMgPSByZXF1aXJlKCcuL1BhdHRlcm5VdGlscycpO1xuXG4vKipcbiAqIEV4dHJhY3RzIGFuIG9iamVjdCBvZiBwYXJhbXMgdGhlIGdpdmVuIHJvdXRlIGNhcmVzIGFib3V0IGZyb21cbiAqIHRoZSBnaXZlbiBwYXJhbXMgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBnZXRSb3V0ZVBhcmFtcyhyb3V0ZSwgcGFyYW1zKSB7XG4gIHZhciByb3V0ZVBhcmFtcyA9IHt9O1xuXG4gIGlmICghcm91dGUucGF0aCkgcmV0dXJuIHJvdXRlUGFyYW1zO1xuXG4gICgwLCBfUGF0dGVyblV0aWxzLmdldFBhcmFtTmFtZXMpKHJvdXRlLnBhdGgpLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtcywgcCkpIHtcbiAgICAgIHJvdXRlUGFyYW1zW3BdID0gcGFyYW1zW3BdO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJvdXRlUGFyYW1zO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBnZXRSb3V0ZVBhcmFtcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2dldFJvdXRlUGFyYW1zLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLmNyZWF0ZVJvdXRlck9iamVjdCA9IGNyZWF0ZVJvdXRlck9iamVjdDtcbmV4cG9ydHMuY3JlYXRlUm91dGluZ0hpc3RvcnkgPSBjcmVhdGVSb3V0aW5nSGlzdG9yeTtcblxudmFyIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzJyk7XG5cbnZhciBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY3JlYXRlUm91dGVyT2JqZWN0KGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgIHNldFJvdXRlTGVhdmVIb29rOiB0cmFuc2l0aW9uTWFuYWdlci5saXN0ZW5CZWZvcmVMZWF2aW5nUm91dGUsXG4gICAgaXNBY3RpdmU6IHRyYW5zaXRpb25NYW5hZ2VyLmlzQWN0aXZlXG4gIH0pO1xufVxuXG4vLyBkZXByZWNhdGVkXG5mdW5jdGlvbiBjcmVhdGVSb3V0aW5nSGlzdG9yeShoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcikge1xuICBoaXN0b3J5ID0gX2V4dGVuZHMoe30sIGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGhpc3RvcnkgPSAoMCwgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMyLmRlZmF1bHQpKGhpc3RvcnksICdgcHJvcHMuaGlzdG9yeWAgYW5kIGBjb250ZXh0Lmhpc3RvcnlgIGFyZSBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIGBjb250ZXh0LnJvdXRlcmAuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1jb250ZXh0Y2hhbmdlcycpO1xuICB9XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGVyVXRpbHMuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Qcm9wVHlwZXMgPSByZXF1aXJlKCcuL1Byb3BUeXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBfUmVhY3QkUHJvcFR5cGVzID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcztcbnZhciBib29sID0gX1JlYWN0JFByb3BUeXBlcy5ib29sO1xudmFyIG9iamVjdCA9IF9SZWFjdCRQcm9wVHlwZXMub2JqZWN0O1xudmFyIHN0cmluZyA9IF9SZWFjdCRQcm9wVHlwZXMuc3RyaW5nO1xudmFyIGZ1bmMgPSBfUmVhY3QkUHJvcFR5cGVzLmZ1bmM7XG52YXIgb25lT2ZUeXBlID0gX1JlYWN0JFByb3BUeXBlcy5vbmVPZlR5cGU7XG5cblxuZnVuY3Rpb24gaXNMZWZ0Q2xpY2tFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQuYnV0dG9uID09PSAwO1xufVxuXG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuICEhKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkpO1xufVxuXG4vLyBUT0RPOiBEZS1kdXBsaWNhdGUgYWdhaW5zdCBoYXNBbnlQcm9wZXJ0aWVzIGluIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLlxuZnVuY3Rpb24gaXNFbXB0eU9iamVjdChvYmplY3QpIHtcbiAgZm9yICh2YXIgcCBpbiBvYmplY3QpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcCkpIHJldHVybiBmYWxzZTtcbiAgfXJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMb2NhdGlvbkRlc2NyaXB0b3IodG8sIF9yZWYpIHtcbiAgdmFyIHF1ZXJ5ID0gX3JlZi5xdWVyeTtcbiAgdmFyIGhhc2ggPSBfcmVmLmhhc2g7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGU7XG5cbiAgaWYgKHF1ZXJ5IHx8IGhhc2ggfHwgc3RhdGUpIHtcbiAgICByZXR1cm4geyBwYXRobmFtZTogdG8sIHF1ZXJ5OiBxdWVyeSwgaGFzaDogaGFzaCwgc3RhdGU6IHN0YXRlIH07XG4gIH1cblxuICByZXR1cm4gdG87XG59XG5cbi8qKlxuICogQSA8TGluaz4gaXMgdXNlZCB0byBjcmVhdGUgYW4gPGE+IGVsZW1lbnQgdGhhdCBsaW5rcyB0byBhIHJvdXRlLlxuICogV2hlbiB0aGF0IHJvdXRlIGlzIGFjdGl2ZSwgdGhlIGxpbmsgZ2V0cyB0aGUgdmFsdWUgb2YgaXRzXG4gKiBhY3RpdmVDbGFzc05hbWUgcHJvcC5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgYXNzdW1pbmcgeW91IGhhdmUgdGhlIGZvbGxvd2luZyByb3V0ZTpcbiAqXG4gKiAgIDxSb3V0ZSBwYXRoPVwiL3Bvc3RzLzpwb3N0SURcIiBjb21wb25lbnQ9e1Bvc3R9IC8+XG4gKlxuICogWW91IGNvdWxkIHVzZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudCB0byBsaW5rIHRvIHRoYXQgcm91dGU6XG4gKlxuICogICA8TGluayB0bz17YC9wb3N0cy8ke3Bvc3QuaWR9YH0gLz5cbiAqXG4gKiBMaW5rcyBtYXkgcGFzcyBhbG9uZyBsb2NhdGlvbiBzdGF0ZSBhbmQvb3IgcXVlcnkgc3RyaW5nIHBhcmFtZXRlcnNcbiAqIGluIHRoZSBzdGF0ZS9xdWVyeSBwcm9wcywgcmVzcGVjdGl2ZWx5LlxuICpcbiAqICAgPExpbmsgLi4uIHF1ZXJ5PXt7IHNob3c6IHRydWUgfX0gc3RhdGU9e3sgdGhlOiAnc3RhdGUnIH19IC8+XG4gKi9cbnZhciBMaW5rID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdMaW5rJyxcblxuXG4gIGNvbnRleHRUeXBlczoge1xuICAgIHJvdXRlcjogX1Byb3BUeXBlcy5yb3V0ZXJTaGFwZVxuICB9LFxuXG4gIHByb3BUeXBlczoge1xuICAgIHRvOiBvbmVPZlR5cGUoW3N0cmluZywgb2JqZWN0XSksXG4gICAgcXVlcnk6IG9iamVjdCxcbiAgICBoYXNoOiBzdHJpbmcsXG4gICAgc3RhdGU6IG9iamVjdCxcbiAgICBhY3RpdmVTdHlsZTogb2JqZWN0LFxuICAgIGFjdGl2ZUNsYXNzTmFtZTogc3RyaW5nLFxuICAgIG9ubHlBY3RpdmVPbkluZGV4OiBib29sLmlzUmVxdWlyZWQsXG4gICAgb25DbGljazogZnVuYyxcbiAgICB0YXJnZXQ6IHN0cmluZ1xuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvbmx5QWN0aXZlT25JbmRleDogZmFsc2UsXG4gICAgICBzdHlsZToge31cbiAgICB9O1xuICB9LFxuICBoYW5kbGVDbGljazogZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5vbkNsaWNrKSB0aGlzLnByb3BzLm9uQ2xpY2soZXZlbnQpO1xuXG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuICAgICF0aGlzLmNvbnRleHQucm91dGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJzxMaW5rPnMgcmVuZGVyZWQgb3V0c2lkZSBvZiBhIHJvdXRlciBjb250ZXh0IGNhbm5vdCBuYXZpZ2F0ZS4nKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICBpZiAoaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB8fCAhaXNMZWZ0Q2xpY2tFdmVudChldmVudCkpIHJldHVybjtcblxuICAgIC8vIElmIHRhcmdldCBwcm9wIGlzIHNldCAoZS5nLiB0byBcIl9ibGFua1wiKSwgbGV0IGJyb3dzZXIgaGFuZGxlIGxpbmsuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmOiB1bnRlc3RhYmxlIHdpdGggS2FybWEgKi9cbiAgICBpZiAodGhpcy5wcm9wcy50YXJnZXQpIHJldHVybjtcblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgdG8gPSBfcHJvcHMudG87XG4gICAgdmFyIHF1ZXJ5ID0gX3Byb3BzLnF1ZXJ5O1xuICAgIHZhciBoYXNoID0gX3Byb3BzLmhhc2g7XG4gICAgdmFyIHN0YXRlID0gX3Byb3BzLnN0YXRlO1xuXG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb25EZXNjcmlwdG9yKHRvLCB7IHF1ZXJ5OiBxdWVyeSwgaGFzaDogaGFzaCwgc3RhdGU6IHN0YXRlIH0pO1xuXG4gICAgdGhpcy5jb250ZXh0LnJvdXRlci5wdXNoKGxvY2F0aW9uKTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzO1xuICAgIHZhciB0byA9IF9wcm9wczIudG87XG4gICAgdmFyIHF1ZXJ5ID0gX3Byb3BzMi5xdWVyeTtcbiAgICB2YXIgaGFzaCA9IF9wcm9wczIuaGFzaDtcbiAgICB2YXIgc3RhdGUgPSBfcHJvcHMyLnN0YXRlO1xuICAgIHZhciBhY3RpdmVDbGFzc05hbWUgPSBfcHJvcHMyLmFjdGl2ZUNsYXNzTmFtZTtcbiAgICB2YXIgYWN0aXZlU3R5bGUgPSBfcHJvcHMyLmFjdGl2ZVN0eWxlO1xuICAgIHZhciBvbmx5QWN0aXZlT25JbmRleCA9IF9wcm9wczIub25seUFjdGl2ZU9uSW5kZXg7XG5cbiAgICB2YXIgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzMiwgWyd0bycsICdxdWVyeScsICdoYXNoJywgJ3N0YXRlJywgJ2FjdGl2ZUNsYXNzTmFtZScsICdhY3RpdmVTdHlsZScsICdvbmx5QWN0aXZlT25JbmRleCddKTtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKCEocXVlcnkgfHwgaGFzaCB8fCBzdGF0ZSksICd0aGUgYHF1ZXJ5YCwgYGhhc2hgLCBhbmQgYHN0YXRlYCBwcm9wcyBvbiBgPExpbms+YCBhcmUgZGVwcmVjYXRlZCwgdXNlIGA8TGluayB0bz17eyBwYXRobmFtZSwgcXVlcnksIGhhc2gsIHN0YXRlIH19Lz4uIGh0dHA6Ly90aW55LmNjL3JvdXRlci1pc0FjdGl2ZWRlcHJlY2F0ZWQnKSA6IHZvaWQgMDtcblxuICAgIC8vIElnbm9yZSBpZiByZW5kZXJlZCBvdXRzaWRlIHRoZSBjb250ZXh0IG9mIHJvdXRlciwgc2ltcGxpZmllcyB1bml0IHRlc3RpbmcuXG4gICAgdmFyIHJvdXRlciA9IHRoaXMuY29udGV4dC5yb3V0ZXI7XG5cblxuICAgIGlmIChyb3V0ZXIpIHtcbiAgICAgIC8vIElmIHVzZXIgZG9lcyBub3Qgc3BlY2lmeSBhIGB0b2AgcHJvcCwgcmV0dXJuIGFuIGVtcHR5IGFuY2hvciB0YWcuXG4gICAgICBpZiAodG8gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoJ2EnLCBwcm9wcyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uRGVzY3JpcHRvcih0bywgeyBxdWVyeTogcXVlcnksIGhhc2g6IGhhc2gsIHN0YXRlOiBzdGF0ZSB9KTtcbiAgICAgIHByb3BzLmhyZWYgPSByb3V0ZXIuY3JlYXRlSHJlZihsb2NhdGlvbik7XG5cbiAgICAgIGlmIChhY3RpdmVDbGFzc05hbWUgfHwgYWN0aXZlU3R5bGUgIT0gbnVsbCAmJiAhaXNFbXB0eU9iamVjdChhY3RpdmVTdHlsZSkpIHtcbiAgICAgICAgaWYgKHJvdXRlci5pc0FjdGl2ZShsb2NhdGlvbiwgb25seUFjdGl2ZU9uSW5kZXgpKSB7XG4gICAgICAgICAgaWYgKGFjdGl2ZUNsYXNzTmFtZSkge1xuICAgICAgICAgICAgaWYgKHByb3BzLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICBwcm9wcy5jbGFzc05hbWUgKz0gJyAnICsgYWN0aXZlQ2xhc3NOYW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcHJvcHMuY2xhc3NOYW1lID0gYWN0aXZlQ2xhc3NOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhY3RpdmVTdHlsZSkgcHJvcHMuc3R5bGUgPSBfZXh0ZW5kcyh7fSwgcHJvcHMuc3R5bGUsIGFjdGl2ZVN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgnYScsIF9leHRlbmRzKHt9LCBwcm9wcywgeyBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrIH0pKTtcbiAgfVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IExpbms7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9MaW5rLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfTGluayA9IHJlcXVpcmUoJy4vTGluaycpO1xuXG52YXIgX0xpbmsyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTGluayk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogQW4gPEluZGV4TGluaz4gaXMgdXNlZCB0byBsaW5rIHRvIGFuIDxJbmRleFJvdXRlPi5cbiAqL1xudmFyIEluZGV4TGluayA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnSW5kZXhMaW5rJyxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9MaW5rMi5kZWZhdWx0LCBfZXh0ZW5kcyh7fSwgdGhpcy5wcm9wcywgeyBvbmx5QWN0aXZlT25JbmRleDogdHJ1ZSB9KSk7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBJbmRleExpbms7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9JbmRleExpbmsuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHdpdGhSb3V0ZXI7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9ob2lzdE5vblJlYWN0U3RhdGljcyA9IHJlcXVpcmUoJ2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzJyk7XG5cbnZhciBfaG9pc3ROb25SZWFjdFN0YXRpY3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaG9pc3ROb25SZWFjdFN0YXRpY3MpO1xuXG52YXIgX1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vUHJvcFR5cGVzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKFdyYXBwZWRDb21wb25lbnQpIHtcbiAgcmV0dXJuIFdyYXBwZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgV3JhcHBlZENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnO1xufVxuXG5mdW5jdGlvbiB3aXRoUm91dGVyKFdyYXBwZWRDb21wb25lbnQsIG9wdGlvbnMpIHtcbiAgdmFyIHdpdGhSZWYgPSBvcHRpb25zICYmIG9wdGlvbnMud2l0aFJlZjtcblxuICB2YXIgV2l0aFJvdXRlciA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gICAgZGlzcGxheU5hbWU6ICdXaXRoUm91dGVyJyxcblxuICAgIGNvbnRleHRUeXBlczogeyByb3V0ZXI6IF9Qcm9wVHlwZXMucm91dGVyU2hhcGUgfSxcbiAgICBwcm9wVHlwZXM6IHsgcm91dGVyOiBfUHJvcFR5cGVzLnJvdXRlclNoYXBlIH0sXG5cbiAgICBnZXRXcmFwcGVkSW5zdGFuY2U6IGZ1bmN0aW9uIGdldFdyYXBwZWRJbnN0YW5jZSgpIHtcbiAgICAgICF3aXRoUmVmID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ1RvIGFjY2VzcyB0aGUgd3JhcHBlZCBpbnN0YW5jZSwgeW91IG5lZWQgdG8gc3BlY2lmeSAnICsgJ2B7IHdpdGhSZWY6IHRydWUgfWAgYXMgdGhlIHNlY29uZCBhcmd1bWVudCBvZiB0aGUgd2l0aFJvdXRlcigpIGNhbGwuJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkSW5zdGFuY2U7XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciByb3V0ZXIgPSB0aGlzLnByb3BzLnJvdXRlciB8fCB0aGlzLmNvbnRleHQucm91dGVyO1xuICAgICAgdmFyIHByb3BzID0gX2V4dGVuZHMoe30sIHRoaXMucHJvcHMsIHsgcm91dGVyOiByb3V0ZXIgfSk7XG5cbiAgICAgIGlmICh3aXRoUmVmKSB7XG4gICAgICAgIHByb3BzLnJlZiA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgX3RoaXMud3JhcHBlZEluc3RhbmNlID0gYztcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFdyYXBwZWRDb21wb25lbnQsIHByb3BzKTtcbiAgICB9XG4gIH0pO1xuXG4gIFdpdGhSb3V0ZXIuZGlzcGxheU5hbWUgPSAnd2l0aFJvdXRlcignICsgZ2V0RGlzcGxheU5hbWUoV3JhcHBlZENvbXBvbmVudCkgKyAnKSc7XG4gIFdpdGhSb3V0ZXIuV3JhcHBlZENvbXBvbmVudCA9IFdyYXBwZWRDb21wb25lbnQ7XG5cbiAgcmV0dXJuICgwLCBfaG9pc3ROb25SZWFjdFN0YXRpY3MyLmRlZmF1bHQpKFdpdGhSb3V0ZXIsIFdyYXBwZWRDb21wb25lbnQpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvd2l0aFJvdXRlci5qc1xuICoqLyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIFlhaG9vISBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFJFQUNUX1NUQVRJQ1MgPSB7XG4gICAgY2hpbGRDb250ZXh0VHlwZXM6IHRydWUsXG4gICAgY29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgICBnZXREZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgbWl4aW5zOiB0cnVlLFxuICAgIHByb3BUeXBlczogdHJ1ZSxcbiAgICB0eXBlOiB0cnVlXG59O1xuXG52YXIgS05PV05fU1RBVElDUyA9IHtcbiAgICBuYW1lOiB0cnVlLFxuICAgIGxlbmd0aDogdHJ1ZSxcbiAgICBwcm90b3R5cGU6IHRydWUsXG4gICAgY2FsbGVyOiB0cnVlLFxuICAgIGFyZ3VtZW50czogdHJ1ZSxcbiAgICBhcml0eTogdHJ1ZVxufTtcblxudmFyIGlzR2V0T3duUHJvcGVydHlTeW1ib2xzQXZhaWxhYmxlID0gdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbic7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQsIGN1c3RvbVN0YXRpY3MpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZUNvbXBvbmVudCAhPT0gJ3N0cmluZycpIHsgLy8gZG9uJ3QgaG9pc3Qgb3ZlciBzdHJpbmcgKGh0bWwpIGNvbXBvbmVudHNcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChpc0dldE93blByb3BlcnR5U3ltYm9sc0F2YWlsYWJsZSkge1xuICAgICAgICAgICAga2V5cyA9IGtleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlQ29tcG9uZW50KSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghUkVBQ1RfU1RBVElDU1trZXlzW2ldXSAmJiAhS05PV05fU1RBVElDU1trZXlzW2ldXSAmJiAoIWN1c3RvbVN0YXRpY3MgfHwgIWN1c3RvbVN0YXRpY3Nba2V5c1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q29tcG9uZW50W2tleXNbaV1dID0gc291cmNlQ29tcG9uZW50W2tleXNbaV1dO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX1JlZGlyZWN0ID0gcmVxdWlyZSgnLi9SZWRpcmVjdCcpO1xuXG52YXIgX1JlZGlyZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlZGlyZWN0KTtcblxudmFyIF9JbnRlcm5hbFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vSW50ZXJuYWxQcm9wVHlwZXMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIF9SZWFjdCRQcm9wVHlwZXMgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzO1xudmFyIHN0cmluZyA9IF9SZWFjdCRQcm9wVHlwZXMuc3RyaW5nO1xudmFyIG9iamVjdCA9IF9SZWFjdCRQcm9wVHlwZXMub2JqZWN0O1xuXG4vKipcbiAqIEFuIDxJbmRleFJlZGlyZWN0PiBpcyB1c2VkIHRvIHJlZGlyZWN0IGZyb20gYW4gaW5kZXhSb3V0ZS5cbiAqL1xuXG52YXIgSW5kZXhSZWRpcmVjdCA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnSW5kZXhSZWRpcmVjdCcsXG5cblxuICBzdGF0aWNzOiB7XG4gICAgY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50OiBmdW5jdGlvbiBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQoZWxlbWVudCwgcGFyZW50Um91dGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBzYW5pdHkgY2hlY2sgKi9cbiAgICAgIGlmIChwYXJlbnRSb3V0ZSkge1xuICAgICAgICBwYXJlbnRSb3V0ZS5pbmRleFJvdXRlID0gX1JlZGlyZWN0Mi5kZWZhdWx0LmNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnQW4gPEluZGV4UmVkaXJlY3Q+IGRvZXMgbm90IG1ha2Ugc2Vuc2UgYXQgdGhlIHJvb3Qgb2YgeW91ciByb3V0ZSBjb25maWcnKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgdG86IHN0cmluZy5pc1JlcXVpcmVkLFxuICAgIHF1ZXJ5OiBvYmplY3QsXG4gICAgc3RhdGU6IG9iamVjdCxcbiAgICBvbkVudGVyOiBfSW50ZXJuYWxQcm9wVHlwZXMuZmFsc3ksXG4gICAgY2hpbGRyZW46IF9JbnRlcm5hbFByb3BUeXBlcy5mYWxzeVxuICB9LFxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzYW5pdHkgY2hlY2sgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJzxJbmRleFJlZGlyZWN0PiBlbGVtZW50cyBhcmUgZm9yIHJvdXRlciBjb25maWd1cmF0aW9uIG9ubHkgYW5kIHNob3VsZCBub3QgYmUgcmVuZGVyZWQnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBJbmRleFJlZGlyZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvSW5kZXhSZWRpcmVjdC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxudmFyIF9QYXR0ZXJuVXRpbHMgPSByZXF1aXJlKCcuL1BhdHRlcm5VdGlscycpO1xuXG52YXIgX0ludGVybmFsUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9JbnRlcm5hbFByb3BUeXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgX1JlYWN0JFByb3BUeXBlcyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXM7XG52YXIgc3RyaW5nID0gX1JlYWN0JFByb3BUeXBlcy5zdHJpbmc7XG52YXIgb2JqZWN0ID0gX1JlYWN0JFByb3BUeXBlcy5vYmplY3Q7XG5cbi8qKlxuICogQSA8UmVkaXJlY3Q+IGlzIHVzZWQgdG8gZGVjbGFyZSBhbm90aGVyIFVSTCBwYXRoIGEgY2xpZW50IHNob3VsZFxuICogYmUgc2VudCB0byB3aGVuIHRoZXkgcmVxdWVzdCBhIGdpdmVuIFVSTC5cbiAqXG4gKiBSZWRpcmVjdHMgYXJlIHBsYWNlZCBhbG9uZ3NpZGUgcm91dGVzIGluIHRoZSByb3V0ZSBjb25maWd1cmF0aW9uXG4gKiBhbmQgYXJlIHRyYXZlcnNlZCBpbiB0aGUgc2FtZSBtYW5uZXIuXG4gKi9cblxudmFyIFJlZGlyZWN0ID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSZWRpcmVjdCcsXG5cblxuICBzdGF0aWNzOiB7XG4gICAgY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50OiBmdW5jdGlvbiBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgdmFyIHJvdXRlID0gKDAsIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudCkoZWxlbWVudCk7XG5cbiAgICAgIGlmIChyb3V0ZS5mcm9tKSByb3V0ZS5wYXRoID0gcm91dGUuZnJvbTtcblxuICAgICAgcm91dGUub25FbnRlciA9IGZ1bmN0aW9uIChuZXh0U3RhdGUsIHJlcGxhY2UpIHtcbiAgICAgICAgdmFyIGxvY2F0aW9uID0gbmV4dFN0YXRlLmxvY2F0aW9uO1xuICAgICAgICB2YXIgcGFyYW1zID0gbmV4dFN0YXRlLnBhcmFtcztcblxuXG4gICAgICAgIHZhciBwYXRobmFtZSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKHJvdXRlLnRvLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICAgICAgcGF0aG5hbWUgPSAoMCwgX1BhdHRlcm5VdGlscy5mb3JtYXRQYXR0ZXJuKShyb3V0ZS50bywgcGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIGlmICghcm91dGUudG8pIHtcbiAgICAgICAgICBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByb3V0ZUluZGV4ID0gbmV4dFN0YXRlLnJvdXRlcy5pbmRleE9mKHJvdXRlKTtcbiAgICAgICAgICB2YXIgcGFyZW50UGF0dGVybiA9IFJlZGlyZWN0LmdldFJvdXRlUGF0dGVybihuZXh0U3RhdGUucm91dGVzLCByb3V0ZUluZGV4IC0gMSk7XG4gICAgICAgICAgdmFyIHBhdHRlcm4gPSBwYXJlbnRQYXR0ZXJuLnJlcGxhY2UoL1xcLyokLywgJy8nKSArIHJvdXRlLnRvO1xuICAgICAgICAgIHBhdGhuYW1lID0gKDAsIF9QYXR0ZXJuVXRpbHMuZm9ybWF0UGF0dGVybikocGF0dGVybiwgcGFyYW1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcGxhY2Uoe1xuICAgICAgICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICAgICAgICBxdWVyeTogcm91dGUucXVlcnkgfHwgbG9jYXRpb24ucXVlcnksXG4gICAgICAgICAgc3RhdGU6IHJvdXRlLnN0YXRlIHx8IGxvY2F0aW9uLnN0YXRlXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHJvdXRlO1xuICAgIH0sXG4gICAgZ2V0Um91dGVQYXR0ZXJuOiBmdW5jdGlvbiBnZXRSb3V0ZVBhdHRlcm4ocm91dGVzLCByb3V0ZUluZGV4KSB7XG4gICAgICB2YXIgcGFyZW50UGF0dGVybiA9ICcnO1xuXG4gICAgICBmb3IgKHZhciBpID0gcm91dGVJbmRleDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIHJvdXRlID0gcm91dGVzW2ldO1xuICAgICAgICB2YXIgcGF0dGVybiA9IHJvdXRlLnBhdGggfHwgJyc7XG5cbiAgICAgICAgcGFyZW50UGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZSgvXFwvKiQvLCAnLycpICsgcGFyZW50UGF0dGVybjtcblxuICAgICAgICBpZiAocGF0dGVybi5pbmRleE9mKCcvJykgPT09IDApIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJy8nICsgcGFyZW50UGF0dGVybjtcbiAgICB9XG4gIH0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgcGF0aDogc3RyaW5nLFxuICAgIGZyb206IHN0cmluZywgLy8gQWxpYXMgZm9yIHBhdGhcbiAgICB0bzogc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgcXVlcnk6IG9iamVjdCxcbiAgICBzdGF0ZTogb2JqZWN0LFxuICAgIG9uRW50ZXI6IF9JbnRlcm5hbFByb3BUeXBlcy5mYWxzeSxcbiAgICBjaGlsZHJlbjogX0ludGVybmFsUHJvcFR5cGVzLmZhbHN5XG4gIH0sXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNhbml0eSBjaGVjayAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnPFJlZGlyZWN0PiBlbGVtZW50cyBhcmUgZm9yIHJvdXRlciBjb25maWd1cmF0aW9uIG9ubHkgYW5kIHNob3VsZCBub3QgYmUgcmVuZGVyZWQnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSZWRpcmVjdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1JlZGlyZWN0LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xuXG52YXIgX0ludGVybmFsUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9JbnRlcm5hbFByb3BUeXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZnVuYyA9IF9yZWFjdDIuZGVmYXVsdC5Qcm9wVHlwZXMuZnVuYztcblxuLyoqXG4gKiBBbiA8SW5kZXhSb3V0ZT4gaXMgdXNlZCB0byBzcGVjaWZ5IGl0cyBwYXJlbnQncyA8Um91dGUgaW5kZXhSb3V0ZT4gaW5cbiAqIGEgSlNYIHJvdXRlIGNvbmZpZy5cbiAqL1xuXG52YXIgSW5kZXhSb3V0ZSA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnSW5kZXhSb3V0ZScsXG5cblxuICBzdGF0aWNzOiB7XG4gICAgY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50OiBmdW5jdGlvbiBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQoZWxlbWVudCwgcGFyZW50Um91dGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBzYW5pdHkgY2hlY2sgKi9cbiAgICAgIGlmIChwYXJlbnRSb3V0ZSkge1xuICAgICAgICBwYXJlbnRSb3V0ZS5pbmRleFJvdXRlID0gKDAsIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudCkoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ0FuIDxJbmRleFJvdXRlPiBkb2VzIG5vdCBtYWtlIHNlbnNlIGF0IHRoZSByb290IG9mIHlvdXIgcm91dGUgY29uZmlnJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHByb3BUeXBlczoge1xuICAgIHBhdGg6IF9JbnRlcm5hbFByb3BUeXBlcy5mYWxzeSxcbiAgICBjb21wb25lbnQ6IF9JbnRlcm5hbFByb3BUeXBlcy5jb21wb25lbnQsXG4gICAgY29tcG9uZW50czogX0ludGVybmFsUHJvcFR5cGVzLmNvbXBvbmVudHMsXG4gICAgZ2V0Q29tcG9uZW50OiBmdW5jLFxuICAgIGdldENvbXBvbmVudHM6IGZ1bmNcbiAgfSxcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2FuaXR5IGNoZWNrICovXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICc8SW5kZXhSb3V0ZT4gZWxlbWVudHMgYXJlIGZvciByb3V0ZXIgY29uZmlndXJhdGlvbiBvbmx5IGFuZCBzaG91bGQgbm90IGJlIHJlbmRlcmVkJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSW5kZXhSb3V0ZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL0luZGV4Um91dGUuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbnZhciBfSW50ZXJuYWxQcm9wVHlwZXMgPSByZXF1aXJlKCcuL0ludGVybmFsUHJvcFR5cGVzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBfUmVhY3QkUHJvcFR5cGVzID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcztcbnZhciBzdHJpbmcgPSBfUmVhY3QkUHJvcFR5cGVzLnN0cmluZztcbnZhciBmdW5jID0gX1JlYWN0JFByb3BUeXBlcy5mdW5jO1xuXG4vKipcbiAqIEEgPFJvdXRlPiBpcyB1c2VkIHRvIGRlY2xhcmUgd2hpY2ggY29tcG9uZW50cyBhcmUgcmVuZGVyZWQgdG8gdGhlXG4gKiBwYWdlIHdoZW4gdGhlIFVSTCBtYXRjaGVzIGEgZ2l2ZW4gcGF0dGVybi5cbiAqXG4gKiBSb3V0ZXMgYXJlIGFycmFuZ2VkIGluIGEgbmVzdGVkIHRyZWUgc3RydWN0dXJlLiBXaGVuIGEgbmV3IFVSTCBpc1xuICogcmVxdWVzdGVkLCB0aGUgdHJlZSBpcyBzZWFyY2hlZCBkZXB0aC1maXJzdCB0byBmaW5kIGEgcm91dGUgd2hvc2VcbiAqIHBhdGggbWF0Y2hlcyB0aGUgVVJMLiAgV2hlbiBvbmUgaXMgZm91bmQsIGFsbCByb3V0ZXMgaW4gdGhlIHRyZWVcbiAqIHRoYXQgbGVhZCB0byBpdCBhcmUgY29uc2lkZXJlZCBcImFjdGl2ZVwiIGFuZCB0aGVpciBjb21wb25lbnRzIGFyZVxuICogcmVuZGVyZWQgaW50byB0aGUgRE9NLCBuZXN0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgaW4gdGhlIHRyZWUuXG4gKi9cblxudmFyIFJvdXRlID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSb3V0ZScsXG5cblxuICBzdGF0aWNzOiB7XG4gICAgY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50OiBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnRcbiAgfSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgY29tcG9uZW50OiBfSW50ZXJuYWxQcm9wVHlwZXMuY29tcG9uZW50LFxuICAgIGNvbXBvbmVudHM6IF9JbnRlcm5hbFByb3BUeXBlcy5jb21wb25lbnRzLFxuICAgIGdldENvbXBvbmVudDogZnVuYyxcbiAgICBnZXRDb21wb25lbnRzOiBmdW5jXG4gIH0sXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNhbml0eSBjaGVjayAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnPFJvdXRlPiBlbGVtZW50cyBhcmUgZm9yIHJvdXRlciBjb25maWd1cmF0aW9uIG9ubHkgYW5kIHNob3VsZCBub3QgYmUgcmVuZGVyZWQnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSb3V0ZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX0ludGVybmFsUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9JbnRlcm5hbFByb3BUeXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIEEgbWl4aW4gdGhhdCBhZGRzIHRoZSBcImhpc3RvcnlcIiBpbnN0YW5jZSB2YXJpYWJsZSB0byBjb21wb25lbnRzLlxuICovXG52YXIgSGlzdG9yeSA9IHtcblxuICBjb250ZXh0VHlwZXM6IHtcbiAgICBoaXN0b3J5OiBfSW50ZXJuYWxQcm9wVHlwZXMuaGlzdG9yeVxuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAndGhlIGBIaXN0b3J5YCBtaXhpbiBpcyBkZXByZWNhdGVkLCBwbGVhc2UgYWNjZXNzIGBjb250ZXh0LnJvdXRlcmAgd2l0aCB5b3VyIG93biBgY29udGV4dFR5cGVzYC4gaHR0cDovL3RpbnkuY2Mvcm91dGVyLWhpc3RvcnltaXhpbicpIDogdm9pZCAwO1xuICAgIHRoaXMuaGlzdG9yeSA9IHRoaXMuY29udGV4dC5oaXN0b3J5O1xuICB9XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBIaXN0b3J5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvSGlzdG9yeS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgb2JqZWN0ID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcy5vYmplY3Q7XG5cbi8qKlxuICogVGhlIExpZmVjeWNsZSBtaXhpbiBhZGRzIHRoZSByb3V0ZXJXaWxsTGVhdmUgbGlmZWN5Y2xlIG1ldGhvZCB0byBhXG4gKiBjb21wb25lbnQgdGhhdCBtYXkgYmUgdXNlZCB0byBjYW5jZWwgYSB0cmFuc2l0aW9uIG9yIHByb21wdCB0aGUgdXNlclxuICogZm9yIGNvbmZpcm1hdGlvbi5cbiAqXG4gKiBPbiBzdGFuZGFyZCB0cmFuc2l0aW9ucywgcm91dGVyV2lsbExlYXZlIHJlY2VpdmVzIGEgc2luZ2xlIGFyZ3VtZW50OiB0aGVcbiAqIGxvY2F0aW9uIHdlJ3JlIHRyYW5zaXRpb25pbmcgdG8uIFRvIGNhbmNlbCB0aGUgdHJhbnNpdGlvbiwgcmV0dXJuIGZhbHNlLlxuICogVG8gcHJvbXB0IHRoZSB1c2VyIGZvciBjb25maXJtYXRpb24sIHJldHVybiBhIHByb21wdCBtZXNzYWdlIChzdHJpbmcpLlxuICpcbiAqIER1cmluZyB0aGUgYmVmb3JldW5sb2FkIGV2ZW50IChhc3N1bWluZyB5b3UncmUgdXNpbmcgdGhlIHVzZUJlZm9yZVVubG9hZFxuICogaGlzdG9yeSBlbmhhbmNlciksIHJvdXRlcldpbGxMZWF2ZSBkb2VzIG5vdCByZWNlaXZlIGEgbG9jYXRpb24gb2JqZWN0XG4gKiBiZWNhdXNlIGl0IGlzbid0IHBvc3NpYmxlIGZvciB1cyB0byBrbm93IHRoZSBsb2NhdGlvbiB3ZSdyZSB0cmFuc2l0aW9uaW5nXG4gKiB0by4gSW4gdGhpcyBjYXNlIHJvdXRlcldpbGxMZWF2ZSBtdXN0IHJldHVybiBhIHByb21wdCBtZXNzYWdlIHRvIHByZXZlbnRcbiAqIHRoZSB1c2VyIGZyb20gY2xvc2luZyB0aGUgd2luZG93L3RhYi5cbiAqL1xuXG52YXIgTGlmZWN5Y2xlID0ge1xuXG4gIGNvbnRleHRUeXBlczoge1xuICAgIGhpc3Rvcnk6IG9iamVjdC5pc1JlcXVpcmVkLFxuICAgIC8vIE5lc3RlZCBjaGlsZHJlbiByZWNlaXZlIHRoZSByb3V0ZSBhcyBjb250ZXh0LCBlaXRoZXJcbiAgICAvLyBzZXQgYnkgdGhlIHJvdXRlIGNvbXBvbmVudCB1c2luZyB0aGUgUm91dGVDb250ZXh0IG1peGluXG4gICAgLy8gb3IgYnkgc29tZSBvdGhlciBhbmNlc3Rvci5cbiAgICByb3V0ZTogb2JqZWN0XG4gIH0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgLy8gUm91dGUgY29tcG9uZW50cyByZWNlaXZlIHRoZSByb3V0ZSBvYmplY3QgYXMgYSBwcm9wLlxuICAgIHJvdXRlOiBvYmplY3RcbiAgfSxcblxuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICd0aGUgYExpZmVjeWNsZWAgbWl4aW4gaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBgY29udGV4dC5yb3V0ZXIuc2V0Um91dGVMZWF2ZUhvb2socm91dGUsIGhvb2spYC4gaHR0cDovL3RpbnkuY2Mvcm91dGVyLWxpZmVjeWNsZW1peGluJykgOiB2b2lkIDA7XG4gICAgIXRoaXMucm91dGVyV2lsbExlYXZlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ1RoZSBMaWZlY3ljbGUgbWl4aW4gcmVxdWlyZXMgeW91IHRvIGRlZmluZSBhIHJvdXRlcldpbGxMZWF2ZSBtZXRob2QnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICB2YXIgcm91dGUgPSB0aGlzLnByb3BzLnJvdXRlIHx8IHRoaXMuY29udGV4dC5yb3V0ZTtcblxuICAgICFyb3V0ZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdUaGUgTGlmZWN5Y2xlIG1peGluIG11c3QgYmUgdXNlZCBvbiBlaXRoZXIgYSkgYSA8Um91dGUgY29tcG9uZW50PiBvciAnICsgJ2IpIGEgZGVzY2VuZGFudCBvZiBhIDxSb3V0ZSBjb21wb25lbnQ+IHRoYXQgdXNlcyB0aGUgUm91dGVDb250ZXh0IG1peGluJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgdGhpcy5fdW5saXN0ZW5CZWZvcmVMZWF2aW5nUm91dGUgPSB0aGlzLmNvbnRleHQuaGlzdG9yeS5saXN0ZW5CZWZvcmVMZWF2aW5nUm91dGUocm91dGUsIHRoaXMucm91dGVyV2lsbExlYXZlKTtcbiAgfSxcbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLl91bmxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZSkgdGhpcy5fdW5saXN0ZW5CZWZvcmVMZWF2aW5nUm91dGUoKTtcbiAgfVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTGlmZWN5Y2xlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvTGlmZWN5Y2xlLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBvYmplY3QgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzLm9iamVjdDtcblxuLyoqXG4gKiBUaGUgUm91dGVDb250ZXh0IG1peGluIHByb3ZpZGVzIGEgY29udmVuaWVudCB3YXkgZm9yIHJvdXRlXG4gKiBjb21wb25lbnRzIHRvIHNldCB0aGUgcm91dGUgaW4gY29udGV4dC4gVGhpcyBpcyBuZWVkZWQgZm9yXG4gKiByb3V0ZXMgdGhhdCByZW5kZXIgZWxlbWVudHMgdGhhdCB3YW50IHRvIHVzZSB0aGUgTGlmZWN5Y2xlXG4gKiBtaXhpbiB0byBwcmV2ZW50IHRyYW5zaXRpb25zLlxuICovXG5cbnZhciBSb3V0ZUNvbnRleHQgPSB7XG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgcm91dGU6IG9iamVjdC5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgY2hpbGRDb250ZXh0VHlwZXM6IHtcbiAgICByb3V0ZTogb2JqZWN0LmlzUmVxdWlyZWRcbiAgfSxcblxuICBnZXRDaGlsZENvbnRleHQ6IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm91dGU6IHRoaXMucHJvcHMucm91dGVcbiAgICB9O1xuICB9LFxuICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ1RoZSBgUm91dGVDb250ZXh0YCBtaXhpbiBpcyBkZXByZWNhdGVkLiBZb3UgY2FuIHByb3ZpZGUgYHRoaXMucHJvcHMucm91dGVgIG9uIGNvbnRleHQgd2l0aCB5b3VyIG93biBgY29udGV4dFR5cGVzYC4gaHR0cDovL3RpbnkuY2Mvcm91dGVyLXJvdXRlY29udGV4dG1peGluJykgOiB2b2lkIDA7XG4gIH1cbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJvdXRlQ29udGV4dDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlQ29udGV4dC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF91c2VRdWVyaWVzID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvdXNlUXVlcmllcycpO1xuXG52YXIgX3VzZVF1ZXJpZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlUXVlcmllcyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBjcmVhdGVIaXN0b3J5IGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gY3JlYXRlXG4gKiBoaXN0b3J5IG9iamVjdHMgdGhhdCBrbm93IGFib3V0IHJvdXRpbmcuXG4gKlxuICogRW5oYW5jZXMgaGlzdG9yeSBvYmplY3RzIHdpdGggdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuICpcbiAqIC0gbGlzdGVuKChlcnJvciwgbmV4dFN0YXRlKSA9PiB7fSlcbiAqIC0gbGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlKHJvdXRlLCAobmV4dExvY2F0aW9uKSA9PiB7fSlcbiAqIC0gbWF0Y2gobG9jYXRpb24sIChlcnJvciwgcmVkaXJlY3RMb2NhdGlvbiwgbmV4dFN0YXRlKSA9PiB7fSlcbiAqIC0gaXNBY3RpdmUocGF0aG5hbWUsIHF1ZXJ5LCBpbmRleE9ubHk9ZmFsc2UpXG4gKi9cbmZ1bmN0aW9uIHVzZVJvdXRlcyhjcmVhdGVIaXN0b3J5KSB7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnYHVzZVJvdXRlc2AgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXJgIGluc3RlYWQuJykgOiB2b2lkIDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgdmFyIHJvdXRlcyA9IF9yZWYucm91dGVzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgWydyb3V0ZXMnXSk7XG5cbiAgICB2YXIgaGlzdG9yeSA9ICgwLCBfdXNlUXVlcmllczIuZGVmYXVsdCkoY3JlYXRlSGlzdG9yeSkob3B0aW9ucyk7XG4gICAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gKDAsIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIuZGVmYXVsdCkoaGlzdG9yeSwgcm91dGVzKTtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyKTtcbiAgfTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gdXNlUm91dGVzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvdXNlUm91dGVzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfUm91dGVyQ29udGV4dCA9IHJlcXVpcmUoJy4vUm91dGVyQ29udGV4dCcpO1xuXG52YXIgX1JvdXRlckNvbnRleHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGVyQ29udGV4dCk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBSb3V0aW5nQ29udGV4dCA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUm91dGluZ0NvbnRleHQnLFxuICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ2BSb3V0aW5nQ29udGV4dGAgaGFzIGJlZW4gcmVuYW1lZCB0byBgUm91dGVyQ29udGV4dGAuIFBsZWFzZSB1c2UgYGltcG9ydCB7IFJvdXRlckNvbnRleHQgfSBmcm9tIFxcJ3JlYWN0LXJvdXRlclxcJ2AuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1yb3V0ZXJjb250ZXh0JykgOiB2b2lkIDA7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChfUm91dGVyQ29udGV4dDIuZGVmYXVsdCwgdGhpcy5wcm9wcyk7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSb3V0aW5nQ29udGV4dDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRpbmdDb250ZXh0LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX0FjdGlvbnMgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi9BY3Rpb25zJyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfY3JlYXRlTWVtb3J5SGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlTWVtb3J5SGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlTWVtb3J5SGlzdG9yeSk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIpO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxudmFyIF9Sb3V0ZXJVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVyVXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG4vKipcbiAqIEEgaGlnaC1sZXZlbCBBUEkgdG8gYmUgdXNlZCBmb3Igc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gbWF0Y2hlcyBhIGxvY2F0aW9uIHRvIGEgc2V0IG9mIHJvdXRlcyBhbmQgY2FsbHNcbiAqIGNhbGxiYWNrKGVycm9yLCByZWRpcmVjdExvY2F0aW9uLCByZW5kZXJQcm9wcykgd2hlbiBmaW5pc2hlZC5cbiAqXG4gKiBOb3RlOiBZb3UgcHJvYmFibHkgZG9uJ3Qgd2FudCB0byB1c2UgdGhpcyBpbiBhIGJyb3dzZXIgdW5sZXNzIHlvdSdyZSB1c2luZ1xuICogc2VydmVyLXNpZGUgcmVuZGVyaW5nIHdpdGggYXN5bmMgcm91dGVzLlxuICovXG5mdW5jdGlvbiBtYXRjaChfcmVmLCBjYWxsYmFjaykge1xuICB2YXIgaGlzdG9yeSA9IF9yZWYuaGlzdG9yeTtcbiAgdmFyIHJvdXRlcyA9IF9yZWYucm91dGVzO1xuICB2YXIgbG9jYXRpb24gPSBfcmVmLmxvY2F0aW9uO1xuXG4gIHZhciBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnaGlzdG9yeScsICdyb3V0ZXMnLCAnbG9jYXRpb24nXSk7XG5cbiAgIShoaXN0b3J5IHx8IGxvY2F0aW9uKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdtYXRjaCBuZWVkcyBhIGhpc3Rvcnkgb3IgYSBsb2NhdGlvbicpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICBoaXN0b3J5ID0gaGlzdG9yeSA/IGhpc3RvcnkgOiAoMCwgX2NyZWF0ZU1lbW9yeUhpc3RvcnkyLmRlZmF1bHQpKG9wdGlvbnMpO1xuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSAoMCwgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMi5kZWZhdWx0KShoaXN0b3J5LCAoMCwgX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVzKShyb3V0ZXMpKTtcblxuICB2YXIgdW5saXN0ZW4gPSB2b2lkIDA7XG5cbiAgaWYgKGxvY2F0aW9uKSB7XG4gICAgLy8gQWxsb3cgbWF0Y2goeyBsb2NhdGlvbjogJy90aGUvcGF0aCcsIC4uLiB9KVxuICAgIGxvY2F0aW9uID0gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbihsb2NhdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gUGljayB1cCB0aGUgbG9jYXRpb24gZnJvbSB0aGUgaGlzdG9yeSB2aWEgc3luY2hyb25vdXMgaGlzdG9yeS5saXN0ZW5cbiAgICAvLyBjYWxsIGlmIG5lZWRlZC5cbiAgICB1bmxpc3RlbiA9IGhpc3RvcnkubGlzdGVuKGZ1bmN0aW9uIChoaXN0b3J5TG9jYXRpb24pIHtcbiAgICAgIGxvY2F0aW9uID0gaGlzdG9yeUxvY2F0aW9uO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHJvdXRlciA9ICgwLCBfUm91dGVyVXRpbHMuY3JlYXRlUm91dGVyT2JqZWN0KShoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcik7XG4gIGhpc3RvcnkgPSAoMCwgX1JvdXRlclV0aWxzLmNyZWF0ZVJvdXRpbmdIaXN0b3J5KShoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcik7XG5cbiAgdHJhbnNpdGlvbk1hbmFnZXIubWF0Y2gobG9jYXRpb24sIGZ1bmN0aW9uIChlcnJvciwgcmVkaXJlY3RMb2NhdGlvbiwgbmV4dFN0YXRlKSB7XG4gICAgY2FsbGJhY2soZXJyb3IsIHJlZGlyZWN0TG9jYXRpb24gJiYgcm91dGVyLmNyZWF0ZUxvY2F0aW9uKHJlZGlyZWN0TG9jYXRpb24sIF9BY3Rpb25zLlJFUExBQ0UpLCBuZXh0U3RhdGUgJiYgX2V4dGVuZHMoe30sIG5leHRTdGF0ZSwge1xuICAgICAgaGlzdG9yeTogaGlzdG9yeSxcbiAgICAgIHJvdXRlcjogcm91dGVyLFxuICAgICAgbWF0Y2hDb250ZXh0OiB7IGhpc3Rvcnk6IGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyOiB0cmFuc2l0aW9uTWFuYWdlciwgcm91dGVyOiByb3V0ZXIgfVxuICAgIH0pKTtcblxuICAgIC8vIERlZmVyIHJlbW92aW5nIHRoZSBsaXN0ZW5lciB0byBoZXJlIHRvIHByZXZlbnQgRE9NIGhpc3RvcmllcyBmcm9tIGhhdmluZ1xuICAgIC8vIHRvIHVud2luZCBET00gZXZlbnQgbGlzdGVuZXJzIHVubmVjZXNzYXJpbHksIGluIGNhc2UgY2FsbGJhY2sgcmVuZGVycyBhXG4gICAgLy8gPFJvdXRlcj4gYW5kIGF0dGFjaGVzIGFub3RoZXIgaGlzdG9yeSBsaXN0ZW5lci5cbiAgICBpZiAodW5saXN0ZW4pIHtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gbWF0Y2g7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9tYXRjaC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZU1lbW9yeUhpc3Rvcnk7XG5cbnZhciBfdXNlUXVlcmllcyA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZVF1ZXJpZXMnKTtcblxudmFyIF91c2VRdWVyaWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZVF1ZXJpZXMpO1xuXG52YXIgX3VzZUJhc2VuYW1lID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvdXNlQmFzZW5hbWUnKTtcblxudmFyIF91c2VCYXNlbmFtZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VCYXNlbmFtZSk7XG5cbnZhciBfY3JlYXRlTWVtb3J5SGlzdG9yeSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL2NyZWF0ZU1lbW9yeUhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVNZW1vcnlIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZU1lbW9yeUhpc3RvcnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlIaXN0b3J5KG9wdGlvbnMpIHtcbiAgLy8gc2lnbmF0dXJlcyBhbmQgdHlwZSBjaGVja2luZyBkaWZmZXIgYmV0d2VlbiBgdXNlUm91dGVzYCBhbmRcbiAgLy8gYGNyZWF0ZU1lbW9yeUhpc3RvcnlgLCBoYXZlIHRvIGNyZWF0ZSBgbWVtb3J5SGlzdG9yeWAgZmlyc3QgYmVjYXVzZVxuICAvLyBgdXNlUXVlcmllc2AgZG9lc24ndCB1bmRlcnN0YW5kIHRoZSBzaWduYXR1cmVcbiAgdmFyIG1lbW9yeUhpc3RvcnkgPSAoMCwgX2NyZWF0ZU1lbW9yeUhpc3RvcnkyLmRlZmF1bHQpKG9wdGlvbnMpO1xuICB2YXIgY3JlYXRlSGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUhpc3RvcnkoKSB7XG4gICAgcmV0dXJuIG1lbW9yeUhpc3Rvcnk7XG4gIH07XG4gIHZhciBoaXN0b3J5ID0gKDAsIF91c2VRdWVyaWVzMi5kZWZhdWx0KSgoMCwgX3VzZUJhc2VuYW1lMi5kZWZhdWx0KShjcmVhdGVIaXN0b3J5KSkob3B0aW9ucyk7XG4gIGhpc3RvcnkuX192Ml9jb21wYXRpYmxlX18gPSB0cnVlO1xuICByZXR1cm4gaGlzdG9yeTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vayA9IHJlcXVpcmUoJy4vcnVuVHJhbnNpdGlvbkhvb2snKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ydW5UcmFuc2l0aW9uSG9vayk7XG5cbnZhciBfZGVwcmVjYXRlID0gcmVxdWlyZSgnLi9kZXByZWNhdGUnKTtcblxudmFyIF9kZXByZWNhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVwcmVjYXRlKTtcblxuZnVuY3Rpb24gdXNlQmFzZW5hbWUoY3JlYXRlSGlzdG9yeSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgICB2YXIgaGlzdG9yeSA9IGNyZWF0ZUhpc3Rvcnkob3B0aW9ucyk7XG5cbiAgICB2YXIgYmFzZW5hbWUgPSBvcHRpb25zLmJhc2VuYW1lO1xuXG4gICAgdmFyIGNoZWNrZWRCYXNlSHJlZiA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gY2hlY2tCYXNlSHJlZigpIHtcbiAgICAgIGlmIChjaGVja2VkQmFzZUhyZWYpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBBdXRvbWF0aWNhbGx5IHVzZSB0aGUgdmFsdWUgb2YgPGJhc2UgaHJlZj4gaW4gSFRNTFxuICAgICAgLy8gZG9jdW1lbnRzIGFzIGJhc2VuYW1lIGlmIGl0J3Mgbm90IGV4cGxpY2l0bHkgZ2l2ZW4uXG4gICAgICBpZiAoYmFzZW5hbWUgPT0gbnVsbCAmJiBfRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gICAgICAgIHZhciBiYXNlID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2Jhc2UnKVswXTtcbiAgICAgICAgdmFyIGJhc2VIcmVmID0gYmFzZSAmJiBiYXNlLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuXG4gICAgICAgIGlmIChiYXNlSHJlZiAhPSBudWxsKSB7XG4gICAgICAgICAgYmFzZW5hbWUgPSBiYXNlSHJlZjtcblxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ0F1dG9tYXRpY2FsbHkgc2V0dGluZyBiYXNlbmFtZSB1c2luZyA8YmFzZSBocmVmPiBpcyBkZXByZWNhdGVkIGFuZCB3aWxsICcgKyAnYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLiBUaGUgc2VtYW50aWNzIG9mIDxiYXNlIGhyZWY+IGFyZSAnICsgJ3N1YnRseSBkaWZmZXJlbnQgZnJvbSBiYXNlbmFtZS4gUGxlYXNlIHBhc3MgdGhlIGJhc2VuYW1lIGV4cGxpY2l0bHkgaW4gJyArICd0aGUgb3B0aW9ucyB0byBjcmVhdGVIaXN0b3J5JykgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2hlY2tlZEJhc2VIcmVmID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRCYXNlbmFtZShsb2NhdGlvbikge1xuICAgICAgY2hlY2tCYXNlSHJlZigpO1xuXG4gICAgICBpZiAoYmFzZW5hbWUgJiYgbG9jYXRpb24uYmFzZW5hbWUgPT0gbnVsbCkge1xuICAgICAgICBpZiAobG9jYXRpb24ucGF0aG5hbWUuaW5kZXhPZihiYXNlbmFtZSkgPT09IDApIHtcbiAgICAgICAgICBsb2NhdGlvbi5wYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lLnN1YnN0cmluZyhiYXNlbmFtZS5sZW5ndGgpO1xuICAgICAgICAgIGxvY2F0aW9uLmJhc2VuYW1lID0gYmFzZW5hbWU7XG5cbiAgICAgICAgICBpZiAobG9jYXRpb24ucGF0aG5hbWUgPT09ICcnKSBsb2NhdGlvbi5wYXRobmFtZSA9ICcvJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2NhdGlvbi5iYXNlbmFtZSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pIHtcbiAgICAgIGNoZWNrQmFzZUhyZWYoKTtcblxuICAgICAgaWYgKCFiYXNlbmFtZSkgcmV0dXJuIGxvY2F0aW9uO1xuXG4gICAgICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJykgbG9jYXRpb24gPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChsb2NhdGlvbik7XG5cbiAgICAgIHZhciBwbmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgICAgdmFyIG5vcm1hbGl6ZWRCYXNlbmFtZSA9IGJhc2VuYW1lLnNsaWNlKC0xKSA9PT0gJy8nID8gYmFzZW5hbWUgOiBiYXNlbmFtZSArICcvJztcbiAgICAgIHZhciBub3JtYWxpemVkUGF0aG5hbWUgPSBwbmFtZS5jaGFyQXQoMCkgPT09ICcvJyA/IHBuYW1lLnNsaWNlKDEpIDogcG5hbWU7XG4gICAgICB2YXIgcGF0aG5hbWUgPSBub3JtYWxpemVkQmFzZW5hbWUgKyBub3JtYWxpemVkUGF0aG5hbWU7XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHtcbiAgICAgICAgcGF0aG5hbWU6IHBhdGhuYW1lXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBPdmVycmlkZSBhbGwgcmVhZCBtZXRob2RzIHdpdGggYmFzZW5hbWUtYXdhcmUgdmVyc2lvbnMuXG4gICAgZnVuY3Rpb24gbGlzdGVuQmVmb3JlKGhvb2spIHtcbiAgICAgIHJldHVybiBoaXN0b3J5Lmxpc3RlbkJlZm9yZShmdW5jdGlvbiAobG9jYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIF9ydW5UcmFuc2l0aW9uSG9vazJbJ2RlZmF1bHQnXShob29rLCBhZGRCYXNlbmFtZShsb2NhdGlvbiksIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkubGlzdGVuKGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgICBsaXN0ZW5lcihhZGRCYXNlbmFtZShsb2NhdGlvbikpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gT3ZlcnJpZGUgYWxsIHdyaXRlIG1ldGhvZHMgd2l0aCBiYXNlbmFtZS1hd2FyZSB2ZXJzaW9ucy5cbiAgICBmdW5jdGlvbiBwdXNoKGxvY2F0aW9uKSB7XG4gICAgICBoaXN0b3J5LnB1c2gocHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZShsb2NhdGlvbikge1xuICAgICAgaGlzdG9yeS5yZXBsYWNlKHByZXBlbmRCYXNlbmFtZShsb2NhdGlvbikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhdGgobG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBoaXN0b3J5LmNyZWF0ZVBhdGgocHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlSHJlZihwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWRkQmFzZW5hbWUoaGlzdG9yeS5jcmVhdGVMb2NhdGlvbi5hcHBseShoaXN0b3J5LCBbcHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKV0uY29uY2F0KGFyZ3MpKSk7XG4gICAgfVxuXG4gICAgLy8gZGVwcmVjYXRlZFxuICAgIGZ1bmN0aW9uIHB1c2hTdGF0ZShzdGF0ZSwgcGF0aCkge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgcGF0aCA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgICBwdXNoKF9leHRlbmRzKHsgc3RhdGU6IHN0YXRlIH0sIHBhdGgpKTtcbiAgICB9XG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgZnVuY3Rpb24gcmVwbGFjZVN0YXRlKHN0YXRlLCBwYXRoKSB7XG4gICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSBwYXRoID0gX1BhdGhVdGlscy5wYXJzZVBhdGgocGF0aCk7XG5cbiAgICAgIHJlcGxhY2UoX2V4dGVuZHMoeyBzdGF0ZTogc3RhdGUgfSwgcGF0aCkpO1xuICAgIH1cblxuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgICBsaXN0ZW46IGxpc3RlbixcbiAgICAgIHB1c2g6IHB1c2gsXG4gICAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgICAgY3JlYXRlUGF0aDogY3JlYXRlUGF0aCxcbiAgICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgICBjcmVhdGVMb2NhdGlvbjogY3JlYXRlTG9jYXRpb24sXG5cbiAgICAgIHB1c2hTdGF0ZTogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXShwdXNoU3RhdGUsICdwdXNoU3RhdGUgaXMgZGVwcmVjYXRlZDsgdXNlIHB1c2ggaW5zdGVhZCcpLFxuICAgICAgcmVwbGFjZVN0YXRlOiBfZGVwcmVjYXRlMlsnZGVmYXVsdCddKHJlcGxhY2VTdGF0ZSwgJ3JlcGxhY2VTdGF0ZSBpcyBkZXByZWNhdGVkOyB1c2UgcmVwbGFjZSBpbnN0ZWFkJylcbiAgICB9KTtcbiAgfTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gdXNlQmFzZW5hbWU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vaGlzdG9yeS9saWIvdXNlQmFzZW5hbWUuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9BY3Rpb25zID0gcmVxdWlyZSgnLi9BY3Rpb25zJyk7XG5cbnZhciBfY3JlYXRlSGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlSGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZUhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlSGlzdG9yeSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlU3RvcmFnZShlbnRyaWVzKSB7XG4gIHJldHVybiBlbnRyaWVzLmZpbHRlcihmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gZW50cnkuc3RhdGU7XG4gIH0pLnJlZHVjZShmdW5jdGlvbiAobWVtbywgZW50cnkpIHtcbiAgICBtZW1vW2VudHJ5LmtleV0gPSBlbnRyeS5zdGF0ZTtcbiAgICByZXR1cm4gbWVtbztcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlIaXN0b3J5KCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucyA9IHsgZW50cmllczogb3B0aW9ucyB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7IGVudHJpZXM6IFtvcHRpb25zXSB9O1xuICB9XG5cbiAgdmFyIGhpc3RvcnkgPSBfY3JlYXRlSGlzdG9yeTJbJ2RlZmF1bHQnXShfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgIGdldEN1cnJlbnRMb2NhdGlvbjogZ2V0Q3VycmVudExvY2F0aW9uLFxuICAgIGZpbmlzaFRyYW5zaXRpb246IGZpbmlzaFRyYW5zaXRpb24sXG4gICAgc2F2ZVN0YXRlOiBzYXZlU3RhdGUsXG4gICAgZ286IGdvXG4gIH0pKTtcblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zO1xuICB2YXIgZW50cmllcyA9IF9vcHRpb25zLmVudHJpZXM7XG4gIHZhciBjdXJyZW50ID0gX29wdGlvbnMuY3VycmVudDtcblxuICBpZiAodHlwZW9mIGVudHJpZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgZW50cmllcyA9IFtlbnRyaWVzXTtcbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShlbnRyaWVzKSkge1xuICAgIGVudHJpZXMgPSBbJy8nXTtcbiAgfVxuXG4gIGVudHJpZXMgPSBlbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICB2YXIga2V5ID0gaGlzdG9yeS5jcmVhdGVLZXkoKTtcblxuICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSByZXR1cm4geyBwYXRobmFtZTogZW50cnksIGtleToga2V5IH07XG5cbiAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnb2JqZWN0JyAmJiBlbnRyeSkgcmV0dXJuIF9leHRlbmRzKHt9LCBlbnRyeSwgeyBrZXk6IGtleSB9KTtcblxuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlLCAnVW5hYmxlIHRvIGNyZWF0ZSBoaXN0b3J5IGVudHJ5IGZyb20gJXMnLCBlbnRyeSkgOiBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfSk7XG5cbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGN1cnJlbnQgPSBlbnRyaWVzLmxlbmd0aCAtIDE7XG4gIH0gZWxzZSB7XG4gICAgIShjdXJyZW50ID49IDAgJiYgY3VycmVudCA8IGVudHJpZXMubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlLCAnQ3VycmVudCBpbmRleCBtdXN0IGJlID49IDAgYW5kIDwgJXMsIHdhcyAlcycsIGVudHJpZXMubGVuZ3RoLCBjdXJyZW50KSA6IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIHN0b3JhZ2UgPSBjcmVhdGVTdGF0ZVN0b3JhZ2UoZW50cmllcyk7XG5cbiAgZnVuY3Rpb24gc2F2ZVN0YXRlKGtleSwgc3RhdGUpIHtcbiAgICBzdG9yYWdlW2tleV0gPSBzdGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRTdGF0ZShrZXkpIHtcbiAgICByZXR1cm4gc3RvcmFnZVtrZXldO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbY3VycmVudF07XG4gICAgdmFyIGJhc2VuYW1lID0gZW50cnkuYmFzZW5hbWU7XG4gICAgdmFyIHBhdGhuYW1lID0gZW50cnkucGF0aG5hbWU7XG4gICAgdmFyIHNlYXJjaCA9IGVudHJ5LnNlYXJjaDtcblxuICAgIHZhciBwYXRoID0gKGJhc2VuYW1lIHx8ICcnKSArIHBhdGhuYW1lICsgKHNlYXJjaCB8fCAnJyk7XG5cbiAgICB2YXIga2V5ID0gdW5kZWZpbmVkLFxuICAgICAgICBzdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICBpZiAoZW50cnkua2V5KSB7XG4gICAgICBrZXkgPSBlbnRyeS5rZXk7XG4gICAgICBzdGF0ZSA9IHJlYWRTdGF0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBoaXN0b3J5LmNyZWF0ZUtleSgpO1xuICAgICAgc3RhdGUgPSBudWxsO1xuICAgICAgZW50cnkua2V5ID0ga2V5O1xuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbiA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlTG9jYXRpb24oX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7IHN0YXRlOiBzdGF0ZSB9KSwgdW5kZWZpbmVkLCBrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuR28obikge1xuICAgIHZhciBpbmRleCA9IGN1cnJlbnQgKyBuO1xuICAgIHJldHVybiBpbmRleCA+PSAwICYmIGluZGV4IDwgZW50cmllcy5sZW5ndGg7XG4gIH1cblxuICBmdW5jdGlvbiBnbyhuKSB7XG4gICAgaWYgKG4pIHtcbiAgICAgIGlmICghY2FuR28obikpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnQ2Fubm90IGdvKCVzKSB0aGVyZSBpcyBub3QgZW5vdWdoIGhpc3RvcnknLCBuKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50ICs9IG47XG5cbiAgICAgIHZhciBjdXJyZW50TG9jYXRpb24gPSBnZXRDdXJyZW50TG9jYXRpb24oKTtcblxuICAgICAgLy8gY2hhbmdlIGFjdGlvbiB0byBQT1BcbiAgICAgIGhpc3RvcnkudHJhbnNpdGlvblRvKF9leHRlbmRzKHt9LCBjdXJyZW50TG9jYXRpb24sIHsgYWN0aW9uOiBfQWN0aW9ucy5QT1AgfSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaFRyYW5zaXRpb24obG9jYXRpb24pIHtcbiAgICBzd2l0Y2ggKGxvY2F0aW9uLmFjdGlvbikge1xuICAgICAgY2FzZSBfQWN0aW9ucy5QVVNIOlxuICAgICAgICBjdXJyZW50ICs9IDE7XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlIG5vdCBvbiB0aGUgdG9wIG9mIHN0YWNrXG4gICAgICAgIC8vIHJlbW92ZSByZXN0IGFuZCBwdXNoIG5ld1xuICAgICAgICBpZiAoY3VycmVudCA8IGVudHJpZXMubGVuZ3RoKSBlbnRyaWVzLnNwbGljZShjdXJyZW50KTtcblxuICAgICAgICBlbnRyaWVzLnB1c2gobG9jYXRpb24pO1xuICAgICAgICBzYXZlU3RhdGUobG9jYXRpb24ua2V5LCBsb2NhdGlvbi5zdGF0ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfQWN0aW9ucy5SRVBMQUNFOlxuICAgICAgICBlbnRyaWVzW2N1cnJlbnRdID0gbG9jYXRpb247XG4gICAgICAgIHNhdmVTdGF0ZShsb2NhdGlvbi5rZXksIGxvY2F0aW9uLnN0YXRlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZU1lbW9yeUhpc3Rvcnk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vaGlzdG9yeS9saWIvY3JlYXRlTWVtb3J5SGlzdG9yeS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IHVzZVJvdXRlckhpc3Rvcnk7XG5cbnZhciBfdXNlUXVlcmllcyA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZVF1ZXJpZXMnKTtcblxudmFyIF91c2VRdWVyaWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZVF1ZXJpZXMpO1xuXG52YXIgX3VzZUJhc2VuYW1lID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvdXNlQmFzZW5hbWUnKTtcblxudmFyIF91c2VCYXNlbmFtZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VCYXNlbmFtZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIHVzZVJvdXRlckhpc3RvcnkoY3JlYXRlSGlzdG9yeSkge1xuICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgaGlzdG9yeSA9ICgwLCBfdXNlUXVlcmllczIuZGVmYXVsdCkoKDAsIF91c2VCYXNlbmFtZTIuZGVmYXVsdCkoY3JlYXRlSGlzdG9yeSkpKG9wdGlvbnMpO1xuICAgIGhpc3RvcnkuX192Ml9jb21wYXRpYmxlX18gPSB0cnVlO1xuICAgIHJldHVybiBoaXN0b3J5O1xuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvdXNlUm91dGVySGlzdG9yeS5qc1xuICoqLyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX1JvdXRlckNvbnRleHQgPSByZXF1aXJlKCcuL1JvdXRlckNvbnRleHQnKTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRlckNvbnRleHQpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBtaWRkbGV3YXJlcyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG1pZGRsZXdhcmVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBtaWRkbGV3YXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChtaWRkbGV3YXJlLCBpbmRleCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkobWlkZGxld2FyZS5yZW5kZXJSb3V0ZXJDb250ZXh0IHx8IG1pZGRsZXdhcmUucmVuZGVyUm91dGVDb21wb25lbnQsICdUaGUgbWlkZGxld2FyZSBzcGVjaWZpZWQgYXQgaW5kZXggJyArIGluZGV4ICsgJyBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgJyArICdhIHZhbGlkIFJlYWN0IFJvdXRlciBtaWRkbGV3YXJlLicpIDogdm9pZCAwO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHdpdGhDb250ZXh0ID0gbWlkZGxld2FyZXMubWFwKGZ1bmN0aW9uIChtaWRkbGV3YXJlKSB7XG4gICAgcmV0dXJuIG1pZGRsZXdhcmUucmVuZGVyUm91dGVyQ29udGV4dDtcbiAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICB2YXIgd2l0aENvbXBvbmVudCA9IG1pZGRsZXdhcmVzLm1hcChmdW5jdGlvbiAobWlkZGxld2FyZSkge1xuICAgIHJldHVybiBtaWRkbGV3YXJlLnJlbmRlclJvdXRlQ29tcG9uZW50O1xuICB9KS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgdmFyIG1ha2VDcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gbWFrZUNyZWF0ZUVsZW1lbnQoKSB7XG4gICAgdmFyIGJhc2VDcmVhdGVFbGVtZW50ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gX3JlYWN0LmNyZWF0ZUVsZW1lbnQgOiBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChDb21wb25lbnQsIHByb3BzKSB7XG4gICAgICByZXR1cm4gd2l0aENvbXBvbmVudC5yZWR1Y2VSaWdodChmdW5jdGlvbiAocHJldmlvdXMsIHJlbmRlclJvdXRlQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiByZW5kZXJSb3V0ZUNvbXBvbmVudChwcmV2aW91cywgcHJvcHMpO1xuICAgICAgfSwgYmFzZUNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBwcm9wcykpO1xuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChyZW5kZXJQcm9wcykge1xuICAgIHJldHVybiB3aXRoQ29udGV4dC5yZWR1Y2VSaWdodChmdW5jdGlvbiAocHJldmlvdXMsIHJlbmRlclJvdXRlckNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZW5kZXJSb3V0ZXJDb250ZXh0KHByZXZpb3VzLCByZW5kZXJQcm9wcyk7XG4gICAgfSwgX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX1JvdXRlckNvbnRleHQyLmRlZmF1bHQsIF9leHRlbmRzKHt9LCByZW5kZXJQcm9wcywge1xuICAgICAgY3JlYXRlRWxlbWVudDogbWFrZUNyZWF0ZUVsZW1lbnQocmVuZGVyUHJvcHMuY3JlYXRlRWxlbWVudClcbiAgICB9KSkpO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3JlYWN0LXJvdXRlci9saWIvYXBwbHlSb3V0ZXJNaWRkbGV3YXJlLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NyZWF0ZUJyb3dzZXJIaXN0b3J5ID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvY3JlYXRlQnJvd3Nlckhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVCcm93c2VySGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVCcm93c2VySGlzdG9yeSk7XG5cbnZhciBfY3JlYXRlUm91dGVySGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlUm91dGVySGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZVJvdXRlckhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlUm91dGVySGlzdG9yeSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9ICgwLCBfY3JlYXRlUm91dGVySGlzdG9yeTIuZGVmYXVsdCkoX2NyZWF0ZUJyb3dzZXJIaXN0b3J5Mi5kZWZhdWx0KTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2Jyb3dzZXJIaXN0b3J5LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJy4vQWN0aW9ucycpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBfRE9NVXRpbHMgPSByZXF1aXJlKCcuL0RPTVV0aWxzJyk7XG5cbnZhciBfRE9NU3RhdGVTdG9yYWdlID0gcmVxdWlyZSgnLi9ET01TdGF0ZVN0b3JhZ2UnKTtcblxudmFyIF9jcmVhdGVET01IaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVET01IaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlRE9NSGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVET01IaXN0b3J5KTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgaGlzdG9yeSBvYmplY3QgdGhhdCB1c2VzIEhUTUw1J3MgaGlzdG9yeSBBUElcbiAqIChwdXNoU3RhdGUsIHJlcGxhY2VTdGF0ZSwgYW5kIHRoZSBwb3BzdGF0ZSBldmVudCkgdG8gbWFuYWdlIGhpc3RvcnkuXG4gKiBUaGlzIGlzIHRoZSByZWNvbW1lbmRlZCBtZXRob2Qgb2YgbWFuYWdpbmcgaGlzdG9yeSBpbiBicm93c2VycyBiZWNhdXNlXG4gKiBpdCBwcm92aWRlcyB0aGUgY2xlYW5lc3QgVVJMcy5cbiAqXG4gKiBOb3RlOiBJbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IHRoZSBIVE1MNSBoaXN0b3J5IEFQSSBmdWxsXG4gKiBwYWdlIHJlbG9hZHMgd2lsbCBiZSB1c2VkIHRvIHByZXNlcnZlIFVSTHMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICFfRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UsICdCcm93c2VyIGhpc3RvcnkgbmVlZHMgYSBET00nKSA6IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIHZhciBmb3JjZVJlZnJlc2ggPSBvcHRpb25zLmZvcmNlUmVmcmVzaDtcblxuICB2YXIgaXNTdXBwb3J0ZWQgPSBfRE9NVXRpbHMuc3VwcG9ydHNIaXN0b3J5KCk7XG4gIHZhciB1c2VSZWZyZXNoID0gIWlzU3VwcG9ydGVkIHx8IGZvcmNlUmVmcmVzaDtcblxuICBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24oaGlzdG9yeVN0YXRlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGhpc3RvcnlTdGF0ZSA9IGhpc3RvcnlTdGF0ZSB8fCB3aW5kb3cuaGlzdG9yeS5zdGF0ZSB8fCB7fTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoaXN0b3J5U3RhdGUgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgcGF0aCA9IF9ET01VdGlscy5nZXRXaW5kb3dQYXRoKCk7XG4gICAgdmFyIF9oaXN0b3J5U3RhdGUgPSBoaXN0b3J5U3RhdGU7XG4gICAgdmFyIGtleSA9IF9oaXN0b3J5U3RhdGUua2V5O1xuXG4gICAgdmFyIHN0YXRlID0gdW5kZWZpbmVkO1xuICAgIGlmIChrZXkpIHtcbiAgICAgIHN0YXRlID0gX0RPTVN0YXRlU3RvcmFnZS5yZWFkU3RhdGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUgPSBudWxsO1xuICAgICAga2V5ID0gaGlzdG9yeS5jcmVhdGVLZXkoKTtcblxuICAgICAgaWYgKGlzU3VwcG9ydGVkKSB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoX2V4dGVuZHMoe30sIGhpc3RvcnlTdGF0ZSwgeyBrZXk6IGtleSB9KSwgbnVsbCk7XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uID0gX1BhdGhVdGlscy5wYXJzZVBhdGgocGF0aCk7XG5cbiAgICByZXR1cm4gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbihfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHsgc3RhdGU6IHN0YXRlIH0pLCB1bmRlZmluZWQsIGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydFBvcFN0YXRlTGlzdGVuZXIoX3JlZikge1xuICAgIHZhciB0cmFuc2l0aW9uVG8gPSBfcmVmLnRyYW5zaXRpb25UbztcblxuICAgIGZ1bmN0aW9uIHBvcFN0YXRlTGlzdGVuZXIoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5zdGF0ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIElnbm9yZSBleHRyYW5lb3VzIHBvcHN0YXRlIGV2ZW50cyBpbiBXZWJLaXQuXG5cbiAgICAgIHRyYW5zaXRpb25UbyhnZXRDdXJyZW50TG9jYXRpb24oZXZlbnQuc3RhdGUpKTtcbiAgICB9XG5cbiAgICBfRE9NVXRpbHMuYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csICdwb3BzdGF0ZScsIHBvcFN0YXRlTGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIF9ET01VdGlscy5yZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgJ3BvcHN0YXRlJywgcG9wU3RhdGVMaXN0ZW5lcik7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaFRyYW5zaXRpb24obG9jYXRpb24pIHtcbiAgICB2YXIgYmFzZW5hbWUgPSBsb2NhdGlvbi5iYXNlbmFtZTtcbiAgICB2YXIgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICB2YXIgc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoO1xuICAgIHZhciBoYXNoID0gbG9jYXRpb24uaGFzaDtcbiAgICB2YXIgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcbiAgICB2YXIgYWN0aW9uID0gbG9jYXRpb24uYWN0aW9uO1xuICAgIHZhciBrZXkgPSBsb2NhdGlvbi5rZXk7XG5cbiAgICBpZiAoYWN0aW9uID09PSBfQWN0aW9ucy5QT1ApIHJldHVybjsgLy8gTm90aGluZyB0byBkby5cblxuICAgIF9ET01TdGF0ZVN0b3JhZ2Uuc2F2ZVN0YXRlKGtleSwgc3RhdGUpO1xuXG4gICAgdmFyIHBhdGggPSAoYmFzZW5hbWUgfHwgJycpICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xuICAgIHZhciBoaXN0b3J5U3RhdGUgPSB7XG4gICAgICBrZXk6IGtleVxuICAgIH07XG5cbiAgICBpZiAoYWN0aW9uID09PSBfQWN0aW9ucy5QVVNIKSB7XG4gICAgICBpZiAodXNlUmVmcmVzaCkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHBhdGg7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gUHJldmVudCBsb2NhdGlvbiB1cGRhdGUuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShoaXN0b3J5U3RhdGUsIG51bGwsIHBhdGgpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJFUExBQ0VcbiAgICAgIGlmICh1c2VSZWZyZXNoKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHBhdGgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFByZXZlbnQgbG9jYXRpb24gdXBkYXRlLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoaGlzdG9yeVN0YXRlLCBudWxsLCBwYXRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBoaXN0b3J5ID0gX2NyZWF0ZURPTUhpc3RvcnkyWydkZWZhdWx0J10oX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICBnZXRDdXJyZW50TG9jYXRpb246IGdldEN1cnJlbnRMb2NhdGlvbixcbiAgICBmaW5pc2hUcmFuc2l0aW9uOiBmaW5pc2hUcmFuc2l0aW9uLFxuICAgIHNhdmVTdGF0ZTogX0RPTVN0YXRlU3RvcmFnZS5zYXZlU3RhdGVcbiAgfSkpO1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMCxcbiAgICAgIHN0b3BQb3BTdGF0ZUxpc3RlbmVyID0gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIGxpc3RlbkJlZm9yZShsaXN0ZW5lcikge1xuICAgIGlmICgrK2xpc3RlbmVyQ291bnQgPT09IDEpIHN0b3BQb3BTdGF0ZUxpc3RlbmVyID0gc3RhcnRQb3BTdGF0ZUxpc3RlbmVyKGhpc3RvcnkpO1xuXG4gICAgdmFyIHVubGlzdGVuID0gaGlzdG9yeS5saXN0ZW5CZWZvcmUobGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHVubGlzdGVuKCk7XG5cbiAgICAgIGlmICgtLWxpc3RlbmVyQ291bnQgPT09IDApIHN0b3BQb3BTdGF0ZUxpc3RlbmVyKCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIGlmICgrK2xpc3RlbmVyQ291bnQgPT09IDEpIHN0b3BQb3BTdGF0ZUxpc3RlbmVyID0gc3RhcnRQb3BTdGF0ZUxpc3RlbmVyKGhpc3RvcnkpO1xuXG4gICAgdmFyIHVubGlzdGVuID0gaGlzdG9yeS5saXN0ZW4obGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHVubGlzdGVuKCk7XG5cbiAgICAgIGlmICgtLWxpc3RlbmVyQ291bnQgPT09IDApIHN0b3BQb3BTdGF0ZUxpc3RlbmVyKCk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gcmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKSB7XG4gICAgaWYgKCsrbGlzdGVuZXJDb3VudCA9PT0gMSkgc3RvcFBvcFN0YXRlTGlzdGVuZXIgPSBzdGFydFBvcFN0YXRlTGlzdGVuZXIoaGlzdG9yeSk7XG5cbiAgICBoaXN0b3J5LnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vayk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKSB7XG4gICAgaGlzdG9yeS51bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vayk7XG5cbiAgICBpZiAoLS1saXN0ZW5lckNvdW50ID09PSAwKSBzdG9wUG9wU3RhdGVMaXN0ZW5lcigpO1xuICB9XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgbGlzdGVuQmVmb3JlOiBsaXN0ZW5CZWZvcmUsXG4gICAgbGlzdGVuOiBsaXN0ZW4sXG4gICAgcmVnaXN0ZXJUcmFuc2l0aW9uSG9vazogcmVnaXN0ZXJUcmFuc2l0aW9uSG9vayxcbiAgICB1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2s6IHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9va1xuICB9KTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gY3JlYXRlQnJvd3Nlckhpc3Rvcnk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vaGlzdG9yeS9saWIvY3JlYXRlQnJvd3Nlckhpc3RvcnkuanNcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChjcmVhdGVIaXN0b3J5KSB7XG4gIHZhciBoaXN0b3J5ID0gdm9pZCAwO1xuICBpZiAoY2FuVXNlRE9NKSBoaXN0b3J5ID0gKDAsIF91c2VSb3V0ZXJIaXN0b3J5Mi5kZWZhdWx0KShjcmVhdGVIaXN0b3J5KSgpO1xuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbnZhciBfdXNlUm91dGVySGlzdG9yeSA9IHJlcXVpcmUoJy4vdXNlUm91dGVySGlzdG9yeScpO1xuXG52YXIgX3VzZVJvdXRlckhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlUm91dGVySGlzdG9yeSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmVhY3Qtcm91dGVyL2xpYi9jcmVhdGVSb3V0ZXJIaXN0b3J5LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NyZWF0ZUhhc2hIaXN0b3J5ID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvY3JlYXRlSGFzaEhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVIYXNoSGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVIYXNoSGlzdG9yeSk7XG5cbnZhciBfY3JlYXRlUm91dGVySGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlUm91dGVySGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZVJvdXRlckhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlUm91dGVySGlzdG9yeSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9ICgwLCBfY3JlYXRlUm91dGVySGlzdG9yeTIuZGVmYXVsdCkoX2NyZWF0ZUhhc2hIaXN0b3J5Mi5kZWZhdWx0KTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2hhc2hIaXN0b3J5LmpzXG4gKiovIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciB1dWlkID0gcmVxdWlyZSgnbm9kZS11dWlkJyk7XG5cbnZhciBUb2RvTGlzdCA9IHJlcXVpcmUoJ1RvZG9MaXN0Jyk7XG52YXIgQWRkVG9kbyA9IHJlcXVpcmUoJ0FkZFRvZG8nKTtcbnZhciBUb2RvU2VhcmNoID0gcmVxdWlyZSgnVG9kb1NlYXJjaCcpO1xudmFyIFRvZG9BUEk9IHJlcXVpcmUoJ1RvZG9BUEknKTtcblxuXG5cbnZhciBUb2RvQXBwID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzaG93Q29tcGxldGVkOiBmYWxzZSxcbiAgICAgIHNlYXJjaFRleHQ6IFwiXCIsXG4gICAgICB0b2RvczogVG9kb0FQSS5nZXRUb2RvcygpXG4gICAgfTtcbiAgfSxcbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICBUb2RvQVBJLnNldFRvZG9zKHRoaXMuc3RhdGUudG9kb3MpO1xuICB9LFxuICBoYW5kbGVUb2dnbGU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIHVwZGF0ZWRUb2RvcyA9IHRoaXMuc3RhdGUudG9kb3MubWFwKCh0b2RvKSA9PiB7XG4gICAgICBpZiAodG9kby5pZCA9PT0gaWQpIHtcbiAgICAgICAgdG9kby5jb21wbGV0ZWQgPSAhdG9kby5jb21wbGV0ZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9kbztcbiAgICB9KTtcblxuICAgIHRoaXMuc2V0U3RhdGUoe3RvZG9zOnVwZGF0ZWRUb2Rvc30pO1xuXG4gIH0sXG4gIGhhbmRsZVNlYXJjaDogZnVuY3Rpb24oc2hvd0NvbXBsZXRlZCwgc2VhcmNoVGV4dCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgc2hvd0NvbXBsZXRlZDogc2hvd0NvbXBsZXRlZCxcbiAgICAgIHNlYXJjaFRleHQ6IHNlYXJjaFRleHQudG9Mb3dlckNhc2UoKVxuICAgIH0pXG4gIH0sXG4gIGhhbmRsZUFkZFRvZG86IGZ1bmN0aW9uKHRleHQpe1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgdG9kb3M6IFtcbiAgICAgICAgLi4udGhpcy5zdGF0ZS50b2RvcyxcbiAgICAgICAge1xuICAgICAgICAgIGlkOiB1dWlkKCksXG4gICAgICAgICAgdGV4dDp0ZXh0XG4gICAgICAgIH1cblxuICAgICAgXVxuICAgIH0pO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB7dG9kb3N9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4oXG4gICAgICA8ZGl2PlxuICAgICAgICA8VG9kb1NlYXJjaCBvblNlYXJjaCA9IHt0aGlzLmhhbmRsZVNlYXJjaH0vPlxuICAgICAgICA8VG9kb0xpc3QgdG9kb3M9e3RvZG9zfSBvblRvZ2dsZT17dGhpcy5oYW5kbGVUb2dnbGV9Lz5cbiAgICAgICAgPEFkZFRvZG8gb25BZGRUb2RvPXt0aGlzLmhhbmRsZUFkZFRvZG99Lz5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVG9kb0FwcDtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL2NvbXBvbmVudHMvVG9kb0FwcC5qc3hcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9pbmRleC5qcyEuL2FwcC5zY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLy4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9pbmRleC5qcyEuL2FwcC5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzIS4vYXBwLnNjc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3N0eWxlLWxvYWRlciEuL34vY3NzLWxvYWRlciEuL34vc2Fzcy1sb2FkZXIhLi9hcHAvc3R5bGVzL2FwcC5zY3NzXG4gKiogbW9kdWxlIGlkID0gMjMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBjaGFyc2V0IFxcXCJVVEYtOFxcXCI7XFxuLyoqXFxuICogRm91bmRhdGlvbiBmb3IgU2l0ZXMgYnkgWlVSQlxcbiAqIFZlcnNpb24gNi4yLjNcXG4gKiBmb3VuZGF0aW9uLnp1cmIuY29tXFxuICogTGljZW5zZWQgdW5kZXIgTUlUIE9wZW4gU291cmNlXFxuICovXFxuLyohIG5vcm1hbGl6ZS5jc3MgdjMuMC4zIHwgTUlUIExpY2Vuc2UgfCBnaXRodWIuY29tL25lY29sYXMvbm9ybWFsaXplLmNzcyAqL1xcbi8qKlxcbiAgICogMS4gU2V0IGRlZmF1bHQgZm9udCBmYW1pbHkgdG8gc2Fucy1zZXJpZi5cXG4gICAqIDIuIFByZXZlbnQgaU9TIGFuZCBJRSB0ZXh0IHNpemUgYWRqdXN0IGFmdGVyIGRldmljZSBvcmllbnRhdGlvbiBjaGFuZ2UsXFxuICAgKiAgICB3aXRob3V0IGRpc2FibGluZyB1c2VyIHpvb20uXFxuICAgKi9cXG5odG1sIHtcXG4gIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xcbiAgLyogMSAqL1xcbiAgLW1zLXRleHQtc2l6ZS1hZGp1c3Q6IDEwMCU7XFxuICAvKiAyICovXFxuICAtd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6IDEwMCU7XFxuICAvKiAyICovIH1cXG5cXG4vKipcXG4gICAqIFJlbW92ZSBkZWZhdWx0IG1hcmdpbi5cXG4gICAqL1xcbmJvZHkge1xcbiAgbWFyZ2luOiAwOyB9XFxuXFxuLyogSFRNTDUgZGlzcGxheSBkZWZpbml0aW9uc1xcbiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG4vKipcXG4gICAqIENvcnJlY3QgYGJsb2NrYCBkaXNwbGF5IG5vdCBkZWZpbmVkIGZvciBhbnkgSFRNTDUgZWxlbWVudCBpbiBJRSA4LzkuXFxuICAgKiBDb3JyZWN0IGBibG9ja2AgZGlzcGxheSBub3QgZGVmaW5lZCBmb3IgYGRldGFpbHNgIG9yIGBzdW1tYXJ5YCBpbiBJRSAxMC8xMVxcbiAgICogYW5kIEZpcmVmb3guXFxuICAgKiBDb3JyZWN0IGBibG9ja2AgZGlzcGxheSBub3QgZGVmaW5lZCBmb3IgYG1haW5gIGluIElFIDExLlxcbiAgICovXFxuYXJ0aWNsZSxcXG5hc2lkZSxcXG5kZXRhaWxzLFxcbmZpZ2NhcHRpb24sXFxuZmlndXJlLFxcbmZvb3RlcixcXG5oZWFkZXIsXFxuaGdyb3VwLFxcbm1haW4sXFxubWVudSxcXG5uYXYsXFxuc2VjdGlvbixcXG5zdW1tYXJ5IHtcXG4gIGRpc3BsYXk6IGJsb2NrOyB9XFxuXFxuLyoqXFxuICAgKiAxLiBDb3JyZWN0IGBpbmxpbmUtYmxvY2tgIGRpc3BsYXkgbm90IGRlZmluZWQgaW4gSUUgOC85LlxcbiAgICogMi4gTm9ybWFsaXplIHZlcnRpY2FsIGFsaWdubWVudCBvZiBgcHJvZ3Jlc3NgIGluIENocm9tZSwgRmlyZWZveCwgYW5kIE9wZXJhLlxcbiAgICovXFxuYXVkaW8sXFxuY2FudmFzLFxcbnByb2dyZXNzLFxcbnZpZGVvIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIC8qIDEgKi9cXG4gIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG4gIC8qIDIgKi8gfVxcblxcbi8qKlxcbiAgICogUHJldmVudCBtb2Rlcm4gYnJvd3NlcnMgZnJvbSBkaXNwbGF5aW5nIGBhdWRpb2Agd2l0aG91dCBjb250cm9scy5cXG4gICAqIFJlbW92ZSBleGNlc3MgaGVpZ2h0IGluIGlPUyA1IGRldmljZXMuXFxuICAgKi9cXG5hdWRpbzpub3QoW2NvbnRyb2xzXSkge1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIGhlaWdodDogMDsgfVxcblxcbi8qKlxcbiAgICogQWRkcmVzcyBgW2hpZGRlbl1gIHN0eWxpbmcgbm90IHByZXNlbnQgaW4gSUUgOC85LzEwLlxcbiAgICogSGlkZSB0aGUgYHRlbXBsYXRlYCBlbGVtZW50IGluIElFIDgvOS8xMC8xMSwgU2FmYXJpLCBhbmQgRmlyZWZveCA8IDIyLlxcbiAgICovXFxuW2hpZGRlbl0sXFxudGVtcGxhdGUge1xcbiAgZGlzcGxheTogbm9uZTsgfVxcblxcbi8qIExpbmtzXFxuICAgICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcbi8qKlxcbiAgICogUmVtb3ZlIHRoZSBncmF5IGJhY2tncm91bmQgY29sb3IgZnJvbSBhY3RpdmUgbGlua3MgaW4gSUUgMTAuXFxuICAgKi9cXG5hIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50OyB9XFxuXFxuLyoqXFxuICAgKiBJbXByb3ZlIHJlYWRhYmlsaXR5IG9mIGZvY3VzZWQgZWxlbWVudHMgd2hlbiB0aGV5IGFyZSBhbHNvIGluIGFuXFxuICAgKiBhY3RpdmUvaG92ZXIgc3RhdGUuXFxuICAgKi9cXG5hOmFjdGl2ZSxcXG5hOmhvdmVyIHtcXG4gIG91dGxpbmU6IDA7IH1cXG5cXG4vKiBUZXh0LWxldmVsIHNlbWFudGljc1xcbiAgICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG4vKipcXG4gICAqIEFkZHJlc3Mgc3R5bGluZyBub3QgcHJlc2VudCBpbiBJRSA4LzkvMTAvMTEsIFNhZmFyaSwgYW5kIENocm9tZS5cXG4gICAqL1xcbmFiYnJbdGl0bGVdIHtcXG4gIGJvcmRlci1ib3R0b206IDFweCBkb3R0ZWQ7IH1cXG5cXG4vKipcXG4gICAqIEFkZHJlc3Mgc3R5bGUgc2V0IHRvIGBib2xkZXJgIGluIEZpcmVmb3ggNCssIFNhZmFyaSwgYW5kIENocm9tZS5cXG4gICAqL1xcbmIsXFxuc3Ryb25nIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkOyB9XFxuXFxuLyoqXFxuICAgKiBBZGRyZXNzIHN0eWxpbmcgbm90IHByZXNlbnQgaW4gU2FmYXJpIGFuZCBDaHJvbWUuXFxuICAgKi9cXG5kZm4ge1xcbiAgZm9udC1zdHlsZTogaXRhbGljOyB9XFxuXFxuLyoqXFxuICAgKiBBZGRyZXNzIHZhcmlhYmxlIGBoMWAgZm9udC1zaXplIGFuZCBtYXJnaW4gd2l0aGluIGBzZWN0aW9uYCBhbmQgYGFydGljbGVgXFxuICAgKiBjb250ZXh0cyBpbiBGaXJlZm94IDQrLCBTYWZhcmksIGFuZCBDaHJvbWUuXFxuICAgKi9cXG5oMSB7XFxuICBmb250LXNpemU6IDJlbTtcXG4gIG1hcmdpbjogMC42N2VtIDA7IH1cXG5cXG4vKipcXG4gICAqIEFkZHJlc3Mgc3R5bGluZyBub3QgcHJlc2VudCBpbiBJRSA4LzkuXFxuICAgKi9cXG5tYXJrIHtcXG4gIGJhY2tncm91bmQ6ICNmZjA7XFxuICBjb2xvcjogIzAwMDsgfVxcblxcbi8qKlxcbiAgICogQWRkcmVzcyBpbmNvbnNpc3RlbnQgYW5kIHZhcmlhYmxlIGZvbnQgc2l6ZSBpbiBhbGwgYnJvd3NlcnMuXFxuICAgKi9cXG5zbWFsbCB7XFxuICBmb250LXNpemU6IDgwJTsgfVxcblxcbi8qKlxcbiAgICogUHJldmVudCBgc3ViYCBhbmQgYHN1cGAgYWZmZWN0aW5nIGBsaW5lLWhlaWdodGAgaW4gYWxsIGJyb3dzZXJzLlxcbiAgICovXFxuc3ViLFxcbnN1cCB7XFxuICBmb250LXNpemU6IDc1JTtcXG4gIGxpbmUtaGVpZ2h0OiAwO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lOyB9XFxuXFxuc3VwIHtcXG4gIHRvcDogLTAuNWVtOyB9XFxuXFxuc3ViIHtcXG4gIGJvdHRvbTogLTAuMjVlbTsgfVxcblxcbi8qIEVtYmVkZGVkIGNvbnRlbnRcXG4gICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuLyoqXFxuICAgKiBSZW1vdmUgYm9yZGVyIHdoZW4gaW5zaWRlIGBhYCBlbGVtZW50IGluIElFIDgvOS8xMC5cXG4gICAqL1xcbmltZyB7XFxuICBib3JkZXI6IDA7IH1cXG5cXG4vKipcXG4gICAqIENvcnJlY3Qgb3ZlcmZsb3cgbm90IGhpZGRlbiBpbiBJRSA5LzEwLzExLlxcbiAgICovXFxuc3ZnOm5vdCg6cm9vdCkge1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjsgfVxcblxcbi8qIEdyb3VwaW5nIGNvbnRlbnRcXG4gICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuLyoqXFxuICAgKiBBZGRyZXNzIG1hcmdpbiBub3QgcHJlc2VudCBpbiBJRSA4LzkgYW5kIFNhZmFyaS5cXG4gICAqL1xcbmZpZ3VyZSB7XFxuICBtYXJnaW46IDFlbSA0MHB4OyB9XFxuXFxuLyoqXFxuICAgKiBBZGRyZXNzIGRpZmZlcmVuY2VzIGJldHdlZW4gRmlyZWZveCBhbmQgb3RoZXIgYnJvd3NlcnMuXFxuICAgKi9cXG5ociB7XFxuICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcXG4gIGhlaWdodDogMDsgfVxcblxcbi8qKlxcbiAgICogQ29udGFpbiBvdmVyZmxvdyBpbiBhbGwgYnJvd3NlcnMuXFxuICAgKi9cXG5wcmUge1xcbiAgb3ZlcmZsb3c6IGF1dG87IH1cXG5cXG4vKipcXG4gICAqIEFkZHJlc3Mgb2RkIGBlbWAtdW5pdCBmb250IHNpemUgcmVuZGVyaW5nIGluIGFsbCBicm93c2Vycy5cXG4gICAqL1xcbmNvZGUsXFxua2JkLFxcbnByZSxcXG5zYW1wIHtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2UsIG1vbm9zcGFjZTtcXG4gIGZvbnQtc2l6ZTogMWVtOyB9XFxuXFxuLyogRm9ybXNcXG4gICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuLyoqXFxuICAgKiBLbm93biBsaW1pdGF0aW9uOiBieSBkZWZhdWx0LCBDaHJvbWUgYW5kIFNhZmFyaSBvbiBPUyBYIGFsbG93IHZlcnkgbGltaXRlZFxcbiAgICogc3R5bGluZyBvZiBgc2VsZWN0YCwgdW5sZXNzIGEgYGJvcmRlcmAgcHJvcGVydHkgaXMgc2V0LlxcbiAgICovXFxuLyoqXFxuICAgKiAxLiBDb3JyZWN0IGNvbG9yIG5vdCBiZWluZyBpbmhlcml0ZWQuXFxuICAgKiAgICBLbm93biBpc3N1ZTogYWZmZWN0cyBjb2xvciBvZiBkaXNhYmxlZCBlbGVtZW50cy5cXG4gICAqIDIuIENvcnJlY3QgZm9udCBwcm9wZXJ0aWVzIG5vdCBiZWluZyBpbmhlcml0ZWQuXFxuICAgKiAzLiBBZGRyZXNzIG1hcmdpbnMgc2V0IGRpZmZlcmVudGx5IGluIEZpcmVmb3ggNCssIFNhZmFyaSwgYW5kIENocm9tZS5cXG4gICAqL1xcbmJ1dHRvbixcXG5pbnB1dCxcXG5vcHRncm91cCxcXG5zZWxlY3QsXFxudGV4dGFyZWEge1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICAvKiAxICovXFxuICBmb250OiBpbmhlcml0O1xcbiAgLyogMiAqL1xcbiAgbWFyZ2luOiAwO1xcbiAgLyogMyAqLyB9XFxuXFxuLyoqXFxuICAgKiBBZGRyZXNzIGBvdmVyZmxvd2Agc2V0IHRvIGBoaWRkZW5gIGluIElFIDgvOS8xMC8xMS5cXG4gICAqL1xcbmJ1dHRvbiB7XFxuICBvdmVyZmxvdzogdmlzaWJsZTsgfVxcblxcbi8qKlxcbiAgICogQWRkcmVzcyBpbmNvbnNpc3RlbnQgYHRleHQtdHJhbnNmb3JtYCBpbmhlcml0YW5jZSBmb3IgYGJ1dHRvbmAgYW5kIGBzZWxlY3RgLlxcbiAgICogQWxsIG90aGVyIGZvcm0gY29udHJvbCBlbGVtZW50cyBkbyBub3QgaW5oZXJpdCBgdGV4dC10cmFuc2Zvcm1gIHZhbHVlcy5cXG4gICAqIENvcnJlY3QgYGJ1dHRvbmAgc3R5bGUgaW5oZXJpdGFuY2UgaW4gRmlyZWZveCwgSUUgOC85LzEwLzExLCBhbmQgT3BlcmEuXFxuICAgKiBDb3JyZWN0IGBzZWxlY3RgIHN0eWxlIGluaGVyaXRhbmNlIGluIEZpcmVmb3guXFxuICAgKi9cXG5idXR0b24sXFxuc2VsZWN0IHtcXG4gIHRleHQtdHJhbnNmb3JtOiBub25lOyB9XFxuXFxuLyoqXFxuICAgKiAxLiBBdm9pZCB0aGUgV2ViS2l0IGJ1ZyBpbiBBbmRyb2lkIDQuMC4qIHdoZXJlICgyKSBkZXN0cm95cyBuYXRpdmUgYGF1ZGlvYFxcbiAgICogICAgYW5kIGB2aWRlb2AgY29udHJvbHMuXFxuICAgKiAyLiBDb3JyZWN0IGluYWJpbGl0eSB0byBzdHlsZSBjbGlja2FibGUgYGlucHV0YCB0eXBlcyBpbiBpT1MuXFxuICAgKiAzLiBJbXByb3ZlIHVzYWJpbGl0eSBhbmQgY29uc2lzdGVuY3kgb2YgY3Vyc29yIHN0eWxlIGJldHdlZW4gaW1hZ2UtdHlwZVxcbiAgICogICAgYGlucHV0YCBhbmQgb3RoZXJzLlxcbiAgICovXFxuYnV0dG9uLFxcbmh0bWwgaW5wdXRbdHlwZT1cXFwiYnV0dG9uXFxcIl0sXFxuaW5wdXRbdHlwZT1cXFwicmVzZXRcXFwiXSxcXG5pbnB1dFt0eXBlPVxcXCJzdWJtaXRcXFwiXSB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjtcXG4gIC8qIDIgKi9cXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIC8qIDMgKi8gfVxcblxcbi8qKlxcbiAgICogUmUtc2V0IGRlZmF1bHQgY3Vyc29yIGZvciBkaXNhYmxlZCBlbGVtZW50cy5cXG4gICAqL1xcbmJ1dHRvbltkaXNhYmxlZF0sXFxuaHRtbCBpbnB1dFtkaXNhYmxlZF0ge1xcbiAgY3Vyc29yOiBub3QtYWxsb3dlZDsgfVxcblxcbi8qKlxcbiAgICogUmVtb3ZlIGlubmVyIHBhZGRpbmcgYW5kIGJvcmRlciBpbiBGaXJlZm94IDQrLlxcbiAgICovXFxuYnV0dG9uOjotbW96LWZvY3VzLWlubmVyLFxcbmlucHV0OjotbW96LWZvY3VzLWlubmVyIHtcXG4gIGJvcmRlcjogMDtcXG4gIHBhZGRpbmc6IDA7IH1cXG5cXG4vKipcXG4gICAqIEFkZHJlc3MgRmlyZWZveCA0KyBzZXR0aW5nIGBsaW5lLWhlaWdodGAgb24gYGlucHV0YCB1c2luZyBgIWltcG9ydGFudGAgaW5cXG4gICAqIHRoZSBVQSBzdHlsZXNoZWV0LlxcbiAgICovXFxuaW5wdXQge1xcbiAgbGluZS1oZWlnaHQ6IG5vcm1hbDsgfVxcblxcbi8qKlxcbiAgICogSXQncyByZWNvbW1lbmRlZCB0aGF0IHlvdSBkb24ndCBhdHRlbXB0IHRvIHN0eWxlIHRoZXNlIGVsZW1lbnRzLlxcbiAgICogRmlyZWZveCdzIGltcGxlbWVudGF0aW9uIGRvZXNuJ3QgcmVzcGVjdCBib3gtc2l6aW5nLCBwYWRkaW5nLCBvciB3aWR0aC5cXG4gICAqXFxuICAgKiAxLiBBZGRyZXNzIGJveCBzaXppbmcgc2V0IHRvIGBjb250ZW50LWJveGAgaW4gSUUgOC85LzEwLlxcbiAgICogMi4gUmVtb3ZlIGV4Y2VzcyBwYWRkaW5nIGluIElFIDgvOS8xMC5cXG4gICAqL1xcbmlucHV0W3R5cGU9XFxcImNoZWNrYm94XFxcIl0sXFxuaW5wdXRbdHlwZT1cXFwicmFkaW9cXFwiXSB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgLyogMSAqL1xcbiAgcGFkZGluZzogMDtcXG4gIC8qIDIgKi8gfVxcblxcbi8qKlxcbiAgICogRml4IHRoZSBjdXJzb3Igc3R5bGUgZm9yIENocm9tZSdzIGluY3JlbWVudC9kZWNyZW1lbnQgYnV0dG9ucy4gRm9yIGNlcnRhaW5cXG4gICAqIGBmb250LXNpemVgIHZhbHVlcyBvZiB0aGUgYGlucHV0YCwgaXQgY2F1c2VzIHRoZSBjdXJzb3Igc3R5bGUgb2YgdGhlXFxuICAgKiBkZWNyZW1lbnQgYnV0dG9uIHRvIGNoYW5nZSBmcm9tIGBkZWZhdWx0YCB0byBgdGV4dGAuXFxuICAgKi9cXG5pbnB1dFt0eXBlPVxcXCJudW1iZXJcXFwiXTo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixcXG5pbnB1dFt0eXBlPVxcXCJudW1iZXJcXFwiXTo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbiB7XFxuICBoZWlnaHQ6IGF1dG87IH1cXG5cXG4vKipcXG4gICAqIDEuIEFkZHJlc3MgYGFwcGVhcmFuY2VgIHNldCB0byBgc2VhcmNoZmllbGRgIGluIFNhZmFyaSBhbmQgQ2hyb21lLlxcbiAgICogMi4gQWRkcmVzcyBgYm94LXNpemluZ2Agc2V0IHRvIGBib3JkZXItYm94YCBpbiBTYWZhcmkgYW5kIENocm9tZS5cXG4gICAqL1xcbmlucHV0W3R5cGU9XFxcInNlYXJjaFxcXCJdIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogdGV4dGZpZWxkO1xcbiAgLyogMSAqL1xcbiAgYm94LXNpemluZzogY29udGVudC1ib3g7XFxuICAvKiAyICovIH1cXG5cXG4vKipcXG4gICAqIFJlbW92ZSBpbm5lciBwYWRkaW5nIGFuZCBzZWFyY2ggY2FuY2VsIGJ1dHRvbiBpbiBTYWZhcmkgYW5kIENocm9tZSBvbiBPUyBYLlxcbiAgICogU2FmYXJpIChidXQgbm90IENocm9tZSkgY2xpcHMgdGhlIGNhbmNlbCBidXR0b24gd2hlbiB0aGUgc2VhcmNoIGlucHV0IGhhc1xcbiAgICogcGFkZGluZyAoYW5kIGB0ZXh0ZmllbGRgIGFwcGVhcmFuY2UpLlxcbiAgICovXFxuaW5wdXRbdHlwZT1cXFwic2VhcmNoXFxcIl06Oi13ZWJraXQtc2VhcmNoLWNhbmNlbC1idXR0b24sXFxuaW5wdXRbdHlwZT1cXFwic2VhcmNoXFxcIl06Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb24ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lOyB9XFxuXFxuLyoqXFxuICAgKiBEZWZpbmUgY29uc2lzdGVudCBib3JkZXIsIG1hcmdpbiwgYW5kIHBhZGRpbmcuXFxuICAgKiBbTk9URV0gV2UgZG9uJ3QgZW5hYmxlIHRoaXMgcnVsZXNldCBpbiBGb3VuZGF0aW9uLCBiZWNhdXNlIHdlIHdhbnQgdGhlIDxmaWVsZHNldD4gZWxlbWVudCB0byBoYXZlIHBsYWluIHN0eWxpbmcuXFxuICAgKi9cXG4vKiBmaWVsZHNldCB7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICNjMGMwYzA7XFxuICAgIG1hcmdpbjogMCAycHg7XFxuICAgIHBhZGRpbmc6IDAuMzVlbSAwLjYyNWVtIDAuNzVlbTtcXG4gIH0gKi9cXG4vKipcXG4gICAqIDEuIENvcnJlY3QgYGNvbG9yYCBub3QgYmVpbmcgaW5oZXJpdGVkIGluIElFIDgvOS8xMC8xMS5cXG4gICAqIDIuIFJlbW92ZSBwYWRkaW5nIHNvIHBlb3BsZSBhcmVuJ3QgY2F1Z2h0IG91dCBpZiB0aGV5IHplcm8gb3V0IGZpZWxkc2V0cy5cXG4gICAqL1xcbmxlZ2VuZCB7XFxuICBib3JkZXI6IDA7XFxuICAvKiAxICovXFxuICBwYWRkaW5nOiAwO1xcbiAgLyogMiAqLyB9XFxuXFxuLyoqXFxuICAgKiBSZW1vdmUgZGVmYXVsdCB2ZXJ0aWNhbCBzY3JvbGxiYXIgaW4gSUUgOC85LzEwLzExLlxcbiAgICovXFxudGV4dGFyZWEge1xcbiAgb3ZlcmZsb3c6IGF1dG87IH1cXG5cXG4vKipcXG4gICAqIERvbid0IGluaGVyaXQgdGhlIGBmb250LXdlaWdodGAgKGFwcGxpZWQgYnkgYSBydWxlIGFib3ZlKS5cXG4gICAqIE5PVEU6IHRoZSBkZWZhdWx0IGNhbm5vdCBzYWZlbHkgYmUgY2hhbmdlZCBpbiBDaHJvbWUgYW5kIFNhZmFyaSBvbiBPUyBYLlxcbiAgICovXFxub3B0Z3JvdXAge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7IH1cXG5cXG4vKiBUYWJsZXNcXG4gICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuLyoqXFxuICAgKiBSZW1vdmUgbW9zdCBzcGFjaW5nIGJldHdlZW4gdGFibGUgY2VsbHMuXFxuICAgKi9cXG50YWJsZSB7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbiAgYm9yZGVyLXNwYWNpbmc6IDA7IH1cXG5cXG50ZCxcXG50aCB7XFxuICBwYWRkaW5nOiAwOyB9XFxuXFxuLmZvdW5kYXRpb24tbXEge1xcbiAgZm9udC1mYW1pbHk6IFxcXCJzbWFsbD0wZW0mbWVkaXVtPTQwZW0mbGFyZ2U9NjRlbSZ4bGFyZ2U9NzVlbSZ4eGxhcmdlPTkwZW1cXFwiOyB9XFxuXFxuaHRtbCB7XFxuICBmb250LXNpemU6IDEwMCU7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9XFxuXFxuKixcXG4qOjpiZWZvcmUsXFxuKjo6YWZ0ZXIge1xcbiAgYm94LXNpemluZzogaW5oZXJpdDsgfVxcblxcbmJvZHkge1xcbiAgcGFkZGluZzogMDtcXG4gIG1hcmdpbjogMDtcXG4gIGZvbnQtZmFtaWx5OiBcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLCBIZWx2ZXRpY2EsIFJvYm90bywgQXJpYWwsIHNhbnMtc2VyaWY7XFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcbiAgbGluZS1oZWlnaHQ6IDEuNTtcXG4gIGNvbG9yOiAjMGEwYTBhO1xcbiAgYmFja2dyb3VuZDogI2ZlZmVmZTtcXG4gIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xcbiAgLW1vei1vc3gtZm9udC1zbW9vdGhpbmc6IGdyYXlzY2FsZTsgfVxcblxcbmltZyB7XFxuICBtYXgtd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IGF1dG87XFxuICAtbXMtaW50ZXJwb2xhdGlvbi1tb2RlOiBiaWN1YmljO1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTsgfVxcblxcbnRleHRhcmVhIHtcXG4gIGhlaWdodDogYXV0bztcXG4gIG1pbi1oZWlnaHQ6IDUwcHg7XFxuICBib3JkZXItcmFkaXVzOiAwOyB9XFxuXFxuc2VsZWN0IHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgYm9yZGVyLXJhZGl1czogMDsgfVxcblxcbiNtYXBfY2FudmFzIGltZyxcXG4jbWFwX2NhbnZhcyBlbWJlZCxcXG4jbWFwX2NhbnZhcyBvYmplY3QsXFxuLm1hcF9jYW52YXMgaW1nLFxcbi5tYXBfY2FudmFzIGVtYmVkLFxcbi5tYXBfY2FudmFzIG9iamVjdCxcXG4ubXFhLWRpc3BsYXkgaW1nLFxcbi5tcWEtZGlzcGxheSBlbWJlZCxcXG4ubXFhLWRpc3BsYXkgb2JqZWN0IHtcXG4gIG1heC13aWR0aDogbm9uZSAhaW1wb3J0YW50OyB9XFxuXFxuYnV0dG9uIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG4gIC1tb3otYXBwZWFyYW5jZTogbm9uZTtcXG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbiAgcGFkZGluZzogMDtcXG4gIGJvcmRlcjogMDtcXG4gIGJvcmRlci1yYWRpdXM6IDA7XFxuICBsaW5lLWhlaWdodDogMTsgfVxcbiAgW2RhdGEtd2hhdGlucHV0PSdtb3VzZSddIGJ1dHRvbiB7XFxuICAgIG91dGxpbmU6IDA7IH1cXG5cXG4uaXMtdmlzaWJsZSB7XFxuICBkaXNwbGF5OiBibG9jayAhaW1wb3J0YW50OyB9XFxuXFxuLmlzLWhpZGRlbiB7XFxuICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7IH1cXG5cXG4ucm93IHtcXG4gIG1heC13aWR0aDogNzVyZW07XFxuICBtYXJnaW4tbGVmdDogYXV0bztcXG4gIG1hcmdpbi1yaWdodDogYXV0bzsgfVxcbiAgLnJvdzo6YmVmb3JlLCAucm93OjphZnRlciB7XFxuICAgIGNvbnRlbnQ6ICcgJztcXG4gICAgZGlzcGxheTogdGFibGU7IH1cXG4gIC5yb3c6OmFmdGVyIHtcXG4gICAgY2xlYXI6IGJvdGg7IH1cXG4gIC5yb3cuY29sbGFwc2UgPiAuY29sdW1uLCAucm93LmNvbGxhcHNlID4gLmNvbHVtbnMge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDA7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDA7IH1cXG4gIC5yb3cgLnJvdyB7XFxuICAgIG1heC13aWR0aDogbm9uZTtcXG4gICAgbWFyZ2luLWxlZnQ6IC0wLjYyNXJlbTtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtMC42MjVyZW07IH1cXG4gICAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNDBlbSkge1xcbiAgICAgIC5yb3cgLnJvdyB7XFxuICAgICAgICBtYXJnaW4tbGVmdDogLTAuOTM3NXJlbTtcXG4gICAgICAgIG1hcmdpbi1yaWdodDogLTAuOTM3NXJlbTsgfSB9XFxuICAgIC5yb3cgLnJvdy5jb2xsYXBzZSB7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiAwOyB9XFxuICAucm93LmV4cGFuZGVkIHtcXG4gICAgbWF4LXdpZHRoOiBub25lOyB9XFxuICAgIC5yb3cuZXhwYW5kZWQgLnJvdyB7XFxuICAgICAgbWFyZ2luLWxlZnQ6IGF1dG87XFxuICAgICAgbWFyZ2luLXJpZ2h0OiBhdXRvOyB9XFxuXFxuLmNvbHVtbiwgLmNvbHVtbnMge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBmbG9hdDogbGVmdDtcXG4gIHBhZGRpbmctbGVmdDogMC42MjVyZW07XFxuICBwYWRkaW5nLXJpZ2h0OiAwLjYyNXJlbTsgfVxcbiAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNDBlbSkge1xcbiAgICAuY29sdW1uLCAuY29sdW1ucyB7XFxuICAgICAgcGFkZGluZy1sZWZ0OiAwLjkzNzVyZW07XFxuICAgICAgcGFkZGluZy1yaWdodDogMC45Mzc1cmVtOyB9IH1cXG4gIC5jb2x1bW46bGFzdC1jaGlsZDpub3QoOmZpcnN0LWNoaWxkKSwgLmNvbHVtbnM6bGFzdC1jaGlsZDpub3QoOmZpcnN0LWNoaWxkKSB7XFxuICAgIGZsb2F0OiByaWdodDsgfVxcbiAgLmNvbHVtbi5lbmQ6bGFzdC1jaGlsZDpsYXN0LWNoaWxkLCAuZW5kLmNvbHVtbnM6bGFzdC1jaGlsZDpsYXN0LWNoaWxkIHtcXG4gICAgZmxvYXQ6IGxlZnQ7IH1cXG5cXG4uY29sdW1uLnJvdy5yb3csIC5yb3cucm93LmNvbHVtbnMge1xcbiAgZmxvYXQ6IG5vbmU7IH1cXG4gIC5yb3cgLmNvbHVtbi5yb3cucm93LCAucm93IC5yb3cucm93LmNvbHVtbnMge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDA7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDA7XFxuICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDA7IH1cXG5cXG4uc21hbGwtMSB7XFxuICB3aWR0aDogOC4zMzMzMyU7IH1cXG5cXG4uc21hbGwtcHVzaC0xIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGxlZnQ6IDguMzMzMzMlOyB9XFxuXFxuLnNtYWxsLXB1bGwtMSB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBsZWZ0OiAtOC4zMzMzMyU7IH1cXG5cXG4uc21hbGwtb2Zmc2V0LTAge1xcbiAgbWFyZ2luLWxlZnQ6IDAlOyB9XFxuXFxuLnNtYWxsLTIge1xcbiAgd2lkdGg6IDE2LjY2NjY3JTsgfVxcblxcbi5zbWFsbC1wdXNoLTIge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgbGVmdDogMTYuNjY2NjclOyB9XFxuXFxuLnNtYWxsLXB1bGwtMiB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBsZWZ0OiAtMTYuNjY2NjclOyB9XFxuXFxuLnNtYWxsLW9mZnNldC0xIHtcXG4gIG1hcmdpbi1sZWZ0OiA4LjMzMzMzJTsgfVxcblxcbi5zbWFsbC0zIHtcXG4gIHdpZHRoOiAyNSU7IH1cXG5cXG4uc21hbGwtcHVzaC0zIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGxlZnQ6IDI1JTsgfVxcblxcbi5zbWFsbC1wdWxsLTMge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgbGVmdDogLTI1JTsgfVxcblxcbi5zbWFsbC1vZmZzZXQtMiB7XFxuICBtYXJnaW4tbGVmdDogMTYuNjY2NjclOyB9XFxuXFxuLnNtYWxsLTQge1xcbiAgd2lkdGg6IDMzLjMzMzMzJTsgfVxcblxcbi5zbWFsbC1wdXNoLTQge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgbGVmdDogMzMuMzMzMzMlOyB9XFxuXFxuLnNtYWxsLXB1bGwtNCB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBsZWZ0OiAtMzMuMzMzMzMlOyB9XFxuXFxuLnNtYWxsLW9mZnNldC0zIHtcXG4gIG1hcmdpbi1sZWZ0OiAyNSU7IH1cXG5cXG4uc21hbGwtNSB7XFxuICB3aWR0aDogNDEuNjY2NjclOyB9XFxuXFxuLnNtYWxsLXB1c2gtNSB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBsZWZ0OiA0MS42NjY2NyU7IH1cXG5cXG4uc21hbGwtcHVsbC01IHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGxlZnQ6IC00MS42NjY2NyU7IH1cXG5cXG4uc21hbGwtb2Zmc2V0LTQge1xcbiAgbWFyZ2luLWxlZnQ6IDMzLjMzMzMzJTsgfVxcblxcbi5zbWFsbC02IHtcXG4gIHdpZHRoOiA1MCU7IH1cXG5cXG4uc21hbGwtcHVzaC02IHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGxlZnQ6IDUwJTsgfVxcblxcbi5zbWFsbC1wdWxsLTYge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgbGVmdDogLTUwJTsgfVxcblxcbi5zbWFsbC1vZmZzZXQtNSB7XFxuICBtYXJnaW4tbGVmdDogNDEuNjY2NjclOyB9XFxuXFxuLnNtYWxsLTcge1xcbiAgd2lkdGg6IDU4LjMzMzMzJTsgfVxcblxcbi5zbWFsbC1wdXNoLTcge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgbGVmdDogNTguMzMzMzMlOyB9XFxuXFxuLnNtYWxsLXB1bGwtNyB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBsZWZ0OiAtNTguMzMzMzMlOyB9XFxuXFxuLnNtYWxsLW9mZnNldC02IHtcXG4gIG1hcmdpbi1sZWZ0OiA1MCU7IH1cXG5cXG4uc21hbGwtOCB7XFxuICB3aWR0aDogNjYuNjY2NjclOyB9XFxuXFxuLnNtYWxsLXB1c2gtOCB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBsZWZ0OiA2Ni42NjY2NyU7IH1cXG5cXG4uc21hbGwtcHVsbC04IHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGxlZnQ6IC02Ni42NjY2NyU7IH1cXG5cXG4uc21hbGwtb2Zmc2V0LTcge1xcbiAgbWFyZ2luLWxlZnQ6IDU4LjMzMzMzJTsgfVxcblxcbi5zbWFsbC05IHtcXG4gIHdpZHRoOiA3NSU7IH1cXG5cXG4uc21hbGwtcHVzaC05IHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGxlZnQ6IDc1JTsgfVxcblxcbi5zbWFsbC1wdWxsLTkge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgbGVmdDogLTc1JTsgfVxcblxcbi5zbWFsbC1vZmZzZXQtOCB7XFxuICBtYXJnaW4tbGVmdDogNjYuNjY2NjclOyB9XFxuXFxuLnNtYWxsLTEwIHtcXG4gIHdpZHRoOiA4My4zMzMzMyU7IH1cXG5cXG4uc21hbGwtcHVzaC0xMCB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBsZWZ0OiA4My4zMzMzMyU7IH1cXG5cXG4uc21hbGwtcHVsbC0xMCB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBsZWZ0OiAtODMuMzMzMzMlOyB9XFxuXFxuLnNtYWxsLW9mZnNldC05IHtcXG4gIG1hcmdpbi1sZWZ0OiA3NSU7IH1cXG5cXG4uc21hbGwtMTEge1xcbiAgd2lkdGg6IDkxLjY2NjY3JTsgfVxcblxcbi5zbWFsbC1wdXNoLTExIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGxlZnQ6IDkxLjY2NjY3JTsgfVxcblxcbi5zbWFsbC1wdWxsLTExIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGxlZnQ6IC05MS42NjY2NyU7IH1cXG5cXG4uc21hbGwtb2Zmc2V0LTEwIHtcXG4gIG1hcmdpbi1sZWZ0OiA4My4zMzMzMyU7IH1cXG5cXG4uc21hbGwtMTIge1xcbiAgd2lkdGg6IDEwMCU7IH1cXG5cXG4uc21hbGwtb2Zmc2V0LTExIHtcXG4gIG1hcmdpbi1sZWZ0OiA5MS42NjY2NyU7IH1cXG5cXG4uc21hbGwtdXAtMSA+IC5jb2x1bW4sIC5zbWFsbC11cC0xID4gLmNvbHVtbnMge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBmbG9hdDogbGVmdDsgfVxcbiAgLnNtYWxsLXVwLTEgPiAuY29sdW1uOm50aC1vZi10eXBlKDFuKSwgLnNtYWxsLXVwLTEgPiAuY29sdW1uczpudGgtb2YtdHlwZSgxbikge1xcbiAgICBjbGVhcjogbm9uZTsgfVxcbiAgLnNtYWxsLXVwLTEgPiAuY29sdW1uOm50aC1vZi10eXBlKDFuKzEpLCAuc21hbGwtdXAtMSA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDFuKzEpIHtcXG4gICAgY2xlYXI6IGJvdGg7IH1cXG4gIC5zbWFsbC11cC0xID4gLmNvbHVtbjpsYXN0LWNoaWxkLCAuc21hbGwtdXAtMSA+IC5jb2x1bW5zOmxhc3QtY2hpbGQge1xcbiAgICBmbG9hdDogbGVmdDsgfVxcblxcbi5zbWFsbC11cC0yID4gLmNvbHVtbiwgLnNtYWxsLXVwLTIgPiAuY29sdW1ucyB7XFxuICB3aWR0aDogNTAlO1xcbiAgZmxvYXQ6IGxlZnQ7IH1cXG4gIC5zbWFsbC11cC0yID4gLmNvbHVtbjpudGgtb2YtdHlwZSgxbiksIC5zbWFsbC11cC0yID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pIHtcXG4gICAgY2xlYXI6IG5vbmU7IH1cXG4gIC5zbWFsbC11cC0yID4gLmNvbHVtbjpudGgtb2YtdHlwZSgybisxKSwgLnNtYWxsLXVwLTIgPiAuY29sdW1uczpudGgtb2YtdHlwZSgybisxKSB7XFxuICAgIGNsZWFyOiBib3RoOyB9XFxuICAuc21hbGwtdXAtMiA+IC5jb2x1bW46bGFzdC1jaGlsZCwgLnNtYWxsLXVwLTIgPiAuY29sdW1uczpsYXN0LWNoaWxkIHtcXG4gICAgZmxvYXQ6IGxlZnQ7IH1cXG5cXG4uc21hbGwtdXAtMyA+IC5jb2x1bW4sIC5zbWFsbC11cC0zID4gLmNvbHVtbnMge1xcbiAgd2lkdGg6IDMzLjMzMzMzJTtcXG4gIGZsb2F0OiBsZWZ0OyB9XFxuICAuc21hbGwtdXAtMyA+IC5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLCAuc21hbGwtdXAtMyA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDFuKSB7XFxuICAgIGNsZWFyOiBub25lOyB9XFxuICAuc21hbGwtdXAtMyA+IC5jb2x1bW46bnRoLW9mLXR5cGUoM24rMSksIC5zbWFsbC11cC0zID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoM24rMSkge1xcbiAgICBjbGVhcjogYm90aDsgfVxcbiAgLnNtYWxsLXVwLTMgPiAuY29sdW1uOmxhc3QtY2hpbGQsIC5zbWFsbC11cC0zID4gLmNvbHVtbnM6bGFzdC1jaGlsZCB7XFxuICAgIGZsb2F0OiBsZWZ0OyB9XFxuXFxuLnNtYWxsLXVwLTQgPiAuY29sdW1uLCAuc21hbGwtdXAtNCA+IC5jb2x1bW5zIHtcXG4gIHdpZHRoOiAyNSU7XFxuICBmbG9hdDogbGVmdDsgfVxcbiAgLnNtYWxsLXVwLTQgPiAuY29sdW1uOm50aC1vZi10eXBlKDFuKSwgLnNtYWxsLXVwLTQgPiAuY29sdW1uczpudGgtb2YtdHlwZSgxbikge1xcbiAgICBjbGVhcjogbm9uZTsgfVxcbiAgLnNtYWxsLXVwLTQgPiAuY29sdW1uOm50aC1vZi10eXBlKDRuKzEpLCAuc21hbGwtdXAtNCA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDRuKzEpIHtcXG4gICAgY2xlYXI6IGJvdGg7IH1cXG4gIC5zbWFsbC11cC00ID4gLmNvbHVtbjpsYXN0LWNoaWxkLCAuc21hbGwtdXAtNCA+IC5jb2x1bW5zOmxhc3QtY2hpbGQge1xcbiAgICBmbG9hdDogbGVmdDsgfVxcblxcbi5zbWFsbC11cC01ID4gLmNvbHVtbiwgLnNtYWxsLXVwLTUgPiAuY29sdW1ucyB7XFxuICB3aWR0aDogMjAlO1xcbiAgZmxvYXQ6IGxlZnQ7IH1cXG4gIC5zbWFsbC11cC01ID4gLmNvbHVtbjpudGgtb2YtdHlwZSgxbiksIC5zbWFsbC11cC01ID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pIHtcXG4gICAgY2xlYXI6IG5vbmU7IH1cXG4gIC5zbWFsbC11cC01ID4gLmNvbHVtbjpudGgtb2YtdHlwZSg1bisxKSwgLnNtYWxsLXVwLTUgPiAuY29sdW1uczpudGgtb2YtdHlwZSg1bisxKSB7XFxuICAgIGNsZWFyOiBib3RoOyB9XFxuICAuc21hbGwtdXAtNSA+IC5jb2x1bW46bGFzdC1jaGlsZCwgLnNtYWxsLXVwLTUgPiAuY29sdW1uczpsYXN0LWNoaWxkIHtcXG4gICAgZmxvYXQ6IGxlZnQ7IH1cXG5cXG4uc21hbGwtdXAtNiA+IC5jb2x1bW4sIC5zbWFsbC11cC02ID4gLmNvbHVtbnMge1xcbiAgd2lkdGg6IDE2LjY2NjY3JTtcXG4gIGZsb2F0OiBsZWZ0OyB9XFxuICAuc21hbGwtdXAtNiA+IC5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLCAuc21hbGwtdXAtNiA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDFuKSB7XFxuICAgIGNsZWFyOiBub25lOyB9XFxuICAuc21hbGwtdXAtNiA+IC5jb2x1bW46bnRoLW9mLXR5cGUoNm4rMSksIC5zbWFsbC11cC02ID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoNm4rMSkge1xcbiAgICBjbGVhcjogYm90aDsgfVxcbiAgLnNtYWxsLXVwLTYgPiAuY29sdW1uOmxhc3QtY2hpbGQsIC5zbWFsbC11cC02ID4gLmNvbHVtbnM6bGFzdC1jaGlsZCB7XFxuICAgIGZsb2F0OiBsZWZ0OyB9XFxuXFxuLnNtYWxsLXVwLTcgPiAuY29sdW1uLCAuc21hbGwtdXAtNyA+IC5jb2x1bW5zIHtcXG4gIHdpZHRoOiAxNC4yODU3MSU7XFxuICBmbG9hdDogbGVmdDsgfVxcbiAgLnNtYWxsLXVwLTcgPiAuY29sdW1uOm50aC1vZi10eXBlKDFuKSwgLnNtYWxsLXVwLTcgPiAuY29sdW1uczpudGgtb2YtdHlwZSgxbikge1xcbiAgICBjbGVhcjogbm9uZTsgfVxcbiAgLnNtYWxsLXVwLTcgPiAuY29sdW1uOm50aC1vZi10eXBlKDduKzEpLCAuc21hbGwtdXAtNyA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDduKzEpIHtcXG4gICAgY2xlYXI6IGJvdGg7IH1cXG4gIC5zbWFsbC11cC03ID4gLmNvbHVtbjpsYXN0LWNoaWxkLCAuc21hbGwtdXAtNyA+IC5jb2x1bW5zOmxhc3QtY2hpbGQge1xcbiAgICBmbG9hdDogbGVmdDsgfVxcblxcbi5zbWFsbC11cC04ID4gLmNvbHVtbiwgLnNtYWxsLXVwLTggPiAuY29sdW1ucyB7XFxuICB3aWR0aDogMTIuNSU7XFxuICBmbG9hdDogbGVmdDsgfVxcbiAgLnNtYWxsLXVwLTggPiAuY29sdW1uOm50aC1vZi10eXBlKDFuKSwgLnNtYWxsLXVwLTggPiAuY29sdW1uczpudGgtb2YtdHlwZSgxbikge1xcbiAgICBjbGVhcjogbm9uZTsgfVxcbiAgLnNtYWxsLXVwLTggPiAuY29sdW1uOm50aC1vZi10eXBlKDhuKzEpLCAuc21hbGwtdXAtOCA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDhuKzEpIHtcXG4gICAgY2xlYXI6IGJvdGg7IH1cXG4gIC5zbWFsbC11cC04ID4gLmNvbHVtbjpsYXN0LWNoaWxkLCAuc21hbGwtdXAtOCA+IC5jb2x1bW5zOmxhc3QtY2hpbGQge1xcbiAgICBmbG9hdDogbGVmdDsgfVxcblxcbi5zbWFsbC1jb2xsYXBzZSA+IC5jb2x1bW4sIC5zbWFsbC1jb2xsYXBzZSA+IC5jb2x1bW5zIHtcXG4gIHBhZGRpbmctbGVmdDogMDtcXG4gIHBhZGRpbmctcmlnaHQ6IDA7IH1cXG5cXG4uc21hbGwtY29sbGFwc2UgLnJvdyxcXG4uZXhwYW5kZWQucm93IC5zbWFsbC1jb2xsYXBzZS5yb3cge1xcbiAgbWFyZ2luLWxlZnQ6IDA7XFxuICBtYXJnaW4tcmlnaHQ6IDA7IH1cXG5cXG4uc21hbGwtdW5jb2xsYXBzZSA+IC5jb2x1bW4sIC5zbWFsbC11bmNvbGxhcHNlID4gLmNvbHVtbnMge1xcbiAgcGFkZGluZy1sZWZ0OiAwLjYyNXJlbTtcXG4gIHBhZGRpbmctcmlnaHQ6IDAuNjI1cmVtOyB9XFxuXFxuLnNtYWxsLWNlbnRlcmVkIHtcXG4gIGZsb2F0OiBub25lO1xcbiAgbWFyZ2luLWxlZnQ6IGF1dG87XFxuICBtYXJnaW4tcmlnaHQ6IGF1dG87IH1cXG5cXG4uc21hbGwtdW5jZW50ZXJlZCxcXG4uc21hbGwtcHVzaC0wLFxcbi5zbWFsbC1wdWxsLTAge1xcbiAgcG9zaXRpb246IHN0YXRpYztcXG4gIG1hcmdpbi1sZWZ0OiAwO1xcbiAgbWFyZ2luLXJpZ2h0OiAwO1xcbiAgZmxvYXQ6IGxlZnQ7IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA0MGVtKSB7XFxuICAubWVkaXVtLTEge1xcbiAgICB3aWR0aDogOC4zMzMzMyU7IH1cXG4gIC5tZWRpdW0tcHVzaC0xIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiA4LjMzMzMzJTsgfVxcbiAgLm1lZGl1bS1wdWxsLTEge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IC04LjMzMzMzJTsgfVxcbiAgLm1lZGl1bS1vZmZzZXQtMCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAwJTsgfVxcbiAgLm1lZGl1bS0yIHtcXG4gICAgd2lkdGg6IDE2LjY2NjY3JTsgfVxcbiAgLm1lZGl1bS1wdXNoLTIge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IDE2LjY2NjY3JTsgfVxcbiAgLm1lZGl1bS1wdWxsLTIge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IC0xNi42NjY2NyU7IH1cXG4gIC5tZWRpdW0tb2Zmc2V0LTEge1xcbiAgICBtYXJnaW4tbGVmdDogOC4zMzMzMyU7IH1cXG4gIC5tZWRpdW0tMyB7XFxuICAgIHdpZHRoOiAyNSU7IH1cXG4gIC5tZWRpdW0tcHVzaC0zIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiAyNSU7IH1cXG4gIC5tZWRpdW0tcHVsbC0zIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiAtMjUlOyB9XFxuICAubWVkaXVtLW9mZnNldC0yIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDE2LjY2NjY3JTsgfVxcbiAgLm1lZGl1bS00IHtcXG4gICAgd2lkdGg6IDMzLjMzMzMzJTsgfVxcbiAgLm1lZGl1bS1wdXNoLTQge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IDMzLjMzMzMzJTsgfVxcbiAgLm1lZGl1bS1wdWxsLTQge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IC0zMy4zMzMzMyU7IH1cXG4gIC5tZWRpdW0tb2Zmc2V0LTMge1xcbiAgICBtYXJnaW4tbGVmdDogMjUlOyB9XFxuICAubWVkaXVtLTUge1xcbiAgICB3aWR0aDogNDEuNjY2NjclOyB9XFxuICAubWVkaXVtLXB1c2gtNSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogNDEuNjY2NjclOyB9XFxuICAubWVkaXVtLXB1bGwtNSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogLTQxLjY2NjY3JTsgfVxcbiAgLm1lZGl1bS1vZmZzZXQtNCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAzMy4zMzMzMyU7IH1cXG4gIC5tZWRpdW0tNiB7XFxuICAgIHdpZHRoOiA1MCU7IH1cXG4gIC5tZWRpdW0tcHVzaC02IHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiA1MCU7IH1cXG4gIC5tZWRpdW0tcHVsbC02IHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiAtNTAlOyB9XFxuICAubWVkaXVtLW9mZnNldC01IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDQxLjY2NjY3JTsgfVxcbiAgLm1lZGl1bS03IHtcXG4gICAgd2lkdGg6IDU4LjMzMzMzJTsgfVxcbiAgLm1lZGl1bS1wdXNoLTcge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IDU4LjMzMzMzJTsgfVxcbiAgLm1lZGl1bS1wdWxsLTcge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IC01OC4zMzMzMyU7IH1cXG4gIC5tZWRpdW0tb2Zmc2V0LTYge1xcbiAgICBtYXJnaW4tbGVmdDogNTAlOyB9XFxuICAubWVkaXVtLTgge1xcbiAgICB3aWR0aDogNjYuNjY2NjclOyB9XFxuICAubWVkaXVtLXB1c2gtOCB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogNjYuNjY2NjclOyB9XFxuICAubWVkaXVtLXB1bGwtOCB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogLTY2LjY2NjY3JTsgfVxcbiAgLm1lZGl1bS1vZmZzZXQtNyB7XFxuICAgIG1hcmdpbi1sZWZ0OiA1OC4zMzMzMyU7IH1cXG4gIC5tZWRpdW0tOSB7XFxuICAgIHdpZHRoOiA3NSU7IH1cXG4gIC5tZWRpdW0tcHVzaC05IHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiA3NSU7IH1cXG4gIC5tZWRpdW0tcHVsbC05IHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiAtNzUlOyB9XFxuICAubWVkaXVtLW9mZnNldC04IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDY2LjY2NjY3JTsgfVxcbiAgLm1lZGl1bS0xMCB7XFxuICAgIHdpZHRoOiA4My4zMzMzMyU7IH1cXG4gIC5tZWRpdW0tcHVzaC0xMCB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogODMuMzMzMzMlOyB9XFxuICAubWVkaXVtLXB1bGwtMTAge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IC04My4zMzMzMyU7IH1cXG4gIC5tZWRpdW0tb2Zmc2V0LTkge1xcbiAgICBtYXJnaW4tbGVmdDogNzUlOyB9XFxuICAubWVkaXVtLTExIHtcXG4gICAgd2lkdGg6IDkxLjY2NjY3JTsgfVxcbiAgLm1lZGl1bS1wdXNoLTExIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiA5MS42NjY2NyU7IH1cXG4gIC5tZWRpdW0tcHVsbC0xMSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogLTkxLjY2NjY3JTsgfVxcbiAgLm1lZGl1bS1vZmZzZXQtMTAge1xcbiAgICBtYXJnaW4tbGVmdDogODMuMzMzMzMlOyB9XFxuICAubWVkaXVtLTEyIHtcXG4gICAgd2lkdGg6IDEwMCU7IH1cXG4gIC5tZWRpdW0tb2Zmc2V0LTExIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDkxLjY2NjY3JTsgfVxcbiAgLm1lZGl1bS11cC0xID4gLmNvbHVtbiwgLm1lZGl1bS11cC0xID4gLmNvbHVtbnMge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgZmxvYXQ6IGxlZnQ7IH1cXG4gICAgLm1lZGl1bS11cC0xID4gLmNvbHVtbjpudGgtb2YtdHlwZSgxbiksIC5tZWRpdW0tdXAtMSA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDFuKSB7XFxuICAgICAgY2xlYXI6IG5vbmU7IH1cXG4gICAgLm1lZGl1bS11cC0xID4gLmNvbHVtbjpudGgtb2YtdHlwZSgxbisxKSwgLm1lZGl1bS11cC0xID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4rMSkge1xcbiAgICAgIGNsZWFyOiBib3RoOyB9XFxuICAgIC5tZWRpdW0tdXAtMSA+IC5jb2x1bW46bGFzdC1jaGlsZCwgLm1lZGl1bS11cC0xID4gLmNvbHVtbnM6bGFzdC1jaGlsZCB7XFxuICAgICAgZmxvYXQ6IGxlZnQ7IH1cXG4gIC5tZWRpdW0tdXAtMiA+IC5jb2x1bW4sIC5tZWRpdW0tdXAtMiA+IC5jb2x1bW5zIHtcXG4gICAgd2lkdGg6IDUwJTtcXG4gICAgZmxvYXQ6IGxlZnQ7IH1cXG4gICAgLm1lZGl1bS11cC0yID4gLmNvbHVtbjpudGgtb2YtdHlwZSgxbiksIC5tZWRpdW0tdXAtMiA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDFuKSB7XFxuICAgICAgY2xlYXI6IG5vbmU7IH1cXG4gICAgLm1lZGl1bS11cC0yID4gLmNvbHVtbjpudGgtb2YtdHlwZSgybisxKSwgLm1lZGl1bS11cC0yID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoMm4rMSkge1xcbiAgICAgIGNsZWFyOiBib3RoOyB9XFxuICAgIC5tZWRpdW0tdXAtMiA+IC5jb2x1bW46bGFzdC1jaGlsZCwgLm1lZGl1bS11cC0yID4gLmNvbHVtbnM6bGFzdC1jaGlsZCB7XFxuICAgICAgZmxvYXQ6IGxlZnQ7IH1cXG4gIC5tZWRpdW0tdXAtMyA+IC5jb2x1bW4sIC5tZWRpdW0tdXAtMyA+IC5jb2x1bW5zIHtcXG4gICAgd2lkdGg6IDMzLjMzMzMzJTtcXG4gICAgZmxvYXQ6IGxlZnQ7IH1cXG4gICAgLm1lZGl1bS11cC0zID4gLmNvbHVtbjpudGgtb2YtdHlwZSgxbiksIC5tZWRpdW0tdXAtMyA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDFuKSB7XFxuICAgICAgY2xlYXI6IG5vbmU7IH1cXG4gICAgLm1lZGl1bS11cC0zID4gLmNvbHVtbjpudGgtb2YtdHlwZSgzbisxKSwgLm1lZGl1bS11cC0zID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoM24rMSkge1xcbiAgICAgIGNsZWFyOiBib3RoOyB9XFxuICAgIC5tZWRpdW0tdXAtMyA+IC5jb2x1bW46bGFzdC1jaGlsZCwgLm1lZGl1bS11cC0zID4gLmNvbHVtbnM6bGFzdC1jaGlsZCB7XFxuICAgICAgZmxvYXQ6IGxlZnQ7IH1cXG4gIC5tZWRpdW0tdXAtNCA+IC5jb2x1bW4sIC5tZWRpdW0tdXAtNCA+IC5jb2x1bW5zIHtcXG4gICAgd2lkdGg6IDI1JTtcXG4gICAgZmxvYXQ6IGxlZnQ7IH1cXG4gICAgLm1lZGl1bS11cC00ID4gLmNvbHVtbjpudGgtb2YtdHlwZSgxbiksIC5tZWRpdW0tdXAtNCA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDFuKSB7XFxuICAgICAgY2xlYXI6IG5vbmU7IH1cXG4gICAgLm1lZGl1bS11cC00ID4gLmNvbHVtbjpudGgtb2YtdHlwZSg0bisxKSwgLm1lZGl1bS11cC00ID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoNG4rMSkge1xcbiAgICAgIGNsZWFyOiBib3RoOyB9XFxuICAgIC5tZWRpdW0tdXAtNCA+IC5jb2x1bW46bGFzdC1jaGlsZCwgLm1lZGl1bS11cC00ID4gLmNvbHVtbnM6bGFzdC1jaGlsZCB7XFxuICAgICAgZmxvYXQ6IGxlZnQ7IH1cXG4gIC5tZWRpdW0tdXAtNSA+IC5jb2x1bW4sIC5tZWRpdW0tdXAtNSA+IC5jb2x1bW5zIHtcXG4gICAgd2lkdGg6IDIwJTtcXG4gICAgZmxvYXQ6IGxlZnQ7IH1cXG4gICAgLm1lZGl1bS11cC01ID4gLmNvbHVtbjpudGgtb2YtdHlwZSgxbiksIC5tZWRpdW0tdXAtNSA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDFuKSB7XFxuICAgICAgY2xlYXI6IG5vbmU7IH1cXG4gICAgLm1lZGl1bS11cC01ID4gLmNvbHVtbjpudGgtb2YtdHlwZSg1bisxKSwgLm1lZGl1bS11cC01ID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoNW4rMSkge1xcbiAgICAgIGNsZWFyOiBib3RoOyB9XFxuICAgIC5tZWRpdW0tdXAtNSA+IC5jb2x1bW46bGFzdC1jaGlsZCwgLm1lZGl1bS11cC01ID4gLmNvbHVtbnM6bGFzdC1jaGlsZCB7XFxuICAgICAgZmxvYXQ6IGxlZnQ7IH1cXG4gIC5tZWRpdW0tdXAtNiA+IC5jb2x1bW4sIC5tZWRpdW0tdXAtNiA+IC5jb2x1bW5zIHtcXG4gICAgd2lkdGg6IDE2LjY2NjY3JTtcXG4gICAgZmxvYXQ6IGxlZnQ7IH1cXG4gICAgLm1lZGl1bS11cC02ID4gLmNvbHVtbjpudGgtb2YtdHlwZSgxbiksIC5tZWRpdW0tdXAtNiA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDFuKSB7XFxuICAgICAgY2xlYXI6IG5vbmU7IH1cXG4gICAgLm1lZGl1bS11cC02ID4gLmNvbHVtbjpudGgtb2YtdHlwZSg2bisxKSwgLm1lZGl1bS11cC02ID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoNm4rMSkge1xcbiAgICAgIGNsZWFyOiBib3RoOyB9XFxuICAgIC5tZWRpdW0tdXAtNiA+IC5jb2x1bW46bGFzdC1jaGlsZCwgLm1lZGl1bS11cC02ID4gLmNvbHVtbnM6bGFzdC1jaGlsZCB7XFxuICAgICAgZmxvYXQ6IGxlZnQ7IH1cXG4gIC5tZWRpdW0tdXAtNyA+IC5jb2x1bW4sIC5tZWRpdW0tdXAtNyA+IC5jb2x1bW5zIHtcXG4gICAgd2lkdGg6IDE0LjI4NTcxJTtcXG4gICAgZmxvYXQ6IGxlZnQ7IH1cXG4gICAgLm1lZGl1bS11cC03ID4gLmNvbHVtbjpudGgtb2YtdHlwZSgxbiksIC5tZWRpdW0tdXAtNyA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDFuKSB7XFxuICAgICAgY2xlYXI6IG5vbmU7IH1cXG4gICAgLm1lZGl1bS11cC03ID4gLmNvbHVtbjpudGgtb2YtdHlwZSg3bisxKSwgLm1lZGl1bS11cC03ID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoN24rMSkge1xcbiAgICAgIGNsZWFyOiBib3RoOyB9XFxuICAgIC5tZWRpdW0tdXAtNyA+IC5jb2x1bW46bGFzdC1jaGlsZCwgLm1lZGl1bS11cC03ID4gLmNvbHVtbnM6bGFzdC1jaGlsZCB7XFxuICAgICAgZmxvYXQ6IGxlZnQ7IH1cXG4gIC5tZWRpdW0tdXAtOCA+IC5jb2x1bW4sIC5tZWRpdW0tdXAtOCA+IC5jb2x1bW5zIHtcXG4gICAgd2lkdGg6IDEyLjUlO1xcbiAgICBmbG9hdDogbGVmdDsgfVxcbiAgICAubWVkaXVtLXVwLTggPiAuY29sdW1uOm50aC1vZi10eXBlKDFuKSwgLm1lZGl1bS11cC04ID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pIHtcXG4gICAgICBjbGVhcjogbm9uZTsgfVxcbiAgICAubWVkaXVtLXVwLTggPiAuY29sdW1uOm50aC1vZi10eXBlKDhuKzEpLCAubWVkaXVtLXVwLTggPiAuY29sdW1uczpudGgtb2YtdHlwZSg4bisxKSB7XFxuICAgICAgY2xlYXI6IGJvdGg7IH1cXG4gICAgLm1lZGl1bS11cC04ID4gLmNvbHVtbjpsYXN0LWNoaWxkLCAubWVkaXVtLXVwLTggPiAuY29sdW1uczpsYXN0LWNoaWxkIHtcXG4gICAgICBmbG9hdDogbGVmdDsgfVxcbiAgLm1lZGl1bS1jb2xsYXBzZSA+IC5jb2x1bW4sIC5tZWRpdW0tY29sbGFwc2UgPiAuY29sdW1ucyB7XFxuICAgIHBhZGRpbmctbGVmdDogMDtcXG4gICAgcGFkZGluZy1yaWdodDogMDsgfVxcbiAgLm1lZGl1bS1jb2xsYXBzZSAucm93LFxcbiAgLmV4cGFuZGVkLnJvdyAubWVkaXVtLWNvbGxhcHNlLnJvdyB7XFxuICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDA7IH1cXG4gIC5tZWRpdW0tdW5jb2xsYXBzZSA+IC5jb2x1bW4sIC5tZWRpdW0tdW5jb2xsYXBzZSA+IC5jb2x1bW5zIHtcXG4gICAgcGFkZGluZy1sZWZ0OiAwLjkzNzVyZW07XFxuICAgIHBhZGRpbmctcmlnaHQ6IDAuOTM3NXJlbTsgfVxcbiAgLm1lZGl1bS1jZW50ZXJlZCB7XFxuICAgIGZsb2F0OiBub25lO1xcbiAgICBtYXJnaW4tbGVmdDogYXV0bztcXG4gICAgbWFyZ2luLXJpZ2h0OiBhdXRvOyB9XFxuICAubWVkaXVtLXVuY2VudGVyZWQsXFxuICAubWVkaXVtLXB1c2gtMCxcXG4gIC5tZWRpdW0tcHVsbC0wIHtcXG4gICAgcG9zaXRpb246IHN0YXRpYztcXG4gICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgIG1hcmdpbi1yaWdodDogMDtcXG4gICAgZmxvYXQ6IGxlZnQ7IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDY0ZW0pIHtcXG4gIC5sYXJnZS0xIHtcXG4gICAgd2lkdGg6IDguMzMzMzMlOyB9XFxuICAubGFyZ2UtcHVzaC0xIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiA4LjMzMzMzJTsgfVxcbiAgLmxhcmdlLXB1bGwtMSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogLTguMzMzMzMlOyB9XFxuICAubGFyZ2Utb2Zmc2V0LTAge1xcbiAgICBtYXJnaW4tbGVmdDogMCU7IH1cXG4gIC5sYXJnZS0yIHtcXG4gICAgd2lkdGg6IDE2LjY2NjY3JTsgfVxcbiAgLmxhcmdlLXB1c2gtMiB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogMTYuNjY2NjclOyB9XFxuICAubGFyZ2UtcHVsbC0yIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiAtMTYuNjY2NjclOyB9XFxuICAubGFyZ2Utb2Zmc2V0LTEge1xcbiAgICBtYXJnaW4tbGVmdDogOC4zMzMzMyU7IH1cXG4gIC5sYXJnZS0zIHtcXG4gICAgd2lkdGg6IDI1JTsgfVxcbiAgLmxhcmdlLXB1c2gtMyB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogMjUlOyB9XFxuICAubGFyZ2UtcHVsbC0zIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiAtMjUlOyB9XFxuICAubGFyZ2Utb2Zmc2V0LTIge1xcbiAgICBtYXJnaW4tbGVmdDogMTYuNjY2NjclOyB9XFxuICAubGFyZ2UtNCB7XFxuICAgIHdpZHRoOiAzMy4zMzMzMyU7IH1cXG4gIC5sYXJnZS1wdXNoLTQge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IDMzLjMzMzMzJTsgfVxcbiAgLmxhcmdlLXB1bGwtNCB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogLTMzLjMzMzMzJTsgfVxcbiAgLmxhcmdlLW9mZnNldC0zIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDI1JTsgfVxcbiAgLmxhcmdlLTUge1xcbiAgICB3aWR0aDogNDEuNjY2NjclOyB9XFxuICAubGFyZ2UtcHVzaC01IHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiA0MS42NjY2NyU7IH1cXG4gIC5sYXJnZS1wdWxsLTUge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IC00MS42NjY2NyU7IH1cXG4gIC5sYXJnZS1vZmZzZXQtNCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAzMy4zMzMzMyU7IH1cXG4gIC5sYXJnZS02IHtcXG4gICAgd2lkdGg6IDUwJTsgfVxcbiAgLmxhcmdlLXB1c2gtNiB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogNTAlOyB9XFxuICAubGFyZ2UtcHVsbC02IHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiAtNTAlOyB9XFxuICAubGFyZ2Utb2Zmc2V0LTUge1xcbiAgICBtYXJnaW4tbGVmdDogNDEuNjY2NjclOyB9XFxuICAubGFyZ2UtNyB7XFxuICAgIHdpZHRoOiA1OC4zMzMzMyU7IH1cXG4gIC5sYXJnZS1wdXNoLTcge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IDU4LjMzMzMzJTsgfVxcbiAgLmxhcmdlLXB1bGwtNyB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogLTU4LjMzMzMzJTsgfVxcbiAgLmxhcmdlLW9mZnNldC02IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDUwJTsgfVxcbiAgLmxhcmdlLTgge1xcbiAgICB3aWR0aDogNjYuNjY2NjclOyB9XFxuICAubGFyZ2UtcHVzaC04IHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiA2Ni42NjY2NyU7IH1cXG4gIC5sYXJnZS1wdWxsLTgge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IC02Ni42NjY2NyU7IH1cXG4gIC5sYXJnZS1vZmZzZXQtNyB7XFxuICAgIG1hcmdpbi1sZWZ0OiA1OC4zMzMzMyU7IH1cXG4gIC5sYXJnZS05IHtcXG4gICAgd2lkdGg6IDc1JTsgfVxcbiAgLmxhcmdlLXB1c2gtOSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogNzUlOyB9XFxuICAubGFyZ2UtcHVsbC05IHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBsZWZ0OiAtNzUlOyB9XFxuICAubGFyZ2Utb2Zmc2V0LTgge1xcbiAgICBtYXJnaW4tbGVmdDogNjYuNjY2NjclOyB9XFxuICAubGFyZ2UtMTAge1xcbiAgICB3aWR0aDogODMuMzMzMzMlOyB9XFxuICAubGFyZ2UtcHVzaC0xMCB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogODMuMzMzMzMlOyB9XFxuICAubGFyZ2UtcHVsbC0xMCB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbGVmdDogLTgzLjMzMzMzJTsgfVxcbiAgLmxhcmdlLW9mZnNldC05IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDc1JTsgfVxcbiAgLmxhcmdlLTExIHtcXG4gICAgd2lkdGg6IDkxLjY2NjY3JTsgfVxcbiAgLmxhcmdlLXB1c2gtMTEge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IDkxLjY2NjY3JTsgfVxcbiAgLmxhcmdlLXB1bGwtMTEge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGxlZnQ6IC05MS42NjY2NyU7IH1cXG4gIC5sYXJnZS1vZmZzZXQtMTAge1xcbiAgICBtYXJnaW4tbGVmdDogODMuMzMzMzMlOyB9XFxuICAubGFyZ2UtMTIge1xcbiAgICB3aWR0aDogMTAwJTsgfVxcbiAgLmxhcmdlLW9mZnNldC0xMSB7XFxuICAgIG1hcmdpbi1sZWZ0OiA5MS42NjY2NyU7IH1cXG4gIC5sYXJnZS11cC0xID4gLmNvbHVtbiwgLmxhcmdlLXVwLTEgPiAuY29sdW1ucyB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBmbG9hdDogbGVmdDsgfVxcbiAgICAubGFyZ2UtdXAtMSA+IC5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLCAubGFyZ2UtdXAtMSA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDFuKSB7XFxuICAgICAgY2xlYXI6IG5vbmU7IH1cXG4gICAgLmxhcmdlLXVwLTEgPiAuY29sdW1uOm50aC1vZi10eXBlKDFuKzEpLCAubGFyZ2UtdXAtMSA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDFuKzEpIHtcXG4gICAgICBjbGVhcjogYm90aDsgfVxcbiAgICAubGFyZ2UtdXAtMSA+IC5jb2x1bW46bGFzdC1jaGlsZCwgLmxhcmdlLXVwLTEgPiAuY29sdW1uczpsYXN0LWNoaWxkIHtcXG4gICAgICBmbG9hdDogbGVmdDsgfVxcbiAgLmxhcmdlLXVwLTIgPiAuY29sdW1uLCAubGFyZ2UtdXAtMiA+IC5jb2x1bW5zIHtcXG4gICAgd2lkdGg6IDUwJTtcXG4gICAgZmxvYXQ6IGxlZnQ7IH1cXG4gICAgLmxhcmdlLXVwLTIgPiAuY29sdW1uOm50aC1vZi10eXBlKDFuKSwgLmxhcmdlLXVwLTIgPiAuY29sdW1uczpudGgtb2YtdHlwZSgxbikge1xcbiAgICAgIGNsZWFyOiBub25lOyB9XFxuICAgIC5sYXJnZS11cC0yID4gLmNvbHVtbjpudGgtb2YtdHlwZSgybisxKSwgLmxhcmdlLXVwLTIgPiAuY29sdW1uczpudGgtb2YtdHlwZSgybisxKSB7XFxuICAgICAgY2xlYXI6IGJvdGg7IH1cXG4gICAgLmxhcmdlLXVwLTIgPiAuY29sdW1uOmxhc3QtY2hpbGQsIC5sYXJnZS11cC0yID4gLmNvbHVtbnM6bGFzdC1jaGlsZCB7XFxuICAgICAgZmxvYXQ6IGxlZnQ7IH1cXG4gIC5sYXJnZS11cC0zID4gLmNvbHVtbiwgLmxhcmdlLXVwLTMgPiAuY29sdW1ucyB7XFxuICAgIHdpZHRoOiAzMy4zMzMzMyU7XFxuICAgIGZsb2F0OiBsZWZ0OyB9XFxuICAgIC5sYXJnZS11cC0zID4gLmNvbHVtbjpudGgtb2YtdHlwZSgxbiksIC5sYXJnZS11cC0zID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pIHtcXG4gICAgICBjbGVhcjogbm9uZTsgfVxcbiAgICAubGFyZ2UtdXAtMyA+IC5jb2x1bW46bnRoLW9mLXR5cGUoM24rMSksIC5sYXJnZS11cC0zID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoM24rMSkge1xcbiAgICAgIGNsZWFyOiBib3RoOyB9XFxuICAgIC5sYXJnZS11cC0zID4gLmNvbHVtbjpsYXN0LWNoaWxkLCAubGFyZ2UtdXAtMyA+IC5jb2x1bW5zOmxhc3QtY2hpbGQge1xcbiAgICAgIGZsb2F0OiBsZWZ0OyB9XFxuICAubGFyZ2UtdXAtNCA+IC5jb2x1bW4sIC5sYXJnZS11cC00ID4gLmNvbHVtbnMge1xcbiAgICB3aWR0aDogMjUlO1xcbiAgICBmbG9hdDogbGVmdDsgfVxcbiAgICAubGFyZ2UtdXAtNCA+IC5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLCAubGFyZ2UtdXAtNCA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDFuKSB7XFxuICAgICAgY2xlYXI6IG5vbmU7IH1cXG4gICAgLmxhcmdlLXVwLTQgPiAuY29sdW1uOm50aC1vZi10eXBlKDRuKzEpLCAubGFyZ2UtdXAtNCA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDRuKzEpIHtcXG4gICAgICBjbGVhcjogYm90aDsgfVxcbiAgICAubGFyZ2UtdXAtNCA+IC5jb2x1bW46bGFzdC1jaGlsZCwgLmxhcmdlLXVwLTQgPiAuY29sdW1uczpsYXN0LWNoaWxkIHtcXG4gICAgICBmbG9hdDogbGVmdDsgfVxcbiAgLmxhcmdlLXVwLTUgPiAuY29sdW1uLCAubGFyZ2UtdXAtNSA+IC5jb2x1bW5zIHtcXG4gICAgd2lkdGg6IDIwJTtcXG4gICAgZmxvYXQ6IGxlZnQ7IH1cXG4gICAgLmxhcmdlLXVwLTUgPiAuY29sdW1uOm50aC1vZi10eXBlKDFuKSwgLmxhcmdlLXVwLTUgPiAuY29sdW1uczpudGgtb2YtdHlwZSgxbikge1xcbiAgICAgIGNsZWFyOiBub25lOyB9XFxuICAgIC5sYXJnZS11cC01ID4gLmNvbHVtbjpudGgtb2YtdHlwZSg1bisxKSwgLmxhcmdlLXVwLTUgPiAuY29sdW1uczpudGgtb2YtdHlwZSg1bisxKSB7XFxuICAgICAgY2xlYXI6IGJvdGg7IH1cXG4gICAgLmxhcmdlLXVwLTUgPiAuY29sdW1uOmxhc3QtY2hpbGQsIC5sYXJnZS11cC01ID4gLmNvbHVtbnM6bGFzdC1jaGlsZCB7XFxuICAgICAgZmxvYXQ6IGxlZnQ7IH1cXG4gIC5sYXJnZS11cC02ID4gLmNvbHVtbiwgLmxhcmdlLXVwLTYgPiAuY29sdW1ucyB7XFxuICAgIHdpZHRoOiAxNi42NjY2NyU7XFxuICAgIGZsb2F0OiBsZWZ0OyB9XFxuICAgIC5sYXJnZS11cC02ID4gLmNvbHVtbjpudGgtb2YtdHlwZSgxbiksIC5sYXJnZS11cC02ID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pIHtcXG4gICAgICBjbGVhcjogbm9uZTsgfVxcbiAgICAubGFyZ2UtdXAtNiA+IC5jb2x1bW46bnRoLW9mLXR5cGUoNm4rMSksIC5sYXJnZS11cC02ID4gLmNvbHVtbnM6bnRoLW9mLXR5cGUoNm4rMSkge1xcbiAgICAgIGNsZWFyOiBib3RoOyB9XFxuICAgIC5sYXJnZS11cC02ID4gLmNvbHVtbjpsYXN0LWNoaWxkLCAubGFyZ2UtdXAtNiA+IC5jb2x1bW5zOmxhc3QtY2hpbGQge1xcbiAgICAgIGZsb2F0OiBsZWZ0OyB9XFxuICAubGFyZ2UtdXAtNyA+IC5jb2x1bW4sIC5sYXJnZS11cC03ID4gLmNvbHVtbnMge1xcbiAgICB3aWR0aDogMTQuMjg1NzElO1xcbiAgICBmbG9hdDogbGVmdDsgfVxcbiAgICAubGFyZ2UtdXAtNyA+IC5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLCAubGFyZ2UtdXAtNyA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDFuKSB7XFxuICAgICAgY2xlYXI6IG5vbmU7IH1cXG4gICAgLmxhcmdlLXVwLTcgPiAuY29sdW1uOm50aC1vZi10eXBlKDduKzEpLCAubGFyZ2UtdXAtNyA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDduKzEpIHtcXG4gICAgICBjbGVhcjogYm90aDsgfVxcbiAgICAubGFyZ2UtdXAtNyA+IC5jb2x1bW46bGFzdC1jaGlsZCwgLmxhcmdlLXVwLTcgPiAuY29sdW1uczpsYXN0LWNoaWxkIHtcXG4gICAgICBmbG9hdDogbGVmdDsgfVxcbiAgLmxhcmdlLXVwLTggPiAuY29sdW1uLCAubGFyZ2UtdXAtOCA+IC5jb2x1bW5zIHtcXG4gICAgd2lkdGg6IDEyLjUlO1xcbiAgICBmbG9hdDogbGVmdDsgfVxcbiAgICAubGFyZ2UtdXAtOCA+IC5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLCAubGFyZ2UtdXAtOCA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDFuKSB7XFxuICAgICAgY2xlYXI6IG5vbmU7IH1cXG4gICAgLmxhcmdlLXVwLTggPiAuY29sdW1uOm50aC1vZi10eXBlKDhuKzEpLCAubGFyZ2UtdXAtOCA+IC5jb2x1bW5zOm50aC1vZi10eXBlKDhuKzEpIHtcXG4gICAgICBjbGVhcjogYm90aDsgfVxcbiAgICAubGFyZ2UtdXAtOCA+IC5jb2x1bW46bGFzdC1jaGlsZCwgLmxhcmdlLXVwLTggPiAuY29sdW1uczpsYXN0LWNoaWxkIHtcXG4gICAgICBmbG9hdDogbGVmdDsgfVxcbiAgLmxhcmdlLWNvbGxhcHNlID4gLmNvbHVtbiwgLmxhcmdlLWNvbGxhcHNlID4gLmNvbHVtbnMge1xcbiAgICBwYWRkaW5nLWxlZnQ6IDA7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDA7IH1cXG4gIC5sYXJnZS1jb2xsYXBzZSAucm93LFxcbiAgLmV4cGFuZGVkLnJvdyAubGFyZ2UtY29sbGFwc2Uucm93IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgIG1hcmdpbi1yaWdodDogMDsgfVxcbiAgLmxhcmdlLXVuY29sbGFwc2UgPiAuY29sdW1uLCAubGFyZ2UtdW5jb2xsYXBzZSA+IC5jb2x1bW5zIHtcXG4gICAgcGFkZGluZy1sZWZ0OiAwLjkzNzVyZW07XFxuICAgIHBhZGRpbmctcmlnaHQ6IDAuOTM3NXJlbTsgfVxcbiAgLmxhcmdlLWNlbnRlcmVkIHtcXG4gICAgZmxvYXQ6IG5vbmU7XFxuICAgIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbiAgICBtYXJnaW4tcmlnaHQ6IGF1dG87IH1cXG4gIC5sYXJnZS11bmNlbnRlcmVkLFxcbiAgLmxhcmdlLXB1c2gtMCxcXG4gIC5sYXJnZS1wdWxsLTAge1xcbiAgICBwb3NpdGlvbjogc3RhdGljO1xcbiAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAwO1xcbiAgICBmbG9hdDogbGVmdDsgfSB9XFxuXFxuZGl2LFxcbmRsLFxcbmR0LFxcbmRkLFxcbnVsLFxcbm9sLFxcbmxpLFxcbmgxLFxcbmgyLFxcbmgzLFxcbmg0LFxcbmg1LFxcbmg2LFxcbnByZSxcXG5mb3JtLFxcbnAsXFxuYmxvY2txdW90ZSxcXG50aCxcXG50ZCB7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwOyB9XFxuXFxucCB7XFxuICBmb250LXNpemU6IGluaGVyaXQ7XFxuICBsaW5lLWhlaWdodDogMS42O1xcbiAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG4gIHRleHQtcmVuZGVyaW5nOiBvcHRpbWl6ZUxlZ2liaWxpdHk7IH1cXG5cXG5lbSxcXG5pIHtcXG4gIGZvbnQtc3R5bGU6IGl0YWxpYztcXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyB9XFxuXFxuc3Ryb25nLFxcbmIge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDsgfVxcblxcbnNtYWxsIHtcXG4gIGZvbnQtc2l6ZTogODAlO1xcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IH1cXG5cXG5oMSxcXG5oMixcXG5oMyxcXG5oNCxcXG5oNSxcXG5oNiB7XFxuICBmb250LWZhbWlseTogXFxcIkhlbHZldGljYSBOZXVlXFxcIiwgSGVsdmV0aWNhLCBSb2JvdG8sIEFyaWFsLCBzYW5zLXNlcmlmO1xcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbiAgdGV4dC1yZW5kZXJpbmc6IG9wdGltaXplTGVnaWJpbGl0eTtcXG4gIG1hcmdpbi10b3A6IDA7XFxuICBtYXJnaW4tYm90dG9tOiAwLjVyZW07XFxuICBsaW5lLWhlaWdodDogMS40OyB9XFxuICBoMSBzbWFsbCxcXG4gIGgyIHNtYWxsLFxcbiAgaDMgc21hbGwsXFxuICBoNCBzbWFsbCxcXG4gIGg1IHNtYWxsLFxcbiAgaDYgc21hbGwge1xcbiAgICBjb2xvcjogI2NhY2FjYTtcXG4gICAgbGluZS1oZWlnaHQ6IDA7IH1cXG5cXG5oMSB7XFxuICBmb250LXNpemU6IDEuNXJlbTsgfVxcblxcbmgyIHtcXG4gIGZvbnQtc2l6ZTogMS4yNXJlbTsgfVxcblxcbmgzIHtcXG4gIGZvbnQtc2l6ZTogMS4xODc1cmVtOyB9XFxuXFxuaDQge1xcbiAgZm9udC1zaXplOiAxLjEyNXJlbTsgfVxcblxcbmg1IHtcXG4gIGZvbnQtc2l6ZTogMS4wNjI1cmVtOyB9XFxuXFxuaDYge1xcbiAgZm9udC1zaXplOiAxcmVtOyB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNDBlbSkge1xcbiAgaDEge1xcbiAgICBmb250LXNpemU6IDNyZW07IH1cXG4gIGgyIHtcXG4gICAgZm9udC1zaXplOiAyLjVyZW07IH1cXG4gIGgzIHtcXG4gICAgZm9udC1zaXplOiAxLjkzNzVyZW07IH1cXG4gIGg0IHtcXG4gICAgZm9udC1zaXplOiAxLjU2MjVyZW07IH1cXG4gIGg1IHtcXG4gICAgZm9udC1zaXplOiAxLjI1cmVtOyB9XFxuICBoNiB7XFxuICAgIGZvbnQtc2l6ZTogMXJlbTsgfSB9XFxuXFxuYSB7XFxuICBjb2xvcjogIzIxOTllODtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xcbiAgY3Vyc29yOiBwb2ludGVyOyB9XFxuICBhOmhvdmVyLCBhOmZvY3VzIHtcXG4gICAgY29sb3I6ICMxNTg1Y2Y7IH1cXG4gIGEgaW1nIHtcXG4gICAgYm9yZGVyOiAwOyB9XFxuXFxuaHIge1xcbiAgbWF4LXdpZHRoOiA3NXJlbTtcXG4gIGhlaWdodDogMDtcXG4gIGJvcmRlci1yaWdodDogMDtcXG4gIGJvcmRlci10b3A6IDA7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2NhY2FjYTtcXG4gIGJvcmRlci1sZWZ0OiAwO1xcbiAgbWFyZ2luOiAxLjI1cmVtIGF1dG87XFxuICBjbGVhcjogYm90aDsgfVxcblxcbnVsLFxcbm9sLFxcbmRsIHtcXG4gIGxpbmUtaGVpZ2h0OiAxLjY7XFxuICBtYXJnaW4tYm90dG9tOiAxcmVtO1xcbiAgbGlzdC1zdHlsZS1wb3NpdGlvbjogb3V0c2lkZTsgfVxcblxcbmxpIHtcXG4gIGZvbnQtc2l6ZTogaW5oZXJpdDsgfVxcblxcbnVsIHtcXG4gIGxpc3Qtc3R5bGUtdHlwZTogZGlzYztcXG4gIG1hcmdpbi1sZWZ0OiAxLjI1cmVtOyB9XFxuXFxub2wge1xcbiAgbWFyZ2luLWxlZnQ6IDEuMjVyZW07IH1cXG5cXG51bCB1bCwgb2wgdWwsIHVsIG9sLCBvbCBvbCB7XFxuICBtYXJnaW4tbGVmdDogMS4yNXJlbTtcXG4gIG1hcmdpbi1ib3R0b206IDA7IH1cXG5cXG5kbCB7XFxuICBtYXJnaW4tYm90dG9tOiAxcmVtOyB9XFxuICBkbCBkdCB7XFxuICAgIG1hcmdpbi1ib3R0b206IDAuM3JlbTtcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7IH1cXG5cXG5ibG9ja3F1b3RlIHtcXG4gIG1hcmdpbjogMCAwIDFyZW07XFxuICBwYWRkaW5nOiAwLjU2MjVyZW0gMS4yNXJlbSAwIDEuMTg3NXJlbTtcXG4gIGJvcmRlci1sZWZ0OiAxcHggc29saWQgI2NhY2FjYTsgfVxcbiAgYmxvY2txdW90ZSwgYmxvY2txdW90ZSBwIHtcXG4gICAgbGluZS1oZWlnaHQ6IDEuNjtcXG4gICAgY29sb3I6ICM4YThhOGE7IH1cXG5cXG5jaXRlIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZm9udC1zaXplOiAwLjgxMjVyZW07XFxuICBjb2xvcjogIzhhOGE4YTsgfVxcbiAgY2l0ZTpiZWZvcmUge1xcbiAgICBjb250ZW50OiAnXFxcXDIwMTQgICAgJzsgfVxcblxcbmFiYnIge1xcbiAgY29sb3I6ICMwYTBhMGE7XFxuICBjdXJzb3I6IGhlbHA7XFxuICBib3JkZXItYm90dG9tOiAxcHggZG90dGVkICMwYTBhMGE7IH1cXG5cXG5jb2RlIHtcXG4gIGZvbnQtZmFtaWx5OiBDb25zb2xhcywgXFxcIkxpYmVyYXRpb24gTW9ub1xcXCIsIENvdXJpZXIsIG1vbm9zcGFjZTtcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICBjb2xvcjogIzBhMGEwYTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlNmU2ZTY7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjY2FjYWNhO1xcbiAgcGFkZGluZzogMC4xMjVyZW0gMC4zMTI1cmVtIDAuMDYyNXJlbTsgfVxcblxcbmtiZCB7XFxuICBwYWRkaW5nOiAwLjEyNXJlbSAwLjI1cmVtIDA7XFxuICBtYXJnaW46IDA7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZTZlNmU2O1xcbiAgY29sb3I6ICMwYTBhMGE7XFxuICBmb250LWZhbWlseTogQ29uc29sYXMsIFxcXCJMaWJlcmF0aW9uIE1vbm9cXFwiLCBDb3VyaWVyLCBtb25vc3BhY2U7IH1cXG5cXG4uc3ViaGVhZGVyIHtcXG4gIG1hcmdpbi10b3A6IDAuMnJlbTtcXG4gIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICBsaW5lLWhlaWdodDogMS40O1xcbiAgY29sb3I6ICM4YThhOGE7IH1cXG5cXG4ubGVhZCB7XFxuICBmb250LXNpemU6IDEyNSU7XFxuICBsaW5lLWhlaWdodDogMS42OyB9XFxuXFxuLnN0YXQge1xcbiAgZm9udC1zaXplOiAyLjVyZW07XFxuICBsaW5lLWhlaWdodDogMTsgfVxcbiAgcCArIC5zdGF0IHtcXG4gICAgbWFyZ2luLXRvcDogLTFyZW07IH1cXG5cXG4ubm8tYnVsbGV0IHtcXG4gIG1hcmdpbi1sZWZ0OiAwO1xcbiAgbGlzdC1zdHlsZTogbm9uZTsgfVxcblxcbi50ZXh0LWxlZnQge1xcbiAgdGV4dC1hbGlnbjogbGVmdDsgfVxcblxcbi50ZXh0LXJpZ2h0IHtcXG4gIHRleHQtYWxpZ246IHJpZ2h0OyB9XFxuXFxuLnRleHQtY2VudGVyIHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjsgfVxcblxcbi50ZXh0LWp1c3RpZnkge1xcbiAgdGV4dC1hbGlnbjoganVzdGlmeTsgfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDQwZW0pIHtcXG4gIC5tZWRpdW0tdGV4dC1sZWZ0IHtcXG4gICAgdGV4dC1hbGlnbjogbGVmdDsgfVxcbiAgLm1lZGl1bS10ZXh0LXJpZ2h0IHtcXG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7IH1cXG4gIC5tZWRpdW0tdGV4dC1jZW50ZXIge1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7IH1cXG4gIC5tZWRpdW0tdGV4dC1qdXN0aWZ5IHtcXG4gICAgdGV4dC1hbGlnbjoganVzdGlmeTsgfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNjRlbSkge1xcbiAgLmxhcmdlLXRleHQtbGVmdCB7XFxuICAgIHRleHQtYWxpZ246IGxlZnQ7IH1cXG4gIC5sYXJnZS10ZXh0LXJpZ2h0IHtcXG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7IH1cXG4gIC5sYXJnZS10ZXh0LWNlbnRlciB7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjsgfVxcbiAgLmxhcmdlLXRleHQtanVzdGlmeSB7XFxuICAgIHRleHQtYWxpZ246IGp1c3RpZnk7IH0gfVxcblxcbi5zaG93LWZvci1wcmludCB7XFxuICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7IH1cXG5cXG5AbWVkaWEgcHJpbnQge1xcbiAgKiB7XFxuICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7XFxuICAgIGNvbG9yOiBibGFjayAhaW1wb3J0YW50O1xcbiAgICBib3gtc2hhZG93OiBub25lICFpbXBvcnRhbnQ7XFxuICAgIHRleHQtc2hhZG93OiBub25lICFpbXBvcnRhbnQ7IH1cXG4gIC5zaG93LWZvci1wcmludCB7XFxuICAgIGRpc3BsYXk6IGJsb2NrICFpbXBvcnRhbnQ7IH1cXG4gIC5oaWRlLWZvci1wcmludCB7XFxuICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDsgfVxcbiAgdGFibGUuc2hvdy1mb3ItcHJpbnQge1xcbiAgICBkaXNwbGF5OiB0YWJsZSAhaW1wb3J0YW50OyB9XFxuICB0aGVhZC5zaG93LWZvci1wcmludCB7XFxuICAgIGRpc3BsYXk6IHRhYmxlLWhlYWRlci1ncm91cCAhaW1wb3J0YW50OyB9XFxuICB0Ym9keS5zaG93LWZvci1wcmludCB7XFxuICAgIGRpc3BsYXk6IHRhYmxlLXJvdy1ncm91cCAhaW1wb3J0YW50OyB9XFxuICB0ci5zaG93LWZvci1wcmludCB7XFxuICAgIGRpc3BsYXk6IHRhYmxlLXJvdyAhaW1wb3J0YW50OyB9XFxuICB0ZC5zaG93LWZvci1wcmludCB7XFxuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGwgIWltcG9ydGFudDsgfVxcbiAgdGguc2hvdy1mb3ItcHJpbnQge1xcbiAgICBkaXNwbGF5OiB0YWJsZS1jZWxsICFpbXBvcnRhbnQ7IH1cXG4gIGEsXFxuICBhOnZpc2l0ZWQge1xcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTsgfVxcbiAgYVtocmVmXTphZnRlciB7XFxuICAgIGNvbnRlbnQ6IFxcXCIgKFxcXCIgYXR0cihocmVmKSBcXFwiKVxcXCI7IH1cXG4gIC5pciBhOmFmdGVyLFxcbiAgYVtocmVmXj0namF2YXNjcmlwdDonXTphZnRlcixcXG4gIGFbaHJlZl49JyMnXTphZnRlciB7XFxuICAgIGNvbnRlbnQ6ICcnOyB9XFxuICBhYmJyW3RpdGxlXTphZnRlciB7XFxuICAgIGNvbnRlbnQ6IFxcXCIgKFxcXCIgYXR0cih0aXRsZSkgXFxcIilcXFwiOyB9XFxuICBwcmUsXFxuICBibG9ja3F1b3RlIHtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgIzhhOGE4YTtcXG4gICAgcGFnZS1icmVhay1pbnNpZGU6IGF2b2lkOyB9XFxuICB0aGVhZCB7XFxuICAgIGRpc3BsYXk6IHRhYmxlLWhlYWRlci1ncm91cDsgfVxcbiAgdHIsXFxuICBpbWcge1xcbiAgICBwYWdlLWJyZWFrLWluc2lkZTogYXZvaWQ7IH1cXG4gIGltZyB7XFxuICAgIG1heC13aWR0aDogMTAwJSAhaW1wb3J0YW50OyB9XFxuICBAcGFnZSB7XFxuICAgIG1hcmdpbjogMC41Y207IH1cXG4gIHAsXFxuICBoMixcXG4gIGgzIHtcXG4gICAgb3JwaGFuczogMztcXG4gICAgd2lkb3dzOiAzOyB9XFxuICBoMixcXG4gIGgzIHtcXG4gICAgcGFnZS1icmVhay1hZnRlcjogYXZvaWQ7IH0gfVxcblxcblt0eXBlPSd0ZXh0J10sIFt0eXBlPSdwYXNzd29yZCddLCBbdHlwZT0nZGF0ZSddLCBbdHlwZT0nZGF0ZXRpbWUnXSwgW3R5cGU9J2RhdGV0aW1lLWxvY2FsJ10sIFt0eXBlPSdtb250aCddLCBbdHlwZT0nd2VlayddLCBbdHlwZT0nZW1haWwnXSwgW3R5cGU9J251bWJlciddLCBbdHlwZT0nc2VhcmNoJ10sIFt0eXBlPSd0ZWwnXSwgW3R5cGU9J3RpbWUnXSwgW3R5cGU9J3VybCddLCBbdHlwZT0nY29sb3InXSxcXG50ZXh0YXJlYSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMi40Mzc1cmVtO1xcbiAgcGFkZGluZzogMC41cmVtO1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2NhY2FjYTtcXG4gIG1hcmdpbjogMCAwIDFyZW07XFxuICBmb250LWZhbWlseTogaW5oZXJpdDtcXG4gIGZvbnQtc2l6ZTogMXJlbTtcXG4gIGNvbG9yOiAjMGEwYTBhO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZlZmVmZTtcXG4gIGJveC1zaGFkb3c6IGluc2V0IDAgMXB4IDJweCByZ2JhKDEwLCAxMCwgMTAsIDAuMSk7XFxuICBib3JkZXItcmFkaXVzOiAwO1xcbiAgdHJhbnNpdGlvbjogYm94LXNoYWRvdyAwLjVzLCBib3JkZXItY29sb3IgMC4yNXMgZWFzZS1pbi1vdXQ7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAtbW96LWFwcGVhcmFuY2U6IG5vbmU7IH1cXG4gIFt0eXBlPSd0ZXh0J106Zm9jdXMsIFt0eXBlPSdwYXNzd29yZCddOmZvY3VzLCBbdHlwZT0nZGF0ZSddOmZvY3VzLCBbdHlwZT0nZGF0ZXRpbWUnXTpmb2N1cywgW3R5cGU9J2RhdGV0aW1lLWxvY2FsJ106Zm9jdXMsIFt0eXBlPSdtb250aCddOmZvY3VzLCBbdHlwZT0nd2VlayddOmZvY3VzLCBbdHlwZT0nZW1haWwnXTpmb2N1cywgW3R5cGU9J251bWJlciddOmZvY3VzLCBbdHlwZT0nc2VhcmNoJ106Zm9jdXMsIFt0eXBlPSd0ZWwnXTpmb2N1cywgW3R5cGU9J3RpbWUnXTpmb2N1cywgW3R5cGU9J3VybCddOmZvY3VzLCBbdHlwZT0nY29sb3InXTpmb2N1cyxcXG4gIHRleHRhcmVhOmZvY3VzIHtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgIzhhOGE4YTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZlZmVmZTtcXG4gICAgb3V0bGluZTogbm9uZTtcXG4gICAgYm94LXNoYWRvdzogMCAwIDVweCAjY2FjYWNhO1xcbiAgICB0cmFuc2l0aW9uOiBib3gtc2hhZG93IDAuNXMsIGJvcmRlci1jb2xvciAwLjI1cyBlYXNlLWluLW91dDsgfVxcblxcbnRleHRhcmVhIHtcXG4gIG1heC13aWR0aDogMTAwJTsgfVxcbiAgdGV4dGFyZWFbcm93c10ge1xcbiAgICBoZWlnaHQ6IGF1dG87IH1cXG5cXG5pbnB1dDo6cGxhY2Vob2xkZXIsXFxudGV4dGFyZWE6OnBsYWNlaG9sZGVyIHtcXG4gIGNvbG9yOiAjY2FjYWNhOyB9XFxuXFxuaW5wdXQ6ZGlzYWJsZWQsIGlucHV0W3JlYWRvbmx5XSxcXG50ZXh0YXJlYTpkaXNhYmxlZCxcXG50ZXh0YXJlYVtyZWFkb25seV0ge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2U2ZTZlNjtcXG4gIGN1cnNvcjogbm90LWFsbG93ZWQ7IH1cXG5cXG5bdHlwZT0nc3VibWl0J10sXFxuW3R5cGU9J2J1dHRvbiddIHtcXG4gIGJvcmRlci1yYWRpdXM6IDA7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAtbW96LWFwcGVhcmFuY2U6IG5vbmU7IH1cXG5cXG5pbnB1dFt0eXBlPSdzZWFyY2gnXSB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9XFxuXFxuW3R5cGU9J2ZpbGUnXSxcXG5bdHlwZT0nY2hlY2tib3gnXSxcXG5bdHlwZT0ncmFkaW8nXSB7XFxuICBtYXJnaW46IDAgMCAxcmVtOyB9XFxuXFxuW3R5cGU9J2NoZWNrYm94J10gKyBsYWJlbCxcXG5bdHlwZT0ncmFkaW8nXSArIGxhYmVsIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIG1hcmdpbi1sZWZ0OiAwLjVyZW07XFxuICBtYXJnaW4tcmlnaHQ6IDFyZW07XFxuICBtYXJnaW4tYm90dG9tOiAwO1xcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lOyB9XFxuICBbdHlwZT0nY2hlY2tib3gnXSArIGxhYmVsW2Zvcl0sXFxuICBbdHlwZT0ncmFkaW8nXSArIGxhYmVsW2Zvcl0ge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7IH1cXG5cXG5sYWJlbCA+IFt0eXBlPSdjaGVja2JveCddLFxcbmxhYmVsID4gW3R5cGU9J3JhZGlvJ10ge1xcbiAgbWFyZ2luLXJpZ2h0OiAwLjVyZW07IH1cXG5cXG5bdHlwZT0nZmlsZSddIHtcXG4gIHdpZHRoOiAxMDAlOyB9XFxuXFxubGFiZWwge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBtYXJnaW46IDA7XFxuICBmb250LXNpemU6IDAuODc1cmVtO1xcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gIGxpbmUtaGVpZ2h0OiAxLjg7XFxuICBjb2xvcjogIzBhMGEwYTsgfVxcbiAgbGFiZWwubWlkZGxlIHtcXG4gICAgbWFyZ2luOiAwIDAgMXJlbTtcXG4gICAgcGFkZGluZzogMC41NjI1cmVtIDA7IH1cXG5cXG4uaGVscC10ZXh0IHtcXG4gIG1hcmdpbi10b3A6IC0wLjVyZW07XFxuICBmb250LXNpemU6IDAuODEyNXJlbTtcXG4gIGZvbnQtc3R5bGU6IGl0YWxpYztcXG4gIGNvbG9yOiAjMGEwYTBhOyB9XFxuXFxuLmlucHV0LWdyb3VwIHtcXG4gIGRpc3BsYXk6IHRhYmxlO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBtYXJnaW4tYm90dG9tOiAxcmVtOyB9XFxuICAuaW5wdXQtZ3JvdXAgPiA6Zmlyc3QtY2hpbGQge1xcbiAgICBib3JkZXItcmFkaXVzOiAwIDAgMCAwOyB9XFxuICAuaW5wdXQtZ3JvdXAgPiA6bGFzdC1jaGlsZCA+ICoge1xcbiAgICBib3JkZXItcmFkaXVzOiAwIDAgMCAwOyB9XFxuXFxuLmlucHV0LWdyb3VwLWxhYmVsLCAuaW5wdXQtZ3JvdXAtZmllbGQsIC5pbnB1dC1ncm91cC1idXR0b24ge1xcbiAgbWFyZ2luOiAwO1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIGRpc3BsYXk6IHRhYmxlLWNlbGw7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyB9XFxuXFxuLmlucHV0LWdyb3VwLWxhYmVsIHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIHBhZGRpbmc6IDAgMXJlbTtcXG4gIGJhY2tncm91bmQ6ICNlNmU2ZTY7XFxuICBjb2xvcjogIzBhMGEwYTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNjYWNhY2E7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgd2lkdGg6IDElO1xcbiAgaGVpZ2h0OiAxMDAlOyB9XFxuICAuaW5wdXQtZ3JvdXAtbGFiZWw6Zmlyc3QtY2hpbGQge1xcbiAgICBib3JkZXItcmlnaHQ6IDA7IH1cXG4gIC5pbnB1dC1ncm91cC1sYWJlbDpsYXN0LWNoaWxkIHtcXG4gICAgYm9yZGVyLWxlZnQ6IDA7IH1cXG5cXG4uaW5wdXQtZ3JvdXAtZmllbGQge1xcbiAgYm9yZGVyLXJhZGl1czogMDtcXG4gIGhlaWdodDogMi41cmVtOyB9XFxuXFxuLmlucHV0LWdyb3VwLWJ1dHRvbiB7XFxuICBwYWRkaW5nLXRvcDogMDtcXG4gIHBhZGRpbmctYm90dG9tOiAwO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgd2lkdGg6IDElOyB9XFxuICAuaW5wdXQtZ3JvdXAtYnV0dG9uIGEsXFxuICAuaW5wdXQtZ3JvdXAtYnV0dG9uIGlucHV0LFxcbiAgLmlucHV0LWdyb3VwLWJ1dHRvbiBidXR0b24ge1xcbiAgICBtYXJnaW46IDA7IH1cXG5cXG4uaW5wdXQtZ3JvdXAgLmlucHV0LWdyb3VwLWJ1dHRvbiB7XFxuICBkaXNwbGF5OiB0YWJsZS1jZWxsOyB9XFxuXFxuZmllbGRzZXQge1xcbiAgYm9yZGVyOiAwO1xcbiAgcGFkZGluZzogMDtcXG4gIG1hcmdpbjogMDsgfVxcblxcbmxlZ2VuZCB7XFxuICBtYXJnaW4tYm90dG9tOiAwLjVyZW07XFxuICBtYXgtd2lkdGg6IDEwMCU7IH1cXG5cXG4uZmllbGRzZXQge1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2NhY2FjYTtcXG4gIHBhZGRpbmc6IDEuMjVyZW07XFxuICBtYXJnaW46IDEuMTI1cmVtIDA7IH1cXG4gIC5maWVsZHNldCBsZWdlbmQge1xcbiAgICBiYWNrZ3JvdW5kOiAjZmVmZWZlO1xcbiAgICBwYWRkaW5nOiAwIDAuMTg3NXJlbTtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBtYXJnaW4tbGVmdDogLTAuMTg3NXJlbTsgfVxcblxcbnNlbGVjdCB7XFxuICBoZWlnaHQ6IDIuNDM3NXJlbTtcXG4gIHBhZGRpbmc6IDAuNXJlbTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNjYWNhY2E7XFxuICBtYXJnaW46IDAgMCAxcmVtO1xcbiAgZm9udC1zaXplOiAxcmVtO1xcbiAgZm9udC1mYW1pbHk6IGluaGVyaXQ7XFxuICBsaW5lLWhlaWdodDogbm9ybWFsO1xcbiAgY29sb3I6ICMwYTBhMGE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmVmZWZlO1xcbiAgYm9yZGVyLXJhZGl1czogMDtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG4gIC1tb3otYXBwZWFyYW5jZTogbm9uZTtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sO3V0ZjgsPHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZlcnNpb249JzEuMScgd2lkdGg9JzMyJyBoZWlnaHQ9JzI0JyB2aWV3Qm94PScwIDAgMzIgMjQnPjxwb2x5Z29uIHBvaW50cz0nMCwwIDMyLDAgMTYsMjQnIHN0eWxlPSdmaWxsOiByZ2IlMjgxMzgsIDEzOCwgMTM4JTI5Jz48L3BvbHlnb24+PC9zdmc+XFxcIik7XFxuICBiYWNrZ3JvdW5kLXNpemU6IDlweCA2cHg7XFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiByaWdodCAtMXJlbSBjZW50ZXI7XFxuICBiYWNrZ3JvdW5kLW9yaWdpbjogY29udGVudC1ib3g7XFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgcGFkZGluZy1yaWdodDogMS41cmVtOyB9XFxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiAwXFxcXDApIHtcXG4gICAgc2VsZWN0IHtcXG4gICAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXFxcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQ0FBQUFBWUNBWUFBQUNiVS84MEFBQUFHWFJGV0hSVGIyWjBkMkZ5WlFCQlpHOWlaU0JKYldGblpWSmxZV1I1Y2NsbFBBQUFBSXBKUkVGVWVOckVrY2tOZ0RBTUJCZlJrRXQwT2JSQkJkc0dYVURnbVFmSzRYaEgybThjelFBQXkyN1IzdHN3NFFmZTJ4OHVPTzZvWUxiNkdsT29yM0dGK3N3VVJBT21VSitSd3RFSnM5V3ZUR0VZeEJYcUkxTVFBWmhDZlVRS1J6RE1WaitUd3JBSVY2anZTVUVrWUFyMUxTa2N5VEJiL1YrS1lmWDd4QWV1c3Ezc0xEdEdIM2tFR0FDUFdJZmxOWmZoUlFBQUFBQkpSVTVFcmtKZ2dnPT1cXFwiKTsgfSB9XFxuICBzZWxlY3Q6ZGlzYWJsZWQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZTZlNmU2O1xcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkOyB9XFxuICBzZWxlY3Q6Oi1tcy1leHBhbmQge1xcbiAgICBkaXNwbGF5OiBub25lOyB9XFxuICBzZWxlY3RbbXVsdGlwbGVdIHtcXG4gICAgaGVpZ2h0OiBhdXRvO1xcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiBub25lOyB9XFxuXFxuLmlzLWludmFsaWQtaW5wdXQ6bm90KDpmb2N1cykge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMzYsIDg4LCA2NCwgMC4xKTtcXG4gIGJvcmRlci1jb2xvcjogI2VjNTg0MDsgfVxcblxcbi5pcy1pbnZhbGlkLWxhYmVsIHtcXG4gIGNvbG9yOiAjZWM1ODQwOyB9XFxuXFxuLmZvcm0tZXJyb3Ige1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIG1hcmdpbi10b3A6IC0wLjVyZW07XFxuICBtYXJnaW4tYm90dG9tOiAxcmVtO1xcbiAgZm9udC1zaXplOiAwLjc1cmVtO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBjb2xvcjogI2VjNTg0MDsgfVxcbiAgLmZvcm0tZXJyb3IuaXMtdmlzaWJsZSB7XFxuICAgIGRpc3BsYXk6IGJsb2NrOyB9XFxuXFxuLmJ1dHRvbiB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBsaW5lLWhlaWdodDogMTtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG4gIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMC4yNXMgZWFzZS1vdXQsIGNvbG9yIDAuMjVzIGVhc2Utb3V0O1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyLXJhZGl1czogMDtcXG4gIHBhZGRpbmc6IDAuODVlbSAxZW07XFxuICBtYXJnaW46IDAgMCAxcmVtIDA7XFxuICBmb250LXNpemU6IDAuOXJlbTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMyMTk5ZTg7XFxuICBjb2xvcjogI2ZlZmVmZTsgfVxcbiAgW2RhdGEtd2hhdGlucHV0PSdtb3VzZSddIC5idXR0b24ge1xcbiAgICBvdXRsaW5lOiAwOyB9XFxuICAuYnV0dG9uOmhvdmVyLCAuYnV0dG9uOmZvY3VzIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzE1ODNjYztcXG4gICAgY29sb3I6ICNmZWZlZmU7IH1cXG4gIC5idXR0b24udGlueSB7XFxuICAgIGZvbnQtc2l6ZTogMC42cmVtOyB9XFxuICAuYnV0dG9uLnNtYWxsIHtcXG4gICAgZm9udC1zaXplOiAwLjc1cmVtOyB9XFxuICAuYnV0dG9uLmxhcmdlIHtcXG4gICAgZm9udC1zaXplOiAxLjI1cmVtOyB9XFxuICAuYnV0dG9uLmV4cGFuZGVkIHtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAwOyB9XFxuICAuYnV0dG9uLnByaW1hcnkge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjE5OWU4O1xcbiAgICBjb2xvcjogI2ZlZmVmZTsgfVxcbiAgICAuYnV0dG9uLnByaW1hcnk6aG92ZXIsIC5idXR0b24ucHJpbWFyeTpmb2N1cyB7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzE0N2NjMDtcXG4gICAgICBjb2xvcjogI2ZlZmVmZTsgfVxcbiAgLmJ1dHRvbi5zZWNvbmRhcnkge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNzc3O1xcbiAgICBjb2xvcjogI2ZlZmVmZTsgfVxcbiAgICAuYnV0dG9uLnNlY29uZGFyeTpob3ZlciwgLmJ1dHRvbi5zZWNvbmRhcnk6Zm9jdXMge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICM1ZjVmNWY7XFxuICAgICAgY29sb3I6ICNmZWZlZmU7IH1cXG4gIC5idXR0b24uc3VjY2VzcyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMzYWRiNzY7XFxuICAgIGNvbG9yOiAjZmVmZWZlOyB9XFxuICAgIC5idXR0b24uc3VjY2Vzczpob3ZlciwgLmJ1dHRvbi5zdWNjZXNzOmZvY3VzIHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjJiYjViO1xcbiAgICAgIGNvbG9yOiAjZmVmZWZlOyB9XFxuICAuYnV0dG9uLndhcm5pbmcge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZhZTAwO1xcbiAgICBjb2xvcjogI2ZlZmVmZTsgfVxcbiAgICAuYnV0dG9uLndhcm5pbmc6aG92ZXIsIC5idXR0b24ud2FybmluZzpmb2N1cyB7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2NjOGIwMDtcXG4gICAgICBjb2xvcjogI2ZlZmVmZTsgfVxcbiAgLmJ1dHRvbi5hbGVydCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNlYzU4NDA7XFxuICAgIGNvbG9yOiAjZmVmZWZlOyB9XFxuICAgIC5idXR0b24uYWxlcnQ6aG92ZXIsIC5idXR0b24uYWxlcnQ6Zm9jdXMge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICNkYTMxMTY7XFxuICAgICAgY29sb3I6ICNmZWZlZmU7IH1cXG4gIC5idXR0b24uaG9sbG93IHtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgIzIxOTllODtcXG4gICAgY29sb3I6ICMyMTk5ZTg7IH1cXG4gICAgLmJ1dHRvbi5ob2xsb3csIC5idXR0b24uaG9sbG93OmhvdmVyLCAuYnV0dG9uLmhvbGxvdzpmb2N1cyB7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7IH1cXG4gICAgLmJ1dHRvbi5ob2xsb3c6aG92ZXIsIC5idXR0b24uaG9sbG93OmZvY3VzIHtcXG4gICAgICBib3JkZXItY29sb3I6ICMwYzRkNzg7XFxuICAgICAgY29sb3I6ICMwYzRkNzg7IH1cXG4gICAgLmJ1dHRvbi5ob2xsb3cucHJpbWFyeSB7XFxuICAgICAgYm9yZGVyOiAxcHggc29saWQgIzIxOTllODtcXG4gICAgICBjb2xvcjogIzIxOTllODsgfVxcbiAgICAgIC5idXR0b24uaG9sbG93LnByaW1hcnk6aG92ZXIsIC5idXR0b24uaG9sbG93LnByaW1hcnk6Zm9jdXMge1xcbiAgICAgICAgYm9yZGVyLWNvbG9yOiAjMGM0ZDc4O1xcbiAgICAgICAgY29sb3I6ICMwYzRkNzg7IH1cXG4gICAgLmJ1dHRvbi5ob2xsb3cuc2Vjb25kYXJ5IHtcXG4gICAgICBib3JkZXI6IDFweCBzb2xpZCAjNzc3O1xcbiAgICAgIGNvbG9yOiAjNzc3OyB9XFxuICAgICAgLmJ1dHRvbi5ob2xsb3cuc2Vjb25kYXJ5OmhvdmVyLCAuYnV0dG9uLmhvbGxvdy5zZWNvbmRhcnk6Zm9jdXMge1xcbiAgICAgICAgYm9yZGVyLWNvbG9yOiAjM2MzYzNjO1xcbiAgICAgICAgY29sb3I6ICMzYzNjM2M7IH1cXG4gICAgLmJ1dHRvbi5ob2xsb3cuc3VjY2VzcyB7XFxuICAgICAgYm9yZGVyOiAxcHggc29saWQgIzNhZGI3NjtcXG4gICAgICBjb2xvcjogIzNhZGI3NjsgfVxcbiAgICAgIC5idXR0b24uaG9sbG93LnN1Y2Nlc3M6aG92ZXIsIC5idXR0b24uaG9sbG93LnN1Y2Nlc3M6Zm9jdXMge1xcbiAgICAgICAgYm9yZGVyLWNvbG9yOiAjMTU3NTM5O1xcbiAgICAgICAgY29sb3I6ICMxNTc1Mzk7IH1cXG4gICAgLmJ1dHRvbi5ob2xsb3cud2FybmluZyB7XFxuICAgICAgYm9yZGVyOiAxcHggc29saWQgI2ZmYWUwMDtcXG4gICAgICBjb2xvcjogI2ZmYWUwMDsgfVxcbiAgICAgIC5idXR0b24uaG9sbG93Lndhcm5pbmc6aG92ZXIsIC5idXR0b24uaG9sbG93Lndhcm5pbmc6Zm9jdXMge1xcbiAgICAgICAgYm9yZGVyLWNvbG9yOiAjODA1NzAwO1xcbiAgICAgICAgY29sb3I6ICM4MDU3MDA7IH1cXG4gICAgLmJ1dHRvbi5ob2xsb3cuYWxlcnQge1xcbiAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNlYzU4NDA7XFxuICAgICAgY29sb3I6ICNlYzU4NDA7IH1cXG4gICAgICAuYnV0dG9uLmhvbGxvdy5hbGVydDpob3ZlciwgLmJ1dHRvbi5ob2xsb3cuYWxlcnQ6Zm9jdXMge1xcbiAgICAgICAgYm9yZGVyLWNvbG9yOiAjODgxZjBlO1xcbiAgICAgICAgY29sb3I6ICM4ODFmMGU7IH1cXG4gIC5idXR0b24uZGlzYWJsZWQsIC5idXR0b25bZGlzYWJsZWRdIHtcXG4gICAgb3BhY2l0eTogMC4yNTtcXG4gICAgY3Vyc29yOiBub3QtYWxsb3dlZDsgfVxcbiAgICAuYnV0dG9uLmRpc2FibGVkOmhvdmVyLCAuYnV0dG9uLmRpc2FibGVkOmZvY3VzLCAuYnV0dG9uW2Rpc2FibGVkXTpob3ZlciwgLmJ1dHRvbltkaXNhYmxlZF06Zm9jdXMge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICMyMTk5ZTg7XFxuICAgICAgY29sb3I6ICNmZWZlZmU7IH1cXG4gIC5idXR0b24uZHJvcGRvd246OmFmdGVyIHtcXG4gICAgY29udGVudDogJyc7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICB3aWR0aDogMDtcXG4gICAgaGVpZ2h0OiAwO1xcbiAgICBib3JkZXI6IGluc2V0IDAuNGVtO1xcbiAgICBib3JkZXItY29sb3I6ICNmZWZlZmUgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7XFxuICAgIGJvcmRlci10b3Atc3R5bGU6IHNvbGlkO1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiAwO1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIHRvcDogMC40ZW07XFxuICAgIGZsb2F0OiByaWdodDtcXG4gICAgbWFyZ2luLWxlZnQ6IDFlbTtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrOyB9XFxuICAuYnV0dG9uLmFycm93LW9ubHk6OmFmdGVyIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgIGZsb2F0OiBub25lO1xcbiAgICB0b3A6IC0wLjFlbTsgfVxcblxcbi5hY2NvcmRpb24ge1xcbiAgbGlzdC1zdHlsZS10eXBlOiBub25lO1xcbiAgYmFja2dyb3VuZDogI2ZlZmVmZTtcXG4gIG1hcmdpbi1sZWZ0OiAwOyB9XFxuXFxuLmFjY29yZGlvbi1pdGVtOmZpcnN0LWNoaWxkID4gOmZpcnN0LWNoaWxkIHtcXG4gIGJvcmRlci1yYWRpdXM6IDAgMCAwIDA7IH1cXG5cXG4uYWNjb3JkaW9uLWl0ZW06bGFzdC1jaGlsZCA+IDpsYXN0LWNoaWxkIHtcXG4gIGJvcmRlci1yYWRpdXM6IDAgMCAwIDA7IH1cXG5cXG4uYWNjb3JkaW9uLXRpdGxlIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgcGFkZGluZzogMS4yNXJlbSAxcmVtO1xcbiAgbGluZS1oZWlnaHQ6IDE7XFxuICBmb250LXNpemU6IDAuNzVyZW07XFxuICBjb2xvcjogIzIxOTllODtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlNmU2ZTY7XFxuICBib3JkZXItYm90dG9tOiAwOyB9XFxuICA6bGFzdC1jaGlsZDpub3QoLmlzLWFjdGl2ZSkgPiAuYWNjb3JkaW9uLXRpdGxlIHtcXG4gICAgYm9yZGVyLXJhZGl1czogMCAwIDAgMDtcXG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNlNmU2ZTY7IH1cXG4gIC5hY2NvcmRpb24tdGl0bGU6aG92ZXIsIC5hY2NvcmRpb24tdGl0bGU6Zm9jdXMge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZTZlNmU2OyB9XFxuICAuYWNjb3JkaW9uLXRpdGxlOjpiZWZvcmUge1xcbiAgICBjb250ZW50OiAnKyc7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgcmlnaHQ6IDFyZW07XFxuICAgIHRvcDogNTAlO1xcbiAgICBtYXJnaW4tdG9wOiAtMC41cmVtOyB9XFxuICAuaXMtYWN0aXZlID4gLmFjY29yZGlvbi10aXRsZTo6YmVmb3JlIHtcXG4gICAgY29udGVudDogJ1xcXFwyMDEzJzsgfVxcblxcbi5hY2NvcmRpb24tY29udGVudCB7XFxuICBwYWRkaW5nOiAxcmVtO1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlNmU2ZTY7XFxuICBib3JkZXItYm90dG9tOiAwO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZlZmVmZTtcXG4gIGNvbG9yOiAjMGEwYTBhOyB9XFxuICA6bGFzdC1jaGlsZCA+IC5hY2NvcmRpb24tY29udGVudDpsYXN0LWNoaWxkIHtcXG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNlNmU2ZTY7IH1cXG5cXG4uaXMtYWNjb3JkaW9uLXN1Ym1lbnUtcGFyZW50ID4gYSB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7IH1cXG4gIC5pcy1hY2NvcmRpb24tc3VibWVudS1wYXJlbnQgPiBhOjphZnRlciB7XFxuICAgIGNvbnRlbnQ6ICcnO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgd2lkdGg6IDA7XFxuICAgIGhlaWdodDogMDtcXG4gICAgYm9yZGVyOiBpbnNldCA2cHg7XFxuICAgIGJvcmRlci1jb2xvcjogIzIxOTllOCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtcXG4gICAgYm9yZGVyLXRvcC1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci1ib3R0b20td2lkdGg6IDA7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiA1MCU7XFxuICAgIG1hcmdpbi10b3A6IC00cHg7XFxuICAgIHJpZ2h0OiAxcmVtOyB9XFxuXFxuLmlzLWFjY29yZGlvbi1zdWJtZW51LXBhcmVudFthcmlhLWV4cGFuZGVkPSd0cnVlJ10gPiBhOjphZnRlciB7XFxuICB0cmFuc2Zvcm0tb3JpZ2luOiA1MCUgNTAlO1xcbiAgdHJhbnNmb3JtOiBzY2FsZVkoLTEpOyB9XFxuXFxuLmJhZGdlIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHBhZGRpbmc6IDAuM2VtO1xcbiAgbWluLXdpZHRoOiAyLjFlbTtcXG4gIGZvbnQtc2l6ZTogMC42cmVtO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xcbiAgYmFja2dyb3VuZDogIzIxOTllODtcXG4gIGNvbG9yOiAjZmVmZWZlOyB9XFxuICAuYmFkZ2Uuc2Vjb25kYXJ5IHtcXG4gICAgYmFja2dyb3VuZDogIzc3NztcXG4gICAgY29sb3I6ICNmZWZlZmU7IH1cXG4gIC5iYWRnZS5zdWNjZXNzIHtcXG4gICAgYmFja2dyb3VuZDogIzNhZGI3NjtcXG4gICAgY29sb3I6ICNmZWZlZmU7IH1cXG4gIC5iYWRnZS53YXJuaW5nIHtcXG4gICAgYmFja2dyb3VuZDogI2ZmYWUwMDtcXG4gICAgY29sb3I6ICNmZWZlZmU7IH1cXG4gIC5iYWRnZS5hbGVydCB7XFxuICAgIGJhY2tncm91bmQ6ICNlYzU4NDA7XFxuICAgIGNvbG9yOiAjZmVmZWZlOyB9XFxuXFxuLmJyZWFkY3J1bWJzIHtcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7XFxuICBtYXJnaW46IDAgMCAxcmVtIDA7IH1cXG4gIC5icmVhZGNydW1iczo6YmVmb3JlLCAuYnJlYWRjcnVtYnM6OmFmdGVyIHtcXG4gICAgY29udGVudDogJyAnO1xcbiAgICBkaXNwbGF5OiB0YWJsZTsgfVxcbiAgLmJyZWFkY3J1bWJzOjphZnRlciB7XFxuICAgIGNsZWFyOiBib3RoOyB9XFxuICAuYnJlYWRjcnVtYnMgbGkge1xcbiAgICBmbG9hdDogbGVmdDtcXG4gICAgY29sb3I6ICMwYTBhMGE7XFxuICAgIGZvbnQtc2l6ZTogMC42ODc1cmVtO1xcbiAgICBjdXJzb3I6IGRlZmF1bHQ7XFxuICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7IH1cXG4gICAgLmJyZWFkY3J1bWJzIGxpOm5vdCg6bGFzdC1jaGlsZCk6OmFmdGVyIHtcXG4gICAgICBjb2xvcjogI2NhY2FjYTtcXG4gICAgICBjb250ZW50OiBcXFwiL1xcXCI7XFxuICAgICAgbWFyZ2luOiAwIDAuNzVyZW07XFxuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgIHRvcDogMXB4O1xcbiAgICAgIG9wYWNpdHk6IDE7IH1cXG4gIC5icmVhZGNydW1icyBhIHtcXG4gICAgY29sb3I6ICMyMTk5ZTg7IH1cXG4gICAgLmJyZWFkY3J1bWJzIGE6aG92ZXIge1xcbiAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lOyB9XFxuICAuYnJlYWRjcnVtYnMgLmRpc2FibGVkIHtcXG4gICAgY29sb3I6ICNjYWNhY2E7XFxuICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7IH1cXG5cXG4uYnV0dG9uLWdyb3VwIHtcXG4gIG1hcmdpbi1ib3R0b206IDFyZW07XFxuICBmb250LXNpemU6IDA7IH1cXG4gIC5idXR0b24tZ3JvdXA6OmJlZm9yZSwgLmJ1dHRvbi1ncm91cDo6YWZ0ZXIge1xcbiAgICBjb250ZW50OiAnICc7XFxuICAgIGRpc3BsYXk6IHRhYmxlOyB9XFxuICAuYnV0dG9uLWdyb3VwOjphZnRlciB7XFxuICAgIGNsZWFyOiBib3RoOyB9XFxuICAuYnV0dG9uLWdyb3VwIC5idXR0b24ge1xcbiAgICBtYXJnaW46IDA7XFxuICAgIG1hcmdpbi1yaWdodDogMXB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAxcHg7XFxuICAgIGZvbnQtc2l6ZTogMC45cmVtOyB9XFxuICAgIC5idXR0b24tZ3JvdXAgLmJ1dHRvbjpsYXN0LWNoaWxkIHtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDA7IH1cXG4gIC5idXR0b24tZ3JvdXAudGlueSAuYnV0dG9uIHtcXG4gICAgZm9udC1zaXplOiAwLjZyZW07IH1cXG4gIC5idXR0b24tZ3JvdXAuc21hbGwgLmJ1dHRvbiB7XFxuICAgIGZvbnQtc2l6ZTogMC43NXJlbTsgfVxcbiAgLmJ1dHRvbi1ncm91cC5sYXJnZSAuYnV0dG9uIHtcXG4gICAgZm9udC1zaXplOiAxLjI1cmVtOyB9XFxuICAuYnV0dG9uLWdyb3VwLmV4cGFuZGVkIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtMXB4OyB9XFxuICAgIC5idXR0b24tZ3JvdXAuZXhwYW5kZWQ6OmJlZm9yZSwgLmJ1dHRvbi1ncm91cC5leHBhbmRlZDo6YWZ0ZXIge1xcbiAgICAgIGRpc3BsYXk6IG5vbmU7IH1cXG4gICAgLmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDIpLCAuYnV0dG9uLWdyb3VwLmV4cGFuZGVkIC5idXR0b246Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoMik6Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoMikgfiAuYnV0dG9uIHtcXG4gICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgd2lkdGg6IGNhbGMoNTAlIC0gMXB4KTtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDFweDsgfVxcbiAgICAgIC5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgyKTpsYXN0LWNoaWxkLCAuYnV0dG9uLWdyb3VwLmV4cGFuZGVkIC5idXR0b246Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoMik6Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoMikgfiAuYnV0dG9uOmxhc3QtY2hpbGQge1xcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAtNnB4OyB9XFxuICAgIC5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgzKSwgLmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDMpOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDMpIH4gLmJ1dHRvbiB7XFxuICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgIHdpZHRoOiBjYWxjKDMzLjMzMzMzJSAtIDFweCk7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiAxcHg7IH1cXG4gICAgICAuYnV0dG9uLWdyb3VwLmV4cGFuZGVkIC5idXR0b246Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoMyk6bGFzdC1jaGlsZCwgLmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDMpOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDMpIH4gLmJ1dHRvbjpsYXN0LWNoaWxkIHtcXG4gICAgICAgIG1hcmdpbi1yaWdodDogLTZweDsgfVxcbiAgICAuYnV0dG9uLWdyb3VwLmV4cGFuZGVkIC5idXR0b246Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoNCksIC5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg0KTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg0KSB+IC5idXR0b24ge1xcbiAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgICB3aWR0aDogY2FsYygyNSUgLSAxcHgpO1xcbiAgICAgIG1hcmdpbi1yaWdodDogMXB4OyB9XFxuICAgICAgLmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDQpOmxhc3QtY2hpbGQsIC5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg0KTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg0KSB+IC5idXR0b246bGFzdC1jaGlsZCB7XFxuICAgICAgICBtYXJnaW4tcmlnaHQ6IC02cHg7IH1cXG4gICAgLmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDUpLCAuYnV0dG9uLWdyb3VwLmV4cGFuZGVkIC5idXR0b246Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoNSk6Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoNSkgfiAuYnV0dG9uIHtcXG4gICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgd2lkdGg6IGNhbGMoMjAlIC0gMXB4KTtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDFweDsgfVxcbiAgICAgIC5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg1KTpsYXN0LWNoaWxkLCAuYnV0dG9uLWdyb3VwLmV4cGFuZGVkIC5idXR0b246Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoNSk6Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoNSkgfiAuYnV0dG9uOmxhc3QtY2hpbGQge1xcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAtNnB4OyB9XFxuICAgIC5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg2KSwgLmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDYpOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDYpIH4gLmJ1dHRvbiB7XFxuICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgIHdpZHRoOiBjYWxjKDE2LjY2NjY3JSAtIDFweCk7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiAxcHg7IH1cXG4gICAgICAuYnV0dG9uLWdyb3VwLmV4cGFuZGVkIC5idXR0b246Zmlyc3QtY2hpbGQ6bnRoLWxhc3QtY2hpbGQoNik6bGFzdC1jaGlsZCwgLmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDYpOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDYpIH4gLmJ1dHRvbjpsYXN0LWNoaWxkIHtcXG4gICAgICAgIG1hcmdpbi1yaWdodDogLTZweDsgfVxcbiAgLmJ1dHRvbi1ncm91cC5wcmltYXJ5IC5idXR0b24ge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjE5OWU4O1xcbiAgICBjb2xvcjogI2ZlZmVmZTsgfVxcbiAgICAuYnV0dG9uLWdyb3VwLnByaW1hcnkgLmJ1dHRvbjpob3ZlciwgLmJ1dHRvbi1ncm91cC5wcmltYXJ5IC5idXR0b246Zm9jdXMge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICMxNDdjYzA7XFxuICAgICAgY29sb3I6ICNmZWZlZmU7IH1cXG4gIC5idXR0b24tZ3JvdXAuc2Vjb25kYXJ5IC5idXR0b24ge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNzc3O1xcbiAgICBjb2xvcjogI2ZlZmVmZTsgfVxcbiAgICAuYnV0dG9uLWdyb3VwLnNlY29uZGFyeSAuYnV0dG9uOmhvdmVyLCAuYnV0dG9uLWdyb3VwLnNlY29uZGFyeSAuYnV0dG9uOmZvY3VzIHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNWY1ZjVmO1xcbiAgICAgIGNvbG9yOiAjZmVmZWZlOyB9XFxuICAuYnV0dG9uLWdyb3VwLnN1Y2Nlc3MgLmJ1dHRvbiB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMzYWRiNzY7XFxuICAgIGNvbG9yOiAjZmVmZWZlOyB9XFxuICAgIC5idXR0b24tZ3JvdXAuc3VjY2VzcyAuYnV0dG9uOmhvdmVyLCAuYnV0dG9uLWdyb3VwLnN1Y2Nlc3MgLmJ1dHRvbjpmb2N1cyB7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzIyYmI1YjtcXG4gICAgICBjb2xvcjogI2ZlZmVmZTsgfVxcbiAgLmJ1dHRvbi1ncm91cC53YXJuaW5nIC5idXR0b24ge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZhZTAwO1xcbiAgICBjb2xvcjogI2ZlZmVmZTsgfVxcbiAgICAuYnV0dG9uLWdyb3VwLndhcm5pbmcgLmJ1dHRvbjpob3ZlciwgLmJ1dHRvbi1ncm91cC53YXJuaW5nIC5idXR0b246Zm9jdXMge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICNjYzhiMDA7XFxuICAgICAgY29sb3I6ICNmZWZlZmU7IH1cXG4gIC5idXR0b24tZ3JvdXAuYWxlcnQgLmJ1dHRvbiB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNlYzU4NDA7XFxuICAgIGNvbG9yOiAjZmVmZWZlOyB9XFxuICAgIC5idXR0b24tZ3JvdXAuYWxlcnQgLmJ1dHRvbjpob3ZlciwgLmJ1dHRvbi1ncm91cC5hbGVydCAuYnV0dG9uOmZvY3VzIHtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZGEzMTE2O1xcbiAgICAgIGNvbG9yOiAjZmVmZWZlOyB9XFxuICAuYnV0dG9uLWdyb3VwLnN0YWNrZWQgLmJ1dHRvbiwgLmJ1dHRvbi1ncm91cC5zdGFja2VkLWZvci1zbWFsbCAuYnV0dG9uLCAuYnV0dG9uLWdyb3VwLnN0YWNrZWQtZm9yLW1lZGl1bSAuYnV0dG9uIHtcXG4gICAgd2lkdGg6IDEwMCU7IH1cXG4gICAgLmJ1dHRvbi1ncm91cC5zdGFja2VkIC5idXR0b246bGFzdC1jaGlsZCwgLmJ1dHRvbi1ncm91cC5zdGFja2VkLWZvci1zbWFsbCAuYnV0dG9uOmxhc3QtY2hpbGQsIC5idXR0b24tZ3JvdXAuc3RhY2tlZC1mb3ItbWVkaXVtIC5idXR0b246bGFzdC1jaGlsZCB7XFxuICAgICAgbWFyZ2luLWJvdHRvbTogMDsgfVxcbiAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNDBlbSkge1xcbiAgICAuYnV0dG9uLWdyb3VwLnN0YWNrZWQtZm9yLXNtYWxsIC5idXR0b24ge1xcbiAgICAgIHdpZHRoOiBhdXRvO1xcbiAgICAgIG1hcmdpbi1ib3R0b206IDA7IH0gfVxcbiAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNjRlbSkge1xcbiAgICAuYnV0dG9uLWdyb3VwLnN0YWNrZWQtZm9yLW1lZGl1bSAuYnV0dG9uIHtcXG4gICAgICB3aWR0aDogYXV0bztcXG4gICAgICBtYXJnaW4tYm90dG9tOiAwOyB9IH1cXG4gIEBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDM5LjkzNzVlbSkge1xcbiAgICAuYnV0dG9uLWdyb3VwLnN0YWNrZWQtZm9yLXNtYWxsLmV4cGFuZGVkIHtcXG4gICAgICBkaXNwbGF5OiBibG9jazsgfVxcbiAgICAgIC5idXR0b24tZ3JvdXAuc3RhY2tlZC1mb3Itc21hbGwuZXhwYW5kZWQgLmJ1dHRvbiB7XFxuICAgICAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgICAgIG1hcmdpbi1yaWdodDogMDsgfSB9XFxuXFxuLmNhbGxvdXQge1xcbiAgbWFyZ2luOiAwIDAgMXJlbSAwO1xcbiAgcGFkZGluZzogMXJlbTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMTAsIDEwLCAxMCwgMC4yNSk7XFxuICBib3JkZXItcmFkaXVzOiAwO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgY29sb3I6ICMwYTBhMGE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTsgfVxcbiAgLmNhbGxvdXQgPiA6Zmlyc3QtY2hpbGQge1xcbiAgICBtYXJnaW4tdG9wOiAwOyB9XFxuICAuY2FsbG91dCA+IDpsYXN0LWNoaWxkIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMDsgfVxcbiAgLmNhbGxvdXQucHJpbWFyeSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNkZWYwZmM7IH1cXG4gIC5jYWxsb3V0LnNlY29uZGFyeSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNlYmViZWI7IH1cXG4gIC5jYWxsb3V0LnN1Y2Nlc3Mge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZTFmYWVhOyB9XFxuICAuY2FsbG91dC53YXJuaW5nIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjNkOTsgfVxcbiAgLmNhbGxvdXQuYWxlcnQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmNlNmUyOyB9XFxuICAuY2FsbG91dC5zbWFsbCB7XFxuICAgIHBhZGRpbmctdG9wOiAwLjVyZW07XFxuICAgIHBhZGRpbmctcmlnaHQ6IDAuNXJlbTtcXG4gICAgcGFkZGluZy1ib3R0b206IDAuNXJlbTtcXG4gICAgcGFkZGluZy1sZWZ0OiAwLjVyZW07IH1cXG4gIC5jYWxsb3V0LmxhcmdlIHtcXG4gICAgcGFkZGluZy10b3A6IDNyZW07XFxuICAgIHBhZGRpbmctcmlnaHQ6IDNyZW07XFxuICAgIHBhZGRpbmctYm90dG9tOiAzcmVtO1xcbiAgICBwYWRkaW5nLWxlZnQ6IDNyZW07IH1cXG5cXG4uY2xvc2UtYnV0dG9uIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGNvbG9yOiAjOGE4YThhO1xcbiAgcmlnaHQ6IDFyZW07XFxuICB0b3A6IDAuNXJlbTtcXG4gIGZvbnQtc2l6ZTogMmVtO1xcbiAgbGluZS1oZWlnaHQ6IDE7XFxuICBjdXJzb3I6IHBvaW50ZXI7IH1cXG4gIFtkYXRhLXdoYXRpbnB1dD0nbW91c2UnXSAuY2xvc2UtYnV0dG9uIHtcXG4gICAgb3V0bGluZTogMDsgfVxcbiAgLmNsb3NlLWJ1dHRvbjpob3ZlciwgLmNsb3NlLWJ1dHRvbjpmb2N1cyB7XFxuICAgIGNvbG9yOiAjMGEwYTBhOyB9XFxuXFxuLm1lbnUge1xcbiAgbWFyZ2luOiAwO1xcbiAgbGlzdC1zdHlsZS10eXBlOiBub25lOyB9XFxuICAubWVudSA+IGxpIHtcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTsgfVxcbiAgICBbZGF0YS13aGF0aW5wdXQ9J21vdXNlJ10gLm1lbnUgPiBsaSB7XFxuICAgICAgb3V0bGluZTogMDsgfVxcbiAgLm1lbnUgPiBsaSA+IGEge1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgcGFkZGluZzogMC43cmVtIDFyZW07XFxuICAgIGxpbmUtaGVpZ2h0OiAxOyB9XFxuICAubWVudSBpbnB1dCxcXG4gIC5tZW51IGEsXFxuICAubWVudSBidXR0b24ge1xcbiAgICBtYXJnaW4tYm90dG9tOiAwOyB9XFxuICAubWVudSA+IGxpID4gYSBpbWcsXFxuICAubWVudSA+IGxpID4gYSBpLFxcbiAgLm1lbnUgPiBsaSA+IGEgc3ZnIHtcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTsgfVxcbiAgICAubWVudSA+IGxpID4gYSBpbWcgKyBzcGFuLFxcbiAgICAubWVudSA+IGxpID4gYSBpICsgc3BhbixcXG4gICAgLm1lbnUgPiBsaSA+IGEgc3ZnICsgc3BhbiB7XFxuICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTsgfVxcbiAgLm1lbnUgPiBsaSA+IGEgaW1nLFxcbiAgLm1lbnUgPiBsaSA+IGEgaSxcXG4gIC5tZW51ID4gbGkgPiBhIHN2ZyB7XFxuICAgIG1hcmdpbi1yaWdodDogMC4yNXJlbTtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrOyB9XFxuICAubWVudSA+IGxpIHtcXG4gICAgZGlzcGxheTogdGFibGUtY2VsbDsgfVxcbiAgLm1lbnUudmVydGljYWwgPiBsaSB7XFxuICAgIGRpc3BsYXk6IGJsb2NrOyB9XFxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA0MGVtKSB7XFxuICAgIC5tZW51Lm1lZGl1bS1ob3Jpem9udGFsID4gbGkge1xcbiAgICAgIGRpc3BsYXk6IHRhYmxlLWNlbGw7IH1cXG4gICAgLm1lbnUubWVkaXVtLXZlcnRpY2FsID4gbGkge1xcbiAgICAgIGRpc3BsYXk6IGJsb2NrOyB9IH1cXG4gIEBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDY0ZW0pIHtcXG4gICAgLm1lbnUubGFyZ2UtaG9yaXpvbnRhbCA+IGxpIHtcXG4gICAgICBkaXNwbGF5OiB0YWJsZS1jZWxsOyB9XFxuICAgIC5tZW51LmxhcmdlLXZlcnRpY2FsID4gbGkge1xcbiAgICAgIGRpc3BsYXk6IGJsb2NrOyB9IH1cXG4gIC5tZW51LnNpbXBsZSBsaSB7XFxuICAgIGxpbmUtaGVpZ2h0OiAxO1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIG1hcmdpbi1yaWdodDogMXJlbTsgfVxcbiAgLm1lbnUuc2ltcGxlIGEge1xcbiAgICBwYWRkaW5nOiAwOyB9XFxuICAubWVudS5hbGlnbi1yaWdodDo6YmVmb3JlLCAubWVudS5hbGlnbi1yaWdodDo6YWZ0ZXIge1xcbiAgICBjb250ZW50OiAnICc7XFxuICAgIGRpc3BsYXk6IHRhYmxlOyB9XFxuICAubWVudS5hbGlnbi1yaWdodDo6YWZ0ZXIge1xcbiAgICBjbGVhcjogYm90aDsgfVxcbiAgLm1lbnUuYWxpZ24tcmlnaHQgPiBsaSB7XFxuICAgIGZsb2F0OiByaWdodDsgfVxcbiAgLm1lbnUuZXhwYW5kZWQge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgZGlzcGxheTogdGFibGU7XFxuICAgIHRhYmxlLWxheW91dDogZml4ZWQ7IH1cXG4gICAgLm1lbnUuZXhwYW5kZWQgPiBsaTpmaXJzdC1jaGlsZDpsYXN0LWNoaWxkIHtcXG4gICAgICB3aWR0aDogMTAwJTsgfVxcbiAgLm1lbnUuaWNvbi10b3AgPiBsaSA+IGEge1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7IH1cXG4gICAgLm1lbnUuaWNvbi10b3AgPiBsaSA+IGEgaW1nLFxcbiAgICAubWVudS5pY29uLXRvcCA+IGxpID4gYSBpLFxcbiAgICAubWVudS5pY29uLXRvcCA+IGxpID4gYSBzdmcge1xcbiAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICAgIG1hcmdpbjogMCBhdXRvIDAuMjVyZW07IH1cXG4gIC5tZW51Lm5lc3RlZCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAxcmVtOyB9XFxuICAubWVudSAuYWN0aXZlID4gYSB7XFxuICAgIGNvbG9yOiAjZmVmZWZlO1xcbiAgICBiYWNrZ3JvdW5kOiAjMjE5OWU4OyB9XFxuXFxuLm1lbnUtdGV4dCB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbiAgbGluZS1oZWlnaHQ6IDE7XFxuICBwYWRkaW5nLXRvcDogMDtcXG4gIHBhZGRpbmctYm90dG9tOiAwO1xcbiAgcGFkZGluZzogMC43cmVtIDFyZW07IH1cXG5cXG4ubWVudS1jZW50ZXJlZCB7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7IH1cXG4gIC5tZW51LWNlbnRlcmVkID4gLm1lbnUge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IH1cXG5cXG4ubm8tanMgW2RhdGEtcmVzcG9uc2l2ZS1tZW51XSB1bCB7XFxuICBkaXNwbGF5OiBub25lOyB9XFxuXFxuLm1lbnUtaWNvbiB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgd2lkdGg6IDIwcHg7XFxuICBoZWlnaHQ6IDE2cHg7IH1cXG4gIC5tZW51LWljb246OmFmdGVyIHtcXG4gICAgY29udGVudDogJyc7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDJweDtcXG4gICAgYmFja2dyb3VuZDogI2ZlZmVmZTtcXG4gICAgdG9wOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICBib3gtc2hhZG93OiAwIDdweCAwICNmZWZlZmUsIDAgMTRweCAwICNmZWZlZmU7IH1cXG4gIC5tZW51LWljb246aG92ZXI6OmFmdGVyIHtcXG4gICAgYmFja2dyb3VuZDogI2NhY2FjYTtcXG4gICAgYm94LXNoYWRvdzogMCA3cHggMCAjY2FjYWNhLCAwIDE0cHggMCAjY2FjYWNhOyB9XFxuXFxuLm1lbnUtaWNvbi5kYXJrIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICB3aWR0aDogMjBweDtcXG4gIGhlaWdodDogMTZweDsgfVxcbiAgLm1lbnUtaWNvbi5kYXJrOjphZnRlciB7XFxuICAgIGNvbnRlbnQ6ICcnO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAycHg7XFxuICAgIGJhY2tncm91bmQ6ICMwYTBhMGE7XFxuICAgIHRvcDogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgYm94LXNoYWRvdzogMCA3cHggMCAjMGEwYTBhLCAwIDE0cHggMCAjMGEwYTBhOyB9XFxuICAubWVudS1pY29uLmRhcms6aG92ZXI6OmFmdGVyIHtcXG4gICAgYmFja2dyb3VuZDogIzhhOGE4YTtcXG4gICAgYm94LXNoYWRvdzogMCA3cHggMCAjOGE4YThhLCAwIDE0cHggMCAjOGE4YThhOyB9XFxuXFxuLmlzLWRyaWxsZG93biB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBvdmVyZmxvdzogaGlkZGVuOyB9XFxuICAuaXMtZHJpbGxkb3duIGxpIHtcXG4gICAgZGlzcGxheTogYmxvY2sgIWltcG9ydGFudDsgfVxcblxcbi5pcy1kcmlsbGRvd24tc3VibWVudSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAxMDAlO1xcbiAgei1pbmRleDogLTE7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICB3aWR0aDogMTAwJTtcXG4gIGJhY2tncm91bmQ6ICNmZWZlZmU7XFxuICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4xNXMgbGluZWFyOyB9XFxuICAuaXMtZHJpbGxkb3duLXN1Ym1lbnUuaXMtYWN0aXZlIHtcXG4gICAgei1pbmRleDogMTtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtMTAwJSk7IH1cXG4gIC5pcy1kcmlsbGRvd24tc3VibWVudS5pcy1jbG9zaW5nIHtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDEwMCUpOyB9XFxuXFxuLmlzLWRyaWxsZG93bi1zdWJtZW51LXBhcmVudCA+IGEge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuICAuaXMtZHJpbGxkb3duLXN1Ym1lbnUtcGFyZW50ID4gYTo6YWZ0ZXIge1xcbiAgICBjb250ZW50OiAnJztcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIHdpZHRoOiAwO1xcbiAgICBoZWlnaHQ6IDA7XFxuICAgIGJvcmRlcjogaW5zZXQgNnB4O1xcbiAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50ICMyMTk5ZTg7XFxuICAgIGJvcmRlci1sZWZ0LXN0eWxlOiBzb2xpZDtcXG4gICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAwO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogNTAlO1xcbiAgICBtYXJnaW4tdG9wOiAtNnB4O1xcbiAgICByaWdodDogMXJlbTsgfVxcblxcbi5qcy1kcmlsbGRvd24tYmFjayA+IGE6OmJlZm9yZSB7XFxuICBjb250ZW50OiAnJztcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgd2lkdGg6IDA7XFxuICBoZWlnaHQ6IDA7XFxuICBib3JkZXI6IGluc2V0IDZweDtcXG4gIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQgIzIxOTllOCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtcXG4gIGJvcmRlci1yaWdodC1zdHlsZTogc29saWQ7XFxuICBib3JkZXItbGVmdC13aWR0aDogMDtcXG4gIGJvcmRlci1sZWZ0LXdpZHRoOiAwO1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIG1hcmdpbi1yaWdodDogMC43NXJlbTsgfVxcblxcbi5kcm9wZG93bi1wYW5lIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZWZlZmU7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjY2FjYWNhO1xcbiAgYm9yZGVyLXJhZGl1czogMDtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZm9udC1zaXplOiAxcmVtO1xcbiAgcGFkZGluZzogMXJlbTtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIHdpZHRoOiAzMDBweDtcXG4gIHotaW5kZXg6IDEwOyB9XFxuICAuZHJvcGRvd24tcGFuZS5pcy1vcGVuIHtcXG4gICAgdmlzaWJpbGl0eTogdmlzaWJsZTsgfVxcblxcbi5kcm9wZG93bi1wYW5lLnRpbnkge1xcbiAgd2lkdGg6IDEwMHB4OyB9XFxuXFxuLmRyb3Bkb3duLXBhbmUuc21hbGwge1xcbiAgd2lkdGg6IDIwMHB4OyB9XFxuXFxuLmRyb3Bkb3duLXBhbmUubGFyZ2Uge1xcbiAgd2lkdGg6IDQwMHB4OyB9XFxuXFxuLmRyb3Bkb3duLm1lbnUgPiBsaS5vcGVucy1sZWZ0ID4gLmlzLWRyb3Bkb3duLXN1Ym1lbnUge1xcbiAgbGVmdDogYXV0bztcXG4gIHJpZ2h0OiAwO1xcbiAgdG9wOiAxMDAlOyB9XFxuXFxuLmRyb3Bkb3duLm1lbnUgPiBsaS5vcGVucy1yaWdodCA+IC5pcy1kcm9wZG93bi1zdWJtZW51IHtcXG4gIHJpZ2h0OiBhdXRvO1xcbiAgbGVmdDogMDtcXG4gIHRvcDogMTAwJTsgfVxcblxcbi5kcm9wZG93bi5tZW51ID4gbGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQgPiBhIHtcXG4gIHBhZGRpbmctcmlnaHQ6IDEuNXJlbTtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTsgfVxcblxcbi5kcm9wZG93bi5tZW51ID4gbGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQgPiBhOjphZnRlciB7XFxuICBjb250ZW50OiAnJztcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgd2lkdGg6IDA7XFxuICBoZWlnaHQ6IDA7XFxuICBib3JkZXI6IGluc2V0IDVweDtcXG4gIGJvcmRlci1jb2xvcjogIzIxOTllOCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtcXG4gIGJvcmRlci10b3Atc3R5bGU6IHNvbGlkO1xcbiAgYm9yZGVyLWJvdHRvbS13aWR0aDogMDtcXG4gIHJpZ2h0OiA1cHg7XFxuICBtYXJnaW4tdG9wOiAtMnB4OyB9XFxuXFxuW2RhdGEtd2hhdGlucHV0PSdtb3VzZSddIC5kcm9wZG93bi5tZW51IGEge1xcbiAgb3V0bGluZTogMDsgfVxcblxcbi5uby1qcyAuZHJvcGRvd24ubWVudSB1bCB7XFxuICBkaXNwbGF5OiBub25lOyB9XFxuXFxuLmRyb3Bkb3duLm1lbnUudmVydGljYWwgPiBsaSAuaXMtZHJvcGRvd24tc3VibWVudSB7XFxuICB0b3A6IDA7IH1cXG5cXG4uZHJvcGRvd24ubWVudS52ZXJ0aWNhbCA+IGxpLm9wZW5zLWxlZnQgPiAuaXMtZHJvcGRvd24tc3VibWVudSB7XFxuICBsZWZ0OiBhdXRvO1xcbiAgcmlnaHQ6IDEwMCU7IH1cXG5cXG4uZHJvcGRvd24ubWVudS52ZXJ0aWNhbCA+IGxpLm9wZW5zLXJpZ2h0ID4gLmlzLWRyb3Bkb3duLXN1Ym1lbnUge1xcbiAgcmlnaHQ6IGF1dG87XFxuICBsZWZ0OiAxMDAlOyB9XFxuXFxuLmRyb3Bkb3duLm1lbnUudmVydGljYWwgPiBsaSA+IGE6OmFmdGVyIHtcXG4gIHJpZ2h0OiAxNHB4O1xcbiAgbWFyZ2luLXRvcDogLTNweDsgfVxcblxcbi5kcm9wZG93bi5tZW51LnZlcnRpY2FsID4gbGkub3BlbnMtbGVmdCA+IGE6OmFmdGVyIHtcXG4gIGNvbnRlbnQ6ICcnO1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICB3aWR0aDogMDtcXG4gIGhlaWdodDogMDtcXG4gIGJvcmRlcjogaW5zZXQgNXB4O1xcbiAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudCAjMjE5OWU4IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyLXJpZ2h0LXN0eWxlOiBzb2xpZDtcXG4gIGJvcmRlci1sZWZ0LXdpZHRoOiAwOyB9XFxuXFxuLmRyb3Bkb3duLm1lbnUudmVydGljYWwgPiBsaS5vcGVucy1yaWdodCA+IGE6OmFmdGVyIHtcXG4gIGNvbnRlbnQ6ICcnO1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICB3aWR0aDogMDtcXG4gIGhlaWdodDogMDtcXG4gIGJvcmRlcjogaW5zZXQgNXB4O1xcbiAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCAjMjE5OWU4O1xcbiAgYm9yZGVyLWxlZnQtc3R5bGU6IHNvbGlkO1xcbiAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAwOyB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNDBlbSkge1xcbiAgLmRyb3Bkb3duLm1lbnUubWVkaXVtLWhvcml6b250YWwgPiBsaS5vcGVucy1sZWZ0ID4gLmlzLWRyb3Bkb3duLXN1Ym1lbnUge1xcbiAgICBsZWZ0OiBhdXRvO1xcbiAgICByaWdodDogMDtcXG4gICAgdG9wOiAxMDAlOyB9XFxuICAuZHJvcGRvd24ubWVudS5tZWRpdW0taG9yaXpvbnRhbCA+IGxpLm9wZW5zLXJpZ2h0ID4gLmlzLWRyb3Bkb3duLXN1Ym1lbnUge1xcbiAgICByaWdodDogYXV0bztcXG4gICAgbGVmdDogMDtcXG4gICAgdG9wOiAxMDAlOyB9XFxuICAuZHJvcGRvd24ubWVudS5tZWRpdW0taG9yaXpvbnRhbCA+IGxpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50ID4gYSB7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDEuNXJlbTtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuICAuZHJvcGRvd24ubWVudS5tZWRpdW0taG9yaXpvbnRhbCA+IGxpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50ID4gYTo6YWZ0ZXIge1xcbiAgICBjb250ZW50OiAnJztcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIHdpZHRoOiAwO1xcbiAgICBoZWlnaHQ6IDA7XFxuICAgIGJvcmRlcjogaW5zZXQgNXB4O1xcbiAgICBib3JkZXItY29sb3I6ICMyMTk5ZTggdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7XFxuICAgIGJvcmRlci10b3Atc3R5bGU6IHNvbGlkO1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiAwO1xcbiAgICByaWdodDogNXB4O1xcbiAgICBtYXJnaW4tdG9wOiAtMnB4OyB9XFxuICAuZHJvcGRvd24ubWVudS5tZWRpdW0tdmVydGljYWwgPiBsaSAuaXMtZHJvcGRvd24tc3VibWVudSB7XFxuICAgIHRvcDogMDsgfVxcbiAgLmRyb3Bkb3duLm1lbnUubWVkaXVtLXZlcnRpY2FsID4gbGkub3BlbnMtbGVmdCA+IC5pcy1kcm9wZG93bi1zdWJtZW51IHtcXG4gICAgbGVmdDogYXV0bztcXG4gICAgcmlnaHQ6IDEwMCU7IH1cXG4gIC5kcm9wZG93bi5tZW51Lm1lZGl1bS12ZXJ0aWNhbCA+IGxpLm9wZW5zLXJpZ2h0ID4gLmlzLWRyb3Bkb3duLXN1Ym1lbnUge1xcbiAgICByaWdodDogYXV0bztcXG4gICAgbGVmdDogMTAwJTsgfVxcbiAgLmRyb3Bkb3duLm1lbnUubWVkaXVtLXZlcnRpY2FsID4gbGkgPiBhOjphZnRlciB7XFxuICAgIHJpZ2h0OiAxNHB4O1xcbiAgICBtYXJnaW4tdG9wOiAtM3B4OyB9XFxuICAuZHJvcGRvd24ubWVudS5tZWRpdW0tdmVydGljYWwgPiBsaS5vcGVucy1sZWZ0ID4gYTo6YWZ0ZXIge1xcbiAgICBjb250ZW50OiAnJztcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIHdpZHRoOiAwO1xcbiAgICBoZWlnaHQ6IDA7XFxuICAgIGJvcmRlcjogaW5zZXQgNXB4O1xcbiAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50ICMyMTk5ZTggdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7XFxuICAgIGJvcmRlci1yaWdodC1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci1sZWZ0LXdpZHRoOiAwOyB9XFxuICAuZHJvcGRvd24ubWVudS5tZWRpdW0tdmVydGljYWwgPiBsaS5vcGVucy1yaWdodCA+IGE6OmFmdGVyIHtcXG4gICAgY29udGVudDogJyc7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICB3aWR0aDogMDtcXG4gICAgaGVpZ2h0OiAwO1xcbiAgICBib3JkZXI6IGluc2V0IDVweDtcXG4gICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCAjMjE5OWU4O1xcbiAgICBib3JkZXItbGVmdC1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci1yaWdodC13aWR0aDogMDsgfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNjRlbSkge1xcbiAgLmRyb3Bkb3duLm1lbnUubGFyZ2UtaG9yaXpvbnRhbCA+IGxpLm9wZW5zLWxlZnQgPiAuaXMtZHJvcGRvd24tc3VibWVudSB7XFxuICAgIGxlZnQ6IGF1dG87XFxuICAgIHJpZ2h0OiAwO1xcbiAgICB0b3A6IDEwMCU7IH1cXG4gIC5kcm9wZG93bi5tZW51LmxhcmdlLWhvcml6b250YWwgPiBsaS5vcGVucy1yaWdodCA+IC5pcy1kcm9wZG93bi1zdWJtZW51IHtcXG4gICAgcmlnaHQ6IGF1dG87XFxuICAgIGxlZnQ6IDA7XFxuICAgIHRvcDogMTAwJTsgfVxcbiAgLmRyb3Bkb3duLm1lbnUubGFyZ2UtaG9yaXpvbnRhbCA+IGxpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50ID4gYSB7XFxuICAgIHBhZGRpbmctcmlnaHQ6IDEuNXJlbTtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuICAuZHJvcGRvd24ubWVudS5sYXJnZS1ob3Jpem9udGFsID4gbGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQgPiBhOjphZnRlciB7XFxuICAgIGNvbnRlbnQ6ICcnO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgd2lkdGg6IDA7XFxuICAgIGhlaWdodDogMDtcXG4gICAgYm9yZGVyOiBpbnNldCA1cHg7XFxuICAgIGJvcmRlci1jb2xvcjogIzIxOTllOCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtcXG4gICAgYm9yZGVyLXRvcC1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci1ib3R0b20td2lkdGg6IDA7XFxuICAgIHJpZ2h0OiA1cHg7XFxuICAgIG1hcmdpbi10b3A6IC0ycHg7IH1cXG4gIC5kcm9wZG93bi5tZW51LmxhcmdlLXZlcnRpY2FsID4gbGkgLmlzLWRyb3Bkb3duLXN1Ym1lbnUge1xcbiAgICB0b3A6IDA7IH1cXG4gIC5kcm9wZG93bi5tZW51LmxhcmdlLXZlcnRpY2FsID4gbGkub3BlbnMtbGVmdCA+IC5pcy1kcm9wZG93bi1zdWJtZW51IHtcXG4gICAgbGVmdDogYXV0bztcXG4gICAgcmlnaHQ6IDEwMCU7IH1cXG4gIC5kcm9wZG93bi5tZW51LmxhcmdlLXZlcnRpY2FsID4gbGkub3BlbnMtcmlnaHQgPiAuaXMtZHJvcGRvd24tc3VibWVudSB7XFxuICAgIHJpZ2h0OiBhdXRvO1xcbiAgICBsZWZ0OiAxMDAlOyB9XFxuICAuZHJvcGRvd24ubWVudS5sYXJnZS12ZXJ0aWNhbCA+IGxpID4gYTo6YWZ0ZXIge1xcbiAgICByaWdodDogMTRweDtcXG4gICAgbWFyZ2luLXRvcDogLTNweDsgfVxcbiAgLmRyb3Bkb3duLm1lbnUubGFyZ2UtdmVydGljYWwgPiBsaS5vcGVucy1sZWZ0ID4gYTo6YWZ0ZXIge1xcbiAgICBjb250ZW50OiAnJztcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIHdpZHRoOiAwO1xcbiAgICBoZWlnaHQ6IDA7XFxuICAgIGJvcmRlcjogaW5zZXQgNXB4O1xcbiAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50ICMyMTk5ZTggdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7XFxuICAgIGJvcmRlci1yaWdodC1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci1sZWZ0LXdpZHRoOiAwOyB9XFxuICAuZHJvcGRvd24ubWVudS5sYXJnZS12ZXJ0aWNhbCA+IGxpLm9wZW5zLXJpZ2h0ID4gYTo6YWZ0ZXIge1xcbiAgICBjb250ZW50OiAnJztcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIHdpZHRoOiAwO1xcbiAgICBoZWlnaHQ6IDA7XFxuICAgIGJvcmRlcjogaW5zZXQgNXB4O1xcbiAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50ICMyMTk5ZTg7XFxuICAgIGJvcmRlci1sZWZ0LXN0eWxlOiBzb2xpZDtcXG4gICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAwOyB9IH1cXG5cXG4uZHJvcGRvd24ubWVudS5hbGlnbi1yaWdodCAuaXMtZHJvcGRvd24tc3VibWVudS5maXJzdC1zdWIge1xcbiAgdG9wOiAxMDAlO1xcbiAgbGVmdDogYXV0bztcXG4gIHJpZ2h0OiAwOyB9XFxuXFxuLmlzLWRyb3Bkb3duLW1lbnUudmVydGljYWwge1xcbiAgd2lkdGg6IDEwMHB4OyB9XFxuICAuaXMtZHJvcGRvd24tbWVudS52ZXJ0aWNhbC5hbGlnbi1yaWdodCB7XFxuICAgIGZsb2F0OiByaWdodDsgfVxcblxcbi5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7IH1cXG4gIC5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCBhOjphZnRlciB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiA1MCU7XFxuICAgIHJpZ2h0OiA1cHg7XFxuICAgIG1hcmdpbi10b3A6IC0ycHg7IH1cXG4gIC5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudC5vcGVucy1pbm5lciA+IC5pcy1kcm9wZG93bi1zdWJtZW51IHtcXG4gICAgdG9wOiAxMDAlO1xcbiAgICBsZWZ0OiBhdXRvOyB9XFxuICAuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQub3BlbnMtbGVmdCA+IC5pcy1kcm9wZG93bi1zdWJtZW51IHtcXG4gICAgbGVmdDogYXV0bztcXG4gICAgcmlnaHQ6IDEwMCU7IH1cXG4gIC5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudC5vcGVucy1yaWdodCA+IC5pcy1kcm9wZG93bi1zdWJtZW51IHtcXG4gICAgcmlnaHQ6IGF1dG87XFxuICAgIGxlZnQ6IDEwMCU7IH1cXG5cXG4uaXMtZHJvcGRvd24tc3VibWVudSB7XFxuICBkaXNwbGF5OiBub25lO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMTAwJTtcXG4gIG1pbi13aWR0aDogMjAwcHg7XFxuICB6LWluZGV4OiAxO1xcbiAgYmFja2dyb3VuZDogI2ZlZmVmZTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNjYWNhY2E7IH1cXG4gIC5pcy1kcm9wZG93bi1zdWJtZW51IC5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCA+IGE6OmFmdGVyIHtcXG4gICAgcmlnaHQ6IDE0cHg7XFxuICAgIG1hcmdpbi10b3A6IC0zcHg7IH1cXG4gIC5pcy1kcm9wZG93bi1zdWJtZW51IC5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudC5vcGVucy1sZWZ0ID4gYTo6YWZ0ZXIge1xcbiAgICBjb250ZW50OiAnJztcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIHdpZHRoOiAwO1xcbiAgICBoZWlnaHQ6IDA7XFxuICAgIGJvcmRlcjogaW5zZXQgNXB4O1xcbiAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50ICMyMTk5ZTggdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7XFxuICAgIGJvcmRlci1yaWdodC1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci1sZWZ0LXdpZHRoOiAwOyB9XFxuICAuaXMtZHJvcGRvd24tc3VibWVudSAuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQub3BlbnMtcmlnaHQgPiBhOjphZnRlciB7XFxuICAgIGNvbnRlbnQ6ICcnO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgd2lkdGg6IDA7XFxuICAgIGhlaWdodDogMDtcXG4gICAgYm9yZGVyOiBpbnNldCA1cHg7XFxuICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgIzIxOTllODtcXG4gICAgYm9yZGVyLWxlZnQtc3R5bGU6IHNvbGlkO1xcbiAgICBib3JkZXItcmlnaHQtd2lkdGg6IDA7IH1cXG4gIC5pcy1kcm9wZG93bi1zdWJtZW51IC5pcy1kcm9wZG93bi1zdWJtZW51IHtcXG4gICAgbWFyZ2luLXRvcDogLTFweDsgfVxcbiAgLmlzLWRyb3Bkb3duLXN1Ym1lbnUgPiBsaSB7XFxuICAgIHdpZHRoOiAxMDAlOyB9XFxuICAuaXMtZHJvcGRvd24tc3VibWVudS5qcy1kcm9wZG93bi1hY3RpdmUge1xcbiAgICBkaXNwbGF5OiBibG9jazsgfVxcblxcbi5mbGV4LXZpZGVvIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGhlaWdodDogMDtcXG4gIHBhZGRpbmctYm90dG9tOiA3NSU7XFxuICBtYXJnaW4tYm90dG9tOiAxcmVtO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjsgfVxcbiAgLmZsZXgtdmlkZW8gaWZyYW1lLFxcbiAgLmZsZXgtdmlkZW8gb2JqZWN0LFxcbiAgLmZsZXgtdmlkZW8gZW1iZWQsXFxuICAuZmxleC12aWRlbyB2aWRlbyB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlOyB9XFxuICAuZmxleC12aWRlby53aWRlc2NyZWVuIHtcXG4gICAgcGFkZGluZy1ib3R0b206IDU2LjI1JTsgfVxcbiAgLmZsZXgtdmlkZW8udmltZW8ge1xcbiAgICBwYWRkaW5nLXRvcDogMDsgfVxcblxcbi5sYWJlbCB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBwYWRkaW5nOiAwLjMzMzMzcmVtIDAuNXJlbTtcXG4gIGZvbnQtc2l6ZTogMC44cmVtO1xcbiAgbGluZS1oZWlnaHQ6IDE7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcbiAgYm9yZGVyLXJhZGl1czogMDtcXG4gIGJhY2tncm91bmQ6ICMyMTk5ZTg7XFxuICBjb2xvcjogI2ZlZmVmZTsgfVxcbiAgLmxhYmVsLnNlY29uZGFyeSB7XFxuICAgIGJhY2tncm91bmQ6ICM3Nzc7XFxuICAgIGNvbG9yOiAjZmVmZWZlOyB9XFxuICAubGFiZWwuc3VjY2VzcyB7XFxuICAgIGJhY2tncm91bmQ6ICMzYWRiNzY7XFxuICAgIGNvbG9yOiAjZmVmZWZlOyB9XFxuICAubGFiZWwud2FybmluZyB7XFxuICAgIGJhY2tncm91bmQ6ICNmZmFlMDA7XFxuICAgIGNvbG9yOiAjZmVmZWZlOyB9XFxuICAubGFiZWwuYWxlcnQge1xcbiAgICBiYWNrZ3JvdW5kOiAjZWM1ODQwO1xcbiAgICBjb2xvcjogI2ZlZmVmZTsgfVxcblxcbi5tZWRpYS1vYmplY3Qge1xcbiAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG4gIGRpc3BsYXk6IGJsb2NrOyB9XFxuICAubWVkaWEtb2JqZWN0IGltZyB7XFxuICAgIG1heC13aWR0aDogbm9uZTsgfVxcbiAgQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogMzkuOTM3NWVtKSB7XFxuICAgIC5tZWRpYS1vYmplY3Quc3RhY2stZm9yLXNtYWxsIC5tZWRpYS1vYmplY3Qtc2VjdGlvbiB7XFxuICAgICAgcGFkZGluZzogMDtcXG4gICAgICBwYWRkaW5nLWJvdHRvbTogMXJlbTtcXG4gICAgICBkaXNwbGF5OiBibG9jazsgfVxcbiAgICAgIC5tZWRpYS1vYmplY3Quc3RhY2stZm9yLXNtYWxsIC5tZWRpYS1vYmplY3Qtc2VjdGlvbiBpbWcge1xcbiAgICAgICAgd2lkdGg6IDEwMCU7IH0gfVxcblxcbi5tZWRpYS1vYmplY3Qtc2VjdGlvbiB7XFxuICBkaXNwbGF5OiB0YWJsZS1jZWxsO1xcbiAgdmVydGljYWwtYWxpZ246IHRvcDsgfVxcbiAgLm1lZGlhLW9iamVjdC1zZWN0aW9uOmZpcnN0LWNoaWxkIHtcXG4gICAgcGFkZGluZy1yaWdodDogMXJlbTsgfVxcbiAgLm1lZGlhLW9iamVjdC1zZWN0aW9uOmxhc3QtY2hpbGQ6bm90KDpudGgtY2hpbGQoMikpIHtcXG4gICAgcGFkZGluZy1sZWZ0OiAxcmVtOyB9XFxuICAubWVkaWEtb2JqZWN0LXNlY3Rpb24gPiA6bGFzdC1jaGlsZCB7XFxuICAgIG1hcmdpbi1ib3R0b206IDA7IH1cXG4gIC5tZWRpYS1vYmplY3Qtc2VjdGlvbi5taWRkbGUge1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyB9XFxuICAubWVkaWEtb2JqZWN0LXNlY3Rpb24uYm90dG9tIHtcXG4gICAgdmVydGljYWwtYWxpZ246IGJvdHRvbTsgfVxcblxcbmh0bWwsXFxuYm9keSB7XFxuICBoZWlnaHQ6IDEwMCU7IH1cXG5cXG4ub2ZmLWNhbnZhcy13cmFwcGVyIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgb3ZlcmZsb3cteDogaGlkZGVuO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IGF1dG87IH1cXG5cXG4ub2ZmLWNhbnZhcy13cmFwcGVyLWlubmVyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuNXMgZWFzZTsgfVxcbiAgLm9mZi1jYW52YXMtd3JhcHBlci1pbm5lcjo6YmVmb3JlLCAub2ZmLWNhbnZhcy13cmFwcGVyLWlubmVyOjphZnRlciB7XFxuICAgIGNvbnRlbnQ6ICcgJztcXG4gICAgZGlzcGxheTogdGFibGU7IH1cXG4gIC5vZmYtY2FudmFzLXdyYXBwZXItaW5uZXI6OmFmdGVyIHtcXG4gICAgY2xlYXI6IGJvdGg7IH1cXG5cXG4ub2ZmLWNhbnZhcy1jb250ZW50LFxcbi5vZmYtY2FudmFzLWNvbnRlbnQge1xcbiAgbWluLWhlaWdodDogMTAwJTtcXG4gIGJhY2tncm91bmQ6ICNmZWZlZmU7XFxuICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC41cyBlYXNlO1xcbiAgYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgei1pbmRleDogMTtcXG4gIHBhZGRpbmctYm90dG9tOiAwLjFweDtcXG4gIGJveC1zaGFkb3c6IDAgMCAxMHB4IHJnYmEoMTAsIDEwLCAxMCwgMC41KTsgfVxcblxcbi5qcy1vZmYtY2FudmFzLWV4aXQge1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMjU0LCAyNTQsIDI1NCwgMC4yNSk7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kIDAuNXMgZWFzZTsgfVxcblxcbi5vZmYtY2FudmFzIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGJhY2tncm91bmQ6ICNlNmU2ZTY7XFxuICB6LWluZGV4OiAtMTtcXG4gIG1heC1oZWlnaHQ6IDEwMCU7XFxuICBvdmVyZmxvdy15OiBhdXRvO1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApOyB9XFxuICBbZGF0YS13aGF0aW5wdXQ9J21vdXNlJ10gLm9mZi1jYW52YXMge1xcbiAgICBvdXRsaW5lOiAwOyB9XFxuICAub2ZmLWNhbnZhcy5wb3NpdGlvbi1sZWZ0IHtcXG4gICAgbGVmdDogLTI1MHB4O1xcbiAgICB0b3A6IDA7XFxuICAgIHdpZHRoOiAyNTBweDsgfVxcbiAgICAuaXMtb3Blbi1sZWZ0IHtcXG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMjUwcHgpOyB9XFxuICAub2ZmLWNhbnZhcy5wb3NpdGlvbi1yaWdodCB7XFxuICAgIHJpZ2h0OiAtMjUwcHg7XFxuICAgIHRvcDogMDtcXG4gICAgd2lkdGg6IDI1MHB4OyB9XFxuICAgIC5pcy1vcGVuLXJpZ2h0IHtcXG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTI1MHB4KTsgfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDQwZW0pIHtcXG4gIC5wb3NpdGlvbi1sZWZ0LnJldmVhbC1mb3ItbWVkaXVtIHtcXG4gICAgbGVmdDogMDtcXG4gICAgei1pbmRleDogYXV0bztcXG4gICAgcG9zaXRpb246IGZpeGVkOyB9XFxuICAgIC5wb3NpdGlvbi1sZWZ0LnJldmVhbC1mb3ItbWVkaXVtIH4gLm9mZi1jYW52YXMtY29udGVudCB7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDI1MHB4OyB9XFxuICAucG9zaXRpb24tcmlnaHQucmV2ZWFsLWZvci1tZWRpdW0ge1xcbiAgICByaWdodDogMDtcXG4gICAgei1pbmRleDogYXV0bztcXG4gICAgcG9zaXRpb246IGZpeGVkOyB9XFxuICAgIC5wb3NpdGlvbi1yaWdodC5yZXZlYWwtZm9yLW1lZGl1bSB+IC5vZmYtY2FudmFzLWNvbnRlbnQge1xcbiAgICAgIG1hcmdpbi1yaWdodDogMjUwcHg7IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDY0ZW0pIHtcXG4gIC5wb3NpdGlvbi1sZWZ0LnJldmVhbC1mb3ItbGFyZ2Uge1xcbiAgICBsZWZ0OiAwO1xcbiAgICB6LWluZGV4OiBhdXRvO1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7IH1cXG4gICAgLnBvc2l0aW9uLWxlZnQucmV2ZWFsLWZvci1sYXJnZSB+IC5vZmYtY2FudmFzLWNvbnRlbnQge1xcbiAgICAgIG1hcmdpbi1sZWZ0OiAyNTBweDsgfVxcbiAgLnBvc2l0aW9uLXJpZ2h0LnJldmVhbC1mb3ItbGFyZ2Uge1xcbiAgICByaWdodDogMDtcXG4gICAgei1pbmRleDogYXV0bztcXG4gICAgcG9zaXRpb246IGZpeGVkOyB9XFxuICAgIC5wb3NpdGlvbi1yaWdodC5yZXZlYWwtZm9yLWxhcmdlIH4gLm9mZi1jYW52YXMtY29udGVudCB7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiAyNTBweDsgfSB9XFxuXFxuLm9yYml0IHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTsgfVxcblxcbi5vcmJpdC1jb250YWluZXIge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgbWFyZ2luOiAwO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7IH1cXG5cXG4ub3JiaXQtc2xpZGUge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBtYXgtaGVpZ2h0OiAxMDAlOyB9XFxuICAub3JiaXQtc2xpZGUubm8tbW90aW9udWkuaXMtYWN0aXZlIHtcXG4gICAgdG9wOiAwO1xcbiAgICBsZWZ0OiAwOyB9XFxuXFxuLm9yYml0LWZpZ3VyZSB7XFxuICBtYXJnaW46IDA7IH1cXG5cXG4ub3JiaXQtaW1hZ2Uge1xcbiAgbWFyZ2luOiAwO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBtYXgtd2lkdGg6IDEwMCU7IH1cXG5cXG4ub3JiaXQtY2FwdGlvbiB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBib3R0b206IDA7XFxuICB3aWR0aDogMTAwJTtcXG4gIHBhZGRpbmc6IDFyZW07XFxuICBtYXJnaW4tYm90dG9tOiAwO1xcbiAgY29sb3I6ICNmZWZlZmU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEwLCAxMCwgMTAsIDAuNSk7IH1cXG5cXG4ub3JiaXQtcHJldmlvdXMsIC5vcmJpdC1uZXh0IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogNTAlO1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xcbiAgei1pbmRleDogMTA7XFxuICBwYWRkaW5nOiAxcmVtO1xcbiAgY29sb3I6ICNmZWZlZmU7IH1cXG4gIFtkYXRhLXdoYXRpbnB1dD0nbW91c2UnXSAub3JiaXQtcHJldmlvdXMsIFtkYXRhLXdoYXRpbnB1dD0nbW91c2UnXSAub3JiaXQtbmV4dCB7XFxuICAgIG91dGxpbmU6IDA7IH1cXG4gIC5vcmJpdC1wcmV2aW91czpob3ZlciwgLm9yYml0LW5leHQ6aG92ZXIsIC5vcmJpdC1wcmV2aW91czphY3RpdmUsIC5vcmJpdC1uZXh0OmFjdGl2ZSwgLm9yYml0LXByZXZpb3VzOmZvY3VzLCAub3JiaXQtbmV4dDpmb2N1cyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTAsIDEwLCAxMCwgMC41KTsgfVxcblxcbi5vcmJpdC1wcmV2aW91cyB7XFxuICBsZWZ0OiAwOyB9XFxuXFxuLm9yYml0LW5leHQge1xcbiAgbGVmdDogYXV0bztcXG4gIHJpZ2h0OiAwOyB9XFxuXFxuLm9yYml0LWJ1bGxldHMge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgbWFyZ2luLXRvcDogMC44cmVtO1xcbiAgbWFyZ2luLWJvdHRvbTogMC44cmVtO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyOyB9XFxuICBbZGF0YS13aGF0aW5wdXQ9J21vdXNlJ10gLm9yYml0LWJ1bGxldHMge1xcbiAgICBvdXRsaW5lOiAwOyB9XFxuICAub3JiaXQtYnVsbGV0cyBidXR0b24ge1xcbiAgICB3aWR0aDogMS4ycmVtO1xcbiAgICBoZWlnaHQ6IDEuMnJlbTtcXG4gICAgbWFyZ2luOiAwLjFyZW07XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNjYWNhY2E7XFxuICAgIGJvcmRlci1yYWRpdXM6IDUwJTsgfVxcbiAgICAub3JiaXQtYnVsbGV0cyBidXR0b246aG92ZXIge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICM4YThhOGE7IH1cXG4gICAgLm9yYml0LWJ1bGxldHMgYnV0dG9uLmlzLWFjdGl2ZSB7XFxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzhhOGE4YTsgfVxcblxcbi5wYWdpbmF0aW9uIHtcXG4gIG1hcmdpbi1sZWZ0OiAwO1xcbiAgbWFyZ2luLWJvdHRvbTogMXJlbTsgfVxcbiAgLnBhZ2luYXRpb246OmJlZm9yZSwgLnBhZ2luYXRpb246OmFmdGVyIHtcXG4gICAgY29udGVudDogJyAnO1xcbiAgICBkaXNwbGF5OiB0YWJsZTsgfVxcbiAgLnBhZ2luYXRpb246OmFmdGVyIHtcXG4gICAgY2xlYXI6IGJvdGg7IH1cXG4gIC5wYWdpbmF0aW9uIGxpIHtcXG4gICAgZm9udC1zaXplOiAwLjg3NXJlbTtcXG4gICAgbWFyZ2luLXJpZ2h0OiAwLjA2MjVyZW07XFxuICAgIGJvcmRlci1yYWRpdXM6IDA7XFxuICAgIGRpc3BsYXk6IG5vbmU7IH1cXG4gICAgLnBhZ2luYXRpb24gbGk6bGFzdC1jaGlsZCwgLnBhZ2luYXRpb24gbGk6Zmlyc3QtY2hpbGQge1xcbiAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jazsgfVxcbiAgICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA0MGVtKSB7XFxuICAgICAgLnBhZ2luYXRpb24gbGkge1xcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrOyB9IH1cXG4gIC5wYWdpbmF0aW9uIGEsXFxuICAucGFnaW5hdGlvbiBidXR0b24ge1xcbiAgICBjb2xvcjogIzBhMGEwYTtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIHBhZGRpbmc6IDAuMTg3NXJlbSAwLjYyNXJlbTtcXG4gICAgYm9yZGVyLXJhZGl1czogMDsgfVxcbiAgICAucGFnaW5hdGlvbiBhOmhvdmVyLFxcbiAgICAucGFnaW5hdGlvbiBidXR0b246aG92ZXIge1xcbiAgICAgIGJhY2tncm91bmQ6ICNlNmU2ZTY7IH1cXG4gIC5wYWdpbmF0aW9uIC5jdXJyZW50IHtcXG4gICAgcGFkZGluZzogMC4xODc1cmVtIDAuNjI1cmVtO1xcbiAgICBiYWNrZ3JvdW5kOiAjMjE5OWU4O1xcbiAgICBjb2xvcjogI2ZlZmVmZTtcXG4gICAgY3Vyc29yOiBkZWZhdWx0OyB9XFxuICAucGFnaW5hdGlvbiAuZGlzYWJsZWQge1xcbiAgICBwYWRkaW5nOiAwLjE4NzVyZW0gMC42MjVyZW07XFxuICAgIGNvbG9yOiAjY2FjYWNhO1xcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkOyB9XFxuICAgIC5wYWdpbmF0aW9uIC5kaXNhYmxlZDpob3ZlciB7XFxuICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7IH1cXG4gIC5wYWdpbmF0aW9uIC5lbGxpcHNpczo6YWZ0ZXIge1xcbiAgICBjb250ZW50OiAnXFxcXDIwMjYnO1xcbiAgICBwYWRkaW5nOiAwLjE4NzVyZW0gMC42MjVyZW07XFxuICAgIGNvbG9yOiAjMGEwYTBhOyB9XFxuXFxuLnBhZ2luYXRpb24tcHJldmlvdXMgYTo6YmVmb3JlLFxcbi5wYWdpbmF0aW9uLXByZXZpb3VzLmRpc2FibGVkOjpiZWZvcmUge1xcbiAgY29udGVudDogJ1xcXFxBQic7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBtYXJnaW4tcmlnaHQ6IDAuNXJlbTsgfVxcblxcbi5wYWdpbmF0aW9uLW5leHQgYTo6YWZ0ZXIsXFxuLnBhZ2luYXRpb24tbmV4dC5kaXNhYmxlZDo6YWZ0ZXIge1xcbiAgY29udGVudDogJ1xcXFxCQic7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBtYXJnaW4tbGVmdDogMC41cmVtOyB9XFxuXFxuLnByb2dyZXNzIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNjYWNhY2E7XFxuICBoZWlnaHQ6IDFyZW07XFxuICBtYXJnaW4tYm90dG9tOiAxcmVtO1xcbiAgYm9yZGVyLXJhZGl1czogMDsgfVxcbiAgLnByb2dyZXNzLnByaW1hcnkgLnByb2dyZXNzLW1ldGVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzIxOTllODsgfVxcbiAgLnByb2dyZXNzLnNlY29uZGFyeSAucHJvZ3Jlc3MtbWV0ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNzc3OyB9XFxuICAucHJvZ3Jlc3Muc3VjY2VzcyAucHJvZ3Jlc3MtbWV0ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjM2FkYjc2OyB9XFxuICAucHJvZ3Jlc3Mud2FybmluZyAucHJvZ3Jlc3MtbWV0ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZhZTAwOyB9XFxuICAucHJvZ3Jlc3MuYWxlcnQgLnByb2dyZXNzLW1ldGVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2VjNTg0MDsgfVxcblxcbi5wcm9ncmVzcy1tZXRlciB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHdpZHRoOiAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMyMTk5ZTg7IH1cXG5cXG4ucHJvZ3Jlc3MtbWV0ZXItdGV4dCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDUwJTtcXG4gIGxlZnQ6IDUwJTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgbWFyZ2luOiAwO1xcbiAgZm9udC1zaXplOiAwLjc1cmVtO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBjb2xvcjogI2ZlZmVmZTtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7IH1cXG5cXG4uc2xpZGVyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGhlaWdodDogMC41cmVtO1xcbiAgbWFyZ2luLXRvcDogMS4yNXJlbTtcXG4gIG1hcmdpbi1ib3R0b206IDIuMjVyZW07XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZTZlNmU2O1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICB0b3VjaC1hY3Rpb246IG5vbmU7IH1cXG5cXG4uc2xpZGVyLWZpbGwge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIG1heC13aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMC41cmVtO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2NhY2FjYTtcXG4gIHRyYW5zaXRpb246IGFsbCAwLjJzIGVhc2UtaW4tb3V0OyB9XFxuICAuc2xpZGVyLWZpbGwuaXMtZHJhZ2dpbmcge1xcbiAgICB0cmFuc2l0aW9uOiBhbGwgMHMgbGluZWFyOyB9XFxuXFxuLnNsaWRlci1oYW5kbGUge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA1MCU7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBsZWZ0OiAwO1xcbiAgei1pbmRleDogMTtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHdpZHRoOiAxLjRyZW07XFxuICBoZWlnaHQ6IDEuNHJlbTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMyMTk5ZTg7XFxuICB0cmFuc2l0aW9uOiBhbGwgMC4ycyBlYXNlLWluLW91dDtcXG4gIHRvdWNoLWFjdGlvbjogbWFuaXB1bGF0aW9uO1xcbiAgYm9yZGVyLXJhZGl1czogMDsgfVxcbiAgW2RhdGEtd2hhdGlucHV0PSdtb3VzZSddIC5zbGlkZXItaGFuZGxlIHtcXG4gICAgb3V0bGluZTogMDsgfVxcbiAgLnNsaWRlci1oYW5kbGU6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMTU4M2NjOyB9XFxuICAuc2xpZGVyLWhhbmRsZS5pcy1kcmFnZ2luZyB7XFxuICAgIHRyYW5zaXRpb246IGFsbCAwcyBsaW5lYXI7IH1cXG5cXG4uc2xpZGVyLmRpc2FibGVkLFxcbi5zbGlkZXJbZGlzYWJsZWRdIHtcXG4gIG9wYWNpdHk6IDAuMjU7XFxuICBjdXJzb3I6IG5vdC1hbGxvd2VkOyB9XFxuXFxuLnNsaWRlci52ZXJ0aWNhbCB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB3aWR0aDogMC41cmVtO1xcbiAgaGVpZ2h0OiAxMi41cmVtO1xcbiAgbWFyZ2luOiAwIDEuMjVyZW07XFxuICB0cmFuc2Zvcm06IHNjYWxlKDEsIC0xKTsgfVxcbiAgLnNsaWRlci52ZXJ0aWNhbCAuc2xpZGVyLWZpbGwge1xcbiAgICB0b3A6IDA7XFxuICAgIHdpZHRoOiAwLjVyZW07XFxuICAgIG1heC1oZWlnaHQ6IDEwMCU7IH1cXG4gIC5zbGlkZXIudmVydGljYWwgLnNsaWRlci1oYW5kbGUge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgbGVmdDogNTAlO1xcbiAgICB3aWR0aDogMS40cmVtO1xcbiAgICBoZWlnaHQ6IDEuNHJlbTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpOyB9XFxuXFxuLnN0aWNreS1jb250YWluZXIge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuXFxuLnN0aWNreSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB6LWluZGV4OiAwO1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTsgfVxcblxcbi5zdGlja3kuaXMtc3R1Y2sge1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgei1pbmRleDogNTsgfVxcbiAgLnN0aWNreS5pcy1zdHVjay5pcy1hdC10b3Age1xcbiAgICB0b3A6IDA7IH1cXG4gIC5zdGlja3kuaXMtc3R1Y2suaXMtYXQtYm90dG9tIHtcXG4gICAgYm90dG9tOiAwOyB9XFxuXFxuLnN0aWNreS5pcy1hbmNob3JlZCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBsZWZ0OiBhdXRvO1xcbiAgcmlnaHQ6IGF1dG87IH1cXG4gIC5zdGlja3kuaXMtYW5jaG9yZWQuaXMtYXQtYm90dG9tIHtcXG4gICAgYm90dG9tOiAwOyB9XFxuXFxuYm9keS5pcy1yZXZlYWwtb3BlbiB7XFxuICBvdmVyZmxvdzogaGlkZGVuOyB9XFxuXFxuaHRtbC5pcy1yZXZlYWwtb3BlbixcXG5odG1sLmlzLXJldmVhbC1vcGVuIGJvZHkge1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIHVzZXItc2VsZWN0OiBub25lOyB9XFxuXFxuLnJldmVhbC1vdmVybGF5IHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB0b3A6IDA7XFxuICBib3R0b206IDA7XFxuICBsZWZ0OiAwO1xcbiAgcmlnaHQ6IDA7XFxuICB6LWluZGV4OiAxMDA1O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxMCwgMTAsIDEwLCAwLjQ1KTtcXG4gIG92ZXJmbG93LXk6IHNjcm9sbDsgfVxcblxcbi5yZXZlYWwge1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIHotaW5kZXg6IDEwMDY7XFxuICBwYWRkaW5nOiAxcmVtO1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2NhY2FjYTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZWZlZmU7XFxuICBib3JkZXItcmFkaXVzOiAwO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgdG9wOiAxMDBweDtcXG4gIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbiAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xcbiAgb3ZlcmZsb3cteTogYXV0bzsgfVxcbiAgW2RhdGEtd2hhdGlucHV0PSdtb3VzZSddIC5yZXZlYWwge1xcbiAgICBvdXRsaW5lOiAwOyB9XFxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA0MGVtKSB7XFxuICAgIC5yZXZlYWwge1xcbiAgICAgIG1pbi1oZWlnaHQ6IDA7IH0gfVxcbiAgLnJldmVhbCAuY29sdW1uLCAucmV2ZWFsIC5jb2x1bW5zLFxcbiAgLnJldmVhbCAuY29sdW1ucyB7XFxuICAgIG1pbi13aWR0aDogMDsgfVxcbiAgLnJldmVhbCA+IDpsYXN0LWNoaWxkIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMDsgfVxcbiAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNDBlbSkge1xcbiAgICAucmV2ZWFsIHtcXG4gICAgICB3aWR0aDogNjAwcHg7XFxuICAgICAgbWF4LXdpZHRoOiA3NXJlbTsgfSB9XFxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA0MGVtKSB7XFxuICAgIC5yZXZlYWwgLnJldmVhbCB7XFxuICAgICAgbGVmdDogYXV0bztcXG4gICAgICByaWdodDogYXV0bztcXG4gICAgICBtYXJnaW46IDAgYXV0bzsgfSB9XFxuICAucmV2ZWFsLmNvbGxhcHNlIHtcXG4gICAgcGFkZGluZzogMDsgfVxcbiAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNDBlbSkge1xcbiAgICAucmV2ZWFsLnRpbnkge1xcbiAgICAgIHdpZHRoOiAzMCU7XFxuICAgICAgbWF4LXdpZHRoOiA3NXJlbTsgfSB9XFxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA0MGVtKSB7XFxuICAgIC5yZXZlYWwuc21hbGwge1xcbiAgICAgIHdpZHRoOiA1MCU7XFxuICAgICAgbWF4LXdpZHRoOiA3NXJlbTsgfSB9XFxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA0MGVtKSB7XFxuICAgIC5yZXZlYWwubGFyZ2Uge1xcbiAgICAgIHdpZHRoOiA5MCU7XFxuICAgICAgbWF4LXdpZHRoOiA3NXJlbTsgfSB9XFxuICAucmV2ZWFsLmZ1bGwge1xcbiAgICB0b3A6IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwdmg7XFxuICAgIG1pbi1oZWlnaHQ6IDEwMHZoO1xcbiAgICBtYXgtd2lkdGg6IG5vbmU7XFxuICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICBib3JkZXI6IDA7XFxuICAgIGJvcmRlci1yYWRpdXM6IDA7IH1cXG4gIEBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDM5LjkzNzVlbSkge1xcbiAgICAucmV2ZWFsIHtcXG4gICAgICB0b3A6IDA7XFxuICAgICAgbGVmdDogMDtcXG4gICAgICB3aWR0aDogMTAwJTtcXG4gICAgICBoZWlnaHQ6IDEwMCU7XFxuICAgICAgaGVpZ2h0OiAxMDB2aDtcXG4gICAgICBtaW4taGVpZ2h0OiAxMDB2aDtcXG4gICAgICBtYXgtd2lkdGg6IG5vbmU7XFxuICAgICAgbWFyZ2luLWxlZnQ6IDA7XFxuICAgICAgYm9yZGVyOiAwO1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDA7IH0gfVxcbiAgLnJldmVhbC53aXRob3V0LW92ZXJsYXkge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7IH1cXG5cXG4uc3dpdGNoIHtcXG4gIG1hcmdpbi1ib3R0b206IDFyZW07XFxuICBvdXRsaW5lOiAwO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICBjb2xvcjogI2ZlZmVmZTtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgZm9udC1zaXplOiAwLjg3NXJlbTsgfVxcblxcbi5zd2l0Y2gtaW5wdXQge1xcbiAgb3BhY2l0eTogMDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTsgfVxcblxcbi5zd2l0Y2gtcGFkZGxlIHtcXG4gIGJhY2tncm91bmQ6ICNjYWNhY2E7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHdpZHRoOiA0cmVtO1xcbiAgaGVpZ2h0OiAycmVtO1xcbiAgdHJhbnNpdGlvbjogYWxsIDAuMjVzIGVhc2Utb3V0O1xcbiAgYm9yZGVyLXJhZGl1czogMDtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbiAgZm9udC13ZWlnaHQ6IGluaGVyaXQ7IH1cXG4gIGlucHV0ICsgLnN3aXRjaC1wYWRkbGUge1xcbiAgICBtYXJnaW46IDA7IH1cXG4gIC5zd2l0Y2gtcGFkZGxlOjphZnRlciB7XFxuICAgIGJhY2tncm91bmQ6ICNmZWZlZmU7XFxuICAgIGNvbnRlbnQ6ICcnO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBoZWlnaHQ6IDEuNXJlbTtcXG4gICAgbGVmdDogMC4yNXJlbTtcXG4gICAgdG9wOiAwLjI1cmVtO1xcbiAgICB3aWR0aDogMS41cmVtO1xcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC4yNXMgZWFzZS1vdXQ7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XFxuICAgIGJvcmRlci1yYWRpdXM6IDA7IH1cXG4gIGlucHV0OmNoZWNrZWQgfiAuc3dpdGNoLXBhZGRsZSB7XFxuICAgIGJhY2tncm91bmQ6ICMyMTk5ZTg7IH1cXG4gICAgaW5wdXQ6Y2hlY2tlZCB+IC5zd2l0Y2gtcGFkZGxlOjphZnRlciB7XFxuICAgICAgbGVmdDogMi4yNXJlbTsgfVxcbiAgW2RhdGEtd2hhdGlucHV0PSdtb3VzZSddIGlucHV0OmZvY3VzIH4gLnN3aXRjaC1wYWRkbGUge1xcbiAgICBvdXRsaW5lOiAwOyB9XFxuXFxuLnN3aXRjaC1hY3RpdmUsIC5zd2l0Y2gtaW5hY3RpdmUge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA1MCU7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7IH1cXG5cXG4uc3dpdGNoLWFjdGl2ZSB7XFxuICBsZWZ0OiA4JTtcXG4gIGRpc3BsYXk6IG5vbmU7IH1cXG4gIGlucHV0OmNoZWNrZWQgKyBsYWJlbCA+IC5zd2l0Y2gtYWN0aXZlIHtcXG4gICAgZGlzcGxheTogYmxvY2s7IH1cXG5cXG4uc3dpdGNoLWluYWN0aXZlIHtcXG4gIHJpZ2h0OiAxNSU7IH1cXG4gIGlucHV0OmNoZWNrZWQgKyBsYWJlbCA+IC5zd2l0Y2gtaW5hY3RpdmUge1xcbiAgICBkaXNwbGF5OiBub25lOyB9XFxuXFxuLnN3aXRjaC50aW55IC5zd2l0Y2gtcGFkZGxlIHtcXG4gIHdpZHRoOiAzcmVtO1xcbiAgaGVpZ2h0OiAxLjVyZW07XFxuICBmb250LXNpemU6IDAuNjI1cmVtOyB9XFxuXFxuLnN3aXRjaC50aW55IC5zd2l0Y2gtcGFkZGxlOjphZnRlciB7XFxuICB3aWR0aDogMXJlbTtcXG4gIGhlaWdodDogMXJlbTsgfVxcblxcbi5zd2l0Y2gudGlueSBpbnB1dDpjaGVja2VkIH4gLnN3aXRjaC1wYWRkbGU6OmFmdGVyIHtcXG4gIGxlZnQ6IDEuNzVyZW07IH1cXG5cXG4uc3dpdGNoLnNtYWxsIC5zd2l0Y2gtcGFkZGxlIHtcXG4gIHdpZHRoOiAzLjVyZW07XFxuICBoZWlnaHQ6IDEuNzVyZW07XFxuICBmb250LXNpemU6IDAuNzVyZW07IH1cXG5cXG4uc3dpdGNoLnNtYWxsIC5zd2l0Y2gtcGFkZGxlOjphZnRlciB7XFxuICB3aWR0aDogMS4yNXJlbTtcXG4gIGhlaWdodDogMS4yNXJlbTsgfVxcblxcbi5zd2l0Y2guc21hbGwgaW5wdXQ6Y2hlY2tlZCB+IC5zd2l0Y2gtcGFkZGxlOjphZnRlciB7XFxuICBsZWZ0OiAycmVtOyB9XFxuXFxuLnN3aXRjaC5sYXJnZSAuc3dpdGNoLXBhZGRsZSB7XFxuICB3aWR0aDogNXJlbTtcXG4gIGhlaWdodDogMi41cmVtO1xcbiAgZm9udC1zaXplOiAxcmVtOyB9XFxuXFxuLnN3aXRjaC5sYXJnZSAuc3dpdGNoLXBhZGRsZTo6YWZ0ZXIge1xcbiAgd2lkdGg6IDJyZW07XFxuICBoZWlnaHQ6IDJyZW07IH1cXG5cXG4uc3dpdGNoLmxhcmdlIGlucHV0OmNoZWNrZWQgfiAuc3dpdGNoLXBhZGRsZTo6YWZ0ZXIge1xcbiAgbGVmdDogMi43NXJlbTsgfVxcblxcbnRhYmxlIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG4gIGJvcmRlci1yYWRpdXM6IDA7IH1cXG4gIHRhYmxlIHRoZWFkLFxcbiAgdGFibGUgdGJvZHksXFxuICB0YWJsZSB0Zm9vdCB7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICNmMWYxZjE7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZWZlZmU7IH1cXG4gIHRhYmxlIGNhcHRpb24ge1xcbiAgICBmb250LXdlaWdodDogYm9sZDtcXG4gICAgcGFkZGluZzogMC41cmVtIDAuNjI1cmVtIDAuNjI1cmVtOyB9XFxuICB0YWJsZSB0aGVhZCxcXG4gIHRhYmxlIHRmb290IHtcXG4gICAgYmFja2dyb3VuZDogI2Y4ZjhmODtcXG4gICAgY29sb3I6ICMwYTBhMGE7IH1cXG4gICAgdGFibGUgdGhlYWQgdHIsXFxuICAgIHRhYmxlIHRmb290IHRyIHtcXG4gICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDsgfVxcbiAgICB0YWJsZSB0aGVhZCB0aCxcXG4gICAgdGFibGUgdGhlYWQgdGQsXFxuICAgIHRhYmxlIHRmb290IHRoLFxcbiAgICB0YWJsZSB0Zm9vdCB0ZCB7XFxuICAgICAgcGFkZGluZzogMC41cmVtIDAuNjI1cmVtIDAuNjI1cmVtO1xcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICAgIHRleHQtYWxpZ246IGxlZnQ7IH1cXG4gIHRhYmxlIHRib2R5IHRyOm50aC1jaGlsZChldmVuKSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmMWYxZjE7IH1cXG4gIHRhYmxlIHRib2R5IHRoLFxcbiAgdGFibGUgdGJvZHkgdGQge1xcbiAgICBwYWRkaW5nOiAwLjVyZW0gMC42MjVyZW0gMC42MjVyZW07IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA2My45Mzc1ZW0pIHtcXG4gIHRhYmxlLnN0YWNrIHRoZWFkIHtcXG4gICAgZGlzcGxheTogbm9uZTsgfVxcbiAgdGFibGUuc3RhY2sgdGZvb3Qge1xcbiAgICBkaXNwbGF5OiBub25lOyB9XFxuICB0YWJsZS5zdGFjayB0cixcXG4gIHRhYmxlLnN0YWNrIHRoLFxcbiAgdGFibGUuc3RhY2sgdGQge1xcbiAgICBkaXNwbGF5OiBibG9jazsgfVxcbiAgdGFibGUuc3RhY2sgdGQge1xcbiAgICBib3JkZXItdG9wOiAwOyB9IH1cXG5cXG50YWJsZS5zY3JvbGwge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICB3aWR0aDogMTAwJTtcXG4gIG92ZXJmbG93LXg6IGF1dG87IH1cXG5cXG50YWJsZS5ob3ZlciB0cjpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjlmOWY5OyB9XFxuXFxudGFibGUuaG92ZXIgdHI6bnRoLW9mLXR5cGUoZXZlbik6aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VjZWNlYzsgfVxcblxcbi50YWJsZS1zY3JvbGwge1xcbiAgb3ZlcmZsb3cteDogYXV0bzsgfVxcbiAgLnRhYmxlLXNjcm9sbCB0YWJsZSB7XFxuICAgIHdpZHRoOiBhdXRvOyB9XFxuXFxuLnRhYnMge1xcbiAgbWFyZ2luOiAwO1xcbiAgbGlzdC1zdHlsZS10eXBlOiBub25lO1xcbiAgYmFja2dyb3VuZDogI2ZlZmVmZTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlNmU2ZTY7IH1cXG4gIC50YWJzOjpiZWZvcmUsIC50YWJzOjphZnRlciB7XFxuICAgIGNvbnRlbnQ6ICcgJztcXG4gICAgZGlzcGxheTogdGFibGU7IH1cXG4gIC50YWJzOjphZnRlciB7XFxuICAgIGNsZWFyOiBib3RoOyB9XFxuXFxuLnRhYnMudmVydGljYWwgPiBsaSB7XFxuICB3aWR0aDogYXV0bztcXG4gIGZsb2F0OiBub25lO1xcbiAgZGlzcGxheTogYmxvY2s7IH1cXG5cXG4udGFicy5zaW1wbGUgPiBsaSA+IGEge1xcbiAgcGFkZGluZzogMDsgfVxcbiAgLnRhYnMuc2ltcGxlID4gbGkgPiBhOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7IH1cXG5cXG4udGFicy5wcmltYXJ5IHtcXG4gIGJhY2tncm91bmQ6ICMyMTk5ZTg7IH1cXG4gIC50YWJzLnByaW1hcnkgPiBsaSA+IGEge1xcbiAgICBjb2xvcjogI2ZlZmVmZTsgfVxcbiAgICAudGFicy5wcmltYXJ5ID4gbGkgPiBhOmhvdmVyLCAudGFicy5wcmltYXJ5ID4gbGkgPiBhOmZvY3VzIHtcXG4gICAgICBiYWNrZ3JvdW5kOiAjMTg5M2U0OyB9XFxuXFxuLnRhYnMtdGl0bGUge1xcbiAgZmxvYXQ6IGxlZnQ7IH1cXG4gIC50YWJzLXRpdGxlID4gYSB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBwYWRkaW5nOiAxLjI1cmVtIDEuNXJlbTtcXG4gICAgbGluZS1oZWlnaHQ6IDE7XFxuICAgIGZvbnQtc2l6ZTogMC43NXJlbTsgfVxcbiAgICAudGFicy10aXRsZSA+IGE6aG92ZXIge1xcbiAgICAgIGJhY2tncm91bmQ6ICNmZWZlZmU7IH1cXG4gICAgLnRhYnMtdGl0bGUgPiBhOmZvY3VzLCAudGFicy10aXRsZSA+IGFbYXJpYS1zZWxlY3RlZD0ndHJ1ZSddIHtcXG4gICAgICBiYWNrZ3JvdW5kOiAjZTZlNmU2OyB9XFxuXFxuLnRhYnMtY29udGVudCB7XFxuICBiYWNrZ3JvdW5kOiAjZmVmZWZlO1xcbiAgdHJhbnNpdGlvbjogYWxsIDAuNXMgZWFzZTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlNmU2ZTY7XFxuICBib3JkZXItdG9wOiAwOyB9XFxuXFxuLnRhYnMtY29udGVudC52ZXJ0aWNhbCB7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZTZlNmU2O1xcbiAgYm9yZGVyLWxlZnQ6IDA7IH1cXG5cXG4udGFicy1wYW5lbCB7XFxuICBkaXNwbGF5OiBub25lO1xcbiAgcGFkZGluZzogMXJlbTsgfVxcbiAgLnRhYnMtcGFuZWwuaXMtYWN0aXZlIHtcXG4gICAgZGlzcGxheTogYmxvY2s7IH1cXG5cXG4udGh1bWJuYWlsIHtcXG4gIGJvcmRlcjogc29saWQgNHB4ICNmZWZlZmU7XFxuICBib3gtc2hhZG93OiAwIDAgMCAxcHggcmdiYSgxMCwgMTAsIDEwLCAwLjIpO1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgbGluZS1oZWlnaHQ6IDA7XFxuICBtYXgtd2lkdGg6IDEwMCU7XFxuICB0cmFuc2l0aW9uOiBib3gtc2hhZG93IDIwMG1zIGVhc2Utb3V0O1xcbiAgYm9yZGVyLXJhZGl1czogMDtcXG4gIG1hcmdpbi1ib3R0b206IDFyZW07IH1cXG4gIC50aHVtYm5haWw6aG92ZXIsIC50aHVtYm5haWw6Zm9jdXMge1xcbiAgICBib3gtc2hhZG93OiAwIDAgNnB4IDFweCByZ2JhKDMzLCAxNTMsIDIzMiwgMC41KTsgfVxcblxcbi50aXRsZS1iYXIge1xcbiAgYmFja2dyb3VuZDogIzBhMGEwYTtcXG4gIGNvbG9yOiAjZmVmZWZlO1xcbiAgcGFkZGluZzogMC41cmVtOyB9XFxuICAudGl0bGUtYmFyOjpiZWZvcmUsIC50aXRsZS1iYXI6OmFmdGVyIHtcXG4gICAgY29udGVudDogJyAnO1xcbiAgICBkaXNwbGF5OiB0YWJsZTsgfVxcbiAgLnRpdGxlLWJhcjo6YWZ0ZXIge1xcbiAgICBjbGVhcjogYm90aDsgfVxcbiAgLnRpdGxlLWJhciAubWVudS1pY29uIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDAuMjVyZW07XFxuICAgIG1hcmdpbi1yaWdodDogMC4yNXJlbTsgfVxcblxcbi50aXRsZS1iYXItbGVmdCB7XFxuICBmbG9hdDogbGVmdDsgfVxcblxcbi50aXRsZS1iYXItcmlnaHQge1xcbiAgZmxvYXQ6IHJpZ2h0O1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7IH1cXG5cXG4udGl0bGUtYmFyLXRpdGxlIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jazsgfVxcblxcbi5tZW51LWljb24uZGFyayB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgd2lkdGg6IDIwcHg7XFxuICBoZWlnaHQ6IDE2cHg7IH1cXG4gIC5tZW51LWljb24uZGFyazo6YWZ0ZXIge1xcbiAgICBjb250ZW50OiAnJztcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMnB4O1xcbiAgICBiYWNrZ3JvdW5kOiAjMGEwYTBhO1xcbiAgICB0b3A6IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIGJveC1zaGFkb3c6IDAgN3B4IDAgIzBhMGEwYSwgMCAxNHB4IDAgIzBhMGEwYTsgfVxcbiAgLm1lbnUtaWNvbi5kYXJrOmhvdmVyOjphZnRlciB7XFxuICAgIGJhY2tncm91bmQ6ICM4YThhOGE7XFxuICAgIGJveC1zaGFkb3c6IDAgN3B4IDAgIzhhOGE4YSwgMCAxNHB4IDAgIzhhOGE4YTsgfVxcblxcbi5oYXMtdGlwIHtcXG4gIGJvcmRlci1ib3R0b206IGRvdHRlZCAxcHggIzhhOGE4YTtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgY3Vyc29yOiBoZWxwOyB9XFxuXFxuLnRvb2x0aXAge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzBhMGEwYTtcXG4gIGNvbG9yOiAjZmVmZWZlO1xcbiAgZm9udC1zaXplOiA4MCU7XFxuICBwYWRkaW5nOiAwLjc1cmVtO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDogMTA7XFxuICB0b3A6IGNhbGMoMTAwJSArIDAuNjQ5NXJlbSk7XFxuICBtYXgtd2lkdGg6IDEwcmVtICFpbXBvcnRhbnQ7XFxuICBib3JkZXItcmFkaXVzOiAwOyB9XFxuICAudG9vbHRpcDo6YmVmb3JlIHtcXG4gICAgY29udGVudDogJyc7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICB3aWR0aDogMDtcXG4gICAgaGVpZ2h0OiAwO1xcbiAgICBib3JkZXI6IGluc2V0IDAuNzVyZW07XFxuICAgIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgIzBhMGEwYTtcXG4gICAgYm9yZGVyLWJvdHRvbS1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci10b3Atd2lkdGg6IDA7XFxuICAgIGJvdHRvbTogMTAwJTtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBsZWZ0OiA1MCU7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTsgfVxcbiAgLnRvb2x0aXAudG9wOjpiZWZvcmUge1xcbiAgICBjb250ZW50OiAnJztcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIHdpZHRoOiAwO1xcbiAgICBoZWlnaHQ6IDA7XFxuICAgIGJvcmRlcjogaW5zZXQgMC43NXJlbTtcXG4gICAgYm9yZGVyLWNvbG9yOiAjMGEwYTBhIHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O1xcbiAgICBib3JkZXItdG9wLXN0eWxlOiBzb2xpZDtcXG4gICAgYm9yZGVyLWJvdHRvbS13aWR0aDogMDtcXG4gICAgdG9wOiAxMDAlO1xcbiAgICBib3R0b206IGF1dG87IH1cXG4gIC50b29sdGlwLmxlZnQ6OmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6ICcnO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgd2lkdGg6IDA7XFxuICAgIGhlaWdodDogMDtcXG4gICAgYm9yZGVyOiBpbnNldCAwLjc1cmVtO1xcbiAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50ICMwYTBhMGE7XFxuICAgIGJvcmRlci1sZWZ0LXN0eWxlOiBzb2xpZDtcXG4gICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAwO1xcbiAgICBib3R0b206IGF1dG87XFxuICAgIGxlZnQ6IDEwMCU7XFxuICAgIHRvcDogNTAlO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSk7IH1cXG4gIC50b29sdGlwLnJpZ2h0OjpiZWZvcmUge1xcbiAgICBjb250ZW50OiAnJztcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIHdpZHRoOiAwO1xcbiAgICBoZWlnaHQ6IDA7XFxuICAgIGJvcmRlcjogaW5zZXQgMC43NXJlbTtcXG4gICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudCAjMGEwYTBhIHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O1xcbiAgICBib3JkZXItcmlnaHQtc3R5bGU6IHNvbGlkO1xcbiAgICBib3JkZXItbGVmdC13aWR0aDogMDtcXG4gICAgYm90dG9tOiBhdXRvO1xcbiAgICBsZWZ0OiBhdXRvO1xcbiAgICByaWdodDogMTAwJTtcXG4gICAgdG9wOiA1MCU7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTsgfVxcblxcbi50b3AtYmFyIHtcXG4gIHBhZGRpbmc6IDAuNXJlbTsgfVxcbiAgLnRvcC1iYXI6OmJlZm9yZSwgLnRvcC1iYXI6OmFmdGVyIHtcXG4gICAgY29udGVudDogJyAnO1xcbiAgICBkaXNwbGF5OiB0YWJsZTsgfVxcbiAgLnRvcC1iYXI6OmFmdGVyIHtcXG4gICAgY2xlYXI6IGJvdGg7IH1cXG4gIC50b3AtYmFyLFxcbiAgLnRvcC1iYXIgdWwge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZTZlNmU2OyB9XFxuICAudG9wLWJhciBpbnB1dCB7XFxuICAgIG1heC13aWR0aDogMjAwcHg7XFxuICAgIG1hcmdpbi1yaWdodDogMXJlbTsgfVxcbiAgLnRvcC1iYXIgLmlucHV0LWdyb3VwLWZpZWxkIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIG1hcmdpbi1yaWdodDogMDsgfVxcbiAgLnRvcC1iYXIgaW5wdXQuYnV0dG9uIHtcXG4gICAgd2lkdGg6IGF1dG87IH1cXG4gIC50b3AtYmFyIC50b3AtYmFyLWxlZnQsXFxuICAudG9wLWJhciAudG9wLWJhci1yaWdodCB7XFxuICAgIHdpZHRoOiAxMDAlOyB9XFxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA0MGVtKSB7XFxuICAgIC50b3AtYmFyIC50b3AtYmFyLWxlZnQsXFxuICAgIC50b3AtYmFyIC50b3AtYmFyLXJpZ2h0IHtcXG4gICAgICB3aWR0aDogYXV0bzsgfSB9XFxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA2My45Mzc1ZW0pIHtcXG4gICAgLnRvcC1iYXIuc3RhY2tlZC1mb3ItbWVkaXVtIC50b3AtYmFyLWxlZnQsXFxuICAgIC50b3AtYmFyLnN0YWNrZWQtZm9yLW1lZGl1bSAudG9wLWJhci1yaWdodCB7XFxuICAgICAgd2lkdGg6IDEwMCU7IH0gfVxcbiAgQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogNzQuOTM3NWVtKSB7XFxuICAgIC50b3AtYmFyLnN0YWNrZWQtZm9yLWxhcmdlIC50b3AtYmFyLWxlZnQsXFxuICAgIC50b3AtYmFyLnN0YWNrZWQtZm9yLWxhcmdlIC50b3AtYmFyLXJpZ2h0IHtcXG4gICAgICB3aWR0aDogMTAwJTsgfSB9XFxuXFxuLnRvcC1iYXItdGl0bGUge1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBtYXJnaW4tcmlnaHQ6IDFyZW07IH1cXG5cXG4udG9wLWJhci1sZWZ0IHtcXG4gIGZsb2F0OiBsZWZ0OyB9XFxuXFxuLnRvcC1iYXItcmlnaHQge1xcbiAgZmxvYXQ6IHJpZ2h0OyB9XFxuXFxuLmhpZGUge1xcbiAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50OyB9XFxuXFxuLmludmlzaWJsZSB7XFxuICB2aXNpYmlsaXR5OiBoaWRkZW47IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAzOS45Mzc1ZW0pIHtcXG4gIC5oaWRlLWZvci1zbWFsbC1vbmx5IHtcXG4gICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50OyB9IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAwZW0pLCBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDQwZW0pIHtcXG4gIC5zaG93LWZvci1zbWFsbC1vbmx5IHtcXG4gICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50OyB9IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA0MGVtKSB7XFxuICAuaGlkZS1mb3ItbWVkaXVtIHtcXG4gICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50OyB9IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAzOS45Mzc1ZW0pIHtcXG4gIC5zaG93LWZvci1tZWRpdW0ge1xcbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDQwZW0pIGFuZCAobWF4LXdpZHRoOiA2My45Mzc1ZW0pIHtcXG4gIC5oaWRlLWZvci1tZWRpdW0tb25seSB7XFxuICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDsgfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogMzkuOTM3NWVtKSwgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA2NGVtKSB7XFxuICAuc2hvdy1mb3ItbWVkaXVtLW9ubHkge1xcbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDY0ZW0pIHtcXG4gIC5oaWRlLWZvci1sYXJnZSB7XFxuICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDsgfSB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogNjMuOTM3NWVtKSB7XFxuICAuc2hvdy1mb3ItbGFyZ2Uge1xcbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7IH0gfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDY0ZW0pIGFuZCAobWF4LXdpZHRoOiA3NC45Mzc1ZW0pIHtcXG4gIC5oaWRlLWZvci1sYXJnZS1vbmx5IHtcXG4gICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50OyB9IH1cXG5cXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA2My45Mzc1ZW0pLCBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDc1ZW0pIHtcXG4gIC5zaG93LWZvci1sYXJnZS1vbmx5IHtcXG4gICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50OyB9IH1cXG5cXG4uc2hvdy1mb3Itc3IsXFxuLnNob3ctb24tZm9jdXMge1xcbiAgcG9zaXRpb246IGFic29sdXRlICFpbXBvcnRhbnQ7XFxuICB3aWR0aDogMXB4O1xcbiAgaGVpZ2h0OiAxcHg7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgY2xpcDogcmVjdCgwLCAwLCAwLCAwKTsgfVxcblxcbi5zaG93LW9uLWZvY3VzOmFjdGl2ZSwgLnNob3ctb24tZm9jdXM6Zm9jdXMge1xcbiAgcG9zaXRpb246IHN0YXRpYyAhaW1wb3J0YW50O1xcbiAgaGVpZ2h0OiBhdXRvO1xcbiAgd2lkdGg6IGF1dG87XFxuICBvdmVyZmxvdzogdmlzaWJsZTtcXG4gIGNsaXA6IGF1dG87IH1cXG5cXG4uc2hvdy1mb3ItbGFuZHNjYXBlLFxcbi5oaWRlLWZvci1wb3J0cmFpdCB7XFxuICBkaXNwbGF5OiBibG9jayAhaW1wb3J0YW50OyB9XFxuICBAbWVkaWEgc2NyZWVuIGFuZCAob3JpZW50YXRpb246IGxhbmRzY2FwZSkge1xcbiAgICAuc2hvdy1mb3ItbGFuZHNjYXBlLFxcbiAgICAuaGlkZS1mb3ItcG9ydHJhaXQge1xcbiAgICAgIGRpc3BsYXk6IGJsb2NrICFpbXBvcnRhbnQ7IH0gfVxcbiAgQG1lZGlhIHNjcmVlbiBhbmQgKG9yaWVudGF0aW9uOiBwb3J0cmFpdCkge1xcbiAgICAuc2hvdy1mb3ItbGFuZHNjYXBlLFxcbiAgICAuaGlkZS1mb3ItcG9ydHJhaXQge1xcbiAgICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDsgfSB9XFxuXFxuLmhpZGUtZm9yLWxhbmRzY2FwZSxcXG4uc2hvdy1mb3ItcG9ydHJhaXQge1xcbiAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50OyB9XFxuICBAbWVkaWEgc2NyZWVuIGFuZCAob3JpZW50YXRpb246IGxhbmRzY2FwZSkge1xcbiAgICAuaGlkZS1mb3ItbGFuZHNjYXBlLFxcbiAgICAuc2hvdy1mb3ItcG9ydHJhaXQge1xcbiAgICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDsgfSB9XFxuICBAbWVkaWEgc2NyZWVuIGFuZCAob3JpZW50YXRpb246IHBvcnRyYWl0KSB7XFxuICAgIC5oaWRlLWZvci1sYW5kc2NhcGUsXFxuICAgIC5zaG93LWZvci1wb3J0cmFpdCB7XFxuICAgICAgZGlzcGxheTogYmxvY2sgIWltcG9ydGFudDsgfSB9XFxuXFxuLmZsb2F0LWxlZnQge1xcbiAgZmxvYXQ6IGxlZnQgIWltcG9ydGFudDsgfVxcblxcbi5mbG9hdC1yaWdodCB7XFxuICBmbG9hdDogcmlnaHQgIWltcG9ydGFudDsgfVxcblxcbi5mbG9hdC1jZW50ZXIge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBtYXJnaW4tbGVmdDogYXV0bztcXG4gIG1hcmdpbi1yaWdodDogYXV0bzsgfVxcblxcbi5jbGVhcmZpeDo6YmVmb3JlLCAuY2xlYXJmaXg6OmFmdGVyIHtcXG4gIGNvbnRlbnQ6ICcgJztcXG4gIGRpc3BsYXk6IHRhYmxlOyB9XFxuXFxuLmNsZWFyZml4OjphZnRlciB7XFxuICBjbGVhcjogYm90aDsgfVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9+L3Nhc3MtbG9hZGVyIS4vYXBwL3N0eWxlcy9hcHAuc2Nzc1xuICoqIG1vZHVsZSBpZCA9IDIzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgbGlzdCA9IFtdO1xyXG5cclxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXHJcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xyXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSB0aGlzW2ldO1xyXG5cdFx0XHRpZihpdGVtWzJdKSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBpdGVtWzFdICsgXCJ9XCIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKGl0ZW1bMV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzdWx0LmpvaW4oXCJcIik7XHJcblx0fTtcclxuXHJcblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcclxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XHJcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcclxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xyXG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XHJcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcclxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XHJcblx0XHR9XHJcblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcclxuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxyXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xyXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxyXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxyXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xyXG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xyXG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblx0cmV0dXJuIGxpc3Q7XHJcbn07XHJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuICoqLyIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBzdHlsZXNJbkRvbSA9IHt9LFxyXG5cdG1lbW9pemUgPSBmdW5jdGlvbihmbikge1xyXG5cdFx0dmFyIG1lbW87XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRyZXR1cm4gbWVtbztcclxuXHRcdH07XHJcblx0fSxcclxuXHRpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiAvbXNpZSBbNi05XVxcYi8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcclxuXHR9KSxcclxuXHRnZXRIZWFkRWxlbWVudCA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xyXG5cdH0pLFxyXG5cdHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsLFxyXG5cdHNpbmdsZXRvbkNvdW50ZXIgPSAwLFxyXG5cdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wID0gW107XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcclxuXHRpZih0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcclxuXHRcdGlmKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xyXG5cdH1cclxuXHJcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XHJcblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxyXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xyXG5cclxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgPGhlYWQ+LlxyXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XHJcblxyXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCk7XHJcblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XHJcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xyXG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XHJcblx0XHR9XHJcblx0XHRpZihuZXdMaXN0KSB7XHJcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCk7XHJcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XHJcblx0XHR9XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcclxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xyXG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcclxuXHRcdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKCk7XHJcblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XHJcblx0XHRpZihkb21TdHlsZSkge1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xyXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzKGxpc3QpIHtcclxuXHR2YXIgc3R5bGVzID0gW107XHJcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XHJcblx0XHR2YXIgaWQgPSBpdGVtWzBdO1xyXG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XHJcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xyXG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XHJcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XHJcblx0XHRpZighbmV3U3R5bGVzW2lkXSlcclxuXHRcdFx0c3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcclxuXHRcdGVsc2VcclxuXHRcdFx0bmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xyXG5cdH1cclxuXHRyZXR1cm4gc3R5bGVzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KSB7XHJcblx0dmFyIGhlYWQgPSBnZXRIZWFkRWxlbWVudCgpO1xyXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wW3N0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xyXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XHJcblx0XHRpZighbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcclxuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBoZWFkLmZpcnN0Q2hpbGQpO1xyXG5cdFx0fSBlbHNlIGlmKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XHJcblx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0fVxyXG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AucHVzaChzdHlsZUVsZW1lbnQpO1xyXG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xyXG5cdFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0Jy4gTXVzdCBiZSAndG9wJyBvciAnYm90dG9tJy5cIik7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XHJcblx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHR2YXIgaWR4ID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZUVsZW1lbnQpO1xyXG5cdGlmKGlkeCA+PSAwKSB7XHJcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuXHRzdHlsZUVsZW1lbnQudHlwZSA9IFwidGV4dC9jc3NcIjtcclxuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KTtcclxuXHRyZXR1cm4gc3R5bGVFbGVtZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKSB7XHJcblx0dmFyIGxpbmtFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XHJcblx0bGlua0VsZW1lbnQucmVsID0gXCJzdHlsZXNoZWV0XCI7XHJcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmtFbGVtZW50KTtcclxuXHRyZXR1cm4gbGlua0VsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xyXG5cdHZhciBzdHlsZUVsZW1lbnQsIHVwZGF0ZSwgcmVtb3ZlO1xyXG5cclxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcclxuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XHJcblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSk7XHJcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCB0cnVlKTtcclxuXHR9IGVsc2UgaWYob2JqLnNvdXJjZU1hcCAmJlxyXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXHJcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcclxuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xyXG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0XHRpZihzdHlsZUVsZW1lbnQuaHJlZilcclxuXHRcdFx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlRWxlbWVudC5ocmVmKTtcclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xyXG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdHVwZGF0ZShvYmopO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XHJcblx0XHRpZihuZXdPYmopIHtcclxuXHRcdFx0aWYobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZW1vdmUoKTtcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcclxuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcclxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xyXG5cdH07XHJcbn0pKCk7XHJcblxyXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xyXG5cclxuXHRpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xyXG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2RlcztcclxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcclxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGVFbGVtZW50LCBvYmopIHtcclxuXHR2YXIgY3NzID0gb2JqLmNzcztcclxuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XHJcblxyXG5cdGlmKG1lZGlhKSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXHJcblx0fVxyXG5cclxuXHRpZihzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcclxuXHR9IGVsc2Uge1xyXG5cdFx0d2hpbGUoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcclxuXHRcdH1cclxuXHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUxpbmsobGlua0VsZW1lbnQsIG9iaikge1xyXG5cdHZhciBjc3MgPSBvYmouY3NzO1xyXG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xyXG5cclxuXHRpZihzb3VyY2VNYXApIHtcclxuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XHJcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XHJcblx0fVxyXG5cclxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcclxuXHJcblx0dmFyIG9sZFNyYyA9IGxpbmtFbGVtZW50LmhyZWY7XHJcblxyXG5cdGxpbmtFbGVtZW50LmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG5cclxuXHRpZihvbGRTcmMpXHJcblx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XHJcbn1cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDIzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gICAgIHV1aWQuanNcbi8vXG4vLyAgICAgQ29weXJpZ2h0IChjKSAyMDEwLTIwMTIgUm9iZXJ0IEtpZWZmZXJcbi8vICAgICBNSVQgTGljZW5zZSAtIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblxuLypnbG9iYWwgd2luZG93LCByZXF1aXJlLCBkZWZpbmUgKi9cbihmdW5jdGlvbihfd2luZG93KSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiAgV2UgZmVhdHVyZVxuICAvLyBkZXRlY3QgdG8gZGV0ZXJtaW5lIHRoZSBiZXN0IFJORyBzb3VyY2UsIG5vcm1hbGl6aW5nIHRvIGEgZnVuY3Rpb24gdGhhdFxuICAvLyByZXR1cm5zIDEyOC1iaXRzIG9mIHJhbmRvbW5lc3MsIHNpbmNlIHRoYXQncyB3aGF0J3MgdXN1YWxseSByZXF1aXJlZFxuICB2YXIgX3JuZywgX21hdGhSTkcsIF9ub2RlUk5HLCBfd2hhdHdnUk5HLCBfcHJldmlvdXNSb290O1xuXG4gIGZ1bmN0aW9uIHNldHVwQnJvd3NlcigpIHtcbiAgICAvLyBBbGxvdyBmb3IgTVNJRTExIG1zQ3J5cHRvXG4gICAgdmFyIF9jcnlwdG8gPSBfd2luZG93LmNyeXB0byB8fCBfd2luZG93Lm1zQ3J5cHRvO1xuXG4gICAgaWYgKCFfcm5nICYmIF9jcnlwdG8gJiYgX2NyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgIC8vIFdIQVRXRyBjcnlwdG8tYmFzZWQgUk5HIC0gaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0NyeXB0b1xuICAgICAgLy9cbiAgICAgIC8vIE1vZGVyYXRlbHkgZmFzdCwgaGlnaCBxdWFsaXR5XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgX3JuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICBfd2hhdHdnUk5HID0gX3JuZyA9IGZ1bmN0aW9uIHdoYXR3Z1JORygpIHtcbiAgICAgICAgICBfY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhfcm5kczgpO1xuICAgICAgICAgIHJldHVybiBfcm5kczg7XG4gICAgICAgIH07XG4gICAgICAgIF9ybmcoKTtcbiAgICAgIH0gY2F0Y2goZSkge31cbiAgICB9XG5cbiAgICBpZiAoIV9ybmcpIHtcbiAgICAgIC8vIE1hdGgucmFuZG9tKCktYmFzZWQgKFJORylcbiAgICAgIC8vXG4gICAgICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdXNlIE1hdGgucmFuZG9tKCkuICBJdCdzIGZhc3QsIGJ1dCBpcyBvZiB1bnNwZWNpZmllZFxuICAgICAgLy8gcXVhbGl0eS5cbiAgICAgIHZhciAgX3JuZHMgPSBuZXcgQXJyYXkoMTYpO1xuICAgICAgX21hdGhSTkcgPSBfcm5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgIGlmICgoaSAmIDB4MDMpID09PSAwKSB7IHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7IH1cbiAgICAgICAgICBfcm5kc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfcm5kcztcbiAgICAgIH07XG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBjb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbU0VDVVJJVFldIG5vZGUtdXVpZDogY3J5cHRvIG5vdCB1c2FibGUsIGZhbGxpbmcgYmFjayB0byBpbnNlY3VyZSBNYXRoLnJhbmRvbSgpXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldHVwTm9kZSgpIHtcbiAgICAvLyBOb2RlLmpzIGNyeXB0by1iYXNlZCBSTkcgLSBodHRwOi8vbm9kZWpzLm9yZy9kb2NzL3YwLjYuMi9hcGkvY3J5cHRvLmh0bWxcbiAgICAvL1xuICAgIC8vIE1vZGVyYXRlbHkgZmFzdCwgaGlnaCBxdWFsaXR5XG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiByZXF1aXJlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgX3JiID0gcmVxdWlyZSgnY3J5cHRvJykucmFuZG9tQnl0ZXM7XG4gICAgICAgIF9ub2RlUk5HID0gX3JuZyA9IF9yYiAmJiBmdW5jdGlvbigpIHtyZXR1cm4gX3JiKDE2KTt9O1xuICAgICAgICBfcm5nKCk7XG4gICAgICB9IGNhdGNoKGUpIHt9XG4gICAgfVxuICB9XG5cbiAgaWYgKF93aW5kb3cpIHtcbiAgICBzZXR1cEJyb3dzZXIoKTtcbiAgfSBlbHNlIHtcbiAgICBzZXR1cE5vZGUoKTtcbiAgfVxuXG4gIC8vIEJ1ZmZlciBjbGFzcyB0byB1c2VcbiAgdmFyIEJ1ZmZlckNsYXNzID0gKCdmdW5jdGlvbicgPT09IHR5cGVvZiBCdWZmZXIpID8gQnVmZmVyIDogQXJyYXk7XG5cbiAgLy8gTWFwcyBmb3IgbnVtYmVyIDwtPiBoZXggc3RyaW5nIGNvbnZlcnNpb25cbiAgdmFyIF9ieXRlVG9IZXggPSBbXTtcbiAgdmFyIF9oZXhUb0J5dGUgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgIF9ieXRlVG9IZXhbaV0gPSAoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpO1xuICAgIF9oZXhUb0J5dGVbX2J5dGVUb0hleFtpXV0gPSBpO1xuICB9XG5cbiAgLy8gKipgcGFyc2UoKWAgLSBQYXJzZSBhIFVVSUQgaW50byBpdCdzIGNvbXBvbmVudCBieXRlcyoqXG4gIGZ1bmN0aW9uIHBhcnNlKHMsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgdmFyIGkgPSAoYnVmICYmIG9mZnNldCkgfHwgMCwgaWkgPSAwO1xuXG4gICAgYnVmID0gYnVmIHx8IFtdO1xuICAgIHMudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bMC05YS1mXXsyfS9nLCBmdW5jdGlvbihvY3QpIHtcbiAgICAgIGlmIChpaSA8IDE2KSB7IC8vIERvbid0IG92ZXJmbG93IVxuICAgICAgICBidWZbaSArIGlpKytdID0gX2hleFRvQnl0ZVtvY3RdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gWmVybyBvdXQgcmVtYWluaW5nIGJ5dGVzIGlmIHN0cmluZyB3YXMgc2hvcnRcbiAgICB3aGlsZSAoaWkgPCAxNikge1xuICAgICAgYnVmW2kgKyBpaSsrXSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuXG4gIC8vICoqYHVucGFyc2UoKWAgLSBDb252ZXJ0IFVVSUQgYnl0ZSBhcnJheSAoYWxhIHBhcnNlKCkpIGludG8gYSBzdHJpbmcqKlxuICBmdW5jdGlvbiB1bnBhcnNlKGJ1Ziwgb2Zmc2V0KSB7XG4gICAgdmFyIGkgPSBvZmZzZXQgfHwgMCwgYnRoID0gX2J5dGVUb0hleDtcbiAgICByZXR1cm4gIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICtcbiAgICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICtcbiAgICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICtcbiAgICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dO1xuICB9XG5cbiAgLy8gKipgdjEoKWAgLSBHZW5lcmF0ZSB0aW1lLWJhc2VkIFVVSUQqKlxuICAvL1xuICAvLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuICAvLyBhbmQgaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L3V1aWQuaHRtbFxuXG4gIC8vIHJhbmRvbSAjJ3Mgd2UgbmVlZCB0byBpbml0IG5vZGUgYW5kIGNsb2Nrc2VxXG4gIHZhciBfc2VlZEJ5dGVzID0gX3JuZygpO1xuXG4gIC8vIFBlciA0LjUsIGNyZWF0ZSBhbmQgNDgtYml0IG5vZGUgaWQsICg0NyByYW5kb20gYml0cyArIG11bHRpY2FzdCBiaXQgPSAxKVxuICB2YXIgX25vZGVJZCA9IFtcbiAgICBfc2VlZEJ5dGVzWzBdIHwgMHgwMSxcbiAgICBfc2VlZEJ5dGVzWzFdLCBfc2VlZEJ5dGVzWzJdLCBfc2VlZEJ5dGVzWzNdLCBfc2VlZEJ5dGVzWzRdLCBfc2VlZEJ5dGVzWzVdXG4gIF07XG5cbiAgLy8gUGVyIDQuMi4yLCByYW5kb21pemUgKDE0IGJpdCkgY2xvY2tzZXFcbiAgdmFyIF9jbG9ja3NlcSA9IChfc2VlZEJ5dGVzWzZdIDw8IDggfCBfc2VlZEJ5dGVzWzddKSAmIDB4M2ZmZjtcblxuICAvLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcbiAgdmFyIF9sYXN0TVNlY3MgPSAwLCBfbGFzdE5TZWNzID0gMDtcblxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWQgZm9yIEFQSSBkZXRhaWxzXG4gIGZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gICAgdmFyIGIgPSBidWYgfHwgW107XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBjbG9ja3NlcSA9IChvcHRpb25zLmNsb2Nrc2VxICE9IG51bGwpID8gb3B0aW9ucy5jbG9ja3NlcSA6IF9jbG9ja3NlcTtcblxuICAgIC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gICAgLy8gKDE1ODItMTAtMTUgMDA6MDApLiAgSlNOdW1iZXJzIGFyZW4ndCBwcmVjaXNlIGVub3VnaCBmb3IgdGhpcywgc29cbiAgICAvLyB0aW1lIGlzIGhhbmRsZWQgaW50ZXJuYWxseSBhcyAnbXNlY3MnIChpbnRlZ2VyIG1pbGxpc2Vjb25kcykgYW5kICduc2VjcydcbiAgICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuICAgIHZhciBtc2VjcyA9IChvcHRpb25zLm1zZWNzICE9IG51bGwpID8gb3B0aW9ucy5tc2VjcyA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgLy8gUGVyIDQuMi4xLjIsIHVzZSBjb3VudCBvZiB1dWlkJ3MgZ2VuZXJhdGVkIGR1cmluZyB0aGUgY3VycmVudCBjbG9ja1xuICAgIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG4gICAgdmFyIG5zZWNzID0gKG9wdGlvbnMubnNlY3MgIT0gbnVsbCkgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7XG5cbiAgICAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG4gICAgdmFyIGR0ID0gKG1zZWNzIC0gX2xhc3RNU2VjcykgKyAobnNlY3MgLSBfbGFzdE5TZWNzKS8xMDAwMDtcblxuICAgIC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cbiAgICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgICAgY2xvY2tzZXEgPSBjbG9ja3NlcSArIDEgJiAweDNmZmY7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgbnNlY3MgaWYgY2xvY2sgcmVncmVzc2VzIChuZXcgY2xvY2tzZXEpIG9yIHdlJ3ZlIG1vdmVkIG9udG8gYSBuZXdcbiAgICAvLyB0aW1lIGludGVydmFsXG4gICAgaWYgKChkdCA8IDAgfHwgbXNlY3MgPiBfbGFzdE1TZWNzKSAmJiBvcHRpb25zLm5zZWNzID09IG51bGwpIHtcbiAgICAgIG5zZWNzID0gMDtcbiAgICB9XG5cbiAgICAvLyBQZXIgNC4yLjEuMiBUaHJvdyBlcnJvciBpZiB0b28gbWFueSB1dWlkcyBhcmUgcmVxdWVzdGVkXG4gICAgaWYgKG5zZWNzID49IDEwMDAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3V1aWQudjEoKTogQ2FuXFwndCBjcmVhdGUgbW9yZSB0aGFuIDEwTSB1dWlkcy9zZWMnKTtcbiAgICB9XG5cbiAgICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gICAgX2xhc3ROU2VjcyA9IG5zZWNzO1xuICAgIF9jbG9ja3NlcSA9IGNsb2Nrc2VxO1xuXG4gICAgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG4gICAgbXNlY3MgKz0gMTIyMTkyOTI4MDAwMDA7XG5cbiAgICAvLyBgdGltZV9sb3dgXG4gICAgdmFyIHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICAgIGJbaSsrXSA9IHRsID4+PiAyNCAmIDB4ZmY7XG4gICAgYltpKytdID0gdGwgPj4+IDE2ICYgMHhmZjtcbiAgICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gICAgYltpKytdID0gdGwgJiAweGZmO1xuXG4gICAgLy8gYHRpbWVfbWlkYFxuICAgIHZhciB0bWggPSAobXNlY3MgLyAweDEwMDAwMDAwMCAqIDEwMDAwKSAmIDB4ZmZmZmZmZjtcbiAgICBiW2krK10gPSB0bWggPj4+IDggJiAweGZmO1xuICAgIGJbaSsrXSA9IHRtaCAmIDB4ZmY7XG5cbiAgICAvLyBgdGltZV9oaWdoX2FuZF92ZXJzaW9uYFxuICAgIGJbaSsrXSA9IHRtaCA+Pj4gMjQgJiAweGYgfCAweDEwOyAvLyBpbmNsdWRlIHZlcnNpb25cbiAgICBiW2krK10gPSB0bWggPj4+IDE2ICYgMHhmZjtcblxuICAgIC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuICAgIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDtcblxuICAgIC8vIGBjbG9ja19zZXFfbG93YFxuICAgIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjtcblxuICAgIC8vIGBub2RlYFxuICAgIHZhciBub2RlID0gb3B0aW9ucy5ub2RlIHx8IF9ub2RlSWQ7XG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCA2OyBuKyspIHtcbiAgICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmID8gYnVmIDogdW5wYXJzZShiKTtcbiAgfVxuXG4gIC8vICoqYHY0KClgIC0gR2VuZXJhdGUgcmFuZG9tIFVVSUQqKlxuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZCBmb3IgQVBJIGRldGFpbHNcbiAgZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgICAvLyBEZXByZWNhdGVkIC0gJ2Zvcm1hdCcgYXJndW1lbnQsIGFzIHN1cHBvcnRlZCBpbiB2MS4yXG4gICAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG5cbiAgICBpZiAodHlwZW9mKG9wdGlvbnMpID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmID0gKG9wdGlvbnMgPT09ICdiaW5hcnknKSA/IG5ldyBCdWZmZXJDbGFzcygxNikgOiBudWxsO1xuICAgICAgb3B0aW9ucyA9IG51bGw7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgX3JuZykoKTtcblxuICAgIC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcbiAgICBybmRzWzZdID0gKHJuZHNbNl0gJiAweDBmKSB8IDB4NDA7XG4gICAgcm5kc1s4XSA9IChybmRzWzhdICYgMHgzZikgfCAweDgwO1xuXG4gICAgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG4gICAgaWYgKGJ1Zikge1xuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDE2OyBpaSsrKSB7XG4gICAgICAgIGJ1ZltpICsgaWldID0gcm5kc1tpaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZiB8fCB1bnBhcnNlKHJuZHMpO1xuICB9XG5cbiAgLy8gRXhwb3J0IHB1YmxpYyBBUElcbiAgdmFyIHV1aWQgPSB2NDtcbiAgdXVpZC52MSA9IHYxO1xuICB1dWlkLnY0ID0gdjQ7XG4gIHV1aWQucGFyc2UgPSBwYXJzZTtcbiAgdXVpZC51bnBhcnNlID0gdW5wYXJzZTtcbiAgdXVpZC5CdWZmZXJDbGFzcyA9IEJ1ZmZlckNsYXNzO1xuICB1dWlkLl9ybmcgPSBfcm5nO1xuICB1dWlkLl9tYXRoUk5HID0gX21hdGhSTkc7XG4gIHV1aWQuX25vZGVSTkcgPSBfbm9kZVJORztcbiAgdXVpZC5fd2hhdHdnUk5HID0gX3doYXR3Z1JORztcblxuICBpZiAoKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlKSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIC8vIFB1Ymxpc2ggYXMgbm9kZS5qcyBtb2R1bGVcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHV1aWQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gUHVibGlzaCBhcyBBTUQgbW9kdWxlXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge3JldHVybiB1dWlkO30pO1xuXG5cbiAgfSBlbHNlIHtcbiAgICAvLyBQdWJsaXNoIGFzIGdsb2JhbCAoaW4gYnJvd3NlcnMpXG4gICAgX3ByZXZpb3VzUm9vdCA9IF93aW5kb3cudXVpZDtcblxuICAgIC8vICoqYG5vQ29uZmxpY3QoKWAgLSAoYnJvd3NlciBvbmx5KSB0byByZXNldCBnbG9iYWwgJ3V1aWQnIHZhcioqXG4gICAgdXVpZC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBfd2luZG93LnV1aWQgPSBfcHJldmlvdXNSb290O1xuICAgICAgcmV0dXJuIHV1aWQ7XG4gICAgfTtcblxuICAgIF93aW5kb3cudXVpZCA9IHV1aWQ7XG4gIH1cbn0pKCd1bmRlZmluZWQnICE9PSB0eXBlb2Ygd2luZG93ID8gd2luZG93IDogbnVsbCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vbm9kZS11dWlkL3V1aWQuanNcbiAqKi8iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vYnVmZmVyL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICByZXR1cm4gYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIHBsYWNlSG9sZGVycyA9IHBsYWNlSG9sZGVyc0NvdW50KGI2NClcblxuICBhcnIgPSBuZXcgQXJyKGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2Jhc2U2NC1qcy9pbmRleC5qc1xuICoqLyIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2llZWU3NTQvaW5kZXguanNcbiAqKi8iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9pc2FycmF5L2luZGV4LmpzXG4gKiovIiwidmFyIHJuZyA9IHJlcXVpcmUoJy4vcm5nJylcblxuZnVuY3Rpb24gZXJyb3IgKCkge1xuICB2YXIgbSA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKCcgJylcbiAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICBtLFxuICAgICd3ZSBhY2NlcHQgcHVsbCByZXF1ZXN0cycsXG4gICAgJ2h0dHA6Ly9naXRodWIuY29tL2RvbWluaWN0YXJyL2NyeXB0by1icm93c2VyaWZ5J1xuICAgIF0uam9pbignXFxuJykpXG59XG5cbmV4cG9ydHMuY3JlYXRlSGFzaCA9IHJlcXVpcmUoJy4vY3JlYXRlLWhhc2gnKVxuXG5leHBvcnRzLmNyZWF0ZUhtYWMgPSByZXF1aXJlKCcuL2NyZWF0ZS1obWFjJylcblxuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uKHNpemUsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgdW5kZWZpbmVkLCBuZXcgQnVmZmVyKHJuZyhzaXplKSkpXG4gICAgfSBjYXRjaCAoZXJyKSB7IGNhbGxiYWNrKGVycikgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKHJuZyhzaXplKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBlYWNoKGEsIGYpIHtcbiAgZm9yKHZhciBpIGluIGEpXG4gICAgZihhW2ldLCBpKVxufVxuXG5leHBvcnRzLmdldEhhc2hlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFsnc2hhMScsICdzaGEyNTYnLCAnc2hhNTEyJywgJ21kNScsICdybWQxNjAnXVxufVxuXG52YXIgcCA9IHJlcXVpcmUoJy4vcGJrZGYyJykoZXhwb3J0cylcbmV4cG9ydHMucGJrZGYyID0gcC5wYmtkZjJcbmV4cG9ydHMucGJrZGYyU3luYyA9IHAucGJrZGYyU3luY1xuXG5cbi8vIHRoZSBsZWFzdCBJIGNhbiBkbyBpcyBtYWtlIGVycm9yIG1lc3NhZ2VzIGZvciB0aGUgcmVzdCBvZiB0aGUgbm9kZS5qcy9jcnlwdG8gYXBpLlxuZWFjaChbJ2NyZWF0ZUNyZWRlbnRpYWxzJ1xuLCAnY3JlYXRlQ2lwaGVyJ1xuLCAnY3JlYXRlQ2lwaGVyaXYnXG4sICdjcmVhdGVEZWNpcGhlcidcbiwgJ2NyZWF0ZURlY2lwaGVyaXYnXG4sICdjcmVhdGVTaWduJ1xuLCAnY3JlYXRlVmVyaWZ5J1xuLCAnY3JlYXRlRGlmZmllSGVsbG1hbidcbl0sIGZ1bmN0aW9uIChuYW1lKSB7XG4gIGV4cG9ydHNbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgZXJyb3IoJ3NvcnJ5LCcsIG5hbWUsICdpcyBub3QgaW1wbGVtZW50ZWQgeWV0JylcbiAgfVxufSlcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jcnlwdG8tYnJvd3NlcmlmeS9pbmRleC5qc1xuICoqLyIsIihmdW5jdGlvbigpIHtcbiAgdmFyIGcgPSAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiB3aW5kb3cgPyBnbG9iYWwgOiB3aW5kb3cpIHx8IHt9XG4gIF9jcnlwdG8gPSAoXG4gICAgZy5jcnlwdG8gfHwgZy5tc0NyeXB0byB8fCByZXF1aXJlKCdjcnlwdG8nKVxuICApXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIC8vIE1vZGVybiBCcm93c2Vyc1xuICAgIGlmKF9jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBuZXcgQnVmZmVyKHNpemUpOyAvL2luIGJyb3dzZXJpZnksIHRoaXMgaXMgYW4gZXh0ZW5kZWQgVWludDhBcnJheVxuICAgICAgLyogVGhpcyB3aWxsIG5vdCB3b3JrIGluIG9sZGVyIGJyb3dzZXJzLlxuICAgICAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS93aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlc1xuICAgICAgICovXG4gICAgXG4gICAgICBfY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcyk7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKF9jcnlwdG8ucmFuZG9tQnl0ZXMpIHtcbiAgICAgIHJldHVybiBfY3J5cHRvLnJhbmRvbUJ5dGVzKHNpemUpXG4gICAgfVxuICAgIGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3NlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24gbm90IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXJcXG4nK1xuICAgICAgICAndXNlIGNocm9tZSwgRmlyZUZveCBvciBJbnRlcm5ldCBFeHBsb3JlciAxMSdcbiAgICAgIClcbiAgfVxufSgpKVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2NyeXB0by1icm93c2VyaWZ5L3JuZy5qc1xuICoqLyIsIi8qIChpZ25vcmVkKSAqL1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogY3J5cHRvIChpZ25vcmVkKVxuICoqIG1vZHVsZSBpZCA9IDI0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdzaGEuanMnKVxuXG52YXIgbWQ1ID0gdG9Db25zdHJ1Y3RvcihyZXF1aXJlKCcuL21kNScpKVxudmFyIHJtZDE2MCA9IHRvQ29uc3RydWN0b3IocmVxdWlyZSgncmlwZW1kMTYwJykpXG5cbmZ1bmN0aW9uIHRvQ29uc3RydWN0b3IgKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJ1ZmZlcnMgPSBbXVxuICAgIHZhciBtPSB7XG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIChkYXRhLCBlbmMpIHtcbiAgICAgICAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSwgZW5jKVxuICAgICAgICBidWZmZXJzLnB1c2goZGF0YSlcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH0sXG4gICAgICBkaWdlc3Q6IGZ1bmN0aW9uIChlbmMpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoYnVmZmVycylcbiAgICAgICAgdmFyIHIgPSBmbihidWYpXG4gICAgICAgIGJ1ZmZlcnMgPSBudWxsXG4gICAgICAgIHJldHVybiBlbmMgPyByLnRvU3RyaW5nKGVuYykgOiByXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYWxnKSB7XG4gIGlmKCdtZDUnID09PSBhbGcpIHJldHVybiBuZXcgbWQ1KClcbiAgaWYoJ3JtZDE2MCcgPT09IGFsZykgcmV0dXJuIG5ldyBybWQxNjAoKVxuICByZXR1cm4gY3JlYXRlSGFzaChhbGcpXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY3J5cHRvLWJyb3dzZXJpZnkvY3JlYXRlLWhhc2guanNcbiAqKi8iLCJ2YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFsZykge1xuICB2YXIgQWxnID0gZXhwb3J0c1thbGddXG4gIGlmKCFBbGcpIHRocm93IG5ldyBFcnJvcihhbGcgKyAnIGlzIG5vdCBzdXBwb3J0ZWQgKHdlIGFjY2VwdCBwdWxsIHJlcXVlc3RzKScpXG4gIHJldHVybiBuZXcgQWxnKClcbn1cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlclxudmFyIEhhc2ggICA9IHJlcXVpcmUoJy4vaGFzaCcpKEJ1ZmZlcilcblxuZXhwb3J0cy5zaGExID0gcmVxdWlyZSgnLi9zaGExJykoQnVmZmVyLCBIYXNoKVxuZXhwb3J0cy5zaGEyNTYgPSByZXF1aXJlKCcuL3NoYTI1NicpKEJ1ZmZlciwgSGFzaClcbmV4cG9ydHMuc2hhNTEyID0gcmVxdWlyZSgnLi9zaGE1MTInKShCdWZmZXIsIEhhc2gpXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vc2hhLmpzL2luZGV4LmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQnVmZmVyKSB7XG5cbiAgLy9wcm90b3R5cGUgY2xhc3MgZm9yIGhhc2ggZnVuY3Rpb25zXG4gIGZ1bmN0aW9uIEhhc2ggKGJsb2NrU2l6ZSwgZmluYWxTaXplKSB7XG4gICAgdGhpcy5fYmxvY2sgPSBuZXcgQnVmZmVyKGJsb2NrU2l6ZSkgLy9uZXcgVWludDMyQXJyYXkoYmxvY2tTaXplLzQpXG4gICAgdGhpcy5fZmluYWxTaXplID0gZmluYWxTaXplXG4gICAgdGhpcy5fYmxvY2tTaXplID0gYmxvY2tTaXplXG4gICAgdGhpcy5fbGVuID0gMFxuICAgIHRoaXMuX3MgPSAwXG4gIH1cblxuICBIYXNoLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3MgPSAwXG4gICAgdGhpcy5fbGVuID0gMFxuICB9XG5cbiAgSGFzaC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuYykge1xuICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgZGF0YSkge1xuICAgICAgZW5jID0gZW5jIHx8IFwidXRmOFwiXG4gICAgICBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCBlbmMpXG4gICAgfVxuXG4gICAgdmFyIGwgPSB0aGlzLl9sZW4gKz0gZGF0YS5sZW5ndGhcbiAgICB2YXIgcyA9IHRoaXMuX3MgPSAodGhpcy5fcyB8fCAwKVxuICAgIHZhciBmID0gMFxuICAgIHZhciBidWZmZXIgPSB0aGlzLl9ibG9ja1xuXG4gICAgd2hpbGUgKHMgPCBsKSB7XG4gICAgICB2YXIgdCA9IE1hdGgubWluKGRhdGEubGVuZ3RoLCBmICsgdGhpcy5fYmxvY2tTaXplIC0gKHMgJSB0aGlzLl9ibG9ja1NpemUpKVxuICAgICAgdmFyIGNoID0gKHQgLSBmKVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoOyBpKyspIHtcbiAgICAgICAgYnVmZmVyWyhzICUgdGhpcy5fYmxvY2tTaXplKSArIGldID0gZGF0YVtpICsgZl1cbiAgICAgIH1cblxuICAgICAgcyArPSBjaFxuICAgICAgZiArPSBjaFxuXG4gICAgICBpZiAoKHMgJSB0aGlzLl9ibG9ja1NpemUpID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZShidWZmZXIpXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3MgPSBzXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgSGFzaC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuYykge1xuICAgIC8vIFN1cHBvc2UgdGhlIGxlbmd0aCBvZiB0aGUgbWVzc2FnZSBNLCBpbiBiaXRzLCBpcyBsXG4gICAgdmFyIGwgPSB0aGlzLl9sZW4gKiA4XG5cbiAgICAvLyBBcHBlbmQgdGhlIGJpdCAxIHRvIHRoZSBlbmQgb2YgdGhlIG1lc3NhZ2VcbiAgICB0aGlzLl9ibG9ja1t0aGlzLl9sZW4gJSB0aGlzLl9ibG9ja1NpemVdID0gMHg4MFxuXG4gICAgLy8gYW5kIHRoZW4gayB6ZXJvIGJpdHMsIHdoZXJlIGsgaXMgdGhlIHNtYWxsZXN0IG5vbi1uZWdhdGl2ZSBzb2x1dGlvbiB0byB0aGUgZXF1YXRpb24gKGwgKyAxICsgaykgPT09IGZpbmFsU2l6ZSBtb2QgYmxvY2tTaXplXG4gICAgdGhpcy5fYmxvY2suZmlsbCgwLCB0aGlzLl9sZW4gJSB0aGlzLl9ibG9ja1NpemUgKyAxKVxuXG4gICAgaWYgKGwgJSAodGhpcy5fYmxvY2tTaXplICogOCkgPj0gdGhpcy5fZmluYWxTaXplICogOCkge1xuICAgICAgdGhpcy5fdXBkYXRlKHRoaXMuX2Jsb2NrKVxuICAgICAgdGhpcy5fYmxvY2suZmlsbCgwKVxuICAgIH1cblxuICAgIC8vIHRvIHRoaXMgYXBwZW5kIHRoZSBibG9jayB3aGljaCBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIGwgd3JpdHRlbiBpbiBiaW5hcnlcbiAgICAvLyBUT0RPOiBoYW5kbGUgY2FzZSB3aGVyZSBsIGlzID4gTWF0aC5wb3coMiwgMjkpXG4gICAgdGhpcy5fYmxvY2sud3JpdGVJbnQzMkJFKGwsIHRoaXMuX2Jsb2NrU2l6ZSAtIDQpXG5cbiAgICB2YXIgaGFzaCA9IHRoaXMuX3VwZGF0ZSh0aGlzLl9ibG9jaykgfHwgdGhpcy5faGFzaCgpXG5cbiAgICByZXR1cm4gZW5jID8gaGFzaC50b1N0cmluZyhlbmMpIDogaGFzaFxuICB9XG5cbiAgSGFzaC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ191cGRhdGUgbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzcycpXG4gIH1cblxuICByZXR1cm4gSGFzaFxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3NoYS5qcy9oYXNoLmpzXG4gKiovIiwiLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2VjdXJlIEhhc2ggQWxnb3JpdGhtLCBTSEEtMSwgYXMgZGVmaW5lZFxuICogaW4gRklQUyBQVUIgMTgwLTFcbiAqIFZlcnNpb24gMi4xYSBDb3B5cmlnaHQgUGF1bCBKb2huc3RvbiAyMDAwIC0gMjAwMi5cbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIGRldGFpbHMuXG4gKi9cblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJ1ZmZlciwgSGFzaCkge1xuXG4gIHZhciBBID0gMHwwXG4gIHZhciBCID0gNHwwXG4gIHZhciBDID0gOHwwXG4gIHZhciBEID0gMTJ8MFxuICB2YXIgRSA9IDE2fDBcblxuICB2YXIgVyA9IG5ldyAodHlwZW9mIEludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gQXJyYXkgOiBJbnQzMkFycmF5KSg4MClcblxuICB2YXIgUE9PTCA9IFtdXG5cbiAgZnVuY3Rpb24gU2hhMSAoKSB7XG4gICAgaWYoUE9PTC5sZW5ndGgpXG4gICAgICByZXR1cm4gUE9PTC5wb3AoKS5pbml0KClcblxuICAgIGlmKCEodGhpcyBpbnN0YW5jZW9mIFNoYTEpKSByZXR1cm4gbmV3IFNoYTEoKVxuICAgIHRoaXMuX3cgPSBXXG4gICAgSGFzaC5jYWxsKHRoaXMsIDE2KjQsIDE0KjQpXG5cbiAgICB0aGlzLl9oID0gbnVsbFxuICAgIHRoaXMuaW5pdCgpXG4gIH1cblxuICBpbmhlcml0cyhTaGExLCBIYXNoKVxuXG4gIFNoYTEucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYSA9IDB4Njc0NTIzMDFcbiAgICB0aGlzLl9iID0gMHhlZmNkYWI4OVxuICAgIHRoaXMuX2MgPSAweDk4YmFkY2ZlXG4gICAgdGhpcy5fZCA9IDB4MTAzMjU0NzZcbiAgICB0aGlzLl9lID0gMHhjM2QyZTFmMFxuXG4gICAgSGFzaC5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIFNoYTEucHJvdG90eXBlLl9QT09MID0gUE9PTFxuICBTaGExLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKFgpIHtcblxuICAgIHZhciBhLCBiLCBjLCBkLCBlLCBfYSwgX2IsIF9jLCBfZCwgX2VcblxuICAgIGEgPSBfYSA9IHRoaXMuX2FcbiAgICBiID0gX2IgPSB0aGlzLl9iXG4gICAgYyA9IF9jID0gdGhpcy5fY1xuICAgIGQgPSBfZCA9IHRoaXMuX2RcbiAgICBlID0gX2UgPSB0aGlzLl9lXG5cbiAgICB2YXIgdyA9IHRoaXMuX3dcblxuICAgIGZvcih2YXIgaiA9IDA7IGogPCA4MDsgaisrKSB7XG4gICAgICB2YXIgVyA9IHdbal0gPSBqIDwgMTYgPyBYLnJlYWRJbnQzMkJFKGoqNClcbiAgICAgICAgOiByb2wod1tqIC0gM10gXiB3W2ogLSAgOF0gXiB3W2ogLSAxNF0gXiB3W2ogLSAxNl0sIDEpXG5cbiAgICAgIHZhciB0ID0gYWRkKFxuICAgICAgICBhZGQocm9sKGEsIDUpLCBzaGExX2Z0KGosIGIsIGMsIGQpKSxcbiAgICAgICAgYWRkKGFkZChlLCBXKSwgc2hhMV9rdChqKSlcbiAgICAgIClcblxuICAgICAgZSA9IGRcbiAgICAgIGQgPSBjXG4gICAgICBjID0gcm9sKGIsIDMwKVxuICAgICAgYiA9IGFcbiAgICAgIGEgPSB0XG4gICAgfVxuXG4gICAgdGhpcy5fYSA9IGFkZChhLCBfYSlcbiAgICB0aGlzLl9iID0gYWRkKGIsIF9iKVxuICAgIHRoaXMuX2MgPSBhZGQoYywgX2MpXG4gICAgdGhpcy5fZCA9IGFkZChkLCBfZClcbiAgICB0aGlzLl9lID0gYWRkKGUsIF9lKVxuICB9XG5cbiAgU2hhMS5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoUE9PTC5sZW5ndGggPCAxMDApIFBPT0wucHVzaCh0aGlzKVxuICAgIHZhciBIID0gbmV3IEJ1ZmZlcigyMClcbiAgICAvL2NvbnNvbGUubG9nKHRoaXMuX2F8MCwgdGhpcy5fYnwwLCB0aGlzLl9jfDAsIHRoaXMuX2R8MCwgdGhpcy5fZXwwKVxuICAgIEgud3JpdGVJbnQzMkJFKHRoaXMuX2F8MCwgQSlcbiAgICBILndyaXRlSW50MzJCRSh0aGlzLl9ifDAsIEIpXG4gICAgSC53cml0ZUludDMyQkUodGhpcy5fY3wwLCBDKVxuICAgIEgud3JpdGVJbnQzMkJFKHRoaXMuX2R8MCwgRClcbiAgICBILndyaXRlSW50MzJCRSh0aGlzLl9lfDAsIEUpXG4gICAgcmV0dXJuIEhcbiAgfVxuXG4gIC8qXG4gICAqIFBlcmZvcm0gdGhlIGFwcHJvcHJpYXRlIHRyaXBsZXQgY29tYmluYXRpb24gZnVuY3Rpb24gZm9yIHRoZSBjdXJyZW50XG4gICAqIGl0ZXJhdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gc2hhMV9mdCh0LCBiLCBjLCBkKSB7XG4gICAgaWYodCA8IDIwKSByZXR1cm4gKGIgJiBjKSB8ICgofmIpICYgZCk7XG4gICAgaWYodCA8IDQwKSByZXR1cm4gYiBeIGMgXiBkO1xuICAgIGlmKHQgPCA2MCkgcmV0dXJuIChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKTtcbiAgICByZXR1cm4gYiBeIGMgXiBkO1xuICB9XG5cbiAgLypcbiAgICogRGV0ZXJtaW5lIHRoZSBhcHByb3ByaWF0ZSBhZGRpdGl2ZSBjb25zdGFudCBmb3IgdGhlIGN1cnJlbnQgaXRlcmF0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBzaGExX2t0KHQpIHtcbiAgICByZXR1cm4gKHQgPCAyMCkgPyAgMTUxODUwMDI0OSA6ICh0IDwgNDApID8gIDE4NTk3NzUzOTMgOlxuICAgICAgICAgICAodCA8IDYwKSA/IC0xODk0MDA3NTg4IDogLTg5OTQ5NzUxNDtcbiAgfVxuXG4gIC8qXG4gICAqIEFkZCBpbnRlZ2Vycywgd3JhcHBpbmcgYXQgMl4zMi4gVGhpcyB1c2VzIDE2LWJpdCBvcGVyYXRpb25zIGludGVybmFsbHlcbiAgICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cbiAgICogLy9kb21pbmljdGFycjogdGhpcyBpcyAxMCB5ZWFycyBvbGQsIHNvIG1heWJlIHRoaXMgY2FuIGJlIGRyb3BwZWQ/KVxuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gYWRkKHgsIHkpIHtcbiAgICByZXR1cm4gKHggKyB5ICkgfCAwXG4gIC8vbGV0cyBzZWUgaG93IHRoaXMgZ29lcyBvbiB0ZXN0bGluZy5cbiAgLy8gIHZhciBsc3cgPSAoeCAmIDB4RkZGRikgKyAoeSAmIDB4RkZGRik7XG4gIC8vICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIC8vICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKTtcbiAgfVxuXG4gIC8qXG4gICAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAgICovXG4gIGZ1bmN0aW9uIHJvbChudW0sIGNudCkge1xuICAgIHJldHVybiAobnVtIDw8IGNudCkgfCAobnVtID4+PiAoMzIgLSBjbnQpKTtcbiAgfVxuXG4gIHJldHVybiBTaGExXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vc2hhLmpzL3NoYTEuanNcbiAqKi8iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vdXRpbC91dGlsLmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzXG4gKiovIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qc1xuICoqLyIsIlxuLyoqXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTI1NiwgYXMgZGVmaW5lZFxuICogaW4gRklQUyAxODAtMlxuICogVmVyc2lvbiAyLjItYmV0YSBDb3B5cmlnaHQgQW5nZWwgTWFyaW4sIFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDkuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChCdWZmZXIsIEhhc2gpIHtcblxuICB2YXIgSyA9IFtcbiAgICAgIDB4NDI4QTJGOTgsIDB4NzEzNzQ0OTEsIDB4QjVDMEZCQ0YsIDB4RTlCNURCQTUsXG4gICAgICAweDM5NTZDMjVCLCAweDU5RjExMUYxLCAweDkyM0Y4MkE0LCAweEFCMUM1RUQ1LFxuICAgICAgMHhEODA3QUE5OCwgMHgxMjgzNUIwMSwgMHgyNDMxODVCRSwgMHg1NTBDN0RDMyxcbiAgICAgIDB4NzJCRTVENzQsIDB4ODBERUIxRkUsIDB4OUJEQzA2QTcsIDB4QzE5QkYxNzQsXG4gICAgICAweEU0OUI2OUMxLCAweEVGQkU0Nzg2LCAweDBGQzE5REM2LCAweDI0MENBMUNDLFxuICAgICAgMHgyREU5MkM2RiwgMHg0QTc0ODRBQSwgMHg1Q0IwQTlEQywgMHg3NkY5ODhEQSxcbiAgICAgIDB4OTgzRTUxNTIsIDB4QTgzMUM2NkQsIDB4QjAwMzI3QzgsIDB4QkY1OTdGQzcsXG4gICAgICAweEM2RTAwQkYzLCAweEQ1QTc5MTQ3LCAweDA2Q0E2MzUxLCAweDE0MjkyOTY3LFxuICAgICAgMHgyN0I3MEE4NSwgMHgyRTFCMjEzOCwgMHg0RDJDNkRGQywgMHg1MzM4MEQxMyxcbiAgICAgIDB4NjUwQTczNTQsIDB4NzY2QTBBQkIsIDB4ODFDMkM5MkUsIDB4OTI3MjJDODUsXG4gICAgICAweEEyQkZFOEExLCAweEE4MUE2NjRCLCAweEMyNEI4QjcwLCAweEM3NkM1MUEzLFxuICAgICAgMHhEMTkyRTgxOSwgMHhENjk5MDYyNCwgMHhGNDBFMzU4NSwgMHgxMDZBQTA3MCxcbiAgICAgIDB4MTlBNEMxMTYsIDB4MUUzNzZDMDgsIDB4Mjc0ODc3NEMsIDB4MzRCMEJDQjUsXG4gICAgICAweDM5MUMwQ0IzLCAweDRFRDhBQTRBLCAweDVCOUNDQTRGLCAweDY4MkU2RkYzLFxuICAgICAgMHg3NDhGODJFRSwgMHg3OEE1NjM2RiwgMHg4NEM4NzgxNCwgMHg4Q0M3MDIwOCxcbiAgICAgIDB4OTBCRUZGRkEsIDB4QTQ1MDZDRUIsIDB4QkVGOUEzRjcsIDB4QzY3MTc4RjJcbiAgICBdXG5cbiAgdmFyIFcgPSBuZXcgQXJyYXkoNjQpXG5cbiAgZnVuY3Rpb24gU2hhMjU2KCkge1xuICAgIHRoaXMuaW5pdCgpXG5cbiAgICB0aGlzLl93ID0gVyAvL25ldyBBcnJheSg2NClcblxuICAgIEhhc2guY2FsbCh0aGlzLCAxNio0LCAxNCo0KVxuICB9XG5cbiAgaW5oZXJpdHMoU2hhMjU2LCBIYXNoKVxuXG4gIFNoYTI1Ni5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuX2EgPSAweDZhMDllNjY3fDBcbiAgICB0aGlzLl9iID0gMHhiYjY3YWU4NXwwXG4gICAgdGhpcy5fYyA9IDB4M2M2ZWYzNzJ8MFxuICAgIHRoaXMuX2QgPSAweGE1NGZmNTNhfDBcbiAgICB0aGlzLl9lID0gMHg1MTBlNTI3ZnwwXG4gICAgdGhpcy5fZiA9IDB4OWIwNTY4OGN8MFxuICAgIHRoaXMuX2cgPSAweDFmODNkOWFifDBcbiAgICB0aGlzLl9oID0gMHg1YmUwY2QxOXwwXG5cbiAgICB0aGlzLl9sZW4gPSB0aGlzLl9zID0gMFxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGZ1bmN0aW9uIFMgKFgsIG4pIHtcbiAgICByZXR1cm4gKFggPj4+IG4pIHwgKFggPDwgKDMyIC0gbikpO1xuICB9XG5cbiAgZnVuY3Rpb24gUiAoWCwgbikge1xuICAgIHJldHVybiAoWCA+Pj4gbik7XG4gIH1cblxuICBmdW5jdGlvbiBDaCAoeCwgeSwgeikge1xuICAgIHJldHVybiAoKHggJiB5KSBeICgofngpICYgeikpO1xuICB9XG5cbiAgZnVuY3Rpb24gTWFqICh4LCB5LCB6KSB7XG4gICAgcmV0dXJuICgoeCAmIHkpIF4gKHggJiB6KSBeICh5ICYgeikpO1xuICB9XG5cbiAgZnVuY3Rpb24gU2lnbWEwMjU2ICh4KSB7XG4gICAgcmV0dXJuIChTKHgsIDIpIF4gUyh4LCAxMykgXiBTKHgsIDIyKSk7XG4gIH1cblxuICBmdW5jdGlvbiBTaWdtYTEyNTYgKHgpIHtcbiAgICByZXR1cm4gKFMoeCwgNikgXiBTKHgsIDExKSBeIFMoeCwgMjUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEdhbW1hMDI1NiAoeCkge1xuICAgIHJldHVybiAoUyh4LCA3KSBeIFMoeCwgMTgpIF4gUih4LCAzKSk7XG4gIH1cblxuICBmdW5jdGlvbiBHYW1tYTEyNTYgKHgpIHtcbiAgICByZXR1cm4gKFMoeCwgMTcpIF4gUyh4LCAxOSkgXiBSKHgsIDEwKSk7XG4gIH1cblxuICBTaGEyNTYucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbihNKSB7XG5cbiAgICB2YXIgVyA9IHRoaXMuX3dcbiAgICB2YXIgYSwgYiwgYywgZCwgZSwgZiwgZywgaFxuICAgIHZhciBUMSwgVDJcblxuICAgIGEgPSB0aGlzLl9hIHwgMFxuICAgIGIgPSB0aGlzLl9iIHwgMFxuICAgIGMgPSB0aGlzLl9jIHwgMFxuICAgIGQgPSB0aGlzLl9kIHwgMFxuICAgIGUgPSB0aGlzLl9lIHwgMFxuICAgIGYgPSB0aGlzLl9mIHwgMFxuICAgIGcgPSB0aGlzLl9nIHwgMFxuICAgIGggPSB0aGlzLl9oIHwgMFxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCA2NDsgaisrKSB7XG4gICAgICB2YXIgdyA9IFdbal0gPSBqIDwgMTZcbiAgICAgICAgPyBNLnJlYWRJbnQzMkJFKGogKiA0KVxuICAgICAgICA6IEdhbW1hMTI1NihXW2ogLSAyXSkgKyBXW2ogLSA3XSArIEdhbW1hMDI1NihXW2ogLSAxNV0pICsgV1tqIC0gMTZdXG5cbiAgICAgIFQxID0gaCArIFNpZ21hMTI1NihlKSArIENoKGUsIGYsIGcpICsgS1tqXSArIHdcblxuICAgICAgVDIgPSBTaWdtYTAyNTYoYSkgKyBNYWooYSwgYiwgYyk7XG4gICAgICBoID0gZzsgZyA9IGY7IGYgPSBlOyBlID0gZCArIFQxOyBkID0gYzsgYyA9IGI7IGIgPSBhOyBhID0gVDEgKyBUMjtcbiAgICB9XG5cbiAgICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcbiAgICB0aGlzLl9jID0gKGMgKyB0aGlzLl9jKSB8IDBcbiAgICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcbiAgICB0aGlzLl9mID0gKGYgKyB0aGlzLl9mKSB8IDBcbiAgICB0aGlzLl9nID0gKGcgKyB0aGlzLl9nKSB8IDBcbiAgICB0aGlzLl9oID0gKGggKyB0aGlzLl9oKSB8IDBcblxuICB9O1xuXG4gIFNoYTI1Ni5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIEggPSBuZXcgQnVmZmVyKDMyKVxuXG4gICAgSC53cml0ZUludDMyQkUodGhpcy5fYSwgIDApXG4gICAgSC53cml0ZUludDMyQkUodGhpcy5fYiwgIDQpXG4gICAgSC53cml0ZUludDMyQkUodGhpcy5fYywgIDgpXG4gICAgSC53cml0ZUludDMyQkUodGhpcy5fZCwgMTIpXG4gICAgSC53cml0ZUludDMyQkUodGhpcy5fZSwgMTYpXG4gICAgSC53cml0ZUludDMyQkUodGhpcy5fZiwgMjApXG4gICAgSC53cml0ZUludDMyQkUodGhpcy5fZywgMjQpXG4gICAgSC53cml0ZUludDMyQkUodGhpcy5faCwgMjgpXG5cbiAgICByZXR1cm4gSFxuICB9XG5cbiAgcmV0dXJuIFNoYTI1NlxuXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vc2hhLmpzL3NoYTI1Ni5qc1xuICoqLyIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChCdWZmZXIsIEhhc2gpIHtcbiAgdmFyIEsgPSBbXG4gICAgMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiwgMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCxcbiAgICAweGI1YzBmYmNmLCAweGVjNGQzYjJmLCAweGU5YjVkYmE1LCAweDgxODlkYmJjLFxuICAgIDB4Mzk1NmMyNWIsIDB4ZjM0OGI1MzgsIDB4NTlmMTExZjEsIDB4YjYwNWQwMTksXG4gICAgMHg5MjNmODJhNCwgMHhhZjE5NGY5YiwgMHhhYjFjNWVkNSwgMHhkYTZkODExOCxcbiAgICAweGQ4MDdhYTk4LCAweGEzMDMwMjQyLCAweDEyODM1YjAxLCAweDQ1NzA2ZmJlLFxuICAgIDB4MjQzMTg1YmUsIDB4NGVlNGIyOGMsIDB4NTUwYzdkYzMsIDB4ZDVmZmI0ZTIsXG4gICAgMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiwgMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSxcbiAgICAweDliZGMwNmE3LCAweDI1YzcxMjM1LCAweGMxOWJmMTc0LCAweGNmNjkyNjk0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4OWVmMTRhZDIsIDB4ZWZiZTQ3ODYsIDB4Mzg0ZjI1ZTMsXG4gICAgMHgwZmMxOWRjNiwgMHg4YjhjZDViNSwgMHgyNDBjYTFjYywgMHg3N2FjOWM2NSxcbiAgICAweDJkZTkyYzZmLCAweDU5MmIwMjc1LCAweDRhNzQ4NGFhLCAweDZlYTZlNDgzLFxuICAgIDB4NWNiMGE5ZGMsIDB4YmQ0MWZiZDQsIDB4NzZmOTg4ZGEsIDB4ODMxMTUzYjUsXG4gICAgMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiwgMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCxcbiAgICAweGIwMDMyN2M4LCAweDk4ZmIyMTNmLCAweGJmNTk3ZmM3LCAweGJlZWYwZWU0LFxuICAgIDB4YzZlMDBiZjMsIDB4M2RhODhmYzIsIDB4ZDVhNzkxNDcsIDB4OTMwYWE3MjUsXG4gICAgMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiwgMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCxcbiAgICAweDI3YjcwYTg1LCAweDQ2ZDIyZmZjLCAweDJlMWIyMTM4LCAweDVjMjZjOTI2LFxuICAgIDB4NGQyYzZkZmMsIDB4NWFjNDJhZWQsIDB4NTMzODBkMTMsIDB4OWQ5NWIzZGYsXG4gICAgMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSwgMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCxcbiAgICAweDgxYzJjOTJlLCAweDQ3ZWRhZWU2LCAweDkyNzIyYzg1LCAweDE0ODIzNTNiLFxuICAgIDB4YTJiZmU4YTEsIDB4NGNmMTAzNjQsIDB4YTgxYTY2NGIsIDB4YmM0MjMwMDEsXG4gICAgMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSwgMHhjNzZjNTFhMywgMHgwNjU0YmUzMCxcbiAgICAweGQxOTJlODE5LCAweGQ2ZWY1MjE4LCAweGQ2OTkwNjI0LCAweDU1NjVhOTEwLFxuICAgIDB4ZjQwZTM1ODUsIDB4NTc3MTIwMmEsIDB4MTA2YWEwNzAsIDB4MzJiYmQxYjgsXG4gICAgMHgxOWE0YzExNiwgMHhiOGQyZDBjOCwgMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyxcbiAgICAweDI3NDg3NzRjLCAweGRmOGVlYjk5LCAweDM0YjBiY2I1LCAweGUxOWI0OGE4LFxuICAgIDB4MzkxYzBjYjMsIDB4YzVjOTVhNjMsIDB4NGVkOGFhNGEsIDB4ZTM0MThhY2IsXG4gICAgMHg1YjljY2E0ZiwgMHg3NzYzZTM3MywgMHg2ODJlNmZmMywgMHhkNmIyYjhhMyxcbiAgICAweDc0OGY4MmVlLCAweDVkZWZiMmZjLCAweDc4YTU2MzZmLCAweDQzMTcyZjYwLFxuICAgIDB4ODRjODc4MTQsIDB4YTFmMGFiNzIsIDB4OGNjNzAyMDgsIDB4MWE2NDM5ZWMsXG4gICAgMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCwgMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSxcbiAgICAweGJlZjlhM2Y3LCAweGIyYzY3OTE1LCAweGM2NzE3OGYyLCAweGUzNzI1MzJiLFxuICAgIDB4Y2EyNzNlY2UsIDB4ZWEyNjYxOWMsIDB4ZDE4NmI4YzcsIDB4MjFjMGMyMDcsXG4gICAgMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSwgMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCxcbiAgICAweDA2ZjA2N2FhLCAweDcyMTc2ZmJhLCAweDBhNjM3ZGM1LCAweGEyYzg5OGE2LFxuICAgIDB4MTEzZjk4MDQsIDB4YmVmOTBkYWUsIDB4MWI3MTBiMzUsIDB4MTMxYzQ3MWIsXG4gICAgMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCwgMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyxcbiAgICAweDNjOWViZTBhLCAweDE1YzliZWJjLCAweDQzMWQ2N2M0LCAweDljMTAwZDRjLFxuICAgIDB4NGNjNWQ0YmUsIDB4Y2IzZTQyYjYsIDB4NTk3ZjI5OWMsIDB4ZmM2NTdlMmEsXG4gICAgMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYywgMHg2YzQ0MTk4YywgMHg0YTQ3NTgxN1xuICBdXG5cbiAgdmFyIFcgPSBuZXcgQXJyYXkoMTYwKVxuXG4gIGZ1bmN0aW9uIFNoYTUxMigpIHtcbiAgICB0aGlzLmluaXQoKVxuICAgIHRoaXMuX3cgPSBXXG5cbiAgICBIYXNoLmNhbGwodGhpcywgMTI4LCAxMTIpXG4gIH1cblxuICBpbmhlcml0cyhTaGE1MTIsIEhhc2gpXG5cbiAgU2hhNTEyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5fYSA9IDB4NmEwOWU2Njd8MFxuICAgIHRoaXMuX2IgPSAweGJiNjdhZTg1fDBcbiAgICB0aGlzLl9jID0gMHgzYzZlZjM3MnwwXG4gICAgdGhpcy5fZCA9IDB4YTU0ZmY1M2F8MFxuICAgIHRoaXMuX2UgPSAweDUxMGU1MjdmfDBcbiAgICB0aGlzLl9mID0gMHg5YjA1Njg4Y3wwXG4gICAgdGhpcy5fZyA9IDB4MWY4M2Q5YWJ8MFxuICAgIHRoaXMuX2ggPSAweDViZTBjZDE5fDBcblxuICAgIHRoaXMuX2FsID0gMHhmM2JjYzkwOHwwXG4gICAgdGhpcy5fYmwgPSAweDg0Y2FhNzNifDBcbiAgICB0aGlzLl9jbCA9IDB4ZmU5NGY4MmJ8MFxuICAgIHRoaXMuX2RsID0gMHg1ZjFkMzZmMXwwXG4gICAgdGhpcy5fZWwgPSAweGFkZTY4MmQxfDBcbiAgICB0aGlzLl9mbCA9IDB4MmIzZTZjMWZ8MFxuICAgIHRoaXMuX2dsID0gMHhmYjQxYmQ2YnwwXG4gICAgdGhpcy5faGwgPSAweDEzN2UyMTc5fDBcblxuICAgIHRoaXMuX2xlbiA9IHRoaXMuX3MgPSAwXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZnVuY3Rpb24gUyAoWCwgWGwsIG4pIHtcbiAgICByZXR1cm4gKFggPj4+IG4pIHwgKFhsIDw8ICgzMiAtIG4pKVxuICB9XG5cbiAgZnVuY3Rpb24gQ2ggKHgsIHksIHopIHtcbiAgICByZXR1cm4gKCh4ICYgeSkgXiAoKH54KSAmIHopKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIE1haiAoeCwgeSwgeikge1xuICAgIHJldHVybiAoKHggJiB5KSBeICh4ICYgeikgXiAoeSAmIHopKTtcbiAgfVxuXG4gIFNoYTUxMi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uKE0pIHtcblxuICAgIHZhciBXID0gdGhpcy5fd1xuICAgIHZhciBhLCBiLCBjLCBkLCBlLCBmLCBnLCBoXG4gICAgdmFyIGFsLCBibCwgY2wsIGRsLCBlbCwgZmwsIGdsLCBobFxuXG4gICAgYSA9IHRoaXMuX2EgfCAwXG4gICAgYiA9IHRoaXMuX2IgfCAwXG4gICAgYyA9IHRoaXMuX2MgfCAwXG4gICAgZCA9IHRoaXMuX2QgfCAwXG4gICAgZSA9IHRoaXMuX2UgfCAwXG4gICAgZiA9IHRoaXMuX2YgfCAwXG4gICAgZyA9IHRoaXMuX2cgfCAwXG4gICAgaCA9IHRoaXMuX2ggfCAwXG5cbiAgICBhbCA9IHRoaXMuX2FsIHwgMFxuICAgIGJsID0gdGhpcy5fYmwgfCAwXG4gICAgY2wgPSB0aGlzLl9jbCB8IDBcbiAgICBkbCA9IHRoaXMuX2RsIHwgMFxuICAgIGVsID0gdGhpcy5fZWwgfCAwXG4gICAgZmwgPSB0aGlzLl9mbCB8IDBcbiAgICBnbCA9IHRoaXMuX2dsIHwgMFxuICAgIGhsID0gdGhpcy5faGwgfCAwXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgIHZhciBqID0gaSAqIDJcblxuICAgICAgdmFyIFdpLCBXaWxcblxuICAgICAgaWYgKGkgPCAxNikge1xuICAgICAgICBXaSA9IFdbal0gPSBNLnJlYWRJbnQzMkJFKGogKiA0KVxuICAgICAgICBXaWwgPSBXW2ogKyAxXSA9IE0ucmVhZEludDMyQkUoaiAqIDQgKyA0KVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgeCAgPSBXW2ogLSAxNSoyXVxuICAgICAgICB2YXIgeGwgPSBXW2ogLSAxNSoyICsgMV1cbiAgICAgICAgdmFyIGdhbW1hMCAgPSBTKHgsIHhsLCAxKSBeIFMoeCwgeGwsIDgpIF4gKHggPj4+IDcpXG4gICAgICAgIHZhciBnYW1tYTBsID0gUyh4bCwgeCwgMSkgXiBTKHhsLCB4LCA4KSBeIFMoeGwsIHgsIDcpXG5cbiAgICAgICAgeCAgPSBXW2ogLSAyKjJdXG4gICAgICAgIHhsID0gV1tqIC0gMioyICsgMV1cbiAgICAgICAgdmFyIGdhbW1hMSAgPSBTKHgsIHhsLCAxOSkgXiBTKHhsLCB4LCAyOSkgXiAoeCA+Pj4gNilcbiAgICAgICAgdmFyIGdhbW1hMWwgPSBTKHhsLCB4LCAxOSkgXiBTKHgsIHhsLCAyOSkgXiBTKHhsLCB4LCA2KVxuXG4gICAgICAgIC8vIFdbaV0gPSBnYW1tYTAgKyBXW2kgLSA3XSArIGdhbW1hMSArIFdbaSAtIDE2XVxuICAgICAgICB2YXIgV2k3ICA9IFdbaiAtIDcqMl1cbiAgICAgICAgdmFyIFdpN2wgPSBXW2ogLSA3KjIgKyAxXVxuXG4gICAgICAgIHZhciBXaTE2ICA9IFdbaiAtIDE2KjJdXG4gICAgICAgIHZhciBXaTE2bCA9IFdbaiAtIDE2KjIgKyAxXVxuXG4gICAgICAgIFdpbCA9IGdhbW1hMGwgKyBXaTdsXG4gICAgICAgIFdpICA9IGdhbW1hMCAgKyBXaTcgKyAoKFdpbCA+Pj4gMCkgPCAoZ2FtbWEwbCA+Pj4gMCkgPyAxIDogMClcbiAgICAgICAgV2lsID0gV2lsICsgZ2FtbWExbFxuICAgICAgICBXaSAgPSBXaSAgKyBnYW1tYTEgICsgKChXaWwgPj4+IDApIDwgKGdhbW1hMWwgPj4+IDApID8gMSA6IDApXG4gICAgICAgIFdpbCA9IFdpbCArIFdpMTZsXG4gICAgICAgIFdpICA9IFdpICArIFdpMTYgKyAoKFdpbCA+Pj4gMCkgPCAoV2kxNmwgPj4+IDApID8gMSA6IDApXG5cbiAgICAgICAgV1tqXSA9IFdpXG4gICAgICAgIFdbaiArIDFdID0gV2lsXG4gICAgICB9XG5cbiAgICAgIHZhciBtYWogPSBNYWooYSwgYiwgYylcbiAgICAgIHZhciBtYWpsID0gTWFqKGFsLCBibCwgY2wpXG5cbiAgICAgIHZhciBzaWdtYTBoID0gUyhhLCBhbCwgMjgpIF4gUyhhbCwgYSwgMikgXiBTKGFsLCBhLCA3KVxuICAgICAgdmFyIHNpZ21hMGwgPSBTKGFsLCBhLCAyOCkgXiBTKGEsIGFsLCAyKSBeIFMoYSwgYWwsIDcpXG4gICAgICB2YXIgc2lnbWExaCA9IFMoZSwgZWwsIDE0KSBeIFMoZSwgZWwsIDE4KSBeIFMoZWwsIGUsIDkpXG4gICAgICB2YXIgc2lnbWExbCA9IFMoZWwsIGUsIDE0KSBeIFMoZWwsIGUsIDE4KSBeIFMoZSwgZWwsIDkpXG5cbiAgICAgIC8vIHQxID0gaCArIHNpZ21hMSArIGNoICsgS1tpXSArIFdbaV1cbiAgICAgIHZhciBLaSA9IEtbal1cbiAgICAgIHZhciBLaWwgPSBLW2ogKyAxXVxuXG4gICAgICB2YXIgY2ggPSBDaChlLCBmLCBnKVxuICAgICAgdmFyIGNobCA9IENoKGVsLCBmbCwgZ2wpXG5cbiAgICAgIHZhciB0MWwgPSBobCArIHNpZ21hMWxcbiAgICAgIHZhciB0MSA9IGggKyBzaWdtYTFoICsgKCh0MWwgPj4+IDApIDwgKGhsID4+PiAwKSA/IDEgOiAwKVxuICAgICAgdDFsID0gdDFsICsgY2hsXG4gICAgICB0MSA9IHQxICsgY2ggKyAoKHQxbCA+Pj4gMCkgPCAoY2hsID4+PiAwKSA/IDEgOiAwKVxuICAgICAgdDFsID0gdDFsICsgS2lsXG4gICAgICB0MSA9IHQxICsgS2kgKyAoKHQxbCA+Pj4gMCkgPCAoS2lsID4+PiAwKSA/IDEgOiAwKVxuICAgICAgdDFsID0gdDFsICsgV2lsXG4gICAgICB0MSA9IHQxICsgV2kgKyAoKHQxbCA+Pj4gMCkgPCAoV2lsID4+PiAwKSA/IDEgOiAwKVxuXG4gICAgICAvLyB0MiA9IHNpZ21hMCArIG1halxuICAgICAgdmFyIHQybCA9IHNpZ21hMGwgKyBtYWpsXG4gICAgICB2YXIgdDIgPSBzaWdtYTBoICsgbWFqICsgKCh0MmwgPj4+IDApIDwgKHNpZ21hMGwgPj4+IDApID8gMSA6IDApXG5cbiAgICAgIGggID0gZ1xuICAgICAgaGwgPSBnbFxuICAgICAgZyAgPSBmXG4gICAgICBnbCA9IGZsXG4gICAgICBmICA9IGVcbiAgICAgIGZsID0gZWxcbiAgICAgIGVsID0gKGRsICsgdDFsKSB8IDBcbiAgICAgIGUgID0gKGQgKyB0MSArICgoZWwgPj4+IDApIDwgKGRsID4+PiAwKSA/IDEgOiAwKSkgfCAwXG4gICAgICBkICA9IGNcbiAgICAgIGRsID0gY2xcbiAgICAgIGMgID0gYlxuICAgICAgY2wgPSBibFxuICAgICAgYiAgPSBhXG4gICAgICBibCA9IGFsXG4gICAgICBhbCA9ICh0MWwgKyB0MmwpIHwgMFxuICAgICAgYSAgPSAodDEgKyB0MiArICgoYWwgPj4+IDApIDwgKHQxbCA+Pj4gMCkgPyAxIDogMCkpIHwgMFxuICAgIH1cblxuICAgIHRoaXMuX2FsID0gKHRoaXMuX2FsICsgYWwpIHwgMFxuICAgIHRoaXMuX2JsID0gKHRoaXMuX2JsICsgYmwpIHwgMFxuICAgIHRoaXMuX2NsID0gKHRoaXMuX2NsICsgY2wpIHwgMFxuICAgIHRoaXMuX2RsID0gKHRoaXMuX2RsICsgZGwpIHwgMFxuICAgIHRoaXMuX2VsID0gKHRoaXMuX2VsICsgZWwpIHwgMFxuICAgIHRoaXMuX2ZsID0gKHRoaXMuX2ZsICsgZmwpIHwgMFxuICAgIHRoaXMuX2dsID0gKHRoaXMuX2dsICsgZ2wpIHwgMFxuICAgIHRoaXMuX2hsID0gKHRoaXMuX2hsICsgaGwpIHwgMFxuXG4gICAgdGhpcy5fYSA9ICh0aGlzLl9hICsgYSArICgodGhpcy5fYWwgPj4+IDApIDwgKGFsID4+PiAwKSA/IDEgOiAwKSkgfCAwXG4gICAgdGhpcy5fYiA9ICh0aGlzLl9iICsgYiArICgodGhpcy5fYmwgPj4+IDApIDwgKGJsID4+PiAwKSA/IDEgOiAwKSkgfCAwXG4gICAgdGhpcy5fYyA9ICh0aGlzLl9jICsgYyArICgodGhpcy5fY2wgPj4+IDApIDwgKGNsID4+PiAwKSA/IDEgOiAwKSkgfCAwXG4gICAgdGhpcy5fZCA9ICh0aGlzLl9kICsgZCArICgodGhpcy5fZGwgPj4+IDApIDwgKGRsID4+PiAwKSA/IDEgOiAwKSkgfCAwXG4gICAgdGhpcy5fZSA9ICh0aGlzLl9lICsgZSArICgodGhpcy5fZWwgPj4+IDApIDwgKGVsID4+PiAwKSA/IDEgOiAwKSkgfCAwXG4gICAgdGhpcy5fZiA9ICh0aGlzLl9mICsgZiArICgodGhpcy5fZmwgPj4+IDApIDwgKGZsID4+PiAwKSA/IDEgOiAwKSkgfCAwXG4gICAgdGhpcy5fZyA9ICh0aGlzLl9nICsgZyArICgodGhpcy5fZ2wgPj4+IDApIDwgKGdsID4+PiAwKSA/IDEgOiAwKSkgfCAwXG4gICAgdGhpcy5faCA9ICh0aGlzLl9oICsgaCArICgodGhpcy5faGwgPj4+IDApIDwgKGhsID4+PiAwKSA/IDEgOiAwKSkgfCAwXG4gIH1cblxuICBTaGE1MTIucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBIID0gbmV3IEJ1ZmZlcig2NClcblxuICAgIGZ1bmN0aW9uIHdyaXRlSW50NjRCRShoLCBsLCBvZmZzZXQpIHtcbiAgICAgIEgud3JpdGVJbnQzMkJFKGgsIG9mZnNldClcbiAgICAgIEgud3JpdGVJbnQzMkJFKGwsIG9mZnNldCArIDQpXG4gICAgfVxuXG4gICAgd3JpdGVJbnQ2NEJFKHRoaXMuX2EsIHRoaXMuX2FsLCAwKVxuICAgIHdyaXRlSW50NjRCRSh0aGlzLl9iLCB0aGlzLl9ibCwgOClcbiAgICB3cml0ZUludDY0QkUodGhpcy5fYywgdGhpcy5fY2wsIDE2KVxuICAgIHdyaXRlSW50NjRCRSh0aGlzLl9kLCB0aGlzLl9kbCwgMjQpXG4gICAgd3JpdGVJbnQ2NEJFKHRoaXMuX2UsIHRoaXMuX2VsLCAzMilcbiAgICB3cml0ZUludDY0QkUodGhpcy5fZiwgdGhpcy5fZmwsIDQwKVxuICAgIHdyaXRlSW50NjRCRSh0aGlzLl9nLCB0aGlzLl9nbCwgNDgpXG4gICAgd3JpdGVJbnQ2NEJFKHRoaXMuX2gsIHRoaXMuX2hsLCA1NilcblxuICAgIHJldHVybiBIXG4gIH1cblxuICByZXR1cm4gU2hhNTEyXG5cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9zaGEuanMvc2hhNTEyLmpzXG4gKiovIiwiLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUlNBIERhdGEgU2VjdXJpdHksIEluYy4gTUQ1IE1lc3NhZ2VcbiAqIERpZ2VzdCBBbGdvcml0aG0sIGFzIGRlZmluZWQgaW4gUkZDIDEzMjEuXG4gKiBWZXJzaW9uIDIuMSBDb3B5cmlnaHQgKEMpIFBhdWwgSm9obnN0b24gMTk5OSAtIDIwMDIuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBtb3JlIGluZm8uXG4gKi9cblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcblxuLypcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gY29yZV9tZDUoeCwgbGVuKVxue1xuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8ICgobGVuKSAlIDMyKTtcbiAgeFsoKChsZW4gKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gbGVuO1xuXG4gIHZhciBhID0gIDE3MzI1ODQxOTM7XG4gIHZhciBiID0gLTI3MTczMzg3OTtcbiAgdmFyIGMgPSAtMTczMjU4NDE5NDtcbiAgdmFyIGQgPSAgMjcxNzMzODc4O1xuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNilcbiAge1xuICAgIHZhciBvbGRhID0gYTtcbiAgICB2YXIgb2xkYiA9IGI7XG4gICAgdmFyIG9sZGMgPSBjO1xuICAgIHZhciBvbGRkID0gZDtcblxuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyAwXSwgNyAsIC02ODA4NzY5MzYpO1xuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKyAyXSwgMTcsICA2MDYxMDU4MTkpO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKyAzXSwgMjIsIC0xMDQ0NTI1MzMwKTtcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgNF0sIDcgLCAtMTc2NDE4ODk3KTtcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsgNV0sIDEyLCAgMTIwMDA4MDQyNik7XG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKyA3XSwgMjIsIC00NTcwNTk4Myk7XG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDhdLCA3ICwgIDE3NzAwMzU0MTYpO1xuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyA5XSwgMTIsIC0xOTU4NDE0NDE3KTtcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsxMF0sIDE3LCAtNDIwNjMpO1xuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKzExXSwgMjIsIC0xOTkwNDA0MTYyKTtcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsxMl0sIDcgLCAgMTgwNDYwMzY4Mik7XG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krMTNdLCAxMiwgLTQwMzQxMTAxKTtcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsxNF0sIDE3LCAtMTUwMjAwMjI5MCk7XG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krMTVdLCAyMiwgIDEyMzY1MzUzMjkpO1xuXG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDFdLCA1ICwgLTE2NTc5NjUxMCk7XG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krIDZdLCA5ICwgLTEwNjk1MDE2MzIpO1xuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKzExXSwgMTQsICA2NDM3MTc3MTMpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyAwXSwgMjAsIC0zNzM4OTczMDIpO1xuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyA1XSwgNSAsIC03MDE1NTg2OTEpO1xuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKzEwXSwgOSAsICAzODAxNjA4Myk7XG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krMTVdLCAxNCwgLTY2MDQ3ODMzNSk7XG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krIDRdLCAyMCwgLTQwNTUzNzg0OCk7XG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDldLCA1ICwgIDU2ODQ0NjQzOCk7XG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krMTRdLCA5ICwgLTEwMTk4MDM2OTApO1xuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKyAzXSwgMTQsIC0xODczNjM5NjEpO1xuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKyA4XSwgMjAsICAxMTYzNTMxNTAxKTtcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsxM10sIDUgLCAtMTQ0NDY4MTQ2Nyk7XG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krIDJdLCA5ICwgLTUxNDAzNzg0KTtcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsgN10sIDE0LCAgMTczNTMyODQ3Myk7XG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xuXG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDVdLCA0ICwgLTM3ODU1OCk7XG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKzExXSwgMTYsICAxODM5MDMwNTYyKTtcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsxNF0sIDIzLCAtMzUzMDk1NTYpO1xuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKyAxXSwgNCAsIC0xNTMwOTkyMDYwKTtcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgNF0sIDExLCAgMTI3Mjg5MzM1Myk7XG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krIDddLCAxNiwgLTE1NTQ5NzYzMik7XG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKzEzXSwgNCAsICA2ODEyNzkxNzQpO1xuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyAwXSwgMTEsIC0zNTg1MzcyMjIpO1xuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKyAzXSwgMTYsIC03MjI1MjE5NzkpO1xuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKyA2XSwgMjMsICA3NjAyOTE4OSk7XG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDldLCA0ICwgLTY0MDM2NDQ4Nyk7XG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krMTJdLCAxMSwgLTQyMTgxNTgzNSk7XG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krMTVdLCAxNiwgIDUzMDc0MjUyMCk7XG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krIDJdLCAyMywgLTk5NTMzODY1MSk7XG5cbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgMF0sIDYgLCAtMTk4NjMwODQ0KTtcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsgN10sIDEwLCAgMTEyNjg5MTQxNSk7XG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krMTRdLCAxNSwgLTE0MTYzNTQ5MDUpO1xuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyA1XSwgMjEsIC01NzQzNDA1NSk7XG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krMTJdLCA2ICwgIDE3MDA0ODU1NzEpO1xuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKyAzXSwgMTAsIC0xODk0OTg2NjA2KTtcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsxMF0sIDE1LCAtMTA1MTUyMyk7XG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDFdLCAyMSwgLTIwNTQ5MjI3OTkpO1xuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyA4XSwgNiAsICAxODczMzEzMzU5KTtcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsxNV0sIDEwLCAtMzA2MTE3NDQpO1xuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKyA2XSwgMTUsIC0xNTYwMTk4MzgwKTtcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsxM10sIDIxLCAgMTMwOTE1MTY0OSk7XG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDRdLCA2ICwgLTE0NTUyMzA3MCk7XG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krMTFdLCAxMCwgLTExMjAyMTAzNzkpO1xuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKyAyXSwgMTUsICA3MTg3ODcyNTkpO1xuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xuXG4gICAgYSA9IHNhZmVfYWRkKGEsIG9sZGEpO1xuICAgIGIgPSBzYWZlX2FkZChiLCBvbGRiKTtcbiAgICBjID0gc2FmZV9hZGQoYywgb2xkYyk7XG4gICAgZCA9IHNhZmVfYWRkKGQsIG9sZGQpO1xuICB9XG4gIHJldHVybiBBcnJheShhLCBiLCBjLCBkKTtcblxufVxuXG4vKlxuICogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCB0aGUgZm91ciBiYXNpYyBvcGVyYXRpb25zIHRoZSBhbGdvcml0aG0gdXNlcy5cbiAqL1xuZnVuY3Rpb24gbWQ1X2NtbihxLCBhLCBiLCB4LCBzLCB0KVxue1xuICByZXR1cm4gc2FmZV9hZGQoYml0X3JvbChzYWZlX2FkZChzYWZlX2FkZChhLCBxKSwgc2FmZV9hZGQoeCwgdCkpLCBzKSxiKTtcbn1cbmZ1bmN0aW9uIG1kNV9mZihhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICByZXR1cm4gbWQ1X2NtbigoYiAmIGMpIHwgKCh+YikgJiBkKSwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVfZ2coYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oKGIgJiBkKSB8IChjICYgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xufVxuZnVuY3Rpb24gbWQ1X2hoKGEsIGIsIGMsIGQsIHgsIHMsIHQpXG57XG4gIHJldHVybiBtZDVfY21uKGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVfaWkoYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oYyBeIChiIHwgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xufVxuXG4vKlxuICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxuICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cbiAqL1xuZnVuY3Rpb24gc2FmZV9hZGQoeCwgeSlcbntcbiAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKTtcbiAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKTtcbn1cblxuLypcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAqL1xuZnVuY3Rpb24gYml0X3JvbChudW0sIGNudClcbntcbiAgcmV0dXJuIChudW0gPDwgY250KSB8IChudW0gPj4+ICgzMiAtIGNudCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1kNShidWYpIHtcbiAgcmV0dXJuIGhlbHBlcnMuaGFzaChidWYsIGNvcmVfbWQ1LCAxNik7XG59O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2NyeXB0by1icm93c2VyaWZ5L21kNS5qc1xuICoqLyIsInZhciBpbnRTaXplID0gNDtcbnZhciB6ZXJvQnVmZmVyID0gbmV3IEJ1ZmZlcihpbnRTaXplKTsgemVyb0J1ZmZlci5maWxsKDApO1xudmFyIGNocnN6ID0gODtcblxuZnVuY3Rpb24gdG9BcnJheShidWYsIGJpZ0VuZGlhbikge1xuICBpZiAoKGJ1Zi5sZW5ndGggJSBpbnRTaXplKSAhPT0gMCkge1xuICAgIHZhciBsZW4gPSBidWYubGVuZ3RoICsgKGludFNpemUgLSAoYnVmLmxlbmd0aCAlIGludFNpemUpKTtcbiAgICBidWYgPSBCdWZmZXIuY29uY2F0KFtidWYsIHplcm9CdWZmZXJdLCBsZW4pO1xuICB9XG5cbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgZm4gPSBiaWdFbmRpYW4gPyBidWYucmVhZEludDMyQkUgOiBidWYucmVhZEludDMyTEU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSArPSBpbnRTaXplKSB7XG4gICAgYXJyLnB1c2goZm4uY2FsbChidWYsIGkpKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiB0b0J1ZmZlcihhcnIsIHNpemUsIGJpZ0VuZGlhbikge1xuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzaXplKTtcbiAgdmFyIGZuID0gYmlnRW5kaWFuID8gYnVmLndyaXRlSW50MzJCRSA6IGJ1Zi53cml0ZUludDMyTEU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4uY2FsbChidWYsIGFycltpXSwgaSAqIDQsIHRydWUpO1xuICB9XG4gIHJldHVybiBidWY7XG59XG5cbmZ1bmN0aW9uIGhhc2goYnVmLCBmbiwgaGFzaFNpemUsIGJpZ0VuZGlhbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSBidWYgPSBuZXcgQnVmZmVyKGJ1Zik7XG4gIHZhciBhcnIgPSBmbih0b0FycmF5KGJ1ZiwgYmlnRW5kaWFuKSwgYnVmLmxlbmd0aCAqIGNocnN6KTtcbiAgcmV0dXJuIHRvQnVmZmVyKGFyciwgaGFzaFNpemUsIGJpZ0VuZGlhbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBoYXNoOiBoYXNoIH07XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vY3J5cHRvLWJyb3dzZXJpZnkvaGVscGVycy5qc1xuICoqLyIsIlxubW9kdWxlLmV4cG9ydHMgPSByaXBlbWQxNjBcblxuXG5cbi8qXG5DcnlwdG9KUyB2My4xLjJcbmNvZGUuZ29vZ2xlLmNvbS9wL2NyeXB0by1qc1xuKGMpIDIwMDktMjAxMyBieSBKZWZmIE1vdHQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvd2lraS9MaWNlbnNlXG4qL1xuLyoqIEBwcmVzZXJ2ZVxuKGMpIDIwMTIgYnkgQ8OpZHJpYyBNZXNuaWwuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgIC0gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG4vLyBDb25zdGFudHMgdGFibGVcbnZhciB6bCA9IFtcbiAgICAwLCAgMSwgIDIsICAzLCAgNCwgIDUsICA2LCAgNywgIDgsICA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICAgIDcsICA0LCAxMywgIDEsIDEwLCAgNiwgMTUsICAzLCAxMiwgIDAsICA5LCAgNSwgIDIsIDE0LCAxMSwgIDgsXG4gICAgMywgMTAsIDE0LCAgNCwgIDksIDE1LCAgOCwgIDEsICAyLCAgNywgIDAsICA2LCAxMywgMTEsICA1LCAxMixcbiAgICAxLCAgOSwgMTEsIDEwLCAgMCwgIDgsIDEyLCAgNCwgMTMsICAzLCAgNywgMTUsIDE0LCAgNSwgIDYsICAyLFxuICAgIDQsICAwLCAgNSwgIDksICA3LCAxMiwgIDIsIDEwLCAxNCwgIDEsICAzLCAgOCwgMTEsICA2LCAxNSwgMTNdO1xudmFyIHpyID0gW1xuICAgIDUsIDE0LCAgNywgIDAsICA5LCAgMiwgMTEsICA0LCAxMywgIDYsIDE1LCAgOCwgIDEsIDEwLCAgMywgMTIsXG4gICAgNiwgMTEsICAzLCAgNywgIDAsIDEzLCAgNSwgMTAsIDE0LCAxNSwgIDgsIDEyLCAgNCwgIDksICAxLCAgMixcbiAgICAxNSwgIDUsICAxLCAgMywgIDcsIDE0LCAgNiwgIDksIDExLCAgOCwgMTIsICAyLCAxMCwgIDAsICA0LCAxMyxcbiAgICA4LCAgNiwgIDQsICAxLCAgMywgMTEsIDE1LCAgMCwgIDUsIDEyLCAgMiwgMTMsICA5LCAgNywgMTAsIDE0LFxuICAgIDEyLCAxNSwgMTAsICA0LCAgMSwgIDUsICA4LCAgNywgIDYsICAyLCAxMywgMTQsICAwLCAgMywgIDksIDExXTtcbnZhciBzbCA9IFtcbiAgICAgMTEsIDE0LCAxNSwgMTIsICA1LCAgOCwgIDcsICA5LCAxMSwgMTMsIDE0LCAxNSwgIDYsICA3LCAgOSwgIDgsXG4gICAgNywgNiwgICA4LCAxMywgMTEsICA5LCAgNywgMTUsICA3LCAxMiwgMTUsICA5LCAxMSwgIDcsIDEzLCAxMixcbiAgICAxMSwgMTMsICA2LCAgNywgMTQsICA5LCAxMywgMTUsIDE0LCAgOCwgMTMsICA2LCAgNSwgMTIsICA3LCAgNSxcbiAgICAgIDExLCAxMiwgMTQsIDE1LCAxNCwgMTUsICA5LCAgOCwgIDksIDE0LCAgNSwgIDYsICA4LCAgNiwgIDUsIDEyLFxuICAgIDksIDE1LCAgNSwgMTEsICA2LCAgOCwgMTMsIDEyLCAgNSwgMTIsIDEzLCAxNCwgMTEsICA4LCAgNSwgIDYgXTtcbnZhciBzciA9IFtcbiAgICA4LCAgOSwgIDksIDExLCAxMywgMTUsIDE1LCAgNSwgIDcsICA3LCAgOCwgMTEsIDE0LCAxNCwgMTIsICA2LFxuICAgIDksIDEzLCAxNSwgIDcsIDEyLCAgOCwgIDksIDExLCAgNywgIDcsIDEyLCAgNywgIDYsIDE1LCAxMywgMTEsXG4gICAgOSwgIDcsIDE1LCAxMSwgIDgsICA2LCAgNiwgMTQsIDEyLCAxMywgIDUsIDE0LCAxMywgMTMsICA3LCAgNSxcbiAgICAxNSwgIDUsICA4LCAxMSwgMTQsIDE0LCAgNiwgMTQsICA2LCAgOSwgMTIsICA5LCAxMiwgIDUsIDE1LCAgOCxcbiAgICA4LCAgNSwgMTIsICA5LCAxMiwgIDUsIDE0LCAgNiwgIDgsIDEzLCAgNiwgIDUsIDE1LCAxMywgMTEsIDExIF07XG5cbnZhciBobCA9ICBbIDB4MDAwMDAwMDAsIDB4NUE4Mjc5OTksIDB4NkVEOUVCQTEsIDB4OEYxQkJDREMsIDB4QTk1M0ZENEVdO1xudmFyIGhyID0gIFsgMHg1MEEyOEJFNiwgMHg1QzRERDEyNCwgMHg2RDcwM0VGMywgMHg3QTZENzZFOSwgMHgwMDAwMDAwMF07XG5cbnZhciBieXRlc1RvV29yZHMgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgdmFyIHdvcmRzID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBiID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrLCBiICs9IDgpIHtcbiAgICB3b3Jkc1tiID4+PiA1XSB8PSBieXRlc1tpXSA8PCAoMjQgLSBiICUgMzIpO1xuICB9XG4gIHJldHVybiB3b3Jkcztcbn07XG5cbnZhciB3b3Jkc1RvQnl0ZXMgPSBmdW5jdGlvbiAod29yZHMpIHtcbiAgdmFyIGJ5dGVzID0gW107XG4gIGZvciAodmFyIGIgPSAwOyBiIDwgd29yZHMubGVuZ3RoICogMzI7IGIgKz0gOCkge1xuICAgIGJ5dGVzLnB1c2goKHdvcmRzW2IgPj4+IDVdID4+PiAoMjQgLSBiICUgMzIpKSAmIDB4RkYpO1xuICB9XG4gIHJldHVybiBieXRlcztcbn07XG5cbnZhciBwcm9jZXNzQmxvY2sgPSBmdW5jdGlvbiAoSCwgTSwgb2Zmc2V0KSB7XG5cbiAgLy8gU3dhcCBlbmRpYW5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgdmFyIG9mZnNldF9pID0gb2Zmc2V0ICsgaTtcbiAgICB2YXIgTV9vZmZzZXRfaSA9IE1bb2Zmc2V0X2ldO1xuXG4gICAgLy8gU3dhcFxuICAgIE1bb2Zmc2V0X2ldID0gKFxuICAgICAgICAoKChNX29mZnNldF9pIDw8IDgpICB8IChNX29mZnNldF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuICAgICAgICAoKChNX29mZnNldF9pIDw8IDI0KSB8IChNX29mZnNldF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMClcbiAgICApO1xuICB9XG5cbiAgLy8gV29ya2luZyB2YXJpYWJsZXNcbiAgdmFyIGFsLCBibCwgY2wsIGRsLCBlbDtcbiAgdmFyIGFyLCBiciwgY3IsIGRyLCBlcjtcblxuICBhciA9IGFsID0gSFswXTtcbiAgYnIgPSBibCA9IEhbMV07XG4gIGNyID0gY2wgPSBIWzJdO1xuICBkciA9IGRsID0gSFszXTtcbiAgZXIgPSBlbCA9IEhbNF07XG4gIC8vIENvbXB1dGF0aW9uXG4gIHZhciB0O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDgwOyBpICs9IDEpIHtcbiAgICB0ID0gKGFsICsgIE1bb2Zmc2V0K3psW2ldXSl8MDtcbiAgICBpZiAoaTwxNil7XG4gICAgICAgIHQgKz0gIGYxKGJsLGNsLGRsKSArIGhsWzBdO1xuICAgIH0gZWxzZSBpZiAoaTwzMikge1xuICAgICAgICB0ICs9ICBmMihibCxjbCxkbCkgKyBobFsxXTtcbiAgICB9IGVsc2UgaWYgKGk8NDgpIHtcbiAgICAgICAgdCArPSAgZjMoYmwsY2wsZGwpICsgaGxbMl07XG4gICAgfSBlbHNlIGlmIChpPDY0KSB7XG4gICAgICAgIHQgKz0gIGY0KGJsLGNsLGRsKSArIGhsWzNdO1xuICAgIH0gZWxzZSB7Ly8gaWYgKGk8ODApIHtcbiAgICAgICAgdCArPSAgZjUoYmwsY2wsZGwpICsgaGxbNF07XG4gICAgfVxuICAgIHQgPSB0fDA7XG4gICAgdCA9ICByb3RsKHQsc2xbaV0pO1xuICAgIHQgPSAodCtlbCl8MDtcbiAgICBhbCA9IGVsO1xuICAgIGVsID0gZGw7XG4gICAgZGwgPSByb3RsKGNsLCAxMCk7XG4gICAgY2wgPSBibDtcbiAgICBibCA9IHQ7XG5cbiAgICB0ID0gKGFyICsgTVtvZmZzZXQrenJbaV1dKXwwO1xuICAgIGlmIChpPDE2KXtcbiAgICAgICAgdCArPSAgZjUoYnIsY3IsZHIpICsgaHJbMF07XG4gICAgfSBlbHNlIGlmIChpPDMyKSB7XG4gICAgICAgIHQgKz0gIGY0KGJyLGNyLGRyKSArIGhyWzFdO1xuICAgIH0gZWxzZSBpZiAoaTw0OCkge1xuICAgICAgICB0ICs9ICBmMyhicixjcixkcikgKyBoclsyXTtcbiAgICB9IGVsc2UgaWYgKGk8NjQpIHtcbiAgICAgICAgdCArPSAgZjIoYnIsY3IsZHIpICsgaHJbM107XG4gICAgfSBlbHNlIHsvLyBpZiAoaTw4MCkge1xuICAgICAgICB0ICs9ICBmMShicixjcixkcikgKyBocls0XTtcbiAgICB9XG4gICAgdCA9IHR8MDtcbiAgICB0ID0gIHJvdGwodCxzcltpXSkgO1xuICAgIHQgPSAodCtlcil8MDtcbiAgICBhciA9IGVyO1xuICAgIGVyID0gZHI7XG4gICAgZHIgPSByb3RsKGNyLCAxMCk7XG4gICAgY3IgPSBicjtcbiAgICBiciA9IHQ7XG4gIH1cbiAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcbiAgdCAgICA9IChIWzFdICsgY2wgKyBkcil8MDtcbiAgSFsxXSA9IChIWzJdICsgZGwgKyBlcil8MDtcbiAgSFsyXSA9IChIWzNdICsgZWwgKyBhcil8MDtcbiAgSFszXSA9IChIWzRdICsgYWwgKyBicil8MDtcbiAgSFs0XSA9IChIWzBdICsgYmwgKyBjcil8MDtcbiAgSFswXSA9ICB0O1xufTtcblxuZnVuY3Rpb24gZjEoeCwgeSwgeikge1xuICByZXR1cm4gKCh4KSBeICh5KSBeICh6KSk7XG59XG5cbmZ1bmN0aW9uIGYyKHgsIHksIHopIHtcbiAgcmV0dXJuICgoKHgpJih5KSkgfCAoKH54KSYoeikpKTtcbn1cblxuZnVuY3Rpb24gZjMoeCwgeSwgeikge1xuICByZXR1cm4gKCgoeCkgfCAofih5KSkpIF4gKHopKTtcbn1cblxuZnVuY3Rpb24gZjQoeCwgeSwgeikge1xuICByZXR1cm4gKCgoeCkgJiAoeikpIHwgKCh5KSYofih6KSkpKTtcbn1cblxuZnVuY3Rpb24gZjUoeCwgeSwgeikge1xuICByZXR1cm4gKCh4KSBeICgoeSkgfCh+KHopKSkpO1xufVxuXG5mdW5jdGlvbiByb3RsKHgsbikge1xuICByZXR1cm4gKHg8PG4pIHwgKHg+Pj4oMzItbikpO1xufVxuXG5mdW5jdGlvbiByaXBlbWQxNjAobWVzc2FnZSkge1xuICB2YXIgSCA9IFsweDY3NDUyMzAxLCAweEVGQ0RBQjg5LCAweDk4QkFEQ0ZFLCAweDEwMzI1NDc2LCAweEMzRDJFMUYwXTtcblxuICBpZiAodHlwZW9mIG1lc3NhZ2UgPT0gJ3N0cmluZycpXG4gICAgbWVzc2FnZSA9IG5ldyBCdWZmZXIobWVzc2FnZSwgJ3V0ZjgnKTtcblxuICB2YXIgbSA9IGJ5dGVzVG9Xb3JkcyhtZXNzYWdlKTtcblxuICB2YXIgbkJpdHNMZWZ0ID0gbWVzc2FnZS5sZW5ndGggKiA4O1xuICB2YXIgbkJpdHNUb3RhbCA9IG1lc3NhZ2UubGVuZ3RoICogODtcblxuICAvLyBBZGQgcGFkZGluZ1xuICBtW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG4gIG1bKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IChcbiAgICAgICgoKG5CaXRzVG90YWwgPDwgOCkgIHwgKG5CaXRzVG90YWwgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG4gICAgICAoKChuQml0c1RvdGFsIDw8IDI0KSB8IChuQml0c1RvdGFsID4+PiA4KSkgICYgMHhmZjAwZmYwMClcbiAgKTtcblxuICBmb3IgKHZhciBpPTAgOyBpPG0ubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgcHJvY2Vzc0Jsb2NrKEgsIG0sIGkpO1xuICB9XG5cbiAgLy8gU3dhcCBlbmRpYW5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgIC8vIFNob3J0Y3V0XG4gICAgdmFyIEhfaSA9IEhbaV07XG5cbiAgICAvLyBTd2FwXG4gICAgSFtpXSA9ICgoKEhfaSA8PCA4KSAgfCAoSF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuICAgICAgICAgICgoKEhfaSA8PCAyNCkgfCAoSF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMCk7XG4gIH1cblxuICB2YXIgZGlnZXN0Ynl0ZXMgPSB3b3Jkc1RvQnl0ZXMoSCk7XG4gIHJldHVybiBuZXcgQnVmZmVyKGRpZ2VzdGJ5dGVzKTtcbn1cblxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vcmlwZW1kMTYwL2xpYi9yaXBlbWQxNjAuanNcbiAqKi8iLCJ2YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJy4vY3JlYXRlLWhhc2gnKVxuXG52YXIgemVyb0J1ZmZlciA9IG5ldyBCdWZmZXIoMTI4KVxuemVyb0J1ZmZlci5maWxsKDApXG5cbm1vZHVsZS5leHBvcnRzID0gSG1hY1xuXG5mdW5jdGlvbiBIbWFjIChhbGcsIGtleSkge1xuICBpZighKHRoaXMgaW5zdGFuY2VvZiBIbWFjKSkgcmV0dXJuIG5ldyBIbWFjKGFsZywga2V5KVxuICB0aGlzLl9vcGFkID0gb3BhZFxuICB0aGlzLl9hbGcgPSBhbGdcblxuICB2YXIgYmxvY2tzaXplID0gKGFsZyA9PT0gJ3NoYTUxMicpID8gMTI4IDogNjRcblxuICBrZXkgPSB0aGlzLl9rZXkgPSAhQnVmZmVyLmlzQnVmZmVyKGtleSkgPyBuZXcgQnVmZmVyKGtleSkgOiBrZXlcblxuICBpZihrZXkubGVuZ3RoID4gYmxvY2tzaXplKSB7XG4gICAga2V5ID0gY3JlYXRlSGFzaChhbGcpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpXG4gIH0gZWxzZSBpZihrZXkubGVuZ3RoIDwgYmxvY2tzaXplKSB7XG4gICAga2V5ID0gQnVmZmVyLmNvbmNhdChba2V5LCB6ZXJvQnVmZmVyXSwgYmxvY2tzaXplKVxuICB9XG5cbiAgdmFyIGlwYWQgPSB0aGlzLl9pcGFkID0gbmV3IEJ1ZmZlcihibG9ja3NpemUpXG4gIHZhciBvcGFkID0gdGhpcy5fb3BhZCA9IG5ldyBCdWZmZXIoYmxvY2tzaXplKVxuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBibG9ja3NpemU7IGkrKykge1xuICAgIGlwYWRbaV0gPSBrZXlbaV0gXiAweDM2XG4gICAgb3BhZFtpXSA9IGtleVtpXSBeIDB4NUNcbiAgfVxuXG4gIHRoaXMuX2hhc2ggPSBjcmVhdGVIYXNoKGFsZykudXBkYXRlKGlwYWQpXG59XG5cbkhtYWMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmMpIHtcbiAgdGhpcy5faGFzaC51cGRhdGUoZGF0YSwgZW5jKVxuICByZXR1cm4gdGhpc1xufVxuXG5IbWFjLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIHZhciBoID0gdGhpcy5faGFzaC5kaWdlc3QoKVxuICByZXR1cm4gY3JlYXRlSGFzaCh0aGlzLl9hbGcpLnVwZGF0ZSh0aGlzLl9vcGFkKS51cGRhdGUoaCkuZGlnZXN0KGVuYylcbn1cblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2NyeXB0by1icm93c2VyaWZ5L2NyZWF0ZS1obWFjLmpzXG4gKiovIiwidmFyIHBia2RmMkV4cG9ydCA9IHJlcXVpcmUoJ3Bia2RmMi1jb21wYXQvcGJrZGYyJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3J5cHRvLCBleHBvcnRzKSB7XG4gIGV4cG9ydHMgPSBleHBvcnRzIHx8IHt9XG5cbiAgdmFyIGV4cG9ydGVkID0gcGJrZGYyRXhwb3J0KGNyeXB0bylcblxuICBleHBvcnRzLnBia2RmMiA9IGV4cG9ydGVkLnBia2RmMlxuICBleHBvcnRzLnBia2RmMlN5bmMgPSBleHBvcnRlZC5wYmtkZjJTeW5jXG5cbiAgcmV0dXJuIGV4cG9ydHNcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9jcnlwdG8tYnJvd3NlcmlmeS9wYmtkZjIuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNyeXB0bykge1xuICBmdW5jdGlvbiBwYmtkZjIocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgZGlnZXN0LCBjYWxsYmFjaykge1xuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZGlnZXN0KSB7XG4gICAgICBjYWxsYmFjayA9IGRpZ2VzdFxuICAgICAgZGlnZXN0ID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBjYWxsYmFjaylcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY2FsbGJhY2sgcHJvdmlkZWQgdG8gcGJrZGYyJylcblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVzdWx0XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IHBia2RmMlN5bmMocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgZGlnZXN0KVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZSlcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sodW5kZWZpbmVkLCByZXN1bHQpXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHBia2RmMlN5bmMocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgZGlnZXN0KSB7XG4gICAgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgaXRlcmF0aW9ucylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0l0ZXJhdGlvbnMgbm90IGEgbnVtYmVyJylcblxuICAgIGlmIChpdGVyYXRpb25zIDwgMClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JhZCBpdGVyYXRpb25zJylcblxuICAgIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIGtleWxlbilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0tleSBsZW5ndGggbm90IGEgbnVtYmVyJylcblxuICAgIGlmIChrZXlsZW4gPCAwKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQmFkIGtleSBsZW5ndGgnKVxuXG4gICAgZGlnZXN0ID0gZGlnZXN0IHx8ICdzaGExJ1xuXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGFzc3dvcmQpKSBwYXNzd29yZCA9IG5ldyBCdWZmZXIocGFzc3dvcmQpXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoc2FsdCkpIHNhbHQgPSBuZXcgQnVmZmVyKHNhbHQpXG5cbiAgICB2YXIgaExlbiwgbCA9IDEsIHIsIFRcbiAgICB2YXIgREsgPSBuZXcgQnVmZmVyKGtleWxlbilcbiAgICB2YXIgYmxvY2sxID0gbmV3IEJ1ZmZlcihzYWx0Lmxlbmd0aCArIDQpXG4gICAgc2FsdC5jb3B5KGJsb2NrMSwgMCwgMCwgc2FsdC5sZW5ndGgpXG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBsOyBpKyspIHtcbiAgICAgIGJsb2NrMS53cml0ZVVJbnQzMkJFKGksIHNhbHQubGVuZ3RoKVxuXG4gICAgICB2YXIgVSA9IGNyeXB0by5jcmVhdGVIbWFjKGRpZ2VzdCwgcGFzc3dvcmQpLnVwZGF0ZShibG9jazEpLmRpZ2VzdCgpXG5cbiAgICAgIGlmICghaExlbikge1xuICAgICAgICBoTGVuID0gVS5sZW5ndGhcbiAgICAgICAgVCA9IG5ldyBCdWZmZXIoaExlbilcbiAgICAgICAgbCA9IE1hdGguY2VpbChrZXlsZW4gLyBoTGVuKVxuICAgICAgICByID0ga2V5bGVuIC0gKGwgLSAxKSAqIGhMZW5cblxuICAgICAgICBpZiAoa2V5bGVuID4gKE1hdGgucG93KDIsIDMyKSAtIDEpICogaExlbilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdrZXlsZW4gZXhjZWVkcyBtYXhpbXVtIGxlbmd0aCcpXG4gICAgICB9XG5cbiAgICAgIFUuY29weShULCAwLCAwLCBoTGVuKVxuXG4gICAgICBmb3IgKHZhciBqID0gMTsgaiA8IGl0ZXJhdGlvbnM7IGorKykge1xuICAgICAgICBVID0gY3J5cHRvLmNyZWF0ZUhtYWMoZGlnZXN0LCBwYXNzd29yZCkudXBkYXRlKFUpLmRpZ2VzdCgpXG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBoTGVuOyBrKyspIHtcbiAgICAgICAgICBUW2tdIF49IFVba11cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZGVzdFBvcyA9IChpIC0gMSkgKiBoTGVuXG4gICAgICB2YXIgbGVuID0gKGkgPT0gbCA/IHIgOiBoTGVuKVxuICAgICAgVC5jb3B5KERLLCBkZXN0UG9zLCAwLCBsZW4pXG4gICAgfVxuXG4gICAgcmV0dXJuIERLXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBia2RmMjogcGJrZGYyLFxuICAgIHBia2RmMlN5bmM6IHBia2RmMlN5bmNcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L3Bia2RmMi1jb21wYXQvcGJrZGYyLmpzXG4gKiovIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBUb2RvID0gcmVxdWlyZSgnVG9kbycpO1xuXG52YXIgVG9Eb0xpc3QgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gIHJlbmRlcjogZnVuY3Rpb24oKXtcbiAgICB2YXIge3RvZG9zfSA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHJlbmRlclRvZG9zID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRvZG9zLm1hcCgodG9kbykgPT4ge1xuICAgICAgICByZXR1cm4oXG4gICAgICAgICAgPFRvZG8ga2V5PXt0b2RvLmlkfSB7Li4udG9kb30gb25Ub2dnbGU9e3RoaXMucHJvcHMub25Ub2dnbGV9Lz5cbiAgICAgICAgKVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdj5cbiAgICAgICAge3JlbmRlclRvZG9zKCl9XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRvRG9MaXN0O1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvY29tcG9uZW50cy9Ub2RvTGlzdC5qc3hcbiAqKi8iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgVG9EbyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgcmVuZGVyOiBmdW5jdGlvbigpe1xuICAgIHZhciB7aWQsIHRleHQsIGNvbXBsZXRlZH0gPSB0aGlzLnByb3BzO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IG9uQ2xpY2s9eygpID0+IHtcbiAgICAgICAgICB0aGlzLnByb3BzLm9uVG9nZ2xlKGlkKTtcbiAgICAgICAgfX0+XG4gICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjaGVja2VkPXtjb21wbGV0ZWR9Lz5cbiAgICAgICAge3RleHR9XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRvRG87XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2FwcC9jb21wb25lbnRzL1RvZG8uanN4XG4gKiovIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIEFkZFRvZG8gPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gIGhhbmRsZVN1Ym1pdDogZnVuY3Rpb24oZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgdG9kb1RleHQgPSB0aGlzLnJlZnMudG9kb1RleHQudmFsdWU7XG4gICAgaWYgKHRvZG9UZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucmVmcy50b2RvVGV4dC52YWx1ZSA9IFwiXCI7XG4gICAgICB0aGlzLnByb3BzLm9uQWRkVG9kbyh0b2RvVGV4dClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWZzLnRvZG9UZXh0LmZvY3VzKCk7XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXY+XG4gICAgICAgIDxmb3JtIG9uU3VibWl0PXt0aGlzLmhhbmRsZVN1Ym1pdH0+XG4gICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgcmVmPVwidG9kb1RleHRcIiBwbGFjZWhvbGRlcj1cIldoYXQgZG8geW91IG5lZWQgdG8gZG8/XCIvPlxuICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwiYnV0dG9uIGV4cGFuZGVkXCI+QWRkIHRvZG88L2J1dHRvbj5cbiAgICAgICAgPC9mb3JtPlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZGRUb2RvO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvY29tcG9uZW50cy9BZGRUb2RvLmpzeFxuICoqLyIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBUb2RvU2VhcmNoID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICBoYW5kbGVTZWFyY2g6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzaG93Q29tcGxldGVkID0gdGhpcy5yZWZzLnNob3dDb21wbGV0ZWQuY2hlY2tlZDtcbiAgICB2YXIgc2VhcmNoVGV4dCA9IHRoaXMucmVmcy5zZWFyY2hUZXh0LnZhbHVlO1xuXG4gICAgdGhpcy5wcm9wcy5vblNlYXJjaChzaG93Q29tcGxldGVkLCBzZWFyY2hUZXh0KTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4oXG4gICAgICA8ZGl2PlxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxpbnB1dCB0eXBlPVwic2VhcmNoXCIgcmVmPVwic2VhcmNoVGV4dFwiIHBsYWNlaG9sZGVyPVwiU2VhcmNoIHRvZG9zXCIgb25DaGFuZ2U9e3RoaXMuaGFuZGxlU2VhcmNofS8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxsYWJlbD5cbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiByZWY9XCJzaG93Q29tcGxldGVkXCIgb25DaGFuZ2U9e3RoaXMuaGFuZGxlU2VhcmNofS8+XG4gICAgICAgICAgICBTaG93IGNvbXBsZXRlZCB0b2Rvc1xuICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKX0sXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUb2RvU2VhcmNoO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9hcHAvY29tcG9uZW50cy9Ub2RvU2VhcmNoLmpzeFxuICoqLyIsInZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzPSB7XG4gIHNldFRvZG9zOiBmdW5jdGlvbih0b2Rvcykge1xuICAgIGlmICgkLmlzQXJyYXkodG9kb3MpKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndG9kb3MnLCBKU09OLnN0cmluZ2lmeSh0b2RvcykpO1xuICAgICAgcmV0dXJuIHRvZG9zO1xuICAgIH1cbiAgfSxcbiAgZ2V0VG9kb3M6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmdUb2RvcyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0b2RvcycpO1xuICAgIHZhciB0b2RvcyA9IFtdO1xuXG4gICAgdHJ5e1xuICAgICAgdG9kb3MgPSBKU09OLnBhcnNlKHN0cmluZ1RvZG9zKTtcbiAgICB9IGNhdGNoKGUpe1xuXG4gICAgfVxuXG4gICAgcmV0dXJuICQuaXNBcnJheSh0b2RvcykgPyB0b2RvczogW107XG5cbiAgfVxufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vYXBwL0FQSS9Ub2RvQVBJLmpzeFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=